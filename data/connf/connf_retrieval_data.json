{"ConNF.mem_cloud": {"natural_language_statement": "The `ConNF.mem_cloud` theorem in the context of Constructive Ordinal Notation (ConNF) in Lean 4 states that a tangle `t` of type `\u03b2` belongs to the `ConNF.cloud` of a set `s` of tangles of type `\u03b3` if and only if there exists a tangle `t'` in `s` and a near-litter `N` such that `N` is the `ConNF.fuzz` of `t'` and `t` is the `ConNF.typedNearLitter` of `N`.", "formal_statement": "@[simp]example [ConNF.Params ] {\u03b3 : ConNF.TypeIndex} [ConNF.TangleData \u03b3] [ConNF.PositionedTangles \u03b3] {\u03b2 : ConNF.\u039b} [ConNF.TangleData \u2191\u03b2] [ConNF.PositionedTangles \u2191\u03b2] [ConNF.TypedObjects \u03b2] {h\u03b3\u03b2 : \u03b3 \u2260 \u2191\u03b2} {t : ConNF.Tangle \u2191\u03b2} {s : Set (ConNF.Tangle \u03b3)} :t \u2208 ConNF.cloud h\u03b3\u03b2 s \u2194 \u2203 t' \u2208 s, \u2203 (N : ConNF.NearLitter), N.fst = ConNF.fuzz h\u03b3\u03b2 t' \u2227 t = ConNF.typedNearLitter N := by sorry", "full_tactic_state": "inst\u271d\u2075 : ConNF.Params\n\u03b3 : ConNF.TypeIndex\ninst\u271d\u2074 : ConNF.TangleData \u03b3\ninst\u271d\u00b3 : ConNF.PositionedTangles \u03b3\n\u03b2 : ConNF.\u039b\ninst\u271d\u00b2 : ConNF.TangleData \u2191\u03b2\ninst\u271d\u00b9 : ConNF.PositionedTangles \u2191\u03b2\ninst\u271d : ConNF.TypedObjects \u03b2\nh\u03b3\u03b2 : \u03b3 \u2260 \u2191\u03b2\nt : ConNF.Tangle \u2191\u03b2\ns : Set (ConNF.Tangle \u03b3)\n\u22a2 t \u2208 ConNF.cloud h\u03b3\u03b2 s \u2194 \u2203 t' \u2208 s, \u2203 N, N.fst = ConNF.fuzz h\u03b3\u03b2 t' \u2227 t = ConNF.typedNearLitter N", "dependency": [1, 39, 72, 39, 72, 73, 69, 77, 78]}, "ConNF.cloud_empty": {"natural_language_statement": "Function `ConNF.cloud` maps each tangle to all typed near-litters near the `fuzz`ed tangle, and takes the union over all tangles in the input. This theorem states that if the input set of tangles is empty, then the output set of near-litters is also empty.", "formal_statement": "@[simp]example [ConNF.Params ] {\u03b3 : ConNF.TypeIndex} [ConNF.TangleData \u03b3] [ConNF.PositionedTangles \u03b3] {\u03b2 : ConNF.\u039b} [ConNF.TangleData \u2191\u03b2] [ConNF.PositionedTangles \u2191\u03b2] [ConNF.TypedObjects \u03b2] {h\u03b3\u03b2 : \u03b3 \u2260 \u2191\u03b2} :ConNF.cloud h\u03b3\u03b2 \u2205 = \u2205 := by sorry", "full_tactic_state": "inst\u271d\u2075 : ConNF.Params\n\u03b3 : ConNF.TypeIndex\ninst\u271d\u2074 : ConNF.TangleData \u03b3\ninst\u271d\u00b3 : ConNF.PositionedTangles \u03b3\n\u03b2 : ConNF.\u039b\ninst\u271d\u00b2 : ConNF.TangleData \u2191\u03b2\ninst\u271d\u00b9 : ConNF.PositionedTangles \u2191\u03b2\ninst\u271d : ConNF.TypedObjects \u03b2\nh\u03b3\u03b2 : \u03b3 \u2260 \u2191\u03b2\n\u22a2 ConNF.cloud h\u03b3\u03b2 \u2205 = \u2205", "dependency": [1, 39, 72, 39, 72, 73, 77]}, "ConNF.cloud_singleton": {"natural_language_statement": "In the context of Constructive Ordinal Notation (ConNF), the function `ConNF.cloud` maps each tangle to all typed near-litters near the `fuzz`ed tangle, and takes the union over all tangles in the input. The function `ConNF.localCardinal` defines the local cardinal of a given litter `L` in the context of Constructive Ordinal Notation (ConNF). The local cardinal of a litter `L` is defined as the set of all near-litters `N` such that the first component of `N` is equal to `L`. In other words, the local cardinal of a litter `L` consists of all near-litters that have `L` as their first component. The function `ConNF.fuzz` is a noncomputable function defined in the context of Constructive Ordinal Notation (ConNF) in Lean 4. It takes as input a tangle `t` of type `\u03b2` and returns a `Litter` object. The `Litter` object is defined as a 4-tuple consisting of a `Wf` object, a type index `\u03b2`, a `\u039b` object `\u03b3`, and a proof that `\u03b2` is not equal to `\u03b3`. The `Wf` object is chosen using the `chooseWf` function, which selects an element from a nonempty set. The `chooseWf` function is applied to the set `fuzzDeny \u03b3`, which is defined using the `mk_fuzzDeny` function. The `mk_fuzzDeny` function takes a tangle `t` of type `\u03b2` and returns a `Wf` object. The `Litter` object is then constructed using the chosen `Wf` object, the type index `\u03b2`, the `\u039b` object `\u03b3`, and the proof that `\u03b2` is not equal to `\u03b3`.", "formal_statement": "@[simp]example [ConNF.Params ] {\u03b3 : ConNF.TypeIndex} [ConNF.TangleData \u03b3] [ConNF.PositionedTangles \u03b3] {\u03b2 : ConNF.\u039b} [ConNF.TangleData \u2191\u03b2] [ConNF.PositionedTangles \u2191\u03b2] [ConNF.TypedObjects \u03b2] {h\u03b3\u03b2 : \u03b3 \u2260 \u2191\u03b2} (t : ConNF.Tangle \u03b3) :ConNF.cloud h\u03b3\u03b2 {t} = \u21d1ConNF.typedNearLitter '' ConNF.localCardinal (ConNF.fuzz h\u03b3\u03b2 t) := by sorry", "full_tactic_state": "inst\u271d\u2075 : ConNF.Params\n\u03b3 : ConNF.TypeIndex\ninst\u271d\u2074 : ConNF.TangleData \u03b3\ninst\u271d\u00b3 : ConNF.PositionedTangles \u03b3\n\u03b2 : ConNF.\u039b\ninst\u271d\u00b2 : ConNF.TangleData \u2191\u03b2\ninst\u271d\u00b9 : ConNF.PositionedTangles \u2191\u03b2\ninst\u271d : ConNF.TypedObjects \u03b2\nh\u03b3\u03b2 : \u03b3 \u2260 \u2191\u03b2\nt : ConNF.Tangle \u03b3\n\u22a2 ConNF.cloud h\u03b3\u03b2 {t} = \u21d1ConNF.typedNearLitter '' ConNF.localCardinal (ConNF.fuzz h\u03b3\u03b2 t)", "dependency": [1, 39, 72, 39, 72, 73, 77, 81, 78]}, "Set.Nonempty.cloud": {"natural_language_statement": "In the context of Constructive Ordinal Notation (ConNF), the function `ConNF.cloud` maps each tangle to all typed near-litters near the `fuzz`ed tangle, and takes the union over all tangles in the input. The theorem `Set.Nonempty.cloud` asserts that if `s` is a non-empty set of `\u03b3`-tangles, then the set obtained by applying `ConNF.cloud` to `s` is also non-empty.", "formal_statement": "example [ConNF.Params ] {\u03b3 : ConNF.TypeIndex} [ConNF.TangleData \u03b3] [ConNF.PositionedTangles \u03b3] {\u03b2 : ConNF.\u039b} [ConNF.TangleData \u2191\u03b2] [ConNF.PositionedTangles \u2191\u03b2] [ConNF.TypedObjects \u03b2] {h\u03b3\u03b2 : \u03b3 \u2260 \u2191\u03b2} {s : Set (ConNF.Tangle \u03b3)} (h : Set.Nonempty s) :Set.Nonempty (ConNF.cloud h\u03b3\u03b2 s) := by sorry", "full_tactic_state": "inst\u271d\u2075 : ConNF.Params\n\u03b3 : ConNF.TypeIndex\ninst\u271d\u2074 : ConNF.TangleData \u03b3\ninst\u271d\u00b3 : ConNF.PositionedTangles \u03b3\n\u03b2 : ConNF.\u039b\ninst\u271d\u00b2 : ConNF.TangleData \u2191\u03b2\ninst\u271d\u00b9 : ConNF.PositionedTangles \u2191\u03b2\ninst\u271d : ConNF.TypedObjects \u03b2\nh\u03b3\u03b2 : \u03b3 \u2260 \u2191\u03b2\ns : Set (ConNF.Tangle \u03b3)\nh : Set.Nonempty s\n\u22a2 Set.Nonempty (ConNF.cloud h\u03b3\u03b2 s)", "dependency": [1, 39, 72, 39, 72, 73, 69, 83, 83, 77]}, "ConNF.cloud_eq_empty": {"natural_language_statement": "In the context of Constructive Ordinal Notation (ConNF), the function `ConNF.cloud` maps each tangle to all typed near-litters near the `fuzz`ed tangle, and takes the union over all tangles in the input. The theorem `ConNF.cloud_eq_empty` states that the `ConNF.cloud` of a set of tangles is empty if and only if the set of tangles itself is empty.", "formal_statement": "@[simp]example [ConNF.Params ] {\u03b3 : ConNF.TypeIndex} [ConNF.TangleData \u03b3] [ConNF.PositionedTangles \u03b3] {\u03b2 : ConNF.\u039b} [ConNF.TangleData \u2191\u03b2] [ConNF.PositionedTangles \u2191\u03b2] [ConNF.TypedObjects \u03b2] {s : Set (ConNF.Tangle \u03b3)} (h\u03b3\u03b2 : \u03b3 \u2260 \u2191\u03b2) :ConNF.cloud h\u03b3\u03b2 s = \u2205 \u2194 s = \u2205 := by sorry", "full_tactic_state": "inst\u271d\u2075 : ConNF.Params\n\u03b3 : ConNF.TypeIndex\ninst\u271d\u2074 : ConNF.TangleData \u03b3\ninst\u271d\u00b3 : ConNF.PositionedTangles \u03b3\n\u03b2 : ConNF.\u039b\ninst\u271d\u00b2 : ConNF.TangleData \u2191\u03b2\ninst\u271d\u00b9 : ConNF.PositionedTangles \u2191\u03b2\ninst\u271d : ConNF.TypedObjects \u03b2\ns : Set (ConNF.Tangle \u03b3)\nh\u03b3\u03b2 : \u03b3 \u2260 \u2191\u03b2\n\u22a2 ConNF.cloud h\u03b3\u03b2 s = \u2205 \u2194 s = \u2205", "dependency": [1, 39, 72, 39, 72, 73, 69, 77]}, "ConNF.cloud_nonempty": {"natural_language_statement": "In the context of Constructive Ordinal Notation (ConNF), the function `ConNF.cloud` maps each tangle to all typed near-litters near the `fuzz`ed tangle, and takes the union over all tangles in the input. The theorem `ConNF.cloud_nonempty` asserts that the resulting set is nonempty if and only if the input set is nonempty.", "formal_statement": "@[simp]example [ConNF.Params ] {\u03b3 : ConNF.TypeIndex} [ConNF.TangleData \u03b3] [ConNF.PositionedTangles \u03b3] {\u03b2 : ConNF.\u039b} [ConNF.TangleData \u2191\u03b2] [ConNF.PositionedTangles \u2191\u03b2] [ConNF.TypedObjects \u03b2] {s : Set (ConNF.Tangle \u03b3)} (h\u03b3\u03b2 : \u03b3 \u2260 \u2191\u03b2) :Set.Nonempty (ConNF.cloud h\u03b3\u03b2 s) \u2194 Set.Nonempty s := by sorry", "full_tactic_state": "inst\u271d\u2075 : ConNF.Params\n\u03b3 : ConNF.TypeIndex\ninst\u271d\u2074 : ConNF.TangleData \u03b3\ninst\u271d\u00b3 : ConNF.PositionedTangles \u03b3\n\u03b2 : ConNF.\u039b\ninst\u271d\u00b2 : ConNF.TangleData \u2191\u03b2\ninst\u271d\u00b9 : ConNF.PositionedTangles \u2191\u03b2\ninst\u271d : ConNF.TypedObjects \u03b2\ns : Set (ConNF.Tangle \u03b3)\nh\u03b3\u03b2 : \u03b3 \u2260 \u2191\u03b2\n\u22a2 Set.Nonempty (ConNF.cloud h\u03b3\u03b2 s) \u2194 Set.Nonempty s", "dependency": [1, 39, 72, 39, 72, 73, 69, 83, 77, 83]}, "ConNF.subset_cloud": {"natural_language_statement": "In the context of Constructive Ordinal Notation (ConNF) in Lean 4, the theorem `ConNF.subset_cloud` asserts that for any tangle `t` of type `\u03b3` that belongs to a set `s` of tangles of type `\u03b3`, the set of all typed near-litters near the `fuzz`ed tangle `t` is a subset of the `cloud` of `s`.", "formal_statement": "example [ConNF.Params ] {\u03b3 : ConNF.TypeIndex} [ConNF.TangleData \u03b3] [ConNF.PositionedTangles \u03b3] {\u03b2 : ConNF.\u039b} [ConNF.TangleData \u2191\u03b2] [ConNF.PositionedTangles \u2191\u03b2] [ConNF.TypedObjects \u03b2] {h\u03b3\u03b2 : \u03b3 \u2260 \u2191\u03b2} {s : Set (ConNF.Tangle \u03b3)} {t : ConNF.Tangle \u03b3} (ht : t \u2208 s) :\u21d1ConNF.typedNearLitter '' ConNF.localCardinal (ConNF.fuzz h\u03b3\u03b2 t) \u2286 ConNF.cloud h\u03b3\u03b2 s := by sorry", "full_tactic_state": "inst\u271d\u2075 : ConNF.Params\n\u03b3 : ConNF.TypeIndex\ninst\u271d\u2074 : ConNF.TangleData \u03b3\ninst\u271d\u00b3 : ConNF.PositionedTangles \u03b3\n\u03b2 : ConNF.\u039b\ninst\u271d\u00b2 : ConNF.TangleData \u2191\u03b2\ninst\u271d\u00b9 : ConNF.PositionedTangles \u2191\u03b2\ninst\u271d : ConNF.TypedObjects \u03b2\nh\u03b3\u03b2 : \u03b3 \u2260 \u2191\u03b2\ns : Set (ConNF.Tangle \u03b3)\nt : ConNF.Tangle \u03b3\nht : t \u2208 s\n\u22a2 \u21d1ConNF.typedNearLitter '' ConNF.localCardinal (ConNF.fuzz h\u03b3\u03b2 t) \u2286 ConNF.cloud h\u03b3\u03b2 s", "dependency": [1, 39, 72, 39, 72, 73, 69, 81, 78, 77]}, "ConNF.\u03bc_le_mk_cloud": {"natural_language_statement": "In the context of Constructive Ordinal Notation (ConNF), the theorem `ConNF.\u03bc_le_mk_cloud` asserts that for any non-empty set `s` of `\u03b3`-tangles, the cardinality of `\u03bc` is less than or equal to the cardinality of the set of all `\u03b2`-typed near-litters near the `fuzz`ed tangles in `s`.", "formal_statement": "example [ConNF.Params ] {\u03b3 : ConNF.TypeIndex} [ConNF.TangleData \u03b3] [ConNF.PositionedTangles \u03b3] {\u03b2 : ConNF.\u039b} [ConNF.TangleData \u2191\u03b2] [ConNF.PositionedTangles \u2191\u03b2] [ConNF.TypedObjects \u03b2] {h\u03b3\u03b2 : \u03b3 \u2260 \u2191\u03b2} {s : Set (ConNF.Tangle \u03b3)} :Set.Nonempty s \u2192 Cardinal.mk ConNF.\u03bc \u2264 Cardinal.mk \u2191(ConNF.cloud h\u03b3\u03b2 s) := by sorry", "full_tactic_state": "inst\u271d\u2075 : ConNF.Params\n\u03b3 : ConNF.TypeIndex\ninst\u271d\u2074 : ConNF.TangleData \u03b3\ninst\u271d\u00b3 : ConNF.PositionedTangles \u03b3\n\u03b2 : ConNF.\u039b\ninst\u271d\u00b2 : ConNF.TangleData \u2191\u03b2\ninst\u271d\u00b9 : ConNF.PositionedTangles \u2191\u03b2\ninst\u271d : ConNF.TypedObjects \u03b2\nh\u03b3\u03b2 : \u03b3 \u2260 \u2191\u03b2\ns : Set (ConNF.Tangle \u03b3)\n\u22a2 Set.Nonempty s \u2192 Cardinal.mk ConNF.\u03bc \u2264 Cardinal.mk \u2191(ConNF.cloud h\u03b3\u03b2 s)", "dependency": [1, 39, 72, 39, 72, 73, 69, 83, 29, 29, 77]}, "ConNF.cloud_injective": {"natural_language_statement": "In the context of Constructive Ordinal Notation (ConNF), the theorem `ConNF.cloud_injective` asserts that the function `ConNF.cloud`, which maps each tangle to all typed near-litters near the `fuzz`ed tangle, and takes the union over all tangles in the input, is injective.", "formal_statement": "example [ConNF.Params ] {\u03b3 : ConNF.TypeIndex} [ConNF.TangleData \u03b3] [ConNF.PositionedTangles \u03b3] {\u03b2 : ConNF.\u039b} [ConNF.TangleData \u2191\u03b2] [ConNF.PositionedTangles \u2191\u03b2] [ConNF.TypedObjects \u03b2] {h\u03b3\u03b2 : \u03b3 \u2260 \u2191\u03b2} :Function.Injective (ConNF.cloud h\u03b3\u03b2) := by sorry", "full_tactic_state": "inst\u271d\u2075 : ConNF.Params\n\u03b3 : ConNF.TypeIndex\ninst\u271d\u2074 : ConNF.TangleData \u03b3\ninst\u271d\u00b3 : ConNF.PositionedTangles \u03b3\n\u03b2 : ConNF.\u039b\ninst\u271d\u00b2 : ConNF.TangleData \u2191\u03b2\ninst\u271d\u00b9 : ConNF.PositionedTangles \u2191\u03b2\ninst\u271d : ConNF.TypedObjects \u03b2\nh\u03b3\u03b2 : \u03b3 \u2260 \u2191\u03b2\n\u22a2 Function.Injective (ConNF.cloud h\u03b3\u03b2)", "dependency": [1, 39, 72, 39, 72, 73, 89, 77]}, "ConNF.cloud_disjoint_range": {"natural_language_statement": "In the context of Constructive Ordinal Notation (ConNF), the theorem `ConNF.cloud_disjoint_range` asserts that for any two different types of tangles `\u03b3` and `\u03b4`, and any non-empty set of `\u03b3`-tangles `c` and any set of `\u03b4`-tangles `d`, if the `ConNF.cloud` of `c` equals the `ConNF.cloud` of `d`, then `\u03b3` must equal `\u03b4`.", "formal_statement": "example [ConNF.Params ] {\u03b3 : ConNF.TypeIndex} [ConNF.TangleData \u03b3] [ConNF.PositionedTangles \u03b3] {\u03b2 : ConNF.\u039b} [ConNF.TangleData \u2191\u03b2] [ConNF.PositionedTangles \u2191\u03b2] [ConNF.TypedObjects \u03b2] {h\u03b3\u03b2 : \u03b3 \u2260 \u2191\u03b2} {\u03b4 : ConNF.TypeIndex} [ConNF.TangleData \u03b4] [ConNF.PositionedTangles \u03b4] {h\u03b4\u03b2 : \u03b4 \u2260 \u2191\u03b2} (c : Set (ConNF.Tangle \u03b3)) (d : Set (ConNF.Tangle \u03b4)) (hc : Set.Nonempty c) (h : ConNF.cloud h\u03b3\u03b2 c = ConNF.cloud h\u03b4\u03b2 d) :\u03b3 = \u03b4 := by sorry", "full_tactic_state": "inst\u271d\u2077 : ConNF.Params\n\u03b3 : ConNF.TypeIndex\ninst\u271d\u2076 : ConNF.TangleData \u03b3\ninst\u271d\u2075 : ConNF.PositionedTangles \u03b3\n\u03b2 : ConNF.\u039b\ninst\u271d\u2074 : ConNF.TangleData \u2191\u03b2\ninst\u271d\u00b3 : ConNF.PositionedTangles \u2191\u03b2\ninst\u271d\u00b2 : ConNF.TypedObjects \u03b2\nh\u03b3\u03b2 : \u03b3 \u2260 \u2191\u03b2\n\u03b4 : ConNF.TypeIndex\ninst\u271d\u00b9 : ConNF.TangleData \u03b4\ninst\u271d : ConNF.PositionedTangles \u03b4\nh\u03b4\u03b2 : \u03b4 \u2260 \u2191\u03b2\nc : Set (ConNF.Tangle \u03b3)\nd : Set (ConNF.Tangle \u03b4)\nhc : Set.Nonempty c\nh : ConNF.cloud h\u03b3\u03b2 c = ConNF.cloud h\u03b4\u03b2 d\n\u22a2 \u03b3 = \u03b4", "dependency": [1, 39, 72, 39, 72, 73, 39, 72, 69, 69, 83, 77, 77]}, "ConNF.wellFounded_pos": {"natural_language_statement": "In the context of Constructive Ordinal Notation (ConNF), the theorem `ConNF.wellFounded_pos` asserts that the relation defined by comparing the positions of tangles is well-founded. This means that every non-empty set of tangles has a minimal element with respect to this relation.", "formal_statement": "example [ConNF.Params ] {\u03b3 : ConNF.TypeIndex} [ConNF.TangleData \u03b3] [ConNF.PositionedTangles \u03b3] :WellFounded fun (a b : ConNF.Tangle \u03b3) => ConNF.pos a < ConNF.pos b := by sorry", "full_tactic_state": "inst\u271d\u00b2 : ConNF.Params\n\u03b3 : ConNF.TypeIndex\ninst\u271d\u00b9 : ConNF.TangleData \u03b3\ninst\u271d : ConNF.PositionedTangles \u03b3\n\u22a2 WellFounded fun a b => ConNF.pos a < ConNF.pos b", "dependency": [1, 39, 72, 19]}, "ConNF.minTangle_mem": {"natural_language_statement": "Given a nonempty set of tangles at level `\u03b3` in the context of Constructive Ordinal Notation (ConNF), `ConNF.minTangle_mem` asserts that the tangle with the smallest position among all tangles in the set is indeed a member of that set.", "formal_statement": "example [ConNF.Params ] {\u03b3 : ConNF.TypeIndex} [ConNF.TangleData \u03b3] [ConNF.PositionedTangles \u03b3] (s : Set (ConNF.Tangle \u03b3)) (hs : Set.Nonempty s) :ConNF.minTangle s hs \u2208 s := by sorry", "full_tactic_state": "inst\u271d\u00b2 : ConNF.Params\n\u03b3 : ConNF.TypeIndex\ninst\u271d\u00b9 : ConNF.TangleData \u03b3\ninst\u271d : ConNF.PositionedTangles \u03b3\ns : Set (ConNF.Tangle \u03b3)\nhs : Set.Nonempty s\n\u22a2 ConNF.minTangle s hs \u2208 s", "dependency": [1, 39, 72, 69, 83, 93]}, "ConNF.minTangle_le": {"natural_language_statement": "In the context of Constructive Ordinal Notation (ConNF), the theorem `ConNF.minTangle_le` asserts that for any nonempty set of tangles at level `\u03b3`, the position of the tangle with the smallest position is less than or equal to the position of any other tangle in the set.", "formal_statement": "example [ConNF.Params ] {\u03b3 : ConNF.TypeIndex} [ConNF.TangleData \u03b3] [ConNF.PositionedTangles \u03b3] (s : Set (ConNF.Tangle \u03b3)) (hs : Set.Nonempty s) {t : ConNF.Tangle \u03b3} (ht : t \u2208 s) :ConNF.pos (ConNF.minTangle s hs) \u2264 ConNF.pos t := by sorry", "full_tactic_state": "inst\u271d\u00b2 : ConNF.Params\n\u03b3 : ConNF.TypeIndex\ninst\u271d\u00b9 : ConNF.TangleData \u03b3\ninst\u271d : ConNF.PositionedTangles \u03b3\ns : Set (ConNF.Tangle \u03b3)\nhs : Set.Nonempty s\nt : ConNF.Tangle \u03b3\nht : t \u2208 s\n\u22a2 ConNF.pos (ConNF.minTangle s hs) \u2264 ConNF.pos t", "dependency": [1, 39, 72, 69, 83, 93]}, "ConNF.invImage_codeMinMap_wf": {"natural_language_statement": "The theorem `ConNF.invImage_codeMinMap_wf` states that the inverse image of the `<` relation on codes under the function `ConNF.codeMinMap` is well-founded. This means that every non-empty set of codes has a minimal element with respect to this relation.", "formal_statement": "example [ConNF.Params ] [ConNF.Level] [ConNF.TangleDataLt] [ConNF.PositionedTanglesLt] :WellFounded (InvImage (fun (x x_1 : ConNF.\u03bc) => x < x_1) ConNF.codeMinMap) := by sorry", "full_tactic_state": "inst\u271d\u00b3 : ConNF.Params\ninst\u271d\u00b2 : ConNF.Level\ninst\u271d\u00b9 : ConNF.TangleDataLt\ninst\u271d : ConNF.PositionedTanglesLt\n\u22a2 WellFounded (InvImage (fun x x_1 => x < x_1) ConNF.codeMinMap)", "dependency": [1, 19, 96]}, "ConNF.extension_self": {"natural_language_statement": "Function `ConNF.extension` maps a set of `\u03b2`-tangles to a set of `\u03b3`-tangles, where `\u03b2` and `\u03b3` are type indices in the context of Constructive Ordinal Notation (ConNF). If `\u03b2` equals `\u03b3`, the function is the identity. Otherwise, it uses the `ConNF.cloud` function to map the set of `\u03b2`-tangles to a set of `\u03b3`-tangles. The theorem `ConNF.extension_self` states that when `\u03b2` equals `\u03b3`, the function `ConNF.extension` is the identity, meaning it maps the set of `\u03b2`-tangles to itself.", "formal_statement": "@[simp]example [ConNF.Params ] [ConNF.Level] [ConNF.TangleDataLt] [ConNF.PositionedTanglesLt] [ConNF.TypedObjectsLt] {\u03b3 : ConNF.\u039b} [ConNF.LtLevel \u2191\u03b3] (s : Set (ConNF.Tangle \u2191\u03b3)) :ConNF.extension s \u03b3 = s := by sorry", "full_tactic_state": "inst\u271d\u2075 : ConNF.Params\ninst\u271d\u2074 : ConNF.Level\ninst\u271d\u00b3 : ConNF.TangleDataLt\ninst\u271d\u00b2 : ConNF.PositionedTanglesLt\ninst\u271d\u00b9 : ConNF.TypedObjectsLt\n\u03b3 : ConNF.\u039b\ninst\u271d : ConNF.LtLevel \u2191\u03b3\ns : Set (ConNF.Tangle \u2191\u03b3)\n\u22a2 ConNF.extension s \u03b3 = s", "dependency": [1, 98, 69, 99]}, "ConNF.cloudCode_eq": {"natural_language_statement": "In the context of Constructive Ordinal Notation (ConNF) in Lean 4, the `ConNF.cloudCode` function takes a type index `\u03b2` and a `ConNF.Code` object `c`, and returns a new `ConNF.Code` object. If the level of `c` matches `\u03b2`, then `ConNF.cloudCode` is the identity function. This function is defined in such a way that the first component of the returned `ConNF.Code` object is defeq to `\u03b2`.", "formal_statement": "example [ConNF.Params ] [ConNF.Level] [ConNF.TangleDataLt] [ConNF.PositionedTanglesLt] [ConNF.TypedObjectsLt] (\u03b2 : ConNF.\u039b) [ConNF.LtLevel \u2191\u03b2] (c : ConNF.Code) (hc\u03b2 : c.\u03b2 = \u2191\u03b2) :ConNF.cloudCode \u03b2 c = c := by sorry", "full_tactic_state": "inst\u271d\u2075 : ConNF.Params\ninst\u271d\u2074 : ConNF.Level\ninst\u271d\u00b3 : ConNF.TangleDataLt\ninst\u271d\u00b2 : ConNF.PositionedTanglesLt\ninst\u271d\u00b9 : ConNF.TypedObjectsLt\n\u03b2 : ConNF.\u039b\ninst\u271d : ConNF.LtLevel \u2191\u03b2\nc : ConNF.Code\nhc\u03b2 : c.\u03b2 = \u2191\u03b2\n\u22a2 ConNF.cloudCode \u03b2 c = c", "dependency": [1, 98, 101]}, "ConNF.fst_cloudCode": {"natural_language_statement": "In the context of Constructive Ordinal Notation (ConNF) in Lean 4, the function `ConNF.cloudCode` takes a type index `\u03b2` and a `ConNF.Code` object `c`, and returns a new `ConNF.Code` object. If the level of `c` matches `\u03b2`, then `ConNF.cloudCode` is the identity function. This function is defined in such a way that the first component of the returned `ConNF.Code` object is defeq to `\u03b2`.", "formal_statement": "@[simp]example [ConNF.Params ] [ConNF.Level] [ConNF.TangleDataLt] [ConNF.PositionedTanglesLt] [ConNF.TypedObjectsLt] (\u03b2 : ConNF.\u039b) [ConNF.LtLevel \u2191\u03b2] (c : ConNF.Code) :(ConNF.cloudCode \u03b2 c).\u03b2 = \u2191\u03b2 := by sorry", "full_tactic_state": "inst\u271d\u2075 : ConNF.Params\ninst\u271d\u2074 : ConNF.Level\ninst\u271d\u00b3 : ConNF.TangleDataLt\ninst\u271d\u00b2 : ConNF.PositionedTanglesLt\ninst\u271d\u00b9 : ConNF.TypedObjectsLt\n\u03b2 : ConNF.\u039b\ninst\u271d : ConNF.LtLevel \u2191\u03b2\nc : ConNF.Code\n\u22a2 (ConNF.cloudCode \u03b2 c).\u03b2 = \u2191\u03b2", "dependency": [1, 98, 101]}, "ConNF.cloudCode_mk_eq": {"natural_language_statement": "In the context of Constructive Ordinal Notation (ConNF), the function `ConNF.cloudCode` takes a type index `\u03b2` and a `ConNF.Code` object `c`, and returns a new `ConNF.Code` object. If the level of `c` matches `\u03b2`, then `ConNF.cloudCode` is the identity function. This function is defined in such a way that the first component of the returned `ConNF.Code` object is defeq to `\u03b2`.", "formal_statement": "@[simp]example [ConNF.Params ] [ConNF.Level] [ConNF.TangleDataLt] [ConNF.PositionedTanglesLt] [ConNF.TypedObjectsLt] (\u03b2 : ConNF.\u039b) [ConNF.LtLevel \u2191\u03b2] (s : Set (ConNF.Tangle \u2191\u03b2)) :ConNF.cloudCode \u03b2 (ConNF.Code.mk (\u2191\u03b2) s) = ConNF.Code.mk (\u2191\u03b2) s := by sorry", "full_tactic_state": "inst\u271d\u2075 : ConNF.Params\ninst\u271d\u2074 : ConNF.Level\ninst\u271d\u00b3 : ConNF.TangleDataLt\ninst\u271d\u00b2 : ConNF.PositionedTanglesLt\ninst\u271d\u00b9 : ConNF.TypedObjectsLt\n\u03b2 : ConNF.\u039b\ninst\u271d : ConNF.LtLevel \u2191\u03b2\ns : Set (ConNF.Tangle \u2191\u03b2)\n\u22a2 ConNF.cloudCode \u03b2 (ConNF.Code.mk (\u2191\u03b2) s) = ConNF.Code.mk (\u2191\u03b2) s", "dependency": [1, 98, 69, 101, 104, 104]}, "ConNF.cloudCode_isEmpty": {"natural_language_statement": "Function `ConNF.cloudCode` is defined in the context of Constructive Ordinal Notation (ConNF) in Lean 4. It takes a type index `\u03b2` and a `ConNF.Code` object `c`, and returns a new `ConNF.Code` object. The theorem `ConNF.cloudCode_isEmpty` states that the new `ConNF.Code` object returned by `ConNF.cloudCode` is empty if and only if the original `ConNF.Code` object `c` is empty.", "formal_statement": "@[simp]example [ConNF.Params ] [ConNF.Level] [ConNF.TangleDataLt] [ConNF.PositionedTanglesLt] [ConNF.TypedObjectsLt] {\u03b2 : ConNF.\u039b} [ConNF.LtLevel \u2191\u03b2] {c : ConNF.Code} :ConNF.Code.IsEmpty (ConNF.cloudCode \u03b2 c) \u2194 ConNF.Code.IsEmpty c := by sorry", "full_tactic_state": "inst\u271d\u2075 : ConNF.Params\ninst\u271d\u2074 : ConNF.Level\ninst\u271d\u00b3 : ConNF.TangleDataLt\ninst\u271d\u00b2 : ConNF.PositionedTanglesLt\ninst\u271d\u00b9 : ConNF.TypedObjectsLt\n\u03b2 : ConNF.\u039b\ninst\u271d : ConNF.LtLevel \u2191\u03b2\nc : ConNF.Code\n\u22a2 ConNF.Code.IsEmpty (ConNF.cloudCode \u03b2 c) \u2194 ConNF.Code.IsEmpty c", "dependency": [1, 98, 107, 101, 107]}, "ConNF.cloudCode_nonempty": {"natural_language_statement": "Function `ConNF.cloudCode` in the context of Constructive Ordinal Notation (ConNF) in Lean 4 takes a type index `\u03b2` and a `ConNF.Code` object `c`, and returns a new `ConNF.Code` object. The theorem `ConNF.cloudCode_nonempty` states that the set of members of the returned `ConNF.Code` object is nonempty if and only if the set of members of the original `ConNF.Code` object `c` is nonempty.", "formal_statement": "@[simp]example [ConNF.Params ] [ConNF.Level] [ConNF.TangleDataLt] [ConNF.PositionedTanglesLt] [ConNF.TypedObjectsLt] {\u03b2 : ConNF.\u039b} [ConNF.LtLevel \u2191\u03b2] {c : ConNF.Code} :Set.Nonempty (ConNF.cloudCode \u03b2 c).members \u2194 Set.Nonempty c.members := by sorry", "full_tactic_state": "inst\u271d\u2075 : ConNF.Params\ninst\u271d\u2074 : ConNF.Level\ninst\u271d\u00b3 : ConNF.TangleDataLt\ninst\u271d\u00b2 : ConNF.PositionedTanglesLt\ninst\u271d\u00b9 : ConNF.TypedObjectsLt\n\u03b2 : ConNF.\u039b\ninst\u271d : ConNF.LtLevel \u2191\u03b2\nc : ConNF.Code\n\u22a2 Set.Nonempty (ConNF.cloudCode \u03b2 c).members \u2194 Set.Nonempty c.members", "dependency": [1, 98, 83, 101, 83]}, "ConNF.Code.IsEmpty.cloudCode": {"natural_language_statement": "Function `ConNF.Code.IsEmpty.cloudCode` is a theorem in the context of Constructive Ordinal Notation (ConNF) in Lean 4. It states that if a `ConNF.Code` object `c` is empty, then applying the `ConNF.cloudCode` function to `c` with a type index `\u03b2` that is less than the current level will also result in an empty `ConNF.Code` object.", "formal_statement": "example [ConNF.Params ] [ConNF.Level] [ConNF.TangleDataLt] [ConNF.PositionedTanglesLt] [ConNF.TypedObjectsLt] {\u03b2 : ConNF.\u039b} [ConNF.LtLevel \u2191\u03b2] {c : ConNF.Code} :ConNF.Code.IsEmpty c \u2192 ConNF.Code.IsEmpty (ConNF.cloudCode \u03b2 c) := by sorry", "full_tactic_state": "inst\u271d\u2075 : ConNF.Params\ninst\u271d\u2074 : ConNF.Level\ninst\u271d\u00b3 : ConNF.TangleDataLt\ninst\u271d\u00b2 : ConNF.PositionedTanglesLt\ninst\u271d\u00b9 : ConNF.TypedObjectsLt\n\u03b2 : ConNF.\u039b\ninst\u271d : ConNF.LtLevel \u2191\u03b2\nc : ConNF.Code\n\u22a2 ConNF.Code.IsEmpty c \u2192 ConNF.Code.IsEmpty (ConNF.cloudCode \u03b2 c)", "dependency": [1, 98, 107, 107, 101]}, "ConNF.cloudCode_injOn": {"natural_language_statement": "The theorem `ConNF.cloudCode_injOn` states that the function `ConNF.cloudCode` is injective when restricted to the set of `ConNF.Code` objects `c` such that the level of `c` is not equal to `\u03b2` and the set of members of `c` is nonempty.", "formal_statement": "example [ConNF.Params ] [ConNF.Level] [ConNF.TangleDataLt] [ConNF.PositionedTanglesLt] [ConNF.TypedObjectsLt] {\u03b2 : ConNF.\u039b} [ConNF.LtLevel \u2191\u03b2] :Set.InjOn (ConNF.cloudCode \u03b2) {c : ConNF.Code | c.\u03b2 \u2260 \u2191\u03b2 \u2227 Set.Nonempty c.members} := by sorry", "full_tactic_state": "inst\u271d\u2075 : ConNF.Params\ninst\u271d\u2074 : ConNF.Level\ninst\u271d\u00b3 : ConNF.TangleDataLt\ninst\u271d\u00b2 : ConNF.PositionedTanglesLt\ninst\u271d\u00b9 : ConNF.TypedObjectsLt\n\u03b2 : ConNF.\u039b\ninst\u271d : ConNF.LtLevel \u2191\u03b2\n\u22a2 Set.InjOn (ConNF.cloudCode \u03b2) {c | c.\u03b2 \u2260 \u2191\u03b2 \u2227 Set.Nonempty c.members}", "dependency": [1, 98, 111, 101, 83]}, "ConNF.\u03bc_le_mk_cloudCode": {"natural_language_statement": "This theorem states that, given a `ConNF.Code` object `c` with a level different from `\u03b2`, and assuming `c` has at least one member, the cardinality of `ConNF.\u03bc` (the type of all `ConNF.Code` objects) is less than or equal to the cardinality of the members of the `ConNF.Code` object obtained by applying the `ConNF.cloudCode` function to `\u03b2` and `c`. The `ConNF.cloudCode` function is defined in such a way that it returns a `ConNF.Code` object with a level equal to `\u03b2`, and its members are a subset of the members of `c`. The assumption `Set.Nonempty c.members` ensures that `c` has at least one member, which is necessary for the inequality to hold. The `ConNF.Params` class provides the foundation for the Constructive Ordinal Notation (ConNF) system in Lean 4.", "formal_statement": "example [ConNF.Params ] [ConNF.Level] [ConNF.TangleDataLt] [ConNF.PositionedTanglesLt] [ConNF.TypedObjectsLt] {\u03b2 : ConNF.\u039b} [ConNF.LtLevel \u2191\u03b2] (c : ConNF.Code) (hc\u03b2 : c.\u03b2 \u2260 \u2191\u03b2) :Set.Nonempty c.members \u2192 Cardinal.mk ConNF.\u03bc \u2264 Cardinal.mk \u2191(ConNF.cloudCode \u03b2 c).members := by sorry", "full_tactic_state": "inst\u271d\u2075 : ConNF.Params\ninst\u271d\u2074 : ConNF.Level\ninst\u271d\u00b3 : ConNF.TangleDataLt\ninst\u271d\u00b2 : ConNF.PositionedTanglesLt\ninst\u271d\u00b9 : ConNF.TypedObjectsLt\n\u03b2 : ConNF.\u039b\ninst\u271d : ConNF.LtLevel \u2191\u03b2\nc : ConNF.Code\nhc\u03b2 : c.\u03b2 \u2260 \u2191\u03b2\n\u22a2 Set.Nonempty c.members \u2192 Cardinal.mk ConNF.\u03bc \u2264 Cardinal.mk \u2191(ConNF.cloudCode \u03b2 c).members", "dependency": [1, 98, 83, 29, 29, 101]}, "ConNF.cloudRel_iff": {"natural_language_statement": "`ConNF.cloudRel_iff` is a theorem in the context of Constructive Ordinal Notation (ConNF) in Lean 4. It states that for any two `ConNF.Code` objects `c` and `a`, the relation `c \u219d\u2080 a` holds if and only if there exists a type index `\u03b2` such that `c.\u03b2` is not equal to `\u03b2`, and `a` is equal to the result of applying `ConNF.cloudCode` to `\u03b2` and `c`.", "formal_statement": "example [ConNF.Params ] [ConNF.Level] [ConNF.TangleDataLt] [ConNF.PositionedTanglesLt] [ConNF.TypedObjectsLt] (c : ConNF.Code) :\u2200 (a : ConNF.Code), c \u219d\u2080 a \u2194 \u2203 (\u03b2 : ConNF.\u039b) (inst : ConNF.LtLevel \u2191\u03b2), c.\u03b2 \u2260 \u2191\u03b2 \u2227 a = ConNF.cloudCode \u03b2 c := by sorry", "full_tactic_state": "inst\u271d\u2074 : ConNF.Params\ninst\u271d\u00b3 : ConNF.Level\ninst\u271d\u00b2 : ConNF.TangleDataLt\ninst\u271d\u00b9 : ConNF.PositionedTanglesLt\ninst\u271d : ConNF.TypedObjectsLt\nc : ConNF.Code\n\u22a2 \u2200 (a : ConNF.Code), c \u219d\u2080 a \u2194 \u2203 \u03b2, \u2203 (inst : ConNF.LtLevel \u2191\u03b2), c.\u03b2 \u2260 \u2191\u03b2 \u2227 a = ConNF.cloudCode \u03b2 c", "dependency": [1, 98, 101]}, "ConNF.cloudRel_subsingleton": {"natural_language_statement": "In the context of Constructive Ordinal Notation (ConNF), the theorem `ConNF.cloudRel_subsingleton` asserts that the set of all `ConNF.Code` objects that are related to a given `ConNF.Code` object `c` by the `ConNF.cloudRel` relation is a `Set.Subsingleton`. This means that there is at most one `ConNF.Code` object that is related to `c` by the `ConNF.cloudRel` relation.", "formal_statement": "example [ConNF.Params ] [ConNF.Level] [ConNF.TangleDataLt] [ConNF.PositionedTanglesLt] [ConNF.TypedObjectsLt] {c : ConNF.Code} (hc : Set.Nonempty c.members) :Set.Subsingleton {d : ConNF.Code | d \u219d\u2080 c} := by sorry", "full_tactic_state": "inst\u271d\u2074 : ConNF.Params\ninst\u271d\u00b3 : ConNF.Level\ninst\u271d\u00b2 : ConNF.TangleDataLt\ninst\u271d\u00b9 : ConNF.PositionedTanglesLt\ninst\u271d : ConNF.TypedObjectsLt\nc : ConNF.Code\nhc : Set.Nonempty c.members\n\u22a2 Set.Subsingleton {d | d \u219d\u2080 c}", "dependency": [1, 83, 115]}, "ConNF.cloudRel_cloudCode": {"natural_language_statement": "Function `ConNF.cloudRel_cloudCode` is a theorem in the context of Constructive Ordinal Notation (ConNF) in Lean 4. It states that given a type index `\u03b2` and two `ConNF.Code` objects `c` and `d`, if `d` is nonempty and its level does not match `\u03b2`, then `c` is related to `ConNF.cloudCode \u03b2 d` by the `ConNF.cloudRel` relation if and only if `c` is equal to `d`.", "formal_statement": "example [ConNF.Params ] [ConNF.Level] [ConNF.TangleDataLt] [ConNF.PositionedTanglesLt] [ConNF.TypedObjectsLt] (\u03b2 : ConNF.\u039b) [ConNF.LtLevel \u2191\u03b2] {c : ConNF.Code} {d : ConNF.Code} (hd : Set.Nonempty d.members) (hd\u03b2 : d.\u03b2 \u2260 \u2191\u03b2) :c \u219d\u2080 ConNF.cloudCode \u03b2 d \u2194 c = d := by sorry", "full_tactic_state": "inst\u271d\u2075 : ConNF.Params\ninst\u271d\u2074 : ConNF.Level\ninst\u271d\u00b3 : ConNF.TangleDataLt\ninst\u271d\u00b2 : ConNF.PositionedTanglesLt\ninst\u271d\u00b9 : ConNF.TypedObjectsLt\n\u03b2 : ConNF.\u039b\ninst\u271d : ConNF.LtLevel \u2191\u03b2\nc d : ConNF.Code\nhd : Set.Nonempty d.members\nhd\u03b2 : d.\u03b2 \u2260 \u2191\u03b2\n\u22a2 c \u219d\u2080 ConNF.cloudCode \u03b2 d \u2194 c = d", "dependency": [1, 98, 83, 101]}, "ConNF.CloudRel.nonempty_iff": {"natural_language_statement": "The theorem `ConNF.CloudRel.nonempty_iff` states that for any two codes `c` and `d` in the context of Constructive Ordinal Notation (ConNF), if there is a relation `c \u219d\u2080 d` between them, then the set of members of `c` is nonempty if and only if the set of members of `d` is nonempty.", "formal_statement": "example [ConNF.Params ] [ConNF.Level] [ConNF.TangleDataLt] [ConNF.PositionedTanglesLt] [ConNF.TypedObjectsLt] {c : ConNF.Code} {d : ConNF.Code} :c \u219d\u2080 d \u2192 (Set.Nonempty c.members \u2194 Set.Nonempty d.members) := by sorry", "full_tactic_state": "inst\u271d\u2074 : ConNF.Params\ninst\u271d\u00b3 : ConNF.Level\ninst\u271d\u00b2 : ConNF.TangleDataLt\ninst\u271d\u00b9 : ConNF.PositionedTanglesLt\ninst\u271d : ConNF.TypedObjectsLt\nc d : ConNF.Code\n\u22a2 c \u219d\u2080 d \u2192 (Set.Nonempty c.members \u2194 Set.Nonempty d.members)", "dependency": [1, 83, 83]}, "ConNF.cloudRelEmptyEmpty": {"natural_language_statement": "Given a set of parameters for Constructive Ordinal Notation, and assuming that a type index `\u03b3` is less than the current level `\u03b1`, and another type index `\u03b2` is also less than `\u03b1`, and `\u03b3` is not equal to `\u03b2`, the theorem `ConNF.cloudRelEmptyEmpty` proves that if there is a tangle of type `\u03b2` and `\u03b3` with an empty set of tangles, then there is a tangle of type `\u03b2` with an empty set of tangles, with the condition that `\u03b3` is not equal to `\u03b2`.", "formal_statement": "example [ConNF.Params ] [ConNF.Level] [ConNF.TangleDataLt] [ConNF.PositionedTanglesLt] [ConNF.TypedObjectsLt] (\u03b3 : ConNF.TypeIndex) [ConNF.LtLevel \u03b3] (\u03b2 : ConNF.\u039b) [ConNF.LtLevel \u2191\u03b2] (h\u03b3\u03b2 : \u03b3 \u2260 \u2191\u03b2) :ConNF.Code.mk \u03b3 \u2205 \u219d\u2080 ConNF.Code.mk \u2191\u03b2 \u2205 := by sorry", "full_tactic_state": "inst\u271d\u2076 : ConNF.Params\ninst\u271d\u2075 : ConNF.Level\ninst\u271d\u2074 : ConNF.TangleDataLt\ninst\u271d\u00b3 : ConNF.PositionedTanglesLt\ninst\u271d\u00b2 : ConNF.TypedObjectsLt\n\u03b3 : ConNF.TypeIndex\ninst\u271d\u00b9 : ConNF.LtLevel \u03b3\n\u03b2 : ConNF.\u039b\ninst\u271d : ConNF.LtLevel \u2191\u03b2\nh\u03b3\u03b2 : \u03b3 \u2260 \u2191\u03b2\n\u22a2 ConNF.Code.mk \u03b3 \u2205 \u219d\u2080 ConNF.Code.mk \u2191\u03b2 \u2205", "dependency": [1, 98, 98, 104, 104]}, "ConNF.eq_of_cloudCode": {"natural_language_statement": "Given a type index \u03b2 less than the current level and a code object c of a higher level, if c is not equal to \u03b2, then the cloud code operation ConNF.cloudCode \u03b2 c will return a new code object that is not equal to the original code object c. However, if we apply the same cloud code operation to another code object d of the same level but not equal to \u03b2, and the resulting code objects are the same, then the original code objects c and d must also be equal. This theorem formalizes this property in the context of Constructive Ordinal Notation (ConNF) in Lean 4.", "formal_statement": "example [ConNF.Params ] [ConNF.Level] [ConNF.TangleDataLt] [ConNF.PositionedTanglesLt] [ConNF.TypedObjectsLt] {c : ConNF.Code} {d : ConNF.Code} {\u03b2 : ConNF.\u039b} {\u03b3 : ConNF.\u039b} [ConNF.LtLevel \u2191\u03b2] [ConNF.LtLevel \u2191\u03b3] (hc : Set.Nonempty c.members) (hc\u03b2 : c.\u03b2 \u2260 \u2191\u03b2) (hd\u03b3 : d.\u03b2 \u2260 \u2191\u03b3) (h : ConNF.cloudCode \u03b2 c = ConNF.cloudCode \u03b3 d) :c = d := by sorry", "full_tactic_state": "inst\u271d\u2076 : ConNF.Params\ninst\u271d\u2075 : ConNF.Level\ninst\u271d\u2074 : ConNF.TangleDataLt\ninst\u271d\u00b3 : ConNF.PositionedTanglesLt\ninst\u271d\u00b2 : ConNF.TypedObjectsLt\nc d : ConNF.Code\n\u03b2 \u03b3 : ConNF.\u039b\ninst\u271d\u00b9 : ConNF.LtLevel \u2191\u03b2\ninst\u271d : ConNF.LtLevel \u2191\u03b3\nhc : Set.Nonempty c.members\nhc\u03b2 : c.\u03b2 \u2260 \u2191\u03b2\nhd\u03b3 : d.\u03b2 \u2260 \u2191\u03b3\nh : ConNF.cloudCode \u03b2 c = ConNF.cloudCode \u03b3 d\n\u22a2 c = d", "dependency": [1, 98, 98, 83, 101, 101]}, "ConNF.cloudRel_coe_coe": {"natural_language_statement": "In the context of Constructive Ordinal Notation (ConNF), the theorem `ConNF.cloudRel_coe_coe` states that for any two nonempty codes `c` and `d`, the relation `c \u219d d` holds if and only if the relation `\u2191c \u219d\u2080 \u2191d` holds, where `\u2191c` and `\u2191d` are the coercions of `c` and `d` to their respective types in the context of ConNF.", "formal_statement": "@[simp]example [ConNF.Params ] [ConNF.Level] [ConNF.TangleDataLt] [ConNF.PositionedTanglesLt] [ConNF.TypedObjectsLt] {c : ConNF.NonemptyCode} {d : ConNF.NonemptyCode} :\u2191c \u219d\u2080 \u2191d \u2194 c \u219d d := by sorry", "full_tactic_state": "inst\u271d\u2074 : ConNF.Params\ninst\u271d\u00b3 : ConNF.Level\ninst\u271d\u00b2 : ConNF.TangleDataLt\ninst\u271d\u00b9 : ConNF.PositionedTanglesLt\ninst\u271d : ConNF.TypedObjectsLt\nc d : ConNF.NonemptyCode\n\u22a2 \u2191c \u219d\u2080 \u2191d \u2194 c \u219d d", "dependency": [1]}, "ConNF.cloud_subrelation": {"natural_language_statement": "The theorem `ConNF.cloud_subrelation` states that the relation `\u219d` on `ConNF.NonemptyCode` is a subrelation of the inverse image of the relation `<` on `ConNF.\u03bc` under the function `ConNF.codeMinMap`. This means that if `x \u219d y` holds, then `ConNF.codeMinMap x < ConNF.codeMinMap y` also holds.", "formal_statement": "example [ConNF.Params ] [ConNF.Level] [ConNF.TangleDataLt] [ConNF.PositionedTanglesLt] [ConNF.TypedObjectsLt] :Subrelation (fun (x x_1 : ConNF.NonemptyCode) => x \u219d x_1) (InvImage (fun (x x_1 : ConNF.\u03bc) => x < x_1) ConNF.codeMinMap) := by sorry", "full_tactic_state": "inst\u271d\u2074 : ConNF.Params\ninst\u271d\u00b3 : ConNF.Level\ninst\u271d\u00b2 : ConNF.TangleDataLt\ninst\u271d\u00b9 : ConNF.PositionedTanglesLt\ninst\u271d : ConNF.TypedObjectsLt\n\u22a2 Subrelation (fun x x_1 => x \u219d x_1) (InvImage (fun x x_1 => x < x_1) ConNF.codeMinMap)", "dependency": [1, 122, 96]}, "ConNF.cloudRel'_wellFounded": {"natural_language_statement": "The theorem `ConNF.cloudRel'_wellFounded` in Lean 4 establishes that the relation `\u219d` defined on `ConNF.NonemptyCode` is well-founded. This means that every nonempty set of `ConNF.NonemptyCode` objects has a minimal element with respect to the relation `\u219d`. The relation `\u219d` is defined in terms of the `cloud` map, which is a key part of the ConNF (Constructive Notation For Numbers) system, used to express and manipulate natural numbers. The theorem's proof indicates that the iterated images under the `cloud` map (and its inverse) can be shown to be finite, thus ensuring the well-foundedness of the relation `\u219d`.", "formal_statement": "example [ConNF.Params ] [ConNF.Level] [ConNF.TangleDataLt] [ConNF.PositionedTanglesLt] [ConNF.TypedObjectsLt] :WellFounded fun (x x_1 : ConNF.NonemptyCode) => x \u219d x_1 := by sorry", "full_tactic_state": "inst\u271d\u2074 : ConNF.Params\ninst\u271d\u00b3 : ConNF.Level\ninst\u271d\u00b2 : ConNF.TangleDataLt\ninst\u271d\u00b9 : ConNF.PositionedTanglesLt\ninst\u271d : ConNF.TypedObjectsLt\n\u22a2 WellFounded fun x x_1 => x \u219d x_1", "dependency": [1, 19]}, "ConNF.cloudRel'_subsingleton": {"natural_language_statement": "In the context of Constructive Ordinal Notation (ConNF), the theorem `ConNF.cloudRel'_subsingleton` states that for any given nonempty code `c`, there is at most one nonempty code `d` such that `d` is related to `c` under the `cloud` map relation.", "formal_statement": "example [ConNF.Params ] [ConNF.Level] [ConNF.TangleDataLt] [ConNF.PositionedTanglesLt] [ConNF.TypedObjectsLt] (c : ConNF.NonemptyCode) :Set.Subsingleton {d : ConNF.NonemptyCode | d \u219d c} := by sorry", "full_tactic_state": "inst\u271d\u2074 : ConNF.Params\ninst\u271d\u00b3 : ConNF.Level\ninst\u271d\u00b2 : ConNF.TangleDataLt\ninst\u271d\u00b9 : ConNF.PositionedTanglesLt\ninst\u271d : ConNF.TypedObjectsLt\nc : ConNF.NonemptyCode\n\u22a2 Set.Subsingleton {d | d \u219d c}", "dependency": [1, 115]}, "ConNF.Code.ext_iff": {"natural_language_statement": "The theorem `ConNF.Code.ext_iff` states that two `ConNF.Code` objects are equal if and only if their `\u03b2` components are equal and their `members` components are equal up to heterogeneous equality (`HEq`).", "formal_statement": "example :\u2200 {inst : ConNF.Params } {inst_1 : ConNF.Level} {inst_2 : ConNF.TangleDataLt} (x y : ConNF.Code), x = y \u2194 x.\u03b2 = y.\u03b2 \u2227 HEq x.members y.members := by sorry", "full_tactic_state": "\u22a2 \u2200 {inst : ConNF.Params} {inst_1 : ConNF.Level} {inst_2 : ConNF.TangleDataLt} (x y : ConNF.Code),\n    x = y \u2194 x.\u03b2 = y.\u03b2 \u2227 HEq x.members y.members", "dependency": [1, 126]}, "ConNF.Code.ext": {"natural_language_statement": "In the context of Constructive Ordinal Notation (ConNF), the theorem `ConNF.Code.ext` states that two `ConNF.Code` objects are equal if their `\u03b2` components are equal and their `members` components are equal up to heterogeneous equality (`HEq`).", "formal_statement": "example :\u2200 {inst : ConNF.Params } {inst_1 : ConNF.Level} {inst_2 : ConNF.TangleDataLt} (x y : ConNF.Code), x.\u03b2 = y.\u03b2 \u2192 HEq x.members y.members \u2192 x = y := by sorry", "full_tactic_state": "\u22a2 \u2200 {inst : ConNF.Params} {inst_1 : ConNF.Level} {inst_2 : ConNF.TangleDataLt} (x y : ConNF.Code),\n    x.\u03b2 = y.\u03b2 \u2192 HEq x.members y.members \u2192 x = y", "dependency": [1, 126]}, "ConNF.Code.IsEmpty.eq": {"natural_language_statement": "Function `ConNF.Code.IsEmpty.eq` is a theorem in Lean 4 that states that if a `ConNF.Code` object `c` is empty, then the set of members of `c` is equal to the empty set.", "formal_statement": "example [ConNF.Params ] [ConNF.Level] [ConNF.TangleDataLt] {c : ConNF.Code} :ConNF.Code.IsEmpty c \u2192 c.members = \u2205 := by sorry", "full_tactic_state": "inst\u271d\u00b2 : ConNF.Params\ninst\u271d\u00b9 : ConNF.Level\ninst\u271d : ConNF.TangleDataLt\nc : ConNF.Code\n\u22a2 ConNF.Code.IsEmpty c \u2192 c.members = \u2205", "dependency": [1, 107]}, "ConNF.Code.isEmpty_mk": {"natural_language_statement": "The theorem `ConNF.Code.isEmpty_mk` states that a `ConNF.Code` object is empty if and only if the set of tangles it contains is empty.", "formal_statement": "@[simp]example [ConNF.Params ] [ConNF.Level] [ConNF.TangleDataLt] {\u03b2 : ConNF.\u039b} [ConNF.LtLevel \u2191\u03b2] {s : Set (ConNF.Tangle \u2191\u03b2)} :ConNF.Code.IsEmpty (ConNF.Code.mk (\u2191\u03b2) s) \u2194 s = \u2205 := by sorry", "full_tactic_state": "inst\u271d\u00b3 : ConNF.Params\ninst\u271d\u00b2 : ConNF.Level\ninst\u271d\u00b9 : ConNF.TangleDataLt\n\u03b2 : ConNF.\u039b\ninst\u271d : ConNF.LtLevel \u2191\u03b2\ns : Set (ConNF.Tangle \u2191\u03b2)\n\u22a2 ConNF.Code.IsEmpty (ConNF.Code.mk (\u2191\u03b2) s) \u2194 s = \u2205", "dependency": [1, 98, 69, 107, 104]}, "ConNF.Code.mk_inj": {"natural_language_statement": "The theorem `ConNF.Code.mk_inj` states that for two sets of tangles `s` and `t` of the same type index `\u03b2` less than the current level `\u03b1` in the context of Constructive Ordinal Notation (ConNF), the codes `ConNF.Code.mk (\u2191\u03b2) s` and `ConNF.Code.mk (\u2191\u03b2) t` are equal if and only if the sets `s` and `t` are equal.", "formal_statement": "@[simp]example [ConNF.Params ] [ConNF.Level] [ConNF.TangleDataLt] {\u03b2 : ConNF.\u039b} [ConNF.LtLevel \u2191\u03b2] {s : Set (ConNF.Tangle \u2191\u03b2)} {t : Set (ConNF.Tangle \u2191\u03b2)} :ConNF.Code.mk (\u2191\u03b2) s = ConNF.Code.mk (\u2191\u03b2) t \u2194 s = t := by sorry", "full_tactic_state": "inst\u271d\u00b3 : ConNF.Params\ninst\u271d\u00b2 : ConNF.Level\ninst\u271d\u00b9 : ConNF.TangleDataLt\n\u03b2 : ConNF.\u039b\ninst\u271d : ConNF.LtLevel \u2191\u03b2\ns t : Set (ConNF.Tangle \u2191\u03b2)\n\u22a2 ConNF.Code.mk (\u2191\u03b2) s = ConNF.Code.mk (\u2191\u03b2) t \u2194 s = t", "dependency": [1, 98, 69, 69, 104, 104]}, "ConNF.SemiallowablePerm.mul_apply": {"natural_language_statement": "The `ConNF.SemiallowablePerm.mul_apply` theorem states that the application of the product of two semiallowable permutations `\u03c1` and `\u03c1'` to a type index `\u03b2` is equal to the product of the applications of `\u03c1` and `\u03c1'` to `\u03b2`.", "formal_statement": "@[simp]example [ConNF.Params ] [ConNF.Level] [ConNF.TangleDataLt] (\u03b2 : ConNF.TypeIndex) [ConNF.LtLevel \u03b2] (\u03c1 : ConNF.SemiallowablePerm) (\u03c1' : ConNF.SemiallowablePerm) :(\u03c1 * \u03c1') \u03b2 = \u03c1 \u03b2 * \u03c1' \u03b2 := by sorry", "full_tactic_state": "inst\u271d\u00b3 : ConNF.Params\ninst\u271d\u00b2 : ConNF.Level\ninst\u271d\u00b9 : ConNF.TangleDataLt\n\u03b2 : ConNF.TypeIndex\ninst\u271d : ConNF.LtLevel \u03b2\n\u03c1 \u03c1' : ConNF.SemiallowablePerm\n\u22a2 (\u03c1 * \u03c1') \u03b2 = \u03c1 \u03b2 * \u03c1' \u03b2", "dependency": [1, 98]}, "ConNF.SemiallowablePerm.inv_apply": {"natural_language_statement": "The theorem `ConNF.SemiallowablePerm.inv_apply` states that for any semiallowable permutation `\u03c1` and any type index `\u03b2` less than the current level, the inverse of `\u03c1` applied to `\u03b2` is equal to the inverse of `\u03c1` applied to `\u03b2`.", "formal_statement": "@[simp]example [ConNF.Params ] [ConNF.Level] [ConNF.TangleDataLt] (\u03b2 : ConNF.TypeIndex) [ConNF.LtLevel \u03b2] (\u03c1 : ConNF.SemiallowablePerm) :\u03c1\u207b\u00b9 \u03b2 = (\u03c1 \u03b2)\u207b\u00b9 := by sorry", "full_tactic_state": "inst\u271d\u00b3 : ConNF.Params\ninst\u271d\u00b2 : ConNF.Level\ninst\u271d\u00b9 : ConNF.TangleDataLt\n\u03b2 : ConNF.TypeIndex\ninst\u271d : ConNF.LtLevel \u03b2\n\u03c1 : ConNF.SemiallowablePerm\n\u22a2 \u03c1\u207b\u00b9 \u03b2 = (\u03c1 \u03b2)\u207b\u00b9", "dependency": [1, 98]}, "ConNF.SemiallowablePerm.pathTop_toPath_comp": {"natural_language_statement": "Function `ConNF.SemiallowablePerm.pathTop` takes a path in a quiver from vertex `x` to vertex `y` and returns the second vertex in the path if the path is nonempty, or `y` if the path is empty. Function `Quiver.Path.comp` composes two paths in a quiver. Given a path from vertex `a` to vertex `b` and a path from vertex `b` to vertex `c`, it returns a path from vertex `a` to vertex `c`. Function `Quiver.Hom.toPath` converts a single arrow in a quiver into a path of length one. The theorem `ConNF.SemiallowablePerm.pathTop_toPath_comp` states that if `e` is an arrow from vertex `x` to vertex `y`, and `p` is a path from vertex `y` to vertex `z`, then `ConNF.SemiallowablePerm.pathTop (Quiver.Path.comp (Quiver.Hom.toPath e) p) = y`.", "formal_statement": "example {V : Type u_2} [Quiver V] {x : V} {y : V} {z : V} (e : x \u27f6 y) (p : Quiver.Path y z) :ConNF.SemiallowablePerm.pathTop (Quiver.Path.comp (Quiver.Hom.toPath e) p) = y := by sorry", "full_tactic_state": "V : Type u_2\ninst\u271d : Quiver V\nx y z : V\ne : x \u27f6 y\np : Quiver.Path y z\n\u22a2 ConNF.SemiallowablePerm.pathTop (Quiver.Path.comp (Quiver.Hom.toPath e) p) = y", "dependency": [75, 76, 134, 135, 74]}, "ConNF.SemiallowablePerm.pathTop_pathTail": {"natural_language_statement": "The theorem `ConNF.SemiallowablePerm.pathTop_pathTail` states that given a path `p` from vertex `x` to vertex `y` in a quiver, if the length of `p` is not zero (meaning `p` is not a trivial path), then we can remove the first morphism from `p` and compose it back to form the original path `p`.", "formal_statement": "example {V : Type u_2} [Quiver V] {x : V} {y : V} (p : Quiver.Path x y) (h : Quiver.Path.length p \u2260 0) :Quiver.Path.comp (Quiver.Hom.toPath (ConNF.SemiallowablePerm.pathTop_hom p h)) (ConNF.SemiallowablePerm.pathTail p) = p := by sorry", "full_tactic_state": "V : Type u_2\ninst\u271d : Quiver V\nx y : V\np : Quiver.Path x y\nh : Quiver.Path.length p \u2260 0\n\u22a2 Quiver.Path.comp (Quiver.Hom.toPath (ConNF.SemiallowablePerm.pathTop_hom p h)) (ConNF.SemiallowablePerm.pathTail p) =\n    p", "dependency": [75, 76, 137, 135, 74, 138, 139]}, "ConNF.SemiallowablePerm.toStructPerm'_one": {"natural_language_statement": "The theorem `ConNF.SemiallowablePerm.toStructPerm'_one` states that the function `ConNF.SemiallowablePerm.toStructPerm'`, which converts a semi-allowable permutation to a structural permutation in the context of Constructive Ordinal Notation (ConNF), maps the identity permutation to itself.", "formal_statement": "example [ConNF.Params ] [ConNF.Level] [ConNF.TangleDataLt] :ConNF.SemiallowablePerm.toStructPerm' 1 = 1 := by sorry", "full_tactic_state": "inst\u271d\u00b2 : ConNF.Params\ninst\u271d\u00b9 : ConNF.Level\ninst\u271d : ConNF.TangleDataLt\n\u22a2 ConNF.SemiallowablePerm.toStructPerm' 1 = 1", "dependency": [1, 141]}, "ConNF.SemiallowablePerm.toStructPerm_smul": {"natural_language_statement": "The theorem `ConNF.SemiallowablePerm.toStructPerm_smul` states that the action of a semiallowable permutation `\u03c1` on an element `x` of a type `X` with a multiplicative action by structural permutations is equal to the action of the corresponding structural permutation `ConNF.SemiallowablePerm.toStructPerm \u03c1` on `x`.", "formal_statement": "@[simp]example [ConNF.Params ] [ConNF.Level] [ConNF.TangleDataLt] {X : Type u_1} [MulAction (ConNF.StructPerm \u2191ConNF.\u03b1) X] (\u03c1 : ConNF.SemiallowablePerm) (x : X) :\u03c1 \u2022 x = ConNF.SemiallowablePerm.toStructPerm \u03c1 \u2022 x := by sorry", "full_tactic_state": "inst\u271d\u00b3 : ConNF.Params\ninst\u271d\u00b2 : ConNF.Level\ninst\u271d\u00b9 : ConNF.TangleDataLt\nX : Type u_1\ninst\u271d : MulAction (ConNF.StructPerm \u2191ConNF.\u03b1) X\n\u03c1 : ConNF.SemiallowablePerm\nx : X\n\u22a2 \u03c1 \u2022 x = ConNF.SemiallowablePerm.toStructPerm \u03c1 \u2022 x", "dependency": [1, 56, 55]}, "ConNF.SemiallowablePerm.\u03b2_smul": {"natural_language_statement": "The theorem `ConNF.SemiallowablePerm.\u03b2_smul` states that for any semiallowable permutation `\u03c1` and any code `c`, the `\u03b2` value of `\u03c1` acting on `c` is equal to the `\u03b2` value of `c`.", "formal_statement": "@[simp]example [ConNF.Params ] [ConNF.Level] [ConNF.TangleDataLt] (\u03c1 : ConNF.SemiallowablePerm) (c : ConNF.Code) :(\u03c1 \u2022 c).\u03b2 = c.\u03b2 := by sorry", "full_tactic_state": "inst\u271d\u00b2 : ConNF.Params\ninst\u271d\u00b9 : ConNF.Level\ninst\u271d : ConNF.TangleDataLt\n\u03c1 : ConNF.SemiallowablePerm\nc : ConNF.Code\n\u22a2 (\u03c1 \u2022 c).\u03b2 = c.\u03b2", "dependency": [1]}, "ConNF.SemiallowablePerm.coe_smul": {"natural_language_statement": "The theorem `ConNF.SemiallowablePerm.coe_smul` states that for any semiallowable permutation `\u03c1` and any nonempty code `c`, the action of `\u03c1` on `c` (denoted as `\u03c1 \u2022 c`) is equal to the action of `\u03c1` on the underlying value of `c` (denoted as `\u03c1 \u2022 \u2191c`).", "formal_statement": "@[simp]example [ConNF.Params ] [ConNF.Level] [ConNF.TangleDataLt] (\u03c1 : ConNF.SemiallowablePerm) (c : ConNF.NonemptyCode) :\u2191(\u03c1 \u2022 c) = \u03c1 \u2022 \u2191c := by sorry", "full_tactic_state": "inst\u271d\u00b2 : ConNF.Params\ninst\u271d\u00b9 : ConNF.Level\ninst\u271d : ConNF.TangleDataLt\n\u03c1 : ConNF.SemiallowablePerm\nc : ConNF.NonemptyCode\n\u22a2 \u03c1 \u2022 c = \u03c1 \u2022 c", "dependency": [1]}, "ConNF.isAllowable_one": {"natural_language_statement": "The theorem `ConNF.isAllowable_one` states that the semiallowable permutation `1` is allowable in the context of Constructive Ordinal Notation (ConNF). A semiallowable permutation is allowable if its one-step derivatives commute with the `fuzz` maps, which are functions used in the construction of the natural numbers in ConNF. This property ensures that the permutation `1` behaves consistently with the `fuzz` maps across different levels of the ConNF hierarchy.", "formal_statement": "example [ConNF.Params ] [ConNF.Level] [ConNF.TangleDataLt] [ConNF.PositionedTanglesLt] [ConNF.TypedObjectsLt] :ConNF.SemiallowablePerm.IsAllowable 1 := by sorry", "full_tactic_state": "inst\u271d\u2074 : ConNF.Params\ninst\u271d\u00b3 : ConNF.Level\ninst\u271d\u00b2 : ConNF.TangleDataLt\ninst\u271d\u00b9 : ConNF.PositionedTanglesLt\ninst\u271d : ConNF.TypedObjectsLt\n\u22a2 ConNF.SemiallowablePerm.IsAllowable 1", "dependency": [1, 146]}, "ConNF.isAllowable_inv": {"natural_language_statement": "Given a semiallowable permutation `\u03c1` in the context of Constructive Ordinal Notation (ConNF), if `\u03c1` is allowable, then its inverse `\u03c1\u207b\u00b9` is also allowable.", "formal_statement": "example [ConNF.Params ] [ConNF.Level] [ConNF.TangleDataLt] [ConNF.PositionedTanglesLt] [ConNF.TypedObjectsLt] {\u03c1 : ConNF.SemiallowablePerm} (h : ConNF.SemiallowablePerm.IsAllowable \u03c1) :ConNF.SemiallowablePerm.IsAllowable \u03c1\u207b\u00b9 := by sorry", "full_tactic_state": "inst\u271d\u2074 : ConNF.Params\ninst\u271d\u00b3 : ConNF.Level\ninst\u271d\u00b2 : ConNF.TangleDataLt\ninst\u271d\u00b9 : ConNF.PositionedTanglesLt\ninst\u271d : ConNF.TypedObjectsLt\n\u03c1 : ConNF.SemiallowablePerm\nh : ConNF.SemiallowablePerm.IsAllowable \u03c1\n\u22a2 ConNF.SemiallowablePerm.IsAllowable \u03c1\u207b\u00b9", "dependency": [1, 146, 146]}, "ConNF.isAllowable_mul": {"natural_language_statement": "Function `ConNF.isAllowable_mul` proves that the product of two allowable semiallowable permutations in the context of Constructive Ordinal Notation (ConNF) is also allowable. A semiallowable permutation is allowable if its one-step derivatives commute with the `fuzz` maps, which are functions used in the construction of the natural numbers in ConNF. This property ensures that the permutations behave consistently with the `fuzz` maps across different levels of the ConNF hierarchy.", "formal_statement": "example [ConNF.Params ] [ConNF.Level] [ConNF.TangleDataLt] [ConNF.PositionedTanglesLt] [ConNF.TypedObjectsLt] {\u03c1 : ConNF.SemiallowablePerm} {\u03c1' : ConNF.SemiallowablePerm} (h : ConNF.SemiallowablePerm.IsAllowable \u03c1) (h' : ConNF.SemiallowablePerm.IsAllowable \u03c1') :ConNF.SemiallowablePerm.IsAllowable (\u03c1 * \u03c1') := by sorry", "full_tactic_state": "inst\u271d\u2074 : ConNF.Params\ninst\u271d\u00b3 : ConNF.Level\ninst\u271d\u00b2 : ConNF.TangleDataLt\ninst\u271d\u00b9 : ConNF.PositionedTanglesLt\ninst\u271d : ConNF.TypedObjectsLt\n\u03c1 \u03c1' : ConNF.SemiallowablePerm\nh : ConNF.SemiallowablePerm.IsAllowable \u03c1\nh' : ConNF.SemiallowablePerm.IsAllowable \u03c1'\n\u22a2 ConNF.SemiallowablePerm.IsAllowable (\u03c1 * \u03c1')", "dependency": [1, 146, 146, 146]}, "ConNF.isAllowable_div": {"natural_language_statement": "Function `ConNF.SemiallowablePerm.IsAllowable` checks if a semiallowable permutation `\u03c1` in the context of Constructive Ordinal Notation (ConNF) is allowable. A semiallowable permutation is allowable if its one-step derivatives commute with the `fuzz` maps, which are functions used in the construction of the natural numbers in ConNF. This property ensures that the permutation `\u03c1` behaves consistently with the `fuzz` maps across different levels of the ConNF hierarchy. The theorem `ConNF.isAllowable_div` states that if `\u03c1` and `\u03c1'` are both allowable semiallowable permutations, then their quotient `\u03c1 / \u03c1'` is also allowable.", "formal_statement": "example [ConNF.Params ] [ConNF.Level] [ConNF.TangleDataLt] [ConNF.PositionedTanglesLt] [ConNF.TypedObjectsLt] {\u03c1 : ConNF.SemiallowablePerm} {\u03c1' : ConNF.SemiallowablePerm} (h : ConNF.SemiallowablePerm.IsAllowable \u03c1) (h' : ConNF.SemiallowablePerm.IsAllowable \u03c1') :ConNF.SemiallowablePerm.IsAllowable (\u03c1 / \u03c1') := by sorry", "full_tactic_state": "inst\u271d\u2074 : ConNF.Params\ninst\u271d\u00b3 : ConNF.Level\ninst\u271d\u00b2 : ConNF.TangleDataLt\ninst\u271d\u00b9 : ConNF.PositionedTanglesLt\ninst\u271d : ConNF.TypedObjectsLt\n\u03c1 \u03c1' : ConNF.SemiallowablePerm\nh : ConNF.SemiallowablePerm.IsAllowable \u03c1\nh' : ConNF.SemiallowablePerm.IsAllowable \u03c1'\n\u22a2 ConNF.SemiallowablePerm.IsAllowable (\u03c1 / \u03c1')", "dependency": [1, 146, 146, 146]}, "ConNF.isAllowable_pow": {"natural_language_statement": "The theorem `ConNF.isAllowable_pow` states that if `\u03c1` is an allowable semiallowable permutation in the context of Constructive Ordinal Notation (ConNF), then any power of `\u03c1` is also allowable.", "formal_statement": "example [ConNF.Params ] [ConNF.Level] [ConNF.TangleDataLt] [ConNF.PositionedTanglesLt] [ConNF.TypedObjectsLt] {\u03c1 : ConNF.SemiallowablePerm} (h : ConNF.SemiallowablePerm.IsAllowable \u03c1) (n : \u2115 ) :ConNF.SemiallowablePerm.IsAllowable (\u03c1 ^ n) := by sorry", "full_tactic_state": "inst\u271d\u2074 : ConNF.Params\ninst\u271d\u00b3 : ConNF.Level\ninst\u271d\u00b2 : ConNF.TangleDataLt\ninst\u271d\u00b9 : ConNF.PositionedTanglesLt\ninst\u271d : ConNF.TypedObjectsLt\n\u03c1 : ConNF.SemiallowablePerm\nh : ConNF.SemiallowablePerm.IsAllowable \u03c1\nn : \u2115\n\u22a2 ConNF.SemiallowablePerm.IsAllowable (\u03c1 ^ n)", "dependency": [1, 146, 146]}, "ConNF.isAllowable_zpow": {"natural_language_statement": "The theorem `ConNF.isAllowable_zpow` states that if `\u03c1` is an allowable semiallowable permutation in the context of Constructive Ordinal Notation (ConNF), then `\u03c1` raised to any integer power `n` is also an allowable semiallowable permutation.", "formal_statement": "example [ConNF.Params ] [ConNF.Level] [ConNF.TangleDataLt] [ConNF.PositionedTanglesLt] [ConNF.TypedObjectsLt] {\u03c1 : ConNF.SemiallowablePerm} (h : ConNF.SemiallowablePerm.IsAllowable \u03c1) (n : \u2124 ) :ConNF.SemiallowablePerm.IsAllowable (\u03c1 ^ n) := by sorry", "full_tactic_state": "inst\u271d\u2074 : ConNF.Params\ninst\u271d\u00b3 : ConNF.Level\ninst\u271d\u00b2 : ConNF.TangleDataLt\ninst\u271d\u00b9 : ConNF.PositionedTanglesLt\ninst\u271d : ConNF.TypedObjectsLt\n\u03c1 : ConNF.SemiallowablePerm\nh : ConNF.SemiallowablePerm.IsAllowable \u03c1\nn : \u2124\n\u22a2 ConNF.SemiallowablePerm.IsAllowable (\u03c1 ^ n)", "dependency": [1, 146, 146]}, "ConNF.NewAllowable.coe_one": {"natural_language_statement": "In the context of Constructive Ordinal Notation (ConNF), the theorem `ConNF.NewAllowable.coe_one` states that the natural number 1, when coerced into the type `ConNF.NewAllowable`, is equal to 1. This theorem is marked as `simp` in Lean, indicating that it can be used as a simplification rule.", "formal_statement": "@[simp]example [ConNF.Params ] [ConNF.Level] [ConNF.TangleDataLt] [ConNF.PositionedTanglesLt] [ConNF.TypedObjectsLt] :\u21911 = 1 := by sorry", "full_tactic_state": "inst\u271d\u2074 : ConNF.Params\ninst\u271d\u00b3 : ConNF.Level\ninst\u271d\u00b2 : ConNF.TangleDataLt\ninst\u271d\u00b9 : ConNF.PositionedTanglesLt\ninst\u271d : ConNF.TypedObjectsLt\n\u22a2 1 = 1", "dependency": [1]}, "ConNF.NewAllowable.coe_inv": {"natural_language_statement": "The theorem `ConNF.NewAllowable.coe_inv` states that the inverse of a `ConNF.NewAllowable` object, when coerced to a real number, is equal to the inverse of the real number obtained by coercing the `ConNF.NewAllowable` object.", "formal_statement": "@[simp]example [ConNF.Params ] [ConNF.Level] [ConNF.TangleDataLt] [ConNF.PositionedTanglesLt] [ConNF.TypedObjectsLt] (\u03c1 : ConNF.NewAllowable) :\u2191\u03c1\u207b\u00b9 = (\u2191\u03c1)\u207b\u00b9 := by sorry", "full_tactic_state": "inst\u271d\u2074 : ConNF.Params\ninst\u271d\u00b3 : ConNF.Level\ninst\u271d\u00b2 : ConNF.TangleDataLt\ninst\u271d\u00b9 : ConNF.PositionedTanglesLt\ninst\u271d : ConNF.TypedObjectsLt\n\u03c1 : ConNF.NewAllowable\n\u22a2 \u03c1\u207b\u00b9 = \u03c1\u207b\u00b9", "dependency": [1]}, "ConNF.NewAllowable.coe_mul": {"natural_language_statement": "In the context of Constructive Ordinal Notation (ConNF), the theorem `ConNF.NewAllowable.coe_mul` states that the natural number representation of the product of two `ConNF.NewAllowable` objects is equal to the product of their natural number representations.", "formal_statement": "@[simp]example [ConNF.Params ] [ConNF.Level] [ConNF.TangleDataLt] [ConNF.PositionedTanglesLt] [ConNF.TypedObjectsLt] (\u03c1 : ConNF.NewAllowable) (\u03c1' : ConNF.NewAllowable) :\u2191(\u03c1 * \u03c1') = \u2191\u03c1 * \u2191\u03c1' := by sorry", "full_tactic_state": "inst\u271d\u2074 : ConNF.Params\ninst\u271d\u00b3 : ConNF.Level\ninst\u271d\u00b2 : ConNF.TangleDataLt\ninst\u271d\u00b9 : ConNF.PositionedTanglesLt\ninst\u271d : ConNF.TypedObjectsLt\n\u03c1 \u03c1' : ConNF.NewAllowable\n\u22a2 \u03c1 * \u03c1' = \u03c1 * \u03c1'", "dependency": [1]}, "ConNF.NewAllowable.coe_div": {"natural_language_statement": "The theorem `ConNF.NewAllowable.coe_div` states that the natural number representation of the division of two `ConNF.NewAllowable` objects is equal to the division of their natural number representations.", "formal_statement": "@[simp]example [ConNF.Params ] [ConNF.Level] [ConNF.TangleDataLt] [ConNF.PositionedTanglesLt] [ConNF.TypedObjectsLt] (\u03c1 : ConNF.NewAllowable) (\u03c1' : ConNF.NewAllowable) :\u2191(\u03c1 / \u03c1') = \u2191\u03c1 / \u2191\u03c1' := by sorry", "full_tactic_state": "inst\u271d\u2074 : ConNF.Params\ninst\u271d\u00b3 : ConNF.Level\ninst\u271d\u00b2 : ConNF.TangleDataLt\ninst\u271d\u00b9 : ConNF.PositionedTanglesLt\ninst\u271d : ConNF.TypedObjectsLt\n\u03c1 \u03c1' : ConNF.NewAllowable\n\u22a2 \u03c1 / \u03c1' = \u03c1 / \u03c1'", "dependency": [1]}, "ConNF.NewAllowable.coe_pow": {"natural_language_statement": "The theorem `ConNF.NewAllowable.coe_pow` states that for any `ConNF.NewAllowable` object `\u03c1` and any natural number `n`, the `n`th power of `\u03c1` (denoted as `\u03c1 ^ n`) is equal to the `n`th power of the underlying value of `\u03c1` (denoted as `\u2191\u03c1 ^ n`).", "formal_statement": "@[simp]example [ConNF.Params ] [ConNF.Level] [ConNF.TangleDataLt] [ConNF.PositionedTanglesLt] [ConNF.TypedObjectsLt] (\u03c1 : ConNF.NewAllowable) (n : \u2115 ) :\u2191(\u03c1 ^ n) = \u2191\u03c1 ^ n := by sorry", "full_tactic_state": "inst\u271d\u2074 : ConNF.Params\ninst\u271d\u00b3 : ConNF.Level\ninst\u271d\u00b2 : ConNF.TangleDataLt\ninst\u271d\u00b9 : ConNF.PositionedTanglesLt\ninst\u271d : ConNF.TypedObjectsLt\n\u03c1 : ConNF.NewAllowable\nn : \u2115\n\u22a2 \u03c1 ^ n = \u03c1 ^ n", "dependency": [1]}, "ConNF.NewAllowable.coe_zpow": {"natural_language_statement": "The theorem `ConNF.NewAllowable.coe_zpow` states that for any `ConNF.NewAllowable` object `\u03c1` and any integer `n`, the natural number representation of `\u03c1` raised to the power `n` is equal to the natural number representation of `\u03c1` raised to the power `n`.", "formal_statement": "@[simp]example [ConNF.Params ] [ConNF.Level] [ConNF.TangleDataLt] [ConNF.PositionedTanglesLt] [ConNF.TypedObjectsLt] (\u03c1 : ConNF.NewAllowable) (n : \u2124 ) :\u2191(\u03c1 ^ n) = \u2191\u03c1 ^ n := by sorry", "full_tactic_state": "inst\u271d\u2074 : ConNF.Params\ninst\u271d\u00b3 : ConNF.Level\ninst\u271d\u00b2 : ConNF.TangleDataLt\ninst\u271d\u00b9 : ConNF.PositionedTanglesLt\ninst\u271d : ConNF.TypedObjectsLt\n\u03c1 : ConNF.NewAllowable\nn : \u2124\n\u22a2 \u03c1 ^ n = \u03c1 ^ n", "dependency": [1]}, "ConNF.NewAllowable.coeHom_apply": {"natural_language_statement": "Function `ConNF.NewAllowable.coeHom_apply` is a simplification theorem in the context of Constructive Ordinal Notation (ConNF) in Lean 4. It states that for a semiallowable permutation `\u03c1` that is allowable (i.e., its one-step derivatives commute with the `fuzz` maps), the function `ConNF.NewAllowable.coeHom` applied to `\u03c1` simply returns `\u03c1` itself.", "formal_statement": "@[simp]example [ConNF.Params ] [ConNF.Level] [ConNF.TangleDataLt] [ConNF.PositionedTanglesLt] [ConNF.TypedObjectsLt] (self : { \u03c1 : ConNF.SemiallowablePerm // ConNF.SemiallowablePerm.IsAllowable \u03c1 }) :ConNF.NewAllowable.coeHom self = \u2191self := by sorry", "full_tactic_state": "inst\u271d\u2074 : ConNF.Params\ninst\u271d\u00b3 : ConNF.Level\ninst\u271d\u00b2 : ConNF.TangleDataLt\ninst\u271d\u00b9 : ConNF.PositionedTanglesLt\ninst\u271d : ConNF.TypedObjectsLt\nself : { \u03c1 // ConNF.SemiallowablePerm.IsAllowable \u03c1 }\n\u22a2 ConNF.NewAllowable.coeHom self = \u2191self", "dependency": [1, 146]}, "ConNF.NewAllowable.coe_smul": {"natural_language_statement": "The theorem `ConNF.NewAllowable.coe_smul` is a simplication lemma in Lean 4. It states that for any `ConNF.NewAllowable` object `\u03c1` and any type `X` with a `MulAction` of `ConNF.SemiallowablePerm` on `X`, the action of `\u03c1` on `x : X` is the same whether `\u03c1` is considered as an element of `ConNF.NewAllowable` or as an element of `ConNF.SemiallowablePerm`.", "formal_statement": "@[simp]example [ConNF.Params ] [ConNF.Level] [ConNF.TangleDataLt] [ConNF.PositionedTanglesLt] [ConNF.TypedObjectsLt] {X : Type u_1} [MulAction ConNF.SemiallowablePerm X] (\u03c1 : ConNF.NewAllowable) (x : X) :\u2191\u03c1 \u2022 x = \u03c1 \u2022 x := by sorry", "full_tactic_state": "inst\u271d\u2075 : ConNF.Params\ninst\u271d\u2074 : ConNF.Level\ninst\u271d\u00b3 : ConNF.TangleDataLt\ninst\u271d\u00b2 : ConNF.PositionedTanglesLt\ninst\u271d\u00b9 : ConNF.TypedObjectsLt\nX : Type u_1\ninst\u271d : MulAction ConNF.SemiallowablePerm X\n\u03c1 : ConNF.NewAllowable\nx : X\n\u22a2 \u03c1 \u2022 x = \u03c1 \u2022 x", "dependency": [1, 56]}, "ConNF.NewAllowable.\u03b2_smul": {"natural_language_statement": "The theorem `ConNF.NewAllowable.\u03b2_smul` states that for any `ConNF.NewAllowable` object `\u03c1` and any `ConNF.Code` object `c`, the `\u03b2` component of the `ConNF.Code` object `(\u03c1 \u2022 c)` is equal to the `\u03b2` component of `c`.", "formal_statement": "@[simp]example [ConNF.Params ] [ConNF.Level] [ConNF.TangleDataLt] [ConNF.PositionedTanglesLt] [ConNF.TypedObjectsLt] (\u03c1 : ConNF.NewAllowable) (c : ConNF.Code) :(\u03c1 \u2022 c).\u03b2 = c.\u03b2 := by sorry", "full_tactic_state": "inst\u271d\u2074 : ConNF.Params\ninst\u271d\u00b3 : ConNF.Level\ninst\u271d\u00b2 : ConNF.TangleDataLt\ninst\u271d\u00b9 : ConNF.PositionedTanglesLt\ninst\u271d : ConNF.TypedObjectsLt\n\u03c1 : ConNF.NewAllowable\nc : ConNF.Code\n\u22a2 (\u03c1 \u2022 c).\u03b2 = c.\u03b2", "dependency": [1]}, "ConNF.NewAllowable.smul_cloudCode": {"natural_language_statement": "Function `ConNF.NewAllowable.smul_cloudCode` proves that allowable permutations commute with the `cloudCode` map in the context of Constructive Ordinal Notation (ConNF).", "formal_statement": "example [ConNF.Params ] [ConNF.Level] [ConNF.TangleDataLt] {\u03b3 : ConNF.\u039b} [ConNF.LtLevel \u2191\u03b3] [ConNF.PositionedTanglesLt] [ConNF.TypedObjectsLt] {c : ConNF.Code} (\u03c1 : ConNF.NewAllowable) (hc : c.\u03b2 \u2260 \u2191\u03b3) :\u03c1 \u2022 ConNF.cloudCode \u03b3 c = ConNF.cloudCode \u03b3 (\u03c1 \u2022 c) := by sorry", "full_tactic_state": "inst\u271d\u2075 : ConNF.Params\ninst\u271d\u2074 : ConNF.Level\ninst\u271d\u00b3 : ConNF.TangleDataLt\n\u03b3 : ConNF.\u039b\ninst\u271d\u00b2 : ConNF.LtLevel \u2191\u03b3\ninst\u271d\u00b9 : ConNF.PositionedTanglesLt\ninst\u271d : ConNF.TypedObjectsLt\nc : ConNF.Code\n\u03c1 : ConNF.NewAllowable\nhc : c.\u03b2 \u2260 \u2191\u03b3\n\u22a2 \u03c1 \u2022 ConNF.cloudCode \u03b3 c = ConNF.cloudCode \u03b3 (\u03c1 \u2022 c)", "dependency": [1, 98, 101, 101]}, "ConNF.CloudRel.smul": {"natural_language_statement": "In the context of Constructive Ordinal Notation (ConNF), the theorem `ConNF.CloudRel.smul` states that if there is a relation `c \u219d\u2080 d` between two codes `c` and `d`, then there is also a relation `\u03c1 \u2022 c \u219d\u2080 \u03c1 \u2022 d` between the codes obtained by multiplying `c` and `d` by a new allowable `\u03c1`.", "formal_statement": "example [ConNF.Params ] [ConNF.Level] [ConNF.TangleDataLt] [ConNF.PositionedTanglesLt] [ConNF.TypedObjectsLt] {\u03c1 : ConNF.NewAllowable} {c : ConNF.Code} {d : ConNF.Code} :c \u219d\u2080 d \u2192 \u03c1 \u2022 c \u219d\u2080 \u03c1 \u2022 d := by sorry", "full_tactic_state": "inst\u271d\u2074 : ConNF.Params\ninst\u271d\u00b3 : ConNF.Level\ninst\u271d\u00b2 : ConNF.TangleDataLt\ninst\u271d\u00b9 : ConNF.PositionedTanglesLt\ninst\u271d : ConNF.TypedObjectsLt\n\u03c1 : ConNF.NewAllowable\nc d : ConNF.Code\n\u22a2 c \u219d\u2080 d \u2192 \u03c1 \u2022 c \u219d\u2080 \u03c1 \u2022 d", "dependency": [1]}, "ConNF.smul_cloudRel": {"natural_language_statement": "In the context of Constructive Ordinal Notation (ConNF), the theorem `ConNF.smul_cloudRel` states that for any `ConNF.NewAllowable` object `\u03c1` and any two `ConNF.Code` objects `c` and `d`, the relation `\u03c1 \u2022 c \u219d\u2080 \u03c1 \u2022 d` holds if and only if the relation `c \u219d\u2080 d` holds. This theorem simplifies the manipulation of the `ConNF.smul` operation on `ConNF.Code` objects.", "formal_statement": "@[simp]example [ConNF.Params ] [ConNF.Level] [ConNF.TangleDataLt] [ConNF.PositionedTanglesLt] [ConNF.TypedObjectsLt] {\u03c1 : ConNF.NewAllowable} {c : ConNF.Code} {d : ConNF.Code} :\u03c1 \u2022 c \u219d\u2080 \u03c1 \u2022 d \u2194 c \u219d\u2080 d := by sorry", "full_tactic_state": "inst\u271d\u2074 : ConNF.Params\ninst\u271d\u00b3 : ConNF.Level\ninst\u271d\u00b2 : ConNF.TangleDataLt\ninst\u271d\u00b9 : ConNF.PositionedTanglesLt\ninst\u271d : ConNF.TypedObjectsLt\n\u03c1 : ConNF.NewAllowable\nc d : ConNF.Code\n\u22a2 \u03c1 \u2022 c \u219d\u2080 \u03c1 \u2022 d \u2194 c \u219d\u2080 d", "dependency": [1]}, "ConNF.Code.isEven_smul_nonempty": {"natural_language_statement": "The theorem `ConNF.Code.isEven_smul_nonempty` states that for a nonempty code `c` in the context of Constructive Ordinal Notation (ConNF), the code `\u03c1 \u2022 c` is even if and only if `c` is even.", "formal_statement": "example [ConNF.Params ] [ConNF.Level] [ConNF.TangleDataLt] [ConNF.PositionedTanglesLt] [ConNF.TypedObjectsLt] {\u03c1 : ConNF.NewAllowable} (c : ConNF.NonemptyCode) :ConNF.Code.IsEven (\u03c1 \u2022 \u2191c) \u2194 ConNF.Code.IsEven \u2191c := by sorry", "full_tactic_state": "inst\u271d\u2074 : ConNF.Params\ninst\u271d\u00b3 : ConNF.Level\ninst\u271d\u00b2 : ConNF.TangleDataLt\ninst\u271d\u00b9 : ConNF.PositionedTanglesLt\ninst\u271d : ConNF.TypedObjectsLt\n\u03c1 : ConNF.NewAllowable\nc : ConNF.NonemptyCode\n\u22a2 ConNF.Code.IsEven (\u03c1 \u2022 \u2191c) \u2194 ConNF.Code.IsEven \u2191c", "dependency": [1, 165, 165]}, "ConNF.Code.isEven_smul": {"natural_language_statement": "In the context of Constructive Ordinal Notation (ConNF), a code is considered even if it only leads to odd codes. The theorem `ConNF.Code.isEven_smul` states that the property of being an even code is preserved under the operation of multiplying a code by a new allowable term.", "formal_statement": "@[simp]example [ConNF.Params ] [ConNF.Level] [ConNF.TangleDataLt] [ConNF.PositionedTanglesLt] [ConNF.TypedObjectsLt] {\u03c1 : ConNF.NewAllowable} {c : ConNF.Code} :ConNF.Code.IsEven (\u03c1 \u2022 c) \u2194 ConNF.Code.IsEven c := by sorry", "full_tactic_state": "inst\u271d\u2074 : ConNF.Params\ninst\u271d\u00b3 : ConNF.Level\ninst\u271d\u00b2 : ConNF.TangleDataLt\ninst\u271d\u00b9 : ConNF.PositionedTanglesLt\ninst\u271d : ConNF.TypedObjectsLt\n\u03c1 : ConNF.NewAllowable\nc : ConNF.Code\n\u22a2 ConNF.Code.IsEven (\u03c1 \u2022 c) \u2194 ConNF.Code.IsEven c", "dependency": [1, 165, 165]}, "ConNF.Code.isOdd_smul": {"natural_language_statement": "In the context of Constructive Ordinal Notation (ConNF), a `ConNF.Code` is said to be `IsOdd` if it leads to some `ConNF.Code` that is `IsEven`. This property is defined inductively, stating that a code `c` is odd if there exists an even code `d` such that `d` leads to `c`. The theorem `ConNF.Code.isOdd_smul` states that for any `ConNF.NewAllowable` `\u03c1` and `ConNF.Code` `c`, the `ConNF.Code` `\u03c1 \u2022 c` is `IsOdd` if and only if `c` is `IsOdd`.", "formal_statement": "@[simp]example [ConNF.Params ] [ConNF.Level] [ConNF.TangleDataLt] [ConNF.PositionedTanglesLt] [ConNF.TypedObjectsLt] {\u03c1 : ConNF.NewAllowable} {c : ConNF.Code} :ConNF.Code.IsOdd (\u03c1 \u2022 c) \u2194 ConNF.Code.IsOdd c := by sorry", "full_tactic_state": "inst\u271d\u2074 : ConNF.Params\ninst\u271d\u00b3 : ConNF.Level\ninst\u271d\u00b2 : ConNF.TangleDataLt\ninst\u271d\u00b9 : ConNF.PositionedTanglesLt\ninst\u271d : ConNF.TypedObjectsLt\n\u03c1 : ConNF.NewAllowable\nc : ConNF.Code\n\u22a2 ConNF.Code.IsOdd (\u03c1 \u2022 c) \u2194 ConNF.Code.IsOdd c", "dependency": [1, 168, 168]}, "ConNF.Code.isEven.smul": {"natural_language_statement": "`ConNF.Code.isEven.smul` is a theorem that states that if a code `c` is even, then the result of applying the `smul` operation (which scales a code by a factor) to `c` with a new allowable `\u03c1` will also result in an even code. This is derived from the fact that applying `smul` to an even code will not change its parity, as `smul` only scales the code and does not change its property of being even.", "formal_statement": "example [ConNF.Params ] [ConNF.Level] [ConNF.TangleDataLt] [ConNF.PositionedTanglesLt] [ConNF.TypedObjectsLt] {\u03c1 : ConNF.NewAllowable} {c : ConNF.Code} :ConNF.Code.IsEven c \u2192 ConNF.Code.IsEven (\u03c1 \u2022 c) := by sorry", "full_tactic_state": "inst\u271d\u2074 : ConNF.Params\ninst\u271d\u00b3 : ConNF.Level\ninst\u271d\u00b2 : ConNF.TangleDataLt\ninst\u271d\u00b9 : ConNF.PositionedTanglesLt\ninst\u271d : ConNF.TypedObjectsLt\n\u03c1 : ConNF.NewAllowable\nc : ConNF.Code\n\u22a2 ConNF.Code.IsEven c \u2192 ConNF.Code.IsEven (\u03c1 \u2022 c)", "dependency": [1, 165, 165]}, "ConNF.Code.isOdd.smul": {"natural_language_statement": "The statement represents that if a `ConNF.Code` is `IsOdd`, then when it is scaled by a `ConNF.NewAllowable` (denoted as `\u03c1 \u2022 c`), the resulting code is also `IsOdd`. This is an important property in understanding the behavior of Constructive Ordinal Notation (ConNF) codes under multiplication.", "formal_statement": "example [ConNF.Params ] [ConNF.Level] [ConNF.TangleDataLt] [ConNF.PositionedTanglesLt] [ConNF.TypedObjectsLt] {\u03c1 : ConNF.NewAllowable} {c : ConNF.Code} :ConNF.Code.IsOdd c \u2192 ConNF.Code.IsOdd (\u03c1 \u2022 c) := by sorry", "full_tactic_state": "inst\u271d\u2074 : ConNF.Params\ninst\u271d\u00b3 : ConNF.Level\ninst\u271d\u00b2 : ConNF.TangleDataLt\ninst\u271d\u00b9 : ConNF.PositionedTanglesLt\ninst\u271d : ConNF.TypedObjectsLt\n\u03c1 : ConNF.NewAllowable\nc : ConNF.Code\n\u22a2 ConNF.Code.IsOdd c \u2192 ConNF.Code.IsOdd (\u03c1 \u2022 c)", "dependency": [1, 168, 168]}, "ConNF.Code.isEven_iff": {"natural_language_statement": "In the context of Constructive Ordinal Notation (ConNF), a code is considered even if it only leads to odd codes. The theorem `ConNF.Code.isEven_iff` states that a code `a` is even if and only if every code `d` that leads to `a` is odd.", "formal_statement": "example [ConNF.Params ] [ConNF.Level] [ConNF.TangleDataLt] [ConNF.TypedObjectsLt] [ConNF.PositionedTanglesLt] :\u2200 (a : ConNF.Code), ConNF.Code.IsEven a \u2194 \u2200 (d : ConNF.Code), d \u219d\u2080 a \u2192 ConNF.Code.IsOdd d := by sorry", "full_tactic_state": "inst\u271d\u2074 : ConNF.Params\ninst\u271d\u00b3 : ConNF.Level\ninst\u271d\u00b2 : ConNF.TangleDataLt\ninst\u271d\u00b9 : ConNF.TypedObjectsLt\ninst\u271d : ConNF.PositionedTanglesLt\n\u22a2 \u2200 (a : ConNF.Code), ConNF.Code.IsEven a \u2194 \u2200 (d : ConNF.Code), d \u219d\u2080 a \u2192 ConNF.Code.IsOdd d", "dependency": [1, 165, 168]}, "ConNF.Code.isOdd_iff": {"natural_language_statement": "In the context of Constructive Ordinal Notation (ConNF), a `ConNF.Code` is said to be `IsOdd` if it leads to some `ConNF.Code` that is `IsEven`. This theorem states that a code `a` is odd if and only if there exists an even code `d` such that `d` leads to `a`.", "formal_statement": "example [ConNF.Params ] [ConNF.Level] [ConNF.TangleDataLt] [ConNF.TypedObjectsLt] [ConNF.PositionedTanglesLt] :\u2200 (a : ConNF.Code), ConNF.Code.IsOdd a \u2194 \u2203 (d : ConNF.Code), d \u219d\u2080 a \u2227 ConNF.Code.IsEven d := by sorry", "full_tactic_state": "inst\u271d\u2074 : ConNF.Params\ninst\u271d\u00b3 : ConNF.Level\ninst\u271d\u00b2 : ConNF.TangleDataLt\ninst\u271d\u00b9 : ConNF.TypedObjectsLt\ninst\u271d : ConNF.PositionedTanglesLt\n\u22a2 \u2200 (a : ConNF.Code), ConNF.Code.IsOdd a \u2194 \u2203 d, d \u219d\u2080 a \u2227 ConNF.Code.IsEven d", "dependency": [1, 168, 165]}, "ConNF.Code.isEven_of_forall_not": {"natural_language_statement": "In the context of Constructive Ordinal Notation (ConNF), a code is considered even if it only leads to odd codes. The theorem `ConNF.Code.isEven_of_forall_not` states that if for every code `d`, `d` does not lead to `c`, then `c` is an even code.", "formal_statement": "example [ConNF.Params ] [ConNF.Level] [ConNF.TangleDataLt] [ConNF.TypedObjectsLt] [ConNF.PositionedTanglesLt] {c : ConNF.Code} (h : \u2200 (d : ConNF.Code), \u00ac d \u219d\u2080 c) :ConNF.Code.IsEven c := by sorry", "full_tactic_state": "inst\u271d\u2074 : ConNF.Params\ninst\u271d\u00b3 : ConNF.Level\ninst\u271d\u00b2 : ConNF.TangleDataLt\ninst\u271d\u00b9 : ConNF.TypedObjectsLt\ninst\u271d : ConNF.PositionedTanglesLt\nc : ConNF.Code\nh : \u2200 (d : ConNF.Code), \u00acd \u219d\u2080 c\n\u22a2 ConNF.Code.IsEven c", "dependency": [1, 165]}, "ConNF.Code.isEven_of_eq_bot": {"natural_language_statement": "The theorem `ConNF.Code.isEven_of_eq_bot` states that if a ConNF code `c` satisfies `c.\u03b2 = \u22a5`, then `c` is an even code.", "formal_statement": "@[simp]example [ConNF.Params ] [ConNF.Level] [ConNF.TangleDataLt] [ConNF.TypedObjectsLt] [ConNF.PositionedTanglesLt] (c : ConNF.Code) (hc : c.\u03b2 = \u22a5 ) :ConNF.Code.IsEven c := by sorry", "full_tactic_state": "inst\u271d\u2074 : ConNF.Params\ninst\u271d\u00b3 : ConNF.Level\ninst\u271d\u00b2 : ConNF.TangleDataLt\ninst\u271d\u00b9 : ConNF.TypedObjectsLt\ninst\u271d : ConNF.PositionedTanglesLt\nc : ConNF.Code\nhc : c.\u03b2 = \u22a5\n\u22a2 ConNF.Code.IsEven c", "dependency": [1, 165]}, "ConNF.Code.isEven_bot": {"natural_language_statement": "In the context of Constructive Ordinal Notation (ConNF), a code is considered even if it only leads to odd codes. The theorem `ConNF.Code.isEven_bot` states that the code `ConNF.Code.mk \u22a5 s` is even, where `\u22a5` represents the bottom element in the ConNF hierarchy and `s` is a set of atoms.", "formal_statement": "@[simp]example [ConNF.Params ] [ConNF.Level] [ConNF.TangleDataLt] [ConNF.TypedObjectsLt] [ConNF.PositionedTanglesLt] (s : Set ConNF.Atom) :ConNF.Code.IsEven (ConNF.Code.mk \u22a5 s) := by sorry", "full_tactic_state": "inst\u271d\u2074 : ConNF.Params\ninst\u271d\u00b3 : ConNF.Level\ninst\u271d\u00b2 : ConNF.TangleDataLt\ninst\u271d\u00b9 : ConNF.TypedObjectsLt\ninst\u271d : ConNF.PositionedTanglesLt\ns : Set ConNF.Atom\n\u22a2 ConNF.Code.IsEven (ConNF.Code.mk \u22a5 s)", "dependency": [1, 69, 165, 104]}, "ConNF.Code.not_isOdd_bot": {"natural_language_statement": "In the context of Constructive Ordinal Notation (ConNF), a `ConNF.Code` is said to be `IsOdd` if it leads to some `ConNF.Code` that is `IsEven`. This property is defined inductively, stating that a code `c` is odd if there exists an even code `d` such that `d` leads to `c`. The theorem `ConNF.Code.not_isOdd_bot` states that the bottom code `ConNF.Code.mk \u22a5 s` is not `IsOdd`.", "formal_statement": "example [ConNF.Params ] [ConNF.Level] [ConNF.TangleDataLt] [ConNF.TypedObjectsLt] [ConNF.PositionedTanglesLt] (s : Set ConNF.Atom) :\u00ac ConNF.Code.IsOdd (ConNF.Code.mk \u22a5 s) := by sorry", "full_tactic_state": "inst\u271d\u2074 : ConNF.Params\ninst\u271d\u00b3 : ConNF.Level\ninst\u271d\u00b2 : ConNF.TangleDataLt\ninst\u271d\u00b9 : ConNF.TypedObjectsLt\ninst\u271d : ConNF.PositionedTanglesLt\ns : Set ConNF.Atom\n\u22a2 \u00acConNF.Code.IsOdd (ConNF.Code.mk \u22a5 s)", "dependency": [1, 69, 168, 104]}, "ConNF.Code.IsEmpty.isEven_iff": {"natural_language_statement": "In the context of Constructive Ordinal Notation (ConNF), a code is considered even if it only leads to odd codes. This theorem states that an empty code is even if and only if its extension is `\u22a5`.", "formal_statement": "@[simp]example [ConNF.Params ] [ConNF.Level] [ConNF.TangleDataLt] [ConNF.TypedObjectsLt] [ConNF.PositionedTanglesLt] {c : ConNF.Code} (hc : ConNF.Code.IsEmpty c) :ConNF.Code.IsEven c \u2194 c.\u03b2 = \u22a5 := by sorry", "full_tactic_state": "inst\u271d\u2074 : ConNF.Params\ninst\u271d\u00b3 : ConNF.Level\ninst\u271d\u00b2 : ConNF.TangleDataLt\ninst\u271d\u00b9 : ConNF.TypedObjectsLt\ninst\u271d : ConNF.PositionedTanglesLt\nc : ConNF.Code\nhc : ConNF.Code.IsEmpty c\n\u22a2 ConNF.Code.IsEven c \u2194 c.\u03b2 = \u22a5", "dependency": [1, 107, 165]}, "ConNF.Code.IsEmpty.isOdd_iff": {"natural_language_statement": "In the context of Constructive Ordinal Notation (ConNF), a `ConNF.Code` object is said to be `IsOdd` if it leads to some `ConNF.Code` that is `IsEven`. This property is defined inductively, stating that a code `c` is odd if there exists an even code `d` such that `d` leads to `c`. The theorem `ConNF.Code.IsEmpty.isOdd_iff` states that for an empty `ConNF.Code` object `c`, `c` is `IsOdd` if and only if `c.\u03b2 \u2260 \u22a5`.", "formal_statement": "@[simp]example [ConNF.Params ] [ConNF.Level] [ConNF.TangleDataLt] [ConNF.TypedObjectsLt] [ConNF.PositionedTanglesLt] {c : ConNF.Code} (hc : ConNF.Code.IsEmpty c) :ConNF.Code.IsOdd c \u2194 c.\u03b2 \u2260 \u22a5 := by sorry", "full_tactic_state": "inst\u271d\u2074 : ConNF.Params\ninst\u271d\u00b3 : ConNF.Level\ninst\u271d\u00b2 : ConNF.TangleDataLt\ninst\u271d\u00b9 : ConNF.TypedObjectsLt\ninst\u271d : ConNF.PositionedTanglesLt\nc : ConNF.Code\nhc : ConNF.Code.IsEmpty c\n\u22a2 ConNF.Code.IsOdd c \u2194 c.\u03b2 \u2260 \u22a5", "dependency": [1, 107, 168]}, "ConNF.Code.isEven_empty_iff": {"natural_language_statement": "Function `ConNF.Code.isEven_empty_iff` is a theorem in Lean 4 that states that a code is even (in the context of Constructive Ordinal Notation) if and only if the index type `\u03b2` is equal to the bottom element `\u22a5`. The theorem's proof is a direct consequence of the definition of evenness for codes, which depends on the index type `\u03b2` being less than the current level `\u03b1`, and the empty set being interpreted in the context of tangles as the smallest possible tangle, which corresponds to the bottom element of the type index. The empty set does not itself contribute to the evenness of the code, hence the condition `\u03b2 = \u22a5` arises.", "formal_statement": "@[simp]example [ConNF.Params ] [ConNF.Level] {\u03b2 : ConNF.TypeIndex} [ConNF.LtLevel \u03b2] [ConNF.TangleDataLt] [ConNF.TypedObjectsLt] [ConNF.PositionedTanglesLt] :ConNF.Code.IsEven (ConNF.Code.mk \u03b2 \u2205 ) \u2194 \u03b2 = \u22a5 := by sorry", "full_tactic_state": "inst\u271d\u2075 : ConNF.Params\ninst\u271d\u2074 : ConNF.Level\n\u03b2 : ConNF.TypeIndex\ninst\u271d\u00b3 : ConNF.LtLevel \u03b2\ninst\u271d\u00b2 : ConNF.TangleDataLt\ninst\u271d\u00b9 : ConNF.TypedObjectsLt\ninst\u271d : ConNF.PositionedTanglesLt\n\u22a2 ConNF.Code.IsEven (ConNF.Code.mk \u03b2 \u2205) \u2194 \u03b2 = \u22a5", "dependency": [1, 98, 165, 104]}, "ConNF.Code.isOdd_empty_iff": {"natural_language_statement": "In the context of Constructive Ordinal Notation (ConNF), a `ConNF.Code` is said to be `IsOdd` if it leads to some `ConNF.Code` that is `IsEven`. This property is defined inductively, stating that a code `c` is odd if there exists an even code `d` such that `d` leads to `c`. The theorem `ConNF.Code.isOdd_empty_iff` states that a `ConNF.Code.mk` with an empty set of tangles is `IsOdd` if and only if its type index `\u03b2` is not equal to `\u22a5`.", "formal_statement": "@[simp]example [ConNF.Params ] [ConNF.Level] {\u03b2 : ConNF.TypeIndex} [ConNF.LtLevel \u03b2] [ConNF.TangleDataLt] [ConNF.TypedObjectsLt] [ConNF.PositionedTanglesLt] :ConNF.Code.IsOdd (ConNF.Code.mk \u03b2 \u2205 ) \u2194 \u03b2 \u2260 \u22a5 := by sorry", "full_tactic_state": "inst\u271d\u2075 : ConNF.Params\ninst\u271d\u2074 : ConNF.Level\n\u03b2 : ConNF.TypeIndex\ninst\u271d\u00b3 : ConNF.LtLevel \u03b2\ninst\u271d\u00b2 : ConNF.TangleDataLt\ninst\u271d\u00b9 : ConNF.TypedObjectsLt\ninst\u271d : ConNF.PositionedTanglesLt\n\u22a2 ConNF.Code.IsOdd (ConNF.Code.mk \u03b2 \u2205) \u2194 \u03b2 \u2260 \u22a5", "dependency": [1, 98, 168, 104]}, "ConNF.Code.not_isOdd": {"natural_language_statement": "A code in the context of Constructive Ordinal Notation (ConNF) is not odd if and only if it is even.", "formal_statement": "@[simp]example [ConNF.Params ] [ConNF.Level] [ConNF.TangleDataLt] [ConNF.TypedObjectsLt] [ConNF.PositionedTanglesLt] {c : ConNF.Code} :\u00ac ConNF.Code.IsOdd c \u2194 ConNF.Code.IsEven c := by sorry", "full_tactic_state": "inst\u271d\u2074 : ConNF.Params\ninst\u271d\u00b3 : ConNF.Level\ninst\u271d\u00b2 : ConNF.TangleDataLt\ninst\u271d\u00b9 : ConNF.TypedObjectsLt\ninst\u271d : ConNF.PositionedTanglesLt\nc : ConNF.Code\n\u22a2 \u00acConNF.Code.IsOdd c \u2194 ConNF.Code.IsEven c", "dependency": [1, 168, 165]}, "ConNF.Code.not_isEven": {"natural_language_statement": "A code in the context of Constructive Ordinal Notation (ConNF) is not even if and only if it is odd.", "formal_statement": "@[simp]example [ConNF.Params ] [ConNF.Level] [ConNF.TangleDataLt] [ConNF.TypedObjectsLt] [ConNF.PositionedTanglesLt] {c : ConNF.Code} :\u00ac ConNF.Code.IsEven c \u2194 ConNF.Code.IsOdd c := by sorry", "full_tactic_state": "inst\u271d\u2074 : ConNF.Params\ninst\u271d\u00b3 : ConNF.Level\ninst\u271d\u00b2 : ConNF.TangleDataLt\ninst\u271d\u00b9 : ConNF.TypedObjectsLt\ninst\u271d : ConNF.PositionedTanglesLt\nc : ConNF.Code\n\u22a2 \u00acConNF.Code.IsEven c \u2194 ConNF.Code.IsOdd c", "dependency": [1, 165, 168]}, "ConNF.Code.IsEven.not_isOdd": {"natural_language_statement": "The theorem `ConNF.Code.IsEven.not_isOdd` is an alias of the reverse direction of `ConNF.Code.not_isOdd`. It states that if a code is even, then it is not odd.", "formal_statement": "example [ConNF.Params ] [ConNF.Level] [ConNF.TangleDataLt] [ConNF.TypedObjectsLt] [ConNF.PositionedTanglesLt] {c : ConNF.Code} :ConNF.Code.IsEven c \u2192 \u00ac ConNF.Code.IsOdd c := by sorry", "full_tactic_state": "inst\u271d\u2074 : ConNF.Params\ninst\u271d\u00b3 : ConNF.Level\ninst\u271d\u00b2 : ConNF.TangleDataLt\ninst\u271d\u00b9 : ConNF.TypedObjectsLt\ninst\u271d : ConNF.PositionedTanglesLt\nc : ConNF.Code\n\u22a2 ConNF.Code.IsEven c \u2192 \u00acConNF.Code.IsOdd c", "dependency": [1, 165, 168]}, "ConNF.Code.IsOdd.not_isEven": {"natural_language_statement": "In the context of Constructive Ordinal Notation (ConNF), a `ConNF.Code` is said to be `IsOdd` if it leads to some `ConNF.Code` that is `IsEven`. This property is defined inductively, stating that a code `c` is odd if there exists an even code `d` such that `d` leads to `c`. A code is not even iff it is odd.", "formal_statement": "example [ConNF.Params ] [ConNF.Level] [ConNF.TangleDataLt] [ConNF.TypedObjectsLt] [ConNF.PositionedTanglesLt] {c : ConNF.Code} :ConNF.Code.IsOdd c \u2192 \u00ac ConNF.Code.IsEven c := by sorry", "full_tactic_state": "inst\u271d\u2074 : ConNF.Params\ninst\u271d\u00b3 : ConNF.Level\ninst\u271d\u00b2 : ConNF.TangleDataLt\ninst\u271d\u00b9 : ConNF.TypedObjectsLt\ninst\u271d : ConNF.PositionedTanglesLt\nc : ConNF.Code\n\u22a2 ConNF.Code.IsOdd c \u2192 \u00acConNF.Code.IsEven c", "dependency": [1, 168, 165]}, "ConNF.Code.isEven_or_isOdd": {"natural_language_statement": "In the context of Constructive Ordinal Notation (ConNF), any code can be classified as either even or odd. This theorem, `ConNF.Code.isEven_or_isOdd`, asserts that for any given `ConNF.Code`, it either satisfies the property of being even or odd, according to the inductive definition provided in the `ConNF.Code.IsEven` and `ConNF.Code.IsOdd` types. This categorization is crucial for understanding the structure of the natural numbers and their representation in the ConNF system.", "formal_statement": "example [ConNF.Params ] [ConNF.Level] [ConNF.TangleDataLt] [ConNF.TypedObjectsLt] [ConNF.PositionedTanglesLt] (c : ConNF.Code) :ConNF.Code.IsEven c \u2228 ConNF.Code.IsOdd c := by sorry", "full_tactic_state": "inst\u271d\u2074 : ConNF.Params\ninst\u271d\u00b3 : ConNF.Level\ninst\u271d\u00b2 : ConNF.TangleDataLt\ninst\u271d\u00b9 : ConNF.TypedObjectsLt\ninst\u271d : ConNF.PositionedTanglesLt\nc : ConNF.Code\n\u22a2 ConNF.Code.IsEven c \u2228 ConNF.Code.IsOdd c", "dependency": [1, 165, 168]}, "ConNF.CloudRel.isOdd": {"natural_language_statement": "In the context of Constructive Ordinal Notation (ConNF), if `c` is an even code and `c` leads to `d`, then `d` is an odd code.", "formal_statement": "example [ConNF.Params ] [ConNF.Level] [ConNF.TangleDataLt] [ConNF.TypedObjectsLt] [ConNF.PositionedTanglesLt] {c : ConNF.Code} {d : ConNF.Code} (hc : ConNF.Code.IsEven c) (h : c \u219d\u2080 d) :ConNF.Code.IsOdd d := by sorry", "full_tactic_state": "inst\u271d\u2074 : ConNF.Params\ninst\u271d\u00b3 : ConNF.Level\ninst\u271d\u00b2 : ConNF.TangleDataLt\ninst\u271d\u00b9 : ConNF.TypedObjectsLt\ninst\u271d : ConNF.PositionedTanglesLt\nc d : ConNF.Code\nhc : ConNF.Code.IsEven c\nh : c \u219d\u2080 d\n\u22a2 ConNF.Code.IsOdd d", "dependency": [1, 165, 168]}, "ConNF.Code.IsEven.cloudCode": {"natural_language_statement": "The theorem `ConNF.Code.IsEven.cloudCode` is a theorem in the Lean proof assistant that is used in the context of Constructive Ordinal Notation (ConNF). It states that given a code `c` which is even and a type index `\u03b3`, if `c`'s level does not match `\u03b3`, then the code `ConNF.cloudCode \u03b3 c` is odd. This theorem is proved by leveraging the definitions and properties of ConNF, such as the `ConNF.Code.IsEven` and `ConNF.Code.IsOdd` classes, and the `ConNF.cloudCode` function, which is defined to adjust the first component of a `ConNF.Code` object to match a given type index.", "formal_statement": "example [ConNF.Params ] [ConNF.Level] {\u03b3 : ConNF.\u039b} [ConNF.LtLevel \u2191\u03b3] [ConNF.TangleDataLt] [ConNF.TypedObjectsLt] [ConNF.PositionedTanglesLt] {c : ConNF.Code} (hc : ConNF.Code.IsEven c) (hc\u03b3 : c.\u03b2 \u2260 \u2191\u03b3) :ConNF.Code.IsOdd (ConNF.cloudCode \u03b3 c) := by sorry", "full_tactic_state": "inst\u271d\u2075 : ConNF.Params\ninst\u271d\u2074 : ConNF.Level\n\u03b3 : ConNF.\u039b\ninst\u271d\u00b3 : ConNF.LtLevel \u2191\u03b3\ninst\u271d\u00b2 : ConNF.TangleDataLt\ninst\u271d\u00b9 : ConNF.TypedObjectsLt\ninst\u271d : ConNF.PositionedTanglesLt\nc : ConNF.Code\nhc : ConNF.Code.IsEven c\nhc\u03b3 : c.\u03b2 \u2260 \u2191\u03b3\n\u22a2 ConNF.Code.IsOdd (ConNF.cloudCode \u03b3 c)", "dependency": [1, 98, 165, 168, 101]}, "ConNF.Code.IsOdd.cloudCode": {"natural_language_statement": "The given Lean 4 object is a theorem named `ConNF.Code.IsOdd.cloudCode`, which is a function defined in the context of Constructive Ordinal Notation (ConNF). This function takes a type index `\u03b2` and a `ConNF.Code` object `c`, and returns a new `ConNF.Code` object. The theorem states that if `c` is an odd `ConNF.Code` object with a nonempty set of members and `c.\u03b2` is not equal to `\u03b3`, then the `ConNF.Code` returned by `ConNF.cloudCode \u03b3 c` is even.", "formal_statement": "example [ConNF.Params ] [ConNF.Level] {\u03b3 : ConNF.\u039b} [ConNF.LtLevel \u2191\u03b3] [ConNF.TangleDataLt] [ConNF.TypedObjectsLt] [ConNF.PositionedTanglesLt] {c : ConNF.Code} (hc : ConNF.Code.IsOdd c) (hc' : Set.Nonempty c.members) (hc\u03b3 : c.\u03b2 \u2260 \u2191\u03b3) :ConNF.Code.IsEven (ConNF.cloudCode \u03b3 c) := by sorry", "full_tactic_state": "inst\u271d\u2075 : ConNF.Params\ninst\u271d\u2074 : ConNF.Level\n\u03b3 : ConNF.\u039b\ninst\u271d\u00b3 : ConNF.LtLevel \u2191\u03b3\ninst\u271d\u00b2 : ConNF.TangleDataLt\ninst\u271d\u00b9 : ConNF.TypedObjectsLt\ninst\u271d : ConNF.PositionedTanglesLt\nc : ConNF.Code\nhc : ConNF.Code.IsOdd c\nhc' : Set.Nonempty c.members\nhc\u03b3 : c.\u03b2 \u2260 \u2191\u03b3\n\u22a2 ConNF.Code.IsEven (ConNF.cloudCode \u03b3 c)", "dependency": [1, 98, 168, 83, 165, 101]}, "ConNF.Code.IsEven.cloudCode_ne": {"natural_language_statement": "Given a type index `\u03b3` and two even codes `c` and `d`, the theorem states that if the level of code `c` does not match `\u03b3`, then `ConNF.cloudCode \u03b3 c` (which returns a new code where the `\u03b2` component is defeq to `\u03b3`, while leaving the other components unchanged) is not equal to `d`. The `ConNF.Code.IsEven` typeclass ensures that `c` and `d` only lead to odd codes. The `ConNF.Params`, `ConNF.Level`, `ConNF.TangleDataLt`, `ConNF.TypedObjectsLt`, and `ConNF.PositionedTanglesLt` classes provide the necessary type-level and order-theoretic relationships required for the proof.", "formal_statement": "example [ConNF.Params ] [ConNF.Level] {\u03b3 : ConNF.\u039b} [ConNF.LtLevel \u2191\u03b3] [ConNF.TangleDataLt] [ConNF.TypedObjectsLt] [ConNF.PositionedTanglesLt] {c : ConNF.Code} {d : ConNF.Code} (hc : ConNF.Code.IsEven c) (hd : ConNF.Code.IsEven d) (hc\u03b3 : c.\u03b2 \u2260 \u2191\u03b3) :ConNF.cloudCode \u03b3 c \u2260 d := by sorry", "full_tactic_state": "inst\u271d\u2075 : ConNF.Params\ninst\u271d\u2074 : ConNF.Level\n\u03b3 : ConNF.\u039b\ninst\u271d\u00b3 : ConNF.LtLevel \u2191\u03b3\ninst\u271d\u00b2 : ConNF.TangleDataLt\ninst\u271d\u00b9 : ConNF.TypedObjectsLt\ninst\u271d : ConNF.PositionedTanglesLt\nc d : ConNF.Code\nhc : ConNF.Code.IsEven c\nhd : ConNF.Code.IsEven d\nhc\u03b3 : c.\u03b2 \u2260 \u2191\u03b3\n\u22a2 ConNF.cloudCode \u03b3 c \u2260 d", "dependency": [1, 98, 165, 165, 101]}, "ConNF.Code.cloudCode_ne_bot": {"natural_language_statement": "The theorem `ConNF.Code.cloudCode_ne_bot` asserts that given a type level index \u03b3 less than the current level \u03b1, and a Code object c, the operation `ConNF.cloudCode \u03b3 c` does not result in a Code object that is equal to `ConNF.Code.mk \u22a5 s`, where `s` is a set of tangles at level \u22a5. The conclusion is that the operation `ConNF.cloudCode \u03b3 c` yields a distinct Code object, which has a level of \u03b3, and its tangles are not all at the lowest level \u22a5.", "formal_statement": "example [ConNF.Params ] [ConNF.Level] {\u03b3 : ConNF.\u039b} [ConNF.LtLevel \u2191\u03b3] [ConNF.TangleDataLt] [ConNF.TypedObjectsLt] [ConNF.PositionedTanglesLt] {c : ConNF.Code} {s : Set (ConNF.Tangle \u22a5 )} :ConNF.cloudCode \u03b3 c \u2260 ConNF.Code.mk \u22a5 s := by sorry", "full_tactic_state": "inst\u271d\u2075 : ConNF.Params\ninst\u271d\u2074 : ConNF.Level\n\u03b3 : ConNF.\u039b\ninst\u271d\u00b3 : ConNF.LtLevel \u2191\u03b3\ninst\u271d\u00b2 : ConNF.TangleDataLt\ninst\u271d\u00b9 : ConNF.TypedObjectsLt\ninst\u271d : ConNF.PositionedTanglesLt\nc : ConNF.Code\ns : Set (ConNF.Tangle \u22a5)\n\u22a2 ConNF.cloudCode \u03b3 c \u2260 ConNF.Code.mk \u22a5 s", "dependency": [1, 98, 69, 101, 104]}, "ConNF.Code.cloudCode_ne_singleton": {"natural_language_statement": "In the context of Constructive Ordinal Notation (ConNF), the `ConNF.Code.cloudCode` function takes a type index `\u03b2` and a `ConNF.Code` object `c`, and returns a new `ConNF.Code` object. If the level of `c` matches `\u03b2`, then `ConNF.cloudCode` is the identity function. This function is defined in such a way that the first component of the returned `ConNF.Code` object is defeq to `\u03b2`. The theorem `ConNF.Code.cloudCode_ne_singleton` states that if `c.\u03b2` is not equal to `\u03b2`, then `ConNF.cloudCode \u03b3 c` cannot be a singleton code.", "formal_statement": "example [ConNF.Params ] [ConNF.Level] {\u03b2 : ConNF.TypeIndex} [ConNF.LtLevel \u03b2] {\u03b3 : ConNF.\u039b} [ConNF.LtLevel \u2191\u03b3] [ConNF.TangleDataLt] [ConNF.TypedObjectsLt] [ConNF.PositionedTanglesLt] {c : ConNF.Code} {t : ConNF.Tangle \u03b2} (hc\u03b2 : c.\u03b2 \u2260 \u03b2) :ConNF.cloudCode \u03b3 c \u2260 ConNF.Code.mk \u03b2 {t} := by sorry", "full_tactic_state": "inst\u271d\u2076 : ConNF.Params\ninst\u271d\u2075 : ConNF.Level\n\u03b2 : ConNF.TypeIndex\ninst\u271d\u2074 : ConNF.LtLevel \u03b2\n\u03b3 : ConNF.\u039b\ninst\u271d\u00b3 : ConNF.LtLevel \u2191\u03b3\ninst\u271d\u00b2 : ConNF.TangleDataLt\ninst\u271d\u00b9 : ConNF.TypedObjectsLt\ninst\u271d : ConNF.PositionedTanglesLt\nc : ConNF.Code\nt : ConNF.Tangle \u03b2\nhc\u03b2 : c.\u03b2 \u2260 \u03b2\n\u22a2 ConNF.cloudCode \u03b3 c \u2260 ConNF.Code.mk \u03b2 {t}", "dependency": [1, 98, 98, 101, 104]}, "ConNF.Code.isEven_singleton": {"natural_language_statement": "In the context of Constructive Ordinal Notation (ConNF), a code is considered even if it only leads to odd codes. This theorem states that a singleton code, which consists of a single tangle, is an even code.", "formal_statement": "@[simp]example [ConNF.Params ] [ConNF.Level] {\u03b2 : ConNF.TypeIndex} [ConNF.LtLevel \u03b2] [ConNF.TangleDataLt] [ConNF.TypedObjectsLt] [ConNF.PositionedTanglesLt] (t : ConNF.Tangle \u03b2) :ConNF.Code.IsEven (ConNF.Code.mk \u03b2 {t}) := by sorry", "full_tactic_state": "inst\u271d\u2075 : ConNF.Params\ninst\u271d\u2074 : ConNF.Level\n\u03b2 : ConNF.TypeIndex\ninst\u271d\u00b3 : ConNF.LtLevel \u03b2\ninst\u271d\u00b2 : ConNF.TangleDataLt\ninst\u271d\u00b9 : ConNF.TypedObjectsLt\ninst\u271d : ConNF.PositionedTanglesLt\nt : ConNF.Tangle \u03b2\n\u22a2 ConNF.Code.IsEven (ConNF.Code.mk \u03b2 {t})", "dependency": [1, 98, 165, 104]}, "ConNF.Code.Equiv.rfl": {"natural_language_statement": "`ConNF.Code.Equiv.rfl` is a reflexivity theorem in the context of Constructive Ordinal Notation (ConNF) in Lean 4. It states that for any `ConNF.Code` object `c`, `c` is equivalent to itself (`c \u2261 c`).", "formal_statement": "example [ConNF.Params ] [ConNF.Level] [ConNF.TangleDataLt] [ConNF.TypedObjectsLt] [ConNF.PositionedTanglesLt] {c : ConNF.Code} :c \u2261 c := by sorry", "full_tactic_state": "inst\u271d\u2074 : ConNF.Params\ninst\u271d\u00b3 : ConNF.Level\ninst\u271d\u00b2 : ConNF.TangleDataLt\ninst\u271d\u00b9 : ConNF.TypedObjectsLt\ninst\u271d : ConNF.PositionedTanglesLt\nc : ConNF.Code\n\u22a2 c \u2261 c", "dependency": [1]}, "ConNF.Code.Equiv.of_eq": {"natural_language_statement": "Function `ConNF.Code.Equiv.of_eq` is a theorem in the Constructive Ordinal Notation (ConNF) library in Lean 4. It states that if two ConNF codes `c` and `d` are equal, then they are equivalent, denoted as `c \u2261 d`.", "formal_statement": "example [ConNF.Params ] [ConNF.Level] [ConNF.TangleDataLt] [ConNF.TypedObjectsLt] [ConNF.PositionedTanglesLt] {c : ConNF.Code} {d : ConNF.Code} :c = d \u2192 c \u2261 d := by sorry", "full_tactic_state": "inst\u271d\u2074 : ConNF.Params\ninst\u271d\u00b3 : ConNF.Level\ninst\u271d\u00b2 : ConNF.TangleDataLt\ninst\u271d\u00b9 : ConNF.TypedObjectsLt\ninst\u271d : ConNF.PositionedTanglesLt\nc d : ConNF.Code\n\u22a2 c = d \u2192 c \u2261 d", "dependency": [1]}, "ConNF.Code.Equiv.symm": {"natural_language_statement": "Function `Symmetric` checks if a given binary relation `r` on a type `\u03b2` is symmetric, meaning if `r x y` holds, then `r y x` must also hold. The theorem `ConNF.Code.Equiv.symm` states that the equivalence relation `\u2261` on `ConNF.Code` is symmetric.", "formal_statement": "example [ConNF.Params ] [ConNF.Level] [ConNF.TangleDataLt] [ConNF.TypedObjectsLt] [ConNF.PositionedTanglesLt] :Symmetric fun (x x_1 : ConNF.Code) => x \u2261 x_1 := by sorry", "full_tactic_state": "inst\u271d\u2074 : ConNF.Params\ninst\u271d\u00b3 : ConNF.Level\ninst\u271d\u00b2 : ConNF.TangleDataLt\ninst\u271d\u00b9 : ConNF.TypedObjectsLt\ninst\u271d : ConNF.PositionedTanglesLt\n\u22a2 Symmetric fun x x_1 => x \u2261 x_1", "dependency": [1, 196]}, "ConNF.Code.Equiv.empty_empty": {"natural_language_statement": "All empty codes are equivalent in the context of Constructive Ordinal Notation (ConNF).", "formal_statement": "example [ConNF.Params ] [ConNF.Level] [ConNF.TangleDataLt] [ConNF.TypedObjectsLt] [ConNF.PositionedTanglesLt] (\u03b2 : ConNF.TypeIndex) (\u03b3 : ConNF.TypeIndex) [ConNF.LtLevel \u03b2] [ConNF.LtLevel \u03b3] :ConNF.Code.mk \u03b2 \u2205 \u2261 ConNF.Code.mk \u03b3 \u2205 := by sorry", "full_tactic_state": "inst\u271d\u2076 : ConNF.Params\ninst\u271d\u2075 : ConNF.Level\ninst\u271d\u2074 : ConNF.TangleDataLt\ninst\u271d\u00b3 : ConNF.TypedObjectsLt\ninst\u271d\u00b2 : ConNF.PositionedTanglesLt\n\u03b2 \u03b3 : ConNF.TypeIndex\ninst\u271d\u00b9 : ConNF.LtLevel \u03b2\ninst\u271d : ConNF.LtLevel \u03b3\n\u22a2 ConNF.Code.mk \u03b2 \u2205 \u2261 ConNF.Code.mk \u03b3 \u2205", "dependency": [1, 98, 98, 104, 104]}, "ConNF.Code.IsEmpty.equiv": {"natural_language_statement": "Function `ConNF.Code.IsEmpty.equiv` proves that if two `ConNF.Code` objects `c` and `d` are both empty (`ConNF.Code.IsEmpty c` and `ConNF.Code.IsEmpty d`), then they are equivalent (`c \u2261 d`).", "formal_statement": "example [ConNF.Params ] [ConNF.Level] [ConNF.TangleDataLt] [ConNF.TypedObjectsLt] [ConNF.PositionedTanglesLt] {c : ConNF.Code} {d : ConNF.Code} (hc : ConNF.Code.IsEmpty c) (hd : ConNF.Code.IsEmpty d) :c \u2261 d := by sorry", "full_tactic_state": "inst\u271d\u2074 : ConNF.Params\ninst\u271d\u00b3 : ConNF.Level\ninst\u271d\u00b2 : ConNF.TangleDataLt\ninst\u271d\u00b9 : ConNF.TypedObjectsLt\ninst\u271d : ConNF.PositionedTanglesLt\nc d : ConNF.Code\nhc : ConNF.Code.IsEmpty c\nhd : ConNF.Code.IsEmpty d\n\u22a2 c \u2261 d", "dependency": [1, 107, 107]}, "ConNF.Code.Equiv.equiv_equivalence": {"natural_language_statement": "The theorem `ConNF.Code.Equiv.equiv_equivalence` states that the equivalence relation `\u2261` on `ConNF.Code` is indeed an equivalence relation, meaning it is reflexive, symmetric, and transitive.", "formal_statement": "example [ConNF.Params ] [ConNF.Level] [ConNF.TangleDataLt] [ConNF.TypedObjectsLt] [ConNF.PositionedTanglesLt] :Equivalence fun (x x_1 : ConNF.Code) => x \u2261 x_1 := by sorry", "full_tactic_state": "inst\u271d\u2074 : ConNF.Params\ninst\u271d\u00b3 : ConNF.Level\ninst\u271d\u00b2 : ConNF.TangleDataLt\ninst\u271d\u00b9 : ConNF.TypedObjectsLt\ninst\u271d : ConNF.PositionedTanglesLt\n\u22a2 Equivalence fun x x_1 => x \u2261 x_1", "dependency": [1, 200]}, "ConNF.Code.extension_eq_of_singleton_equiv_singleton": {"natural_language_statement": "The theorem states that given two codes `a` and `b` of type indices `\u03b2` and `\u03b3` respectively, where `a` is a singleton set and `b` is also a singleton set, and these codes are equivalent under the equivalence relation defined by the `ConNF.Params` class, then the types `\u03b2` and `\u03b3` must be equal. This is a key property that underpins the use of ConNF in the context of Constructive Ordinal Notation.", "formal_statement": "example [ConNF.Params ] [ConNF.Level] {\u03b2 : ConNF.TypeIndex} [ConNF.LtLevel \u03b2] [ConNF.TangleDataLt] [ConNF.TypedObjectsLt] [ConNF.PositionedTanglesLt] {\u03b3 : ConNF.TypeIndex} [ConNF.LtLevel \u03b3] {a : ConNF.Tangle \u03b2} {b : ConNF.Tangle \u03b3} (h : ConNF.Code.mk \u03b2 {a} \u2261 ConNF.Code.mk \u03b3 {b}) :\u03b2 = \u03b3 := by sorry", "full_tactic_state": "inst\u271d\u2076 : ConNF.Params\ninst\u271d\u2075 : ConNF.Level\n\u03b2 : ConNF.TypeIndex\ninst\u271d\u2074 : ConNF.LtLevel \u03b2\ninst\u271d\u00b3 : ConNF.TangleDataLt\ninst\u271d\u00b2 : ConNF.TypedObjectsLt\ninst\u271d\u00b9 : ConNF.PositionedTanglesLt\n\u03b3 : ConNF.TypeIndex\ninst\u271d : ConNF.LtLevel \u03b3\na : ConNF.Tangle \u03b2\nb : ConNF.Tangle \u03b3\nh : ConNF.Code.mk \u03b2 {a} \u2261 ConNF.Code.mk \u03b3 {b}\n\u22a2 \u03b2 = \u03b3", "dependency": [1, 98, 98, 104, 104]}, "ConNF.Code.equiv_bot_subsingleton": {"natural_language_statement": "The theorem `ConNF.Code.equiv_bot_subsingleton` states that if two ConNF codes `d` and `e` are equivalent to the same code `c`, and both `d.\u03b2` and `e.\u03b2` are equal to `\u22a5`, then `d` must be equal to `e`.", "formal_statement": "example [ConNF.Params ] [ConNF.Level] [ConNF.TangleDataLt] [ConNF.TypedObjectsLt] [ConNF.PositionedTanglesLt] {c : ConNF.Code} (d : ConNF.Code) (e : ConNF.Code) (hdc : d \u2261 c) (hec : e \u2261 c) (hd : d.\u03b2 = \u22a5 ) (he : e.\u03b2 = \u22a5 ) :d = e := by sorry", "full_tactic_state": "inst\u271d\u2074 : ConNF.Params\ninst\u271d\u00b3 : ConNF.Level\ninst\u271d\u00b2 : ConNF.TangleDataLt\ninst\u271d\u00b9 : ConNF.TypedObjectsLt\ninst\u271d : ConNF.PositionedTanglesLt\nc d e : ConNF.Code\nhdc : d \u2261 c\nhec : e \u2261 c\nhd : d.\u03b2 = \u22a5\nhe : e.\u03b2 = \u22a5\n\u22a2 d = e", "dependency": [1]}, "ConNF.Extensions.ext": {"natural_language_statement": "The `ConNF.Extensions.ext` theorem in Lean 4 is a proof that two `ConNF.Extensions` objects are equal if and only if their values are equal for all types `\u03b2` that are less than the current level `\u03b1` in the context of Constructive Ordinal Notation (ConNF).", "formal_statement": "example [ConNF.Params ] [ConNF.Level] [ConNF.TangleDataLt] {e\u2081 : ConNF.Extensions} {e\u2082 : ConNF.Extensions} (h : \u2200 (\u03b2 : ConNF.\u039b) [inst : ConNF.LtLevel \u2191\u03b2], e\u2081 \u03b2 = e\u2082 \u03b2) :e\u2081 = e\u2082 := by sorry", "full_tactic_state": "inst\u271d\u00b2 : ConNF.Params\ninst\u271d\u00b9 : ConNF.Level\ninst\u271d : ConNF.TangleDataLt\ne\u2081 e\u2082 : ConNF.Extensions\nh : \u2200 (\u03b2 : ConNF.\u039b) [inst : ConNF.LtLevel \u2191\u03b2], e\u2081 \u03b2 = e\u2082 \u03b2\n\u22a2 e\u2081 = e\u2082", "dependency": [1, 98]}, "ConNF.Semitangle.Preference.base_heq_base": {"natural_language_statement": "This theorem states that the Base preference constructor for semitangles is equality-preserving with respect to the set of tangles and the extension function. This means that if two Base preference constructors have the same set of tangles and the same extension function, they are considered equal.", "formal_statement": "example [ConNF.Params ] [ConNF.Level] [ConNF.TangleDataLt] [ConNF.PositionedTanglesLt] [ConNF.TypedObjectsLt] {m\u2081 : ConNF.Extensions} {m\u2082 : ConNF.Extensions} {s\u2081 : Set (ConNF.Tangle \u22a5 )} {s\u2082 : Set (ConNF.Tangle \u22a5 )} {h\u2081 : \u2200 (\u03b3 : ConNF.\u039b) [inst : ConNF.LtLevel \u2191\u03b3], ConNF.cloud \u22ef s\u2081 = m\u2081 \u03b3} {h\u2082 : \u2200 (\u03b3 : ConNF.\u039b) [inst : ConNF.LtLevel \u2191\u03b3], ConNF.cloud \u22ef s\u2082 = m\u2082 \u03b3} (hm : m\u2081 = m\u2082) (hs : s\u2081 = s\u2082) :HEq (ConNF.Semitangle.Preference.base s\u2081 h\u2081) (ConNF.Semitangle.Preference.base s\u2082 h\u2082) := by sorry", "full_tactic_state": "inst\u271d\u2074 : ConNF.Params\ninst\u271d\u00b3 : ConNF.Level\ninst\u271d\u00b2 : ConNF.TangleDataLt\ninst\u271d\u00b9 : ConNF.PositionedTanglesLt\ninst\u271d : ConNF.TypedObjectsLt\nm\u2081 m\u2082 : ConNF.Extensions\ns\u2081 s\u2082 : Set (ConNF.Tangle \u22a5)\nh\u2081 : \u2200 (\u03b3 : ConNF.\u039b) [inst : ConNF.LtLevel \u2191\u03b3], ConNF.cloud \u22ef s\u2081 = m\u2081 \u03b3\nh\u2082 : \u2200 (\u03b3 : ConNF.\u039b) [inst : ConNF.LtLevel \u2191\u03b3], ConNF.cloud \u22ef s\u2082 = m\u2082 \u03b3\nhm : m\u2081 = m\u2082\nhs : s\u2081 = s\u2082\n\u22a2 HEq (ConNF.Semitangle.Preference.base s\u2081 h\u2081) (ConNF.Semitangle.Preference.base s\u2082 h\u2082)", "dependency": [1, 69, 69, 98, 77, 98, 77, 126, 205, 205]}, "ConNF.Semitangle.reprCode_base": {"natural_language_statement": "In the context of Constructive Ordinal Notation (ConNF), the function `ConNF.Semitangle.reprCode` computes the even code associated to a semitangle. The theorem `ConNF.Semitangle.reprCode_base` provides a base case for this computation, where the preferred extension of the semitangle is directly given by the `ConNF.cloud` map applied to a set of tangles.", "formal_statement": "@[simp]example [ConNF.Params ] [ConNF.Level] [ConNF.TangleDataLt] [ConNF.PositionedTanglesLt] [ConNF.TypedObjectsLt] (exts : ConNF.Extensions) (atoms : Set (ConNF.Tangle \u22a5 )) (hA : \u2200 (\u03b3 : ConNF.\u039b) [inst : ConNF.LtLevel \u2191\u03b3], ConNF.cloud \u22ef atoms = exts \u03b3) :ConNF.Semitangle.reprCode { members := exts, pref := ConNF.Semitangle.Preference.base atoms hA } = ConNF.Code.mk \u22a5 atoms := by sorry", "full_tactic_state": "inst\u271d\u2074 : ConNF.Params\ninst\u271d\u00b3 : ConNF.Level\ninst\u271d\u00b2 : ConNF.TangleDataLt\ninst\u271d\u00b9 : ConNF.PositionedTanglesLt\ninst\u271d : ConNF.TypedObjectsLt\nexts : ConNF.Extensions\natoms : Set (ConNF.Tangle \u22a5)\nhA : \u2200 (\u03b3 : ConNF.\u039b) [inst : ConNF.LtLevel \u2191\u03b3], ConNF.cloud \u22ef atoms = exts \u03b3\n\u22a2 ConNF.Semitangle.reprCode { members := exts, pref := ConNF.Semitangle.Preference.base atoms hA } =\n    ConNF.Code.mk \u22a5 atoms", "dependency": [1, 69, 98, 77, 208, 205, 104]}, "ConNF.Semitangle.reprCodeSpec": {"natural_language_statement": "The theorem `ConNF.Semitangle.reprCodeSpec` states that the even code associated to a semitangle in the context of Constructive Ordinal Notation (ConNF) is indeed even.", "formal_statement": "example [ConNF.Params ] [ConNF.Level] [ConNF.TangleDataLt] [ConNF.PositionedTanglesLt] [ConNF.TypedObjectsLt] (t : ConNF.Semitangle) :ConNF.Code.IsEven (ConNF.Semitangle.reprCode t) := by sorry", "full_tactic_state": "inst\u271d\u2074 : ConNF.Params\ninst\u271d\u00b3 : ConNF.Level\ninst\u271d\u00b2 : ConNF.TangleDataLt\ninst\u271d\u00b9 : ConNF.PositionedTanglesLt\ninst\u271d : ConNF.TypedObjectsLt\nt : ConNF.Semitangle\n\u22a2 ConNF.Code.IsEven (ConNF.Semitangle.reprCode t)", "dependency": [1, 165, 208]}, "ConNF.Semitangle.reprCode_members_ne": {"natural_language_statement": "Function `ConNF.Semitangle.reprCode_members_ne` is a theorem in the context of Constructive Ordinal Notation (ConNF) in Lean 4. It states that for a semitangle `t` and a type index `\u03b3` less than the current level, if the first component of the even code `ConNF.Semitangle.reprCode t` is not equal to `\u03b3`, then the members of the cloud code `ConNF.cloudCode \u03b3 (ConNF.Semitangle.reprCode t)` are equal to the members of `t` at `\u03b3`.", "formal_statement": "example [ConNF.Params ] [ConNF.Level] [ConNF.TangleDataLt] [ConNF.PositionedTanglesLt] [ConNF.TypedObjectsLt] (t : ConNF.Semitangle) (\u03b3 : ConNF.\u039b) [ConNF.LtLevel \u2191\u03b3] :(ConNF.Semitangle.reprCode t).\u03b2 \u2260 \u2191\u03b3 \u2192 (ConNF.cloudCode \u03b3 (ConNF.Semitangle.reprCode t)).members = t.members \u03b3 := by sorry", "full_tactic_state": "inst\u271d\u2075 : ConNF.Params\ninst\u271d\u2074 : ConNF.Level\ninst\u271d\u00b3 : ConNF.TangleDataLt\ninst\u271d\u00b2 : ConNF.PositionedTanglesLt\ninst\u271d\u00b9 : ConNF.TypedObjectsLt\nt : ConNF.Semitangle\n\u03b3 : ConNF.\u039b\ninst\u271d : ConNF.LtLevel \u2191\u03b3\n\u22a2 (ConNF.Semitangle.reprCode t).\u03b2 \u2260 \u2191\u03b3 \u2192 (ConNF.cloudCode \u03b3 (ConNF.Semitangle.reprCode t)).members = t.members \u03b3", "dependency": [1, 98, 208, 101, 208]}, "ConNF.Semitangle.ext_core": {"natural_language_statement": "The theorem `ConNF.Semitangle.ext_core` is a form of extensionality for semitangles in the context of Constructive Ordinal Notation (ConNF). It states that if there exists a proper type index `\u03b3` less than the current level `\u03b1`, and two semitangles have the same members, then the two semitangles are equal.", "formal_statement": "example [ConNF.Params ] [ConNF.Level] [ConNF.TangleDataLt] [ConNF.PositionedTanglesLt] [ConNF.TypedObjectsLt] (t\u2081 : ConNF.Semitangle) (t\u2082 : ConNF.Semitangle) :Nonempty ((\u03b3 : ConNF.\u039b) \u00d7' ConNF.LtLevel \u2191\u03b3) \u2192 t\u2081.members = t\u2082.members \u2192 t\u2081 = t\u2082 := by sorry", "full_tactic_state": "inst\u271d\u2074 : ConNF.Params\ninst\u271d\u00b3 : ConNF.Level\ninst\u271d\u00b2 : ConNF.TangleDataLt\ninst\u271d\u00b9 : ConNF.PositionedTanglesLt\ninst\u271d : ConNF.TypedObjectsLt\nt\u2081 t\u2082 : ConNF.Semitangle\n\u22a2 Nonempty ((\u03b3 : ConNF.\u039b) \u00d7' ConNF.LtLevel \u2191\u03b3) \u2192 t\u2081.members = t\u2082.members \u2192 t\u2081 = t\u2082", "dependency": [1, 212, 98]}, "ConNF.Semitangle.ext": {"natural_language_statement": "The theorem `ConNF.Semitangle.ext` is a proof of extensionality for semitangles in the context of Constructive Ordinal Notation (ConNF). It states that two semitangles are equal if their `\u03b2`-extensions are equal for any choice of `\u03b3 < \u03b1`.", "formal_statement": "example [ConNF.Params ] [ConNF.Level] [ConNF.TangleDataLt] {\u03b3 : ConNF.\u039b} [ConNF.LtLevel \u2191\u03b3] [ConNF.PositionedTanglesLt] [ConNF.TypedObjectsLt] (t\u2081 : ConNF.Semitangle) (t\u2082 : ConNF.Semitangle) (h : t\u2081.members \u03b3 = t\u2082.members \u03b3) :t\u2081 = t\u2082 := by sorry", "full_tactic_state": "inst\u271d\u2075 : ConNF.Params\ninst\u271d\u2074 : ConNF.Level\ninst\u271d\u00b3 : ConNF.TangleDataLt\n\u03b3 : ConNF.\u039b\ninst\u271d\u00b2 : ConNF.LtLevel \u2191\u03b3\ninst\u271d\u00b9 : ConNF.PositionedTanglesLt\ninst\u271d : ConNF.TypedObjectsLt\nt\u2081 t\u2082 : ConNF.Semitangle\nh : t\u2081.members \u03b3 = t\u2082.members \u03b3\n\u22a2 t\u2081 = t\u2082", "dependency": [1, 98]}, "ConNF.Semitangle.ext_zero": {"natural_language_statement": "In the context of Constructive Ordinal Notation (ConNF), the theorem `ConNF.Semitangle.ext_zero` establishes an extensionality principle for semitangles at the lowest level of tangled type theory, specifically at type 0. At this level, all semitangles have a `\u22a5`-extension, and the extensionality principle applies to these `\u22a5`-extensions.", "formal_statement": "example [ConNF.Params ] [ConNF.Level] [ConNF.TangleDataLt] [ConNF.PositionedTanglesLt] [ConNF.TypedObjectsLt] (t\u2081 : ConNF.Semitangle) (t\u2082 : ConNF.Semitangle) (\u03b1_zero : IsMin ConNF.\u03b1) (h : ConNF.Semitangle.Preference.atoms t\u2081.pref = ConNF.Semitangle.Preference.atoms t\u2082.pref) :t\u2081 = t\u2082 := by sorry", "full_tactic_state": "inst\u271d\u2074 : ConNF.Params\ninst\u271d\u00b3 : ConNF.Level\ninst\u271d\u00b2 : ConNF.TangleDataLt\ninst\u271d\u00b9 : ConNF.PositionedTanglesLt\ninst\u271d : ConNF.TypedObjectsLt\nt\u2081 t\u2082 : ConNF.Semitangle\n\u03b1_zero : IsMin ConNF.\u03b1\nh : ConNF.Semitangle.Preference.atoms t\u2081.pref = ConNF.Semitangle.Preference.atoms t\u2082.pref\n\u22a2 t\u2081 = t\u2082", "dependency": [1, 215, 216, 216]}, "ConNF.Semitangle.exts_intro": {"natural_language_statement": "The `ConNF.Semitangle.exts_intro` theorem in Lean 4 states that the members of a semitangle constructed from an even code are equal to the extension of the set of tangles used to construct the semitangle.", "formal_statement": "@[simp]example [ConNF.Params ] [ConNF.Level] [ConNF.TangleDataLt] {\u03b2 : ConNF.TypeIndex} [ConNF.LtLevel \u03b2] [ConNF.PositionedTanglesLt] [ConNF.TypedObjectsLt] (s : Set (ConNF.Tangle \u03b2)) (heven : ConNF.Code.IsEven (ConNF.Code.mk \u03b2 s)) :(ConNF.Semitangle.intro s heven).members = ConNF.extension s := by sorry", "full_tactic_state": "inst\u271d\u2075 : ConNF.Params\ninst\u271d\u2074 : ConNF.Level\ninst\u271d\u00b3 : ConNF.TangleDataLt\n\u03b2 : ConNF.TypeIndex\ninst\u271d\u00b2 : ConNF.LtLevel \u03b2\ninst\u271d\u00b9 : ConNF.PositionedTanglesLt\ninst\u271d : ConNF.TypedObjectsLt\ns : Set (ConNF.Tangle \u03b2)\nheven : ConNF.Code.IsEven (ConNF.Code.mk \u03b2 s)\n\u22a2 (ConNF.Semitangle.intro s heven).members = ConNF.extension s", "dependency": [1, 98, 69, 165, 104, 218, 99]}, "ConNF.NewAllowable.members_smul'": {"natural_language_statement": "The theorem `ConNF.NewAllowable.members_smul'` states that for any `ConNF.NewAllowable` object `\u03c1` and any `ConNF.Semitangle` object `t`, the members of the semitangle `(\u03c1 \u2022 t)` is equal to `\u03c1 \u2022 t.members`, where `\u03c1 \u2022 t.members` denotes the scalar multiplication of the members of `t` by `\u03c1`.", "formal_statement": "@[simp]example [ConNF.Params ] [ConNF.Level] [ConNF.TangleDataLt] [ConNF.PositionedTanglesLt] [ConNF.TypedObjectsLt] (\u03c1 : ConNF.NewAllowable) (t : ConNF.Semitangle) :(\u03c1 \u2022 t).members = \u03c1 \u2022 t.members := by sorry", "full_tactic_state": "inst\u271d\u2074 : ConNF.Params\ninst\u271d\u00b3 : ConNF.Level\ninst\u271d\u00b2 : ConNF.TangleDataLt\ninst\u271d\u00b9 : ConNF.PositionedTanglesLt\ninst\u271d : ConNF.TypedObjectsLt\n\u03c1 : ConNF.NewAllowable\nt : ConNF.Semitangle\n\u22a2 (\u03c1 \u2022 t).members = \u03c1 \u2022 t.members", "dependency": [1]}, "ConNF.Code.Equiv.supports": {"natural_language_statement": "The theorem `ConNF.Code.Equiv.supports` states that if a set of addresses supports a code `c`, then it also supports any code `d` that is equivalent to `c`. In the context of Constructive Ordinal Notation (ConNF), this means that if a set of addresses is sufficient to determine the behavior of one code, it is also sufficient to determine the behavior of any equivalent code.", "formal_statement": "example [ConNF.Params ] [ConNF.Level] [ConNF.TangleDataLt] [ConNF.PositionedTanglesLt] [ConNF.TypedObjectsLt] {c : ConNF.Code} {d : ConNF.Code} {S : Set (ConNF.Address \u2191ConNF.\u03b1)} (hcd : c \u2261 d) (hS : MulAction.Supports ConNF.NewAllowable S c) :MulAction.Supports ConNF.NewAllowable S d := by sorry", "full_tactic_state": "inst\u271d\u2074 : ConNF.Params\ninst\u271d\u00b3 : ConNF.Level\ninst\u271d\u00b2 : ConNF.TangleDataLt\ninst\u271d\u00b9 : ConNF.PositionedTanglesLt\ninst\u271d : ConNF.TypedObjectsLt\nc d : ConNF.Code\nS : Set (ConNF.Address \u2191ConNF.\u03b1)\nhcd : c \u2261 d\nhS : MulAction.Supports ConNF.NewAllowable S c\n\u22a2 MulAction.Supports ConNF.NewAllowable S d", "dependency": [1, 69, 60, 68, 68]}, "ConNF.Code.Equiv.supports_iff": {"natural_language_statement": "The theorem `ConNF.Code.Equiv.supports_iff` states that if two ConNF codes `c` and `d` are equivalent (denoted by `c \u2261 d`), then the set `S` supports `c` under the action of `ConNF.NewAllowable` if and only if `S` supports `d` under the same action.", "formal_statement": "example [ConNF.Params ] [ConNF.Level] [ConNF.TangleDataLt] [ConNF.PositionedTanglesLt] [ConNF.TypedObjectsLt] {c : ConNF.Code} {d : ConNF.Code} {S : Set (ConNF.Address \u2191ConNF.\u03b1)} (hcd : c \u2261 d) :MulAction.Supports ConNF.NewAllowable S c \u2194 MulAction.Supports ConNF.NewAllowable S d := by sorry", "full_tactic_state": "inst\u271d\u2074 : ConNF.Params\ninst\u271d\u00b3 : ConNF.Level\ninst\u271d\u00b2 : ConNF.TangleDataLt\ninst\u271d\u00b9 : ConNF.PositionedTanglesLt\ninst\u271d : ConNF.TypedObjectsLt\nc d : ConNF.Code\nS : Set (ConNF.Address \u2191ConNF.\u03b1)\nhcd : c \u2261 d\n\u22a2 MulAction.Supports ConNF.NewAllowable S c \u2194 MulAction.Supports ConNF.NewAllowable S d", "dependency": [1, 69, 60, 68, 68]}, "ConNF.Code.Equiv.supported_iff": {"natural_language_statement": "The theorem `ConNF.Code.Equiv.supported_iff` states that if two codes `c` and `d` are equivalent (denoted by `c \u2261 d`), then there exists a support for `c` if and only if there exists a support for `d`. This means that the property of being supported is preserved under equivalence of codes.", "formal_statement": "example [ConNF.Params ] [ConNF.Level] [ConNF.TangleDataLt] [ConNF.PositionedTanglesLt] [ConNF.TypedObjectsLt] {c : ConNF.Code} {d : ConNF.Code} (hcd : c \u2261 d) :(\u2203 (S : ConNF.Support \u2191ConNF.\u03b1), MulAction.Supports ConNF.NewAllowable (ConNF.Enumeration.carrier S.enum) c) \u2194 \u2203 (S : ConNF.Support \u2191ConNF.\u03b1), MulAction.Supports ConNF.NewAllowable (ConNF.Enumeration.carrier S.enum) d := by sorry", "full_tactic_state": "inst\u271d\u2074 : ConNF.Params\ninst\u271d\u00b3 : ConNF.Level\ninst\u271d\u00b2 : ConNF.TangleDataLt\ninst\u271d\u00b9 : ConNF.PositionedTanglesLt\ninst\u271d : ConNF.TypedObjectsLt\nc d : ConNF.Code\nhcd : c \u2261 d\n\u22a2 (\u2203 S, MulAction.Supports ConNF.NewAllowable (ConNF.Enumeration.carrier S.enum) c) \u2194\n    \u2203 S, MulAction.Supports ConNF.NewAllowable (ConNF.Enumeration.carrier S.enum) d", "dependency": [1, 58, 68, 70, 58, 68, 70]}, "ConNF.NewAllowable.smul_address": {"natural_language_statement": "In the context of Constructive Ordinal Notation (ConNF), `ConNF.NewAllowable.smul_address` is a theorem that defines the action of a `ConNF.NewAllowable` object on a `ConNF.Address` object. Specifically, it states that when a `ConNF.NewAllowable` object `\u03c1` acts on a `ConNF.Address` object `c`, the resulting `ConNF.Address` object has the same path as `c`, but its value is obtained by applying the permutation `ConNF.NewAllowable.toStructPerm \u03c1 c.path` to the value of `c`.", "formal_statement": "example [ConNF.Params ] [ConNF.Level] [ConNF.TangleDataLt] [ConNF.PositionedTanglesLt] [ConNF.TypedObjectsLt] {\u03c1 : ConNF.NewAllowable} {c : ConNF.Address \u2191ConNF.\u03b1} :\u03c1 \u2022 c = { path := c.path, value := ConNF.NewAllowable.toStructPerm \u03c1 c.path \u2022 c.value } := by sorry", "full_tactic_state": "inst\u271d\u2074 : ConNF.Params\ninst\u271d\u00b3 : ConNF.Level\ninst\u271d\u00b2 : ConNF.TangleDataLt\ninst\u271d\u00b9 : ConNF.PositionedTanglesLt\ninst\u271d : ConNF.TypedObjectsLt\n\u03c1 : ConNF.NewAllowable\nc : ConNF.Address \u2191ConNF.\u03b1\n\u22a2 \u03c1 \u2022 c = { path := c.path, value := ConNF.NewAllowable.toStructPerm \u03c1 c.path \u2022 c.value }", "dependency": [1, 60]}, "ConNF.NewAllowable.smul_address_eq_iff": {"natural_language_statement": "In the context of Constructive Ordinal Notation (ConNF), the theorem `ConNF.NewAllowable.smul_address_eq_iff` states that for an element `\u03c1` of the type `ConNF.NewAllowable` and an element `c` of the type `ConNF.Address \u2191ConNF.\u03b1`, the condition `\u03c1 \u2022 c = c` is equivalent to the condition `ConNF.NewAllowable.toStructPerm \u03c1 c.path \u2022 c.value = c.value`. This theorem is marked as `@[simp]`, indicating that it should be used as a simplification rule in further proofs.", "formal_statement": "@[simp]example [ConNF.Params ] [ConNF.Level] [ConNF.TangleDataLt] [ConNF.PositionedTanglesLt] [ConNF.TypedObjectsLt] {\u03c1 : ConNF.NewAllowable} {c : ConNF.Address \u2191ConNF.\u03b1} :\u03c1 \u2022 c = c \u2194 ConNF.NewAllowable.toStructPerm \u03c1 c.path \u2022 c.value = c.value := by sorry", "full_tactic_state": "inst\u271d\u2074 : ConNF.Params\ninst\u271d\u00b3 : ConNF.Level\ninst\u271d\u00b2 : ConNF.TangleDataLt\ninst\u271d\u00b9 : ConNF.PositionedTanglesLt\ninst\u271d : ConNF.TypedObjectsLt\n\u03c1 : ConNF.NewAllowable\nc : ConNF.Address \u2191ConNF.\u03b1\n\u22a2 \u03c1 \u2022 c = c \u2194 ConNF.NewAllowable.toStructPerm \u03c1 c.path \u2022 c.value = c.value", "dependency": [1, 60]}, "ConNF.NewAllowable.smul_address_eq_smul_iff": {"natural_language_statement": "The theorem `ConNF.NewAllowable.smul_address_eq_smul_iff` states that for two `ConNF.NewAllowable` objects `\u03c1` and `\u03c1'` and a `ConNF.Address` object `c`, the equation `\u03c1 \u2022 c = \u03c1' \u2022 c` holds if and only if the permutation of `c`'s value by `\u03c1` is equal to the permutation of `c`'s value by `\u03c1'`.", "formal_statement": "@[simp]example [ConNF.Params ] [ConNF.Level] [ConNF.TangleDataLt] [ConNF.PositionedTanglesLt] [ConNF.TypedObjectsLt] {\u03c1 : ConNF.NewAllowable} {\u03c1' : ConNF.NewAllowable} {c : ConNF.Address \u2191ConNF.\u03b1} :\u03c1 \u2022 c = \u03c1' \u2022 c \u2194 ConNF.NewAllowable.toStructPerm \u03c1 c.path \u2022 c.value = ConNF.NewAllowable.toStructPerm \u03c1' c.path \u2022 c.value := by sorry", "full_tactic_state": "inst\u271d\u2074 : ConNF.Params\ninst\u271d\u00b3 : ConNF.Level\ninst\u271d\u00b2 : ConNF.TangleDataLt\ninst\u271d\u00b9 : ConNF.PositionedTanglesLt\ninst\u271d : ConNF.TypedObjectsLt\n\u03c1 \u03c1' : ConNF.NewAllowable\nc : ConNF.Address \u2191ConNF.\u03b1\n\u22a2 \u03c1 \u2022 c = \u03c1' \u2022 c \u2194\n    ConNF.NewAllowable.toStructPerm \u03c1 c.path \u2022 c.value = ConNF.NewAllowable.toStructPerm \u03c1' c.path \u2022 c.value", "dependency": [1, 60]}, "ConNF.NewAllowable.coe_smul_newTangle": {"natural_language_statement": "The theorem `ConNF.NewAllowable.coe_smul_newTangle` states that the scalar multiplication of a `ConNF.NewAllowable` object `\u03c1` with a `ConNF.NewTangle` object `t` is equal to the scalar multiplication of `\u03c1` with the underlying `ConNF.Tangle` object of `t`.", "formal_statement": "@[simp]example [ConNF.Params ] [ConNF.Level] [ConNF.TangleDataLt] [ConNF.PositionedTanglesLt] [ConNF.TypedObjectsLt] (\u03c1 : ConNF.NewAllowable) (t : ConNF.NewTangle) :\u03c1 \u2022 \u2191t = \u03c1 \u2022 \u2191t := by sorry", "full_tactic_state": "inst\u271d\u2074 : ConNF.Params\ninst\u271d\u00b3 : ConNF.Level\ninst\u271d\u00b2 : ConNF.TangleDataLt\ninst\u271d\u00b9 : ConNF.PositionedTanglesLt\ninst\u271d : ConNF.TypedObjectsLt\n\u03c1 : ConNF.NewAllowable\nt : ConNF.NewTangle\n\u22a2 \u03c1 \u2022 t = \u03c1 \u2022 t", "dependency": [1]}, "ConNF.Enumeration.ext": {"natural_language_statement": "In the context of Constructive Ordinal Notation (ConNF), an `\u03b1`-enumeration is a function from an initial segment of `\u03ba` to `\u03b1`. The theorem `ConNF.Enumeration.ext` states that two `\u03b1`-enumerations `x` and `y` are equal if their maximum values (`x.max` and `y.max`) are equal and their functions (`x.f` and `y.f`) are heterogeneously equal (`HEq`).", "formal_statement": "example :\u2200 {inst : ConNF.Params } {\u03b1 : Type u_1} (x y : ConNF.Enumeration \u03b1), x.max = y.max \u2192 HEq x.f y.f \u2192 x = y := by sorry", "full_tactic_state": "\u22a2 \u2200 {inst : ConNF.Params} {\u03b1 : Type u_1} (x y : ConNF.Enumeration \u03b1), x.max = y.max \u2192 HEq x.f y.f \u2192 x = y", "dependency": [1, 59, 126]}, "ConNF.Enumeration.ext_iff": {"natural_language_statement": "The theorem `ConNF.Enumeration.ext_iff` states that two `\u03b1`-enumerations `x` and `y` are equal if and only if their maximum values `x.max` and `y.max` are equal and the functions `x.f` and `y.f` are heterogeneously equal (`HEq`).", "formal_statement": "example :\u2200 {inst : ConNF.Params } {\u03b1 : Type u_1} (x y : ConNF.Enumeration \u03b1), x = y \u2194 x.max = y.max \u2227 HEq x.f y.f := by sorry", "full_tactic_state": "\u22a2 \u2200 {inst : ConNF.Params} {\u03b1 : Type u_1} (x y : ConNF.Enumeration \u03b1), x = y \u2194 x.max = y.max \u2227 HEq x.f y.f", "dependency": [1, 59, 126]}, "ConNF.Enumeration.mem_carrier_iff": {"natural_language_statement": "The theorem `ConNF.Enumeration.mem_carrier_iff` states that an element `x` is in the carrier set of an `\u03b1`-enumeration `E` if and only if there exists an index `i` less than `E.max` such that `x` is equal to `E.f i h`, where `h` is a proof that `i` is less than `E.max`.", "formal_statement": "example [ConNF.Params ] {\u03b1 : Type u_1} (x : \u03b1) (E : ConNF.Enumeration \u03b1) :x \u2208 ConNF.Enumeration.carrier E \u2194 \u2203 (i : ConNF.\u03ba) (h : i < E.max), x = E.f i h := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03b1 : Type u_1\nx : \u03b1\nE : ConNF.Enumeration \u03b1\n\u22a2 x \u2208 ConNF.Enumeration.carrier E \u2194 \u2203 i, \u2203 (h : i < E.max), x = E.f i h", "dependency": [1, 59, 70]}, "ConNF.Enumeration.mem_iff": {"natural_language_statement": "The theorem `ConNF.Enumeration.mem_iff` states that an element `c` is a member of an enumeration `E` if and only if there exists an index `i` less than the maximum index of `E` such that `c` is equal to the value of `E` at `i`.", "formal_statement": "example [ConNF.Params ] {\u03b1 : Type u_1} (c : \u03b1) (E : ConNF.Enumeration \u03b1) :c \u2208 E \u2194 \u2203 (i : ConNF.\u03ba) (h : i < E.max), c = E.f i h := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03b1 : Type u_1\nc : \u03b1\nE : ConNF.Enumeration \u03b1\n\u22a2 c \u2208 E \u2194 \u2203 i, \u2203 (h : i < E.max), c = E.f i h", "dependency": [1, 59]}, "ConNF.Enumeration.f_mem": {"natural_language_statement": "The theorem `ConNF.Enumeration.f_mem` states that for any `\u03b1`-enumeration `E` and any `i` less than `E.max`, the value `E.f i hi` (where `hi` is a proof that `i < E.max`) is an element of `E`.", "formal_statement": "example [ConNF.Params ] {\u03b1 : Type u_1} (E : ConNF.Enumeration \u03b1) (i : ConNF.\u03ba) (hi : i < E.max) :E.f i hi \u2208 E := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03b1 : Type u_1\nE : ConNF.Enumeration \u03b1\ni : ConNF.\u03ba\nhi : i < E.max\n\u22a2 E.f i hi \u2208 E", "dependency": [1, 59]}, "ConNF.Enumeration.carrier_small": {"natural_language_statement": "The theorem `ConNF.Enumeration.carrier_small` states that the carrier set of an `\u03b1`-enumeration `E`, which consists of all elements `c` of type `\u03b1` that can be expressed as `E.f i h` for some `i < E.max`, has a cardinality strictly less than the cardinality of the type `ConNF.\u03ba` in the context of Constructive Ordinal Notation (ConNF).", "formal_statement": "example [ConNF.Params ] {\u03b1 : Type u} (E : ConNF.Enumeration \u03b1) :ConNF.Small (ConNF.Enumeration.carrier E) := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03b1 : Type u\nE : ConNF.Enumeration \u03b1\n\u22a2 ConNF.Small (ConNF.Enumeration.carrier E)", "dependency": [1, 59, 233, 70]}, "ConNF.Enumeration.small": {"natural_language_statement": "Function `ConNF.Enumeration.small` proves that the carrier set of an `\u03b1`-enumeration `E` is strictly smaller than the type `ConNF.\u03ba` in the context of Constructive Ordinal Notation (ConNF).", "formal_statement": "example [ConNF.Params ] {\u03b1 : Type u} (E : ConNF.Enumeration \u03b1) :ConNF.Small (ConNF.Enumeration.carrier E) := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03b1 : Type u\nE : ConNF.Enumeration \u03b1\n\u22a2 ConNF.Small (ConNF.Enumeration.carrier E)", "dependency": [1, 59, 233, 70]}, "ConNF.funMap_injective": {"natural_language_statement": "The theorem `ConNF.funMap_injective` states that the function `ConNF.funMap`, which maps a function `f` from `\u03b1` to `\u03b2` to a pair consisting of the range of `f` and the inverse image of the less-than relation on `\u03b2` under `f`, is injective.", "formal_statement": "example {\u03b1 : Type u_1} {\u03b2 : Type u_1} [LinearOrder \u03b2] [IsWellOrder \u03b2 fun (x x_1 : \u03b2) => x < x_1] :Function.Injective (ConNF.funMap \u03b1 \u03b2) := by sorry", "full_tactic_state": "\u03b1 \u03b2 : Type u_1\ninst\u271d\u00b9 : LinearOrder \u03b2\ninst\u271d : IsWellOrder \u03b2 fun x x_1 => x < x_1\n\u22a2 Function.Injective (ConNF.funMap \u03b1 \u03b2)", "dependency": [2, 15, 89, 236]}, "ConNF.mk_fun_le": {"natural_language_statement": "The cardinality of the set of functions from \u03b1 to \u03b2 is less than or equal to the product of the cardinality of the set of subsets of \u03b2 whose cardinality is less than or equal to the cardinality of \u03b1, and the set of binary relations on \u03b1.", "formal_statement": "example {\u03b1 : Type u} {\u03b2 : Type u} :Cardinal.mk (\u03b1 \u2192 \u03b2) \u2264 Cardinal.mk ({ E : Set \u03b2 // Cardinal.mk \u2191E \u2264 Cardinal.mk \u03b1 } \u00d7 (\u03b1 \u2192 \u03b1 \u2192 Prop )) := by sorry", "full_tactic_state": "\u03b1 \u03b2 : Type u\n\u22a2 Cardinal.mk (\u03b1 \u2192 \u03b2) \u2264 Cardinal.mk ({ E // Cardinal.mk \u2191E \u2264 Cardinal.mk \u03b1 } \u00d7 (\u03b1 \u2192 \u03b1 \u2192 Prop))", "dependency": [29, 29, 69, 29, 29]}, "ConNF.pow_le_of_isStrongLimit'": {"natural_language_statement": "The theorem `ConNF.pow_le_of_isStrongLimit'` states that for any two infinite types `\u03b1` and `\u03b2`, if `\u03b2` is a strong limit cardinal and the cardinality of `\u03b1` is less than the cofinality of the ordinal corresponding to the cardinality of `\u03b2`, then the cardinality of `\u03b2` raised to the power of the cardinality of `\u03b1` is less than or equal to the cardinality of `\u03b2`.", "formal_statement": "example {\u03b1 : Type u} {\u03b2 : Type u} [Infinite \u03b1] [Infinite \u03b2] (h\u2081 : Cardinal.IsStrongLimit (Cardinal.mk \u03b2)) (h\u2082 : Cardinal.mk \u03b1 < Ordinal.cof (Cardinal.ord (Cardinal.mk \u03b2))) :Cardinal.mk \u03b2 ^ Cardinal.mk \u03b1 \u2264 Cardinal.mk \u03b2 := by sorry", "full_tactic_state": "\u03b1 \u03b2 : Type u\ninst\u271d\u00b9 : Infinite \u03b1\ninst\u271d : Infinite \u03b2\nh\u2081 : Cardinal.IsStrongLimit (Cardinal.mk \u03b2)\nh\u2082 : Cardinal.mk \u03b1 < Ordinal.cof (Cardinal.ord (Cardinal.mk \u03b2))\n\u22a2 Cardinal.mk \u03b2 ^ Cardinal.mk \u03b1 \u2264 Cardinal.mk \u03b2", "dependency": [239, 239, 37, 29, 29, 38, 27, 29, 29, 29, 29]}, "ConNF.pow_le_of_isStrongLimit": {"natural_language_statement": "If `\u03bc` is a strong limit cardinal and `\u03ba` is less than the cofinality of `\u03bc`, then `\u03bc ^ \u03ba \u2264 \u03bc`.", "formal_statement": "example {\u03ba : Cardinal } {\u03bc : Cardinal } (h\u2081 : Cardinal.IsStrongLimit \u03bc) (h\u2082 : \u03ba < Ordinal.cof (Cardinal.ord \u03bc)) :\u03bc ^ \u03ba \u2264 \u03bc := by sorry", "full_tactic_state": "\u03ba \u03bc : Cardinal.{?u.5}\nh\u2081 : Cardinal.IsStrongLimit \u03bc\nh\u2082 : \u03ba < Ordinal.cof (Cardinal.ord \u03bc)\n\u22a2 \u03bc ^ \u03ba \u2264 \u03bc", "dependency": [28, 28, 37, 38, 27]}, "ConNF.mk_enumeration": {"natural_language_statement": "The theorem `ConNF.mk_enumeration` states that if the cardinality of a type `\u03b1` is equal to the cardinality of `\u03bc`, then the number of `\u03b1`-enumerations, which are functions from an initial segment of `\u03ba` to `\u03b1`, is also equal to the cardinality of `\u03bc`.", "formal_statement": "@[simp]example [ConNF.Params ] {\u03b1 : Type u} (mk_\u03b1 : Cardinal.mk \u03b1 = Cardinal.mk ConNF.\u03bc) :Cardinal.mk (ConNF.Enumeration \u03b1) = Cardinal.mk ConNF.\u03bc := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03b1 : Type u\nmk_\u03b1 : Cardinal.mk \u03b1 = Cardinal.mk ConNF.\u03bc\n\u22a2 Cardinal.mk (ConNF.Enumeration \u03b1) = Cardinal.mk ConNF.\u03bc", "dependency": [1, 29, 29, 29, 59, 29]}, "ConNF.Enumeration.image_max": {"natural_language_statement": "The function `ConNF.Enumeration.image` transforms an `\u03b1`-enumeration `E` into a `\u03b2`-enumeration by applying a function `f : \u03b1 \u2192 \u03b2` to each element in the range of `E`. The maximum value of the resulting `\u03b2`-enumeration is equal to the maximum value of the original `\u03b1`-enumeration.", "formal_statement": "@[simp]example [ConNF.Params ] {\u03b1 : Type u_1} {\u03b2 : Type u_2} (E : ConNF.Enumeration \u03b1) (f : \u03b1 \u2192 \u03b2) :(ConNF.Enumeration.image E f).max = E.max := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nE : ConNF.Enumeration \u03b1\nf : \u03b1 \u2192 \u03b2\n\u22a2 (ConNF.Enumeration.image E f).max = E.max", "dependency": [1, 59, 244]}, "ConNF.Enumeration.image_f": {"natural_language_statement": "The function `ConNF.Enumeration.image` transforms an `\u03b1`-enumeration `E` into a `\u03b2`-enumeration by applying a function `f : \u03b1 \u2192 \u03b2` to each element in the range of `E`. The theorem `ConNF.Enumeration.image_f` states that for any `\u03b1`-enumeration `E`, any function `f : \u03b1 \u2192 \u03b2`, and any `i < E.max`, the `i`-th element of the `\u03b2`-enumeration `ConNF.Enumeration.image E f` is equal to `f` applied to the `i`-th element of `E`.", "formal_statement": "@[simp]example [ConNF.Params ] {\u03b1 : Type u_1} {\u03b2 : Type u_2} (E : ConNF.Enumeration \u03b1) (f : \u03b1 \u2192 \u03b2) (i : ConNF.\u03ba) (hi : i < E.max) :(ConNF.Enumeration.image E f).f i hi = f (E.f i hi) := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nE : ConNF.Enumeration \u03b1\nf : \u03b1 \u2192 \u03b2\ni : ConNF.\u03ba\nhi : i < E.max\n\u22a2 (ConNF.Enumeration.image E f).f i hi = f (E.f i hi)", "dependency": [1, 59, 244]}, "ConNF.Enumeration.image_carrier": {"natural_language_statement": "Function `ConNF.Enumeration.image_carrier` states that the carrier set of the image of an `\u03b1`-enumeration `E` under a function `f : \u03b1 \u2192 \u03b2` is equal to the image of the carrier set of `E` under `f`.", "formal_statement": "@[simp]example [ConNF.Params ] {\u03b1 : Type u_1} {\u03b2 : Type u_2} (E : ConNF.Enumeration \u03b1) (f : \u03b1 \u2192 \u03b2) :ConNF.Enumeration.carrier (ConNF.Enumeration.image E f) = f '' ConNF.Enumeration.carrier E := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nE : ConNF.Enumeration \u03b1\nf : \u03b1 \u2192 \u03b2\n\u22a2 ConNF.Enumeration.carrier (ConNF.Enumeration.image E f) = f '' ConNF.Enumeration.carrier E", "dependency": [1, 59, 70, 244, 70]}, "ConNF.Enumeration.image_coe": {"natural_language_statement": "The theorem `ConNF.Enumeration.image_coe` states that the carrier set of the image of an `\u03b1`-enumeration `E` under a function `f : \u03b1 \u2192 \u03b2` is equal to the image of the carrier set of `E` under `f`.", "formal_statement": "@[simp]example [ConNF.Params ] {\u03b1 : Type u_1} {\u03b2 : Type u_2} (E : ConNF.Enumeration \u03b1) (f : \u03b1 \u2192 \u03b2) :ConNF.Enumeration.carrier (ConNF.Enumeration.image E f) = f '' ConNF.Enumeration.carrier E := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nE : ConNF.Enumeration \u03b1\nf : \u03b1 \u2192 \u03b2\n\u22a2 ConNF.Enumeration.carrier (ConNF.Enumeration.image E f) = f '' ConNF.Enumeration.carrier E", "dependency": [1, 59, 70, 244, 70]}, "ConNF.Enumeration.apply_mem_image": {"natural_language_statement": "The theorem `ConNF.Enumeration.apply_mem_image` states that if `x` is an element of an `\u03b1`-enumeration `E` and `f` is a function from `\u03b1` to `\u03b2`, then `f x` is an element of the `\u03b2`-enumeration obtained by applying `f` to each element in the range of `E`.", "formal_statement": "example [ConNF.Params ] {\u03b1 : Type u_1} {\u03b2 : Type u_2} {E : ConNF.Enumeration \u03b1} {x : \u03b1} (h : x \u2208 E) (f : \u03b1 \u2192 \u03b2) :f x \u2208 ConNF.Enumeration.image E f := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nE : ConNF.Enumeration \u03b1\nx : \u03b1\nh : x \u2208 E\nf : \u03b1 \u2192 \u03b2\n\u22a2 f x \u2208 ConNF.Enumeration.image E f", "dependency": [1, 59, 244]}, "ConNF.Enumeration.apply_eq_of_image_eq": {"natural_language_statement": "Given an `\u03b1`-enumeration `E` and a function `f : \u03b1 \u2192 \u03b1`, if the image of `E` under `f` is equal to `E`, and `x` is an element of `E`, then `f x = x`.", "formal_statement": "example [ConNF.Params ] {\u03b1 : Type u_1} {E : ConNF.Enumeration \u03b1} (f : \u03b1 \u2192 \u03b1) (hE : ConNF.Enumeration.image E f = E) {x : \u03b1} (hx : x \u2208 E) :f x = x := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03b1 : Type u_1\nE : ConNF.Enumeration \u03b1\nf : \u03b1 \u2192 \u03b1\nhE : ConNF.Enumeration.image E f = E\nx : \u03b1\nhx : x \u2208 E\n\u22a2 f x = x", "dependency": [1, 59, 244]}, "ConNF.Enumeration.smul_max": {"natural_language_statement": "The theorem `ConNF.Enumeration.smul_max` states that for an enumeration `E` of type `\u03b1` and a scalar `g` of type `G`, the maximum value of the enumeration `g \u2022 E` is equal to the maximum value of the original enumeration `E`.", "formal_statement": "@[simp]example [ConNF.Params ] {\u03b1 : Type u_2} {G : Type u_1} [SMul G \u03b1] (g : G) (E : ConNF.Enumeration \u03b1) :(g \u2022 E).max = E.max := by sorry", "full_tactic_state": "inst\u271d\u00b9 : ConNF.Params\n\u03b1 : Type u_2\nG : Type u_1\ninst\u271d : SMul G \u03b1\ng : G\nE : ConNF.Enumeration \u03b1\n\u22a2 (g \u2022 E).max = E.max", "dependency": [1, 57, 59]}, "ConNF.Enumeration.smul_f": {"natural_language_statement": "The theorem `ConNF.Enumeration.smul_f` states that for an `\u03b1`-enumeration `E` and an element `g` of a group `G` that acts on `\u03b1`, the `i`-th element of the enumeration `g \u2022 E` is equal to `g` acting on the `i`-th element of `E`.", "formal_statement": "@[simp]example [ConNF.Params ] {\u03b1 : Type u_2} {G : Type u_1} [SMul G \u03b1] (g : G) (E : ConNF.Enumeration \u03b1) (i : ConNF.\u03ba) (hi : i < E.max) :(g \u2022 E).f i hi = g \u2022 E.f i hi := by sorry", "full_tactic_state": "inst\u271d\u00b9 : ConNF.Params\n\u03b1 : Type u_2\nG : Type u_1\ninst\u271d : SMul G \u03b1\ng : G\nE : ConNF.Enumeration \u03b1\ni : ConNF.\u03ba\nhi : i < E.max\n\u22a2 (g \u2022 E).f i hi = g \u2022 E.f i hi", "dependency": [1, 57, 59]}, "ConNF.Enumeration.smul_mem_smul": {"natural_language_statement": "The theorem `ConNF.Enumeration.smul_mem_smul` is a member of the `ConNF.Enumeration` class in Lean 4. The `ConNF Params` class defines a set of parameters that are used in the context of Constructive Ordinal Notation (ConNF) for constructing natural numbers. The `SMul` class represents the concept of scalar multiplication, and an `\u03b1`-enumeration is a function from an initial segment of `\u03ba` to `\u03b1`. This theorem states that if `x` is a member of the enumeration `E` and `g` is an element of a group `G` that acts on `\u03b1`, then `g \u2022 x` is a member of `g \u2022 E`.", "formal_statement": "example [ConNF.Params ] {\u03b1 : Type u_2} {G : Type u_1} [SMul G \u03b1] {E : ConNF.Enumeration \u03b1} {x : \u03b1} (h : x \u2208 E) (g : G) :g \u2022 x \u2208 g \u2022 E := by sorry", "full_tactic_state": "inst\u271d\u00b9 : ConNF.Params\n\u03b1 : Type u_2\nG : Type u_1\ninst\u271d : SMul G \u03b1\nE : ConNF.Enumeration \u03b1\nx : \u03b1\nh : x \u2208 E\ng : G\n\u22a2 g \u2022 x \u2208 g \u2022 E", "dependency": [1, 57, 59]}, "ConNF.Enumeration.smul_eq_of_smul_eq": {"natural_language_statement": "The theorem `ConNF.Enumeration.smul_eq_of_smul_eq` states that if `E` is an `\u03b1`-enumeration and `g \u2022 E = E`, then for any `x` in the range of `E`, `g \u2022 x = x`.", "formal_statement": "example [ConNF.Params ] {\u03b1 : Type u_2} {G : Type u_1} [SMul G \u03b1] {g : G} {E : ConNF.Enumeration \u03b1} (hE : g \u2022 E = E) {x : \u03b1} (hx : x \u2208 E) :g \u2022 x = x := by sorry", "full_tactic_state": "inst\u271d\u00b9 : ConNF.Params\n\u03b1 : Type u_2\nG : Type u_1\ninst\u271d : SMul G \u03b1\ng : G\nE : ConNF.Enumeration \u03b1\nhE : g \u2022 E = E\nx : \u03b1\nhx : x \u2208 E\n\u22a2 g \u2022 x = x", "dependency": [1, 57, 59]}, "ConNF.Enumeration.add_max": {"natural_language_statement": "Function `ConNF.Enumeration.add_max` states that the maximum value of the sum of two enumerations `E` and `F` is equal to the sum of their maximum values.", "formal_statement": "@[simp]example [ConNF.Params ] {\u03b1 : Type u_1} {E : ConNF.Enumeration \u03b1} {F : ConNF.Enumeration \u03b1} :(E + F).max = E.max + F.max := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03b1 : Type u_1\nE F : ConNF.Enumeration \u03b1\n\u22a2 (E + F).max = E.max + F.max", "dependency": [1, 59, 59]}, "ConNF.Enumeration.add_coe": {"natural_language_statement": "The theorem `ConNF.Enumeration.add_coe` states that the carrier set of the sum of two `\u03b1`-enumerations `E` and `F` is the union of the carrier sets of `E` and `F`.", "formal_statement": "example [ConNF.Params ] {\u03b1 : Type u_1} (E : ConNF.Enumeration \u03b1) (F : ConNF.Enumeration \u03b1) :ConNF.Enumeration.carrier (E + F) = ConNF.Enumeration.carrier E \u222a ConNF.Enumeration.carrier F := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03b1 : Type u_1\nE F : ConNF.Enumeration \u03b1\n\u22a2 ConNF.Enumeration.carrier (E + F) = ConNF.Enumeration.carrier E \u222a ConNF.Enumeration.carrier F", "dependency": [1, 59, 59, 70, 70, 70]}, "ConNF.Enumeration.mem_add_iff": {"natural_language_statement": "In the context of Constructive Ordinal Notation (ConNF), an `\u03b1`-enumeration is a function from an initial segment of `\u03ba` to `\u03b1`. The theorem `ConNF.Enumeration.mem_add_iff` states that for two `\u03b1`-enumerations `E` and `F`, an element `x` is in the sum of `E` and `F` if and only if `x` is in `E` or `x` is in `F`.", "formal_statement": "@[simp]example [ConNF.Params ] {\u03b1 : Type u_1} (E : ConNF.Enumeration \u03b1) (F : ConNF.Enumeration \u03b1) (x : \u03b1) :x \u2208 E + F \u2194 x \u2208 E \u2228 x \u2208 F := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03b1 : Type u_1\nE F : ConNF.Enumeration \u03b1\nx : \u03b1\n\u22a2 x \u2208 E + F \u2194 x \u2208 E \u2228 x \u2208 F", "dependency": [1, 59, 59]}, "ConNF.Enumeration.smul_add": {"natural_language_statement": "In the context of Constructive Ordinal Notation (ConNF), an `\u03b1`-enumeration is a function from an initial segment of `\u03ba` to `\u03b1`. Given two `\u03b1`-enumerations `E` and `F`, and a scalar `g`, the theorem `smul_add` states that the scalar multiplication of the sum of `E` and `F` by `g` is equal to the sum of the scalar multiplication of `E` by `g` and the scalar multiplication of `F` by `g`.", "formal_statement": "@[simp]example [ConNF.Params ] {\u03b1 : Type u_2} {G : Type u_1} [SMul G \u03b1] {g : G} (E : ConNF.Enumeration \u03b1) (F : ConNF.Enumeration \u03b1) :g \u2022 (E + F) = g \u2022 E + g \u2022 F := by sorry", "full_tactic_state": "inst\u271d\u00b9 : ConNF.Params\n\u03b1 : Type u_2\nG : Type u_1\ninst\u271d : SMul G \u03b1\ng : G\nE F : ConNF.Enumeration \u03b1\n\u22a2 g \u2022 (E + F) = g \u2022 E + g \u2022 F", "dependency": [1, 57, 59, 59]}, "ConNF.Enumeration.le_iff": {"natural_language_statement": "In the context of Constructive Ordinal Notation (ConNF), an `\u03b1`-enumeration is a function from an initial segment of `\u03ba` to `\u03b1`. The theorem `ConNF.Enumeration.le_iff` states that for two `\u03b1`-enumerations `E` and `F`, `E \u2264 F` if and only if `E.max \u2264 F.max` and for all `i < E.max` and `i < F.max`, `E.f i = F.f i`.", "formal_statement": "example [ConNF.Params ] {\u03b1 : Type u_1} (E : ConNF.Enumeration \u03b1) (F : ConNF.Enumeration \u03b1) :E \u2264 F \u2194 E.max \u2264 F.max \u2227 \u2200 (i : ConNF.\u03ba) (hE : i < E.max) (hF : i < F.max), E.f i hE = F.f i hF := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03b1 : Type u_1\nE F : ConNF.Enumeration \u03b1\n\u22a2 E \u2264 F \u2194 E.max \u2264 F.max \u2227 \u2200 (i : ConNF.\u03ba) (hE : i < E.max) (hF : i < F.max), E.f i hE = F.f i hF", "dependency": [1, 59, 59]}, "ConNF.Enumeration.lt_iff": {"natural_language_statement": "In the context of Constructive Ordinal Notation (ConNF), an `\u03b1`-enumeration is a function from an initial segment of `\u03ba` to `\u03b1`. Given two `\u03b1`-enumerations `E` and `F`, `E < F` if and only if `E.max < F.max` and for all `i` less than both `E.max` and `F.max`, `E.f i = F.f i`.", "formal_statement": "example [ConNF.Params ] {\u03b1 : Type u_1} (E : ConNF.Enumeration \u03b1) (F : ConNF.Enumeration \u03b1) :E < F \u2194 E.max < F.max \u2227 \u2200 (i : ConNF.\u03ba) (hE : i < E.max) (hF : i < F.max), E.f i hE = F.f i hF := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03b1 : Type u_1\nE F : ConNF.Enumeration \u03b1\n\u22a2 E < F \u2194 E.max < F.max \u2227 \u2200 (i : ConNF.\u03ba) (hE : i < E.max) (hF : i < F.max), E.f i hE = F.f i hF", "dependency": [1, 59, 59]}, "ConNF.Enumeration.image_le_image": {"natural_language_statement": "Function `ConNF.Enumeration.image` transforms an `\u03b1`-enumeration `E` into a `\u03b2`-enumeration by applying a function `f : \u03b1 \u2192 \u03b2` to each element in the range of `E`. The theorem `ConNF.Enumeration.image_le_image` states that if an `\u03b1`-enumeration `E` is less than or equal to another `\u03b1`-enumeration `F`, then the `\u03b2`-enumeration obtained by applying `f` to `E` is also less than or equal to the `\u03b2`-enumeration obtained by applying `f` to `F`.", "formal_statement": "example [ConNF.Params ] {\u03b1 : Type u_1} {\u03b2 : Type u_2} {E : ConNF.Enumeration \u03b1} {F : ConNF.Enumeration \u03b1} (h : E \u2264 F) (f : \u03b1 \u2192 \u03b2) :ConNF.Enumeration.image E f \u2264 ConNF.Enumeration.image F f := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nE F : ConNF.Enumeration \u03b1\nh : E \u2264 F\nf : \u03b1 \u2192 \u03b2\n\u22a2 ConNF.Enumeration.image E f \u2264 ConNF.Enumeration.image F f", "dependency": [1, 59, 59, 244, 244]}, "ConNF.Enumeration.smul_le_smul": {"natural_language_statement": "The theorem `ConNF.Enumeration.smul_le_smul` states that if `E` and `F` are `\u03b1`-enumerations and `E \u2264 F`, then for any scalar `g`, the scalar multiplication of `E` by `g` is less than or equal to the scalar multiplication of `F` by `g`.", "formal_statement": "example [ConNF.Params ] {\u03b1 : Type u_2} {G : Type u_1} [SMul G \u03b1] {E : ConNF.Enumeration \u03b1} {F : ConNF.Enumeration \u03b1} (h : E \u2264 F) (g : G) :g \u2022 E \u2264 g \u2022 F := by sorry", "full_tactic_state": "inst\u271d\u00b9 : ConNF.Params\n\u03b1 : Type u_2\nG : Type u_1\ninst\u271d : SMul G \u03b1\nE F : ConNF.Enumeration \u03b1\nh : E \u2264 F\ng : G\n\u22a2 g \u2022 E \u2264 g \u2022 F", "dependency": [1, 57, 59, 59]}, "ConNF.Enumeration.le_add": {"natural_language_statement": "The theorem `ConNF.Enumeration.le_add` states that for any two `\u03b1`-enumerations `E` and `F`, the enumeration `E` is less than or equal to the sum of `E` and `F`.", "formal_statement": "example [ConNF.Params ] {\u03b1 : Type u_1} (E : ConNF.Enumeration \u03b1) (F : ConNF.Enumeration \u03b1) :E \u2264 E + F := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03b1 : Type u_1\nE F : ConNF.Enumeration \u03b1\n\u22a2 E \u2264 E + F", "dependency": [1, 59, 59]}, "ConNF.Enumeration.ord_lt_of_small": {"natural_language_statement": "The theorem states that, given a set `s` that is strictly smaller than the cardinality of `ConNF.\u03ba` (the type that represents the ordinal numbers in Constructive Ordinal Notation), and `s` is endowed with a linear order and a well-order, the ordinal number corresponding to this well-ordered set is strictly less than the ordinal type of `ConNF.\u03ba`. This theorem is crucial for establishing the well-ordered structure of the natural numbers within the ConNF framework.", "formal_statement": "example [ConNF.Params ] {\u03b1 : Type u} {s : Set \u03b1} (hs : ConNF.Small s) [LinearOrder \u2191s] [IsWellOrder \u2191s fun (x x_1 : \u2191s) => x < x_1] :(Ordinal.type fun (x x_1 : \u2191s) => x < x_1) < Ordinal.type fun (x x_1 : ConNF.\u03ba) => x < x_1 := by sorry", "full_tactic_state": "inst\u271d\u00b2 : ConNF.Params\n\u03b1 : Type u\ns : Set \u03b1\nhs : ConNF.Small s\ninst\u271d\u00b9 : LinearOrder \u2191s\ninst\u271d : IsWellOrder \u2191s fun x x_1 => x < x_1\n\u22a2 (Ordinal.type fun x x_1 => x < x_1) < Ordinal.type fun x x_1 => x < x_1", "dependency": [1, 69, 233, 2, 15, 26, 26]}, "ConNF.Enumeration.ofSet'_coe": {"natural_language_statement": "Function `ConNF.Enumeration.ofSet'` constructs an `\u03b1`-enumeration from a given set `s` of elements of type `\u03b1`, provided that `s` is small (i.e., its cardinality is strictly less than the cardinality of the type `ConNF.\u03ba` in the context of Constructive Ordinal Notation (ConNF)), and that `s` is linearly ordered and well-ordered. The `\u03b1`-enumeration is represented by a function that maps an initial segment of `ConNF.\u03ba` to `\u03b1`. The theorem `ConNF.Enumeration.ofSet'_coe` states that the carrier set of the `\u03b1`-enumeration constructed by `ConNF.Enumeration.ofSet'` is equal to the original set `s`.", "formal_statement": "@[simp]example [ConNF.Params ] {\u03b1 : Type u} (s : Set \u03b1) (hs : ConNF.Small s) [LinearOrder \u2191s] [IsWellOrder \u2191s fun (x x_1 : \u2191s) => x < x_1] :ConNF.Enumeration.carrier (ConNF.Enumeration.ofSet' s hs) = s := by sorry", "full_tactic_state": "inst\u271d\u00b2 : ConNF.Params\n\u03b1 : Type u\ns : Set \u03b1\nhs : ConNF.Small s\ninst\u271d\u00b9 : LinearOrder \u2191s\ninst\u271d : IsWellOrder \u2191s fun x x_1 => x < x_1\n\u22a2 ConNF.Enumeration.carrier (ConNF.Enumeration.ofSet' s hs) = s", "dependency": [1, 69, 233, 2, 15, 70, 265]}, "ConNF.Enumeration.ofSet_coe": {"natural_language_statement": "The theorem `ConNF.Enumeration.ofSet_coe` states that for any set `s` whose cardinality is strictly less than the cardinality of `ConNF.\u03ba`, the carrier set of the `\u03b1`-enumeration `ConNF.Enumeration.ofSet s hs` is equal to `s`.", "formal_statement": "@[simp]example [ConNF.Params ] {\u03b1 : Type u} (s : Set \u03b1) (hs : ConNF.Small s) :ConNF.Enumeration.carrier (ConNF.Enumeration.ofSet s hs) = s := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03b1 : Type u\ns : Set \u03b1\nhs : ConNF.Small s\n\u22a2 ConNF.Enumeration.carrier (ConNF.Enumeration.ofSet s hs) = s", "dependency": [1, 69, 233, 70, 267]}, "ConNF.Enumeration.mem_ofSet_iff": {"natural_language_statement": "The theorem `ConNF.Enumeration.mem_ofSet_iff` states that for any set `s` whose cardinality is strictly less than the cardinality of `ConNF.\u03ba`, and any element `x` of type `\u03b1`, `x` belongs to the enumeration of `s` if and only if `x` belongs to `s`.", "formal_statement": "@[simp]example [ConNF.Params ] {\u03b1 : Type u} (s : Set \u03b1) (hs : ConNF.Small s) (x : \u03b1) :x \u2208 ConNF.Enumeration.ofSet s hs \u2194 x \u2208 s := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03b1 : Type u\ns : Set \u03b1\nhs : ConNF.Small s\nx : \u03b1\n\u22a2 x \u2208 ConNF.Enumeration.ofSet s hs \u2194 x \u2208 s", "dependency": [1, 69, 233, 267]}, "ConNF.Enumeration.chooseIndex_lt": {"natural_language_statement": "Function `ConNF.Enumeration.chooseIndex` takes an enumeration `E` of type `\u03b1`, a predicate `p` on `\u03b1`, and a proof `h` that there exists an index `i < E.max` such that `p (E.f i h)`. It returns the smallest such index `i`. The theorem `ConNF.Enumeration.chooseIndex_lt` proves that this index `i` is indeed less than `E.max`.", "formal_statement": "example [ConNF.Params ] {\u03b1 : Type u_1} {E : ConNF.Enumeration \u03b1} {p : \u03b1 \u2192 Prop } (h : \u2203 (i : ConNF.\u03ba) (h : i < E.max), p (E.f i h)) :ConNF.Enumeration.chooseIndex E p h < E.max := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03b1 : Type u_1\nE : ConNF.Enumeration \u03b1\np : \u03b1 \u2192 Prop\nh : \u2203 i, \u2203 (h : i < E.max), p (E.f i h)\n\u22a2 ConNF.Enumeration.chooseIndex E p h < E.max", "dependency": [1, 59, 270]}, "ConNF.le_of_path": {"natural_language_statement": "The theorem `ConNF.le_of_path` states that if there is a path between two types `\u03b1` and `\u03b2` in the context of Constructive Ordinal Notation (ConNF), then `\u03b2` must be less than or equal to `\u03b1`. The case where `\u03b2 = \u03b1` can occur with the nil path.", "formal_statement": "example [ConNF.Params ] {\u03b1 : ConNF.TypeIndex} {\u03b2 : ConNF.TypeIndex} :Quiver.Path \u03b1 \u03b2 \u2192 \u03b2 \u2264 \u03b1 := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03b1 \u03b2 : ConNF.TypeIndex\n\u22a2 Quiver.Path \u03b1 \u03b2 \u2192 \u03b2 \u2264 \u03b1", "dependency": [1, 76]}, "ConNF.path_eq_nil": {"natural_language_statement": "The theorem `ConNF.path_eq_nil` states that in the context of Constructive Ordinal Notation (ConNF), the only path from a vertex to itself is the trivial path.", "formal_statement": "example [ConNF.Params ] {\u03b1 : ConNF.TypeIndex} (p : Quiver.Path \u03b1 \u03b1) :p = Quiver.Path.nil := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03b1 : ConNF.TypeIndex\np : Quiver.Path \u03b1 \u03b1\n\u22a2 p = Quiver.Path.nil", "dependency": [1, 76]}, "ConNF.ExtendedIndex.length_ne_zero": {"natural_language_statement": "Function `ConNF.ExtendedIndex` defines a finite path from a type `\u03b1` to the base type `\u22a5` in the context of Constructive Ordinal Notation (ConNF). This path represents a way to understand extensionality by iteratively descending to lower types in the hierarchy until reaching the base type. Since `\u039b` is well-ordered, there are no infinite descending paths. Function `Quiver.Path.length` calculates the length of a path in a quiver, which is defined as the number of arrows in the path. For a trivial path (`nil`), the length is 0, and for a path extended by an arrow (`cons`), the length is the length of the previous path plus 1. The theorem `ConNF.ExtendedIndex.length_ne_zero` states that the length of any non-trivial `ConNF.ExtendedIndex` path is not zero.", "formal_statement": "example [ConNF.Params ] {\u03b1 : ConNF.\u039b} (A : ConNF.ExtendedIndex \u2191\u03b1) :Quiver.Path.length A \u2260 0 := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03b1 : ConNF.\u039b\nA : ConNF.ExtendedIndex \u2191\u03b1\n\u22a2 Quiver.Path.length A \u2260 0", "dependency": [1, 61, 137]}, "ConNF.mk_extendedIndex": {"natural_language_statement": "Function `ConNF.mk_extendedIndex` proves that the cardinality of the set of `\u03b1`-extended type indices is less than or equal to the cardinality of `\u039b`.", "formal_statement": "@[simp]example [ConNF.Params ] (\u03b1 : ConNF.TypeIndex) :Cardinal.mk (ConNF.ExtendedIndex \u03b1) \u2264 Cardinal.mk ConNF.\u039b := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03b1 : ConNF.TypeIndex\n\u22a2 Cardinal.mk (ConNF.ExtendedIndex \u03b1) \u2264 Cardinal.mk ConNF.\u039b", "dependency": [1, 29, 61, 29]}, "ConNF.mk_extendedIndex_ne_zero": {"natural_language_statement": "There exists an `\u03b1` -extended type index.", "formal_statement": "example [ConNF.Params ] (\u03b1 : ConNF.TypeIndex) :Cardinal.mk (ConNF.ExtendedIndex \u03b1) \u2260 0 := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03b1 : ConNF.TypeIndex\n\u22a2 Cardinal.mk (ConNF.ExtendedIndex \u03b1) \u2260 0", "dependency": [1, 29, 61]}, "ConNF.Pretangle.toBot_symm": {"natural_language_statement": "The theorem `ConNF.Pretangle.toBot_symm` states that the inverse of the function `ConNF.Pretangle.toBot` is equal to the function `ConNF.Pretangle.ofBot` in the context of Constructive Ordinal Notation (ConNF).", "formal_statement": "@[simp]example [ConNF.Params ] :ConNF.Pretangle.toBot.symm = ConNF.Pretangle.ofBot := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u22a2 ConNF.Pretangle.toBot.symm = ConNF.Pretangle.ofBot", "dependency": [1]}, "ConNF.Pretangle.ofBot_symm": {"natural_language_statement": "The theorem `ConNF.Pretangle.ofBot_symm` states that the inverse of the function `ConNF.Pretangle.ofBot` is equal to `ConNF.Pretangle.toBot` in the context of Constructive Ordinal Notation (ConNF).", "formal_statement": "@[simp]example [ConNF.Params ] :ConNF.Pretangle.ofBot.symm = ConNF.Pretangle.toBot := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u22a2 ConNF.Pretangle.ofBot.symm = ConNF.Pretangle.toBot", "dependency": [1]}, "ConNF.Pretangle.toBot_ofBot": {"natural_language_statement": "The theorem `ConNF.Pretangle.toBot_ofBot` states that for any pretangle `a` in the context of Constructive Ordinal Notation (ConNF), the operation `ConNF.Pretangle.ofBot` followed by `ConNF.Pretangle.toBot` returns the original pretangle `a`.", "formal_statement": "@[simp]example [ConNF.Params ] (a : ConNF.Pretangle \u22a5 ) :ConNF.Pretangle.toBot (ConNF.Pretangle.ofBot a) = a := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\na : ConNF.Pretangle \u22a5\n\u22a2 ConNF.Pretangle.toBot (ConNF.Pretangle.ofBot a) = a", "dependency": [1, 279]}, "ConNF.Pretangle.ofBot_toBot": {"natural_language_statement": "The theorem `ConNF.Pretangle.ofBot_toBot` states that for any `ConNF.Atom` `a`, converting `a` to a `ConNF.Pretangle` using `ConNF.Pretangle.toBot` and then back to an `ConNF.Atom` using `ConNF.Pretangle.ofBot` results in the original `ConNF.Atom` `a`.", "formal_statement": "@[simp]example [ConNF.Params ] (a : ConNF.Atom) :ConNF.Pretangle.ofBot (ConNF.Pretangle.toBot a) = a := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\na : ConNF.Atom\n\u22a2 ConNF.Pretangle.ofBot (ConNF.Pretangle.toBot a) = a", "dependency": [1]}, "ConNF.Pretangle.toCoe_ofCoe": {"natural_language_statement": "The theorem `ConNF.Pretangle.toCoe_ofCoe` states that the function `ConNF.Pretangle.toCoe` is the left inverse of the function `ConNF.Pretangle.ofCoe`. This means that applying `ConNF.Pretangle.ofCoe` to a pretangle and then applying `ConNF.Pretangle.toCoe` to the result will return the original pretangle.", "formal_statement": "@[simp]example [ConNF.Params ] {\u03b1 : ConNF.\u039b} (a : ConNF.Pretangle \u2191\u03b1) :ConNF.Pretangle.toCoe (ConNF.Pretangle.ofCoe a) = a := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03b1 : ConNF.\u039b\na : ConNF.Pretangle \u2191\u03b1\n\u22a2 ConNF.Pretangle.toCoe (ConNF.Pretangle.ofCoe a) = a", "dependency": [1, 279]}, "ConNF.Pretangle.ofCoe_toCoe": {"natural_language_statement": "The theorem `ConNF.Pretangle.ofCoe_toCoe` states that the function `ConNF.Pretangle.ofCoe` is the left inverse of the function `ConNF.Pretangle.toCoe`. This means that applying `ConNF.Pretangle.ofCoe` to the result of `ConNF.Pretangle.toCoe` returns the original argument.", "formal_statement": "@[simp]example [ConNF.Params ] {\u03b1 : ConNF.\u039b} (a : (\u03b2 : ConNF.TypeIndex) \u2192 \u03b2 < \u2191\u03b1 \u2192 Set (ConNF.Pretangle \u03b2)) :ConNF.Pretangle.ofCoe (ConNF.Pretangle.toCoe a) = a := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03b1 : ConNF.\u039b\na : (\u03b2 : ConNF.TypeIndex) \u2192 \u03b2 < \u2191\u03b1 \u2192 Set (ConNF.Pretangle \u03b2)\n\u22a2 ConNF.Pretangle.ofCoe (ConNF.Pretangle.toCoe a) = a", "dependency": [1, 69, 279]}, "ConNF.Pretangle.toBot_inj": {"natural_language_statement": "Function `ConNF.Pretangle.toBot_inj` is a theorem in Lean 4 that states the injectivity of the function `ConNF.Pretangle.toBot` in the context of Constructive Ordinal Notation (ConNF). It asserts that two `ConNF.Atom`s are equal if and only if their images under the function `ConNF.Pretangle.toBot` are equal.", "formal_statement": "@[simp]example [ConNF.Params ] {a : ConNF.Atom} {b : ConNF.Atom} :ConNF.Pretangle.toBot a = ConNF.Pretangle.toBot b \u2194 a = b := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\na b : ConNF.Atom\n\u22a2 ConNF.Pretangle.toBot a = ConNF.Pretangle.toBot b \u2194 a = b", "dependency": [1]}, "ConNF.Pretangle.ofBot_inj": {"natural_language_statement": "The theorem `ConNF.Pretangle.ofBot_inj` states that the function `ConNF.Pretangle.ofBot` is injective, meaning that it maps distinct pretangles to distinct tangles.", "formal_statement": "@[simp]example [ConNF.Params ] {a : ConNF.Pretangle \u22a5 } {b : ConNF.Pretangle \u22a5 } :ConNF.Pretangle.ofBot a = ConNF.Pretangle.ofBot b \u2194 a = b := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\na b : ConNF.Pretangle \u22a5\n\u22a2 ConNF.Pretangle.ofBot a = ConNF.Pretangle.ofBot b \u2194 a = b", "dependency": [1, 279, 279]}, "ConNF.Pretangle.toCoe_inj": {"natural_language_statement": "The theorem `ConNF.Pretangle.toCoe_inj` states that the function `ConNF.Pretangle.toCoe` is injective. This means that if two pretangles `a` and `b` have the same image under the function `ConNF.Pretangle.toCoe`, then `a` must be equal to `b`.", "formal_statement": "@[simp]example [ConNF.Params ] {\u03b1 : ConNF.\u039b} {a : (\u03b2 : ConNF.TypeIndex) \u2192 \u03b2 < \u2191\u03b1 \u2192 Set (ConNF.Pretangle \u03b2)} {b : (\u03b2 : ConNF.TypeIndex) \u2192 \u03b2 < \u2191\u03b1 \u2192 Set (ConNF.Pretangle \u03b2)} :ConNF.Pretangle.toCoe a = ConNF.Pretangle.toCoe b \u2194 a = b := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03b1 : ConNF.\u039b\na b : (\u03b2 : ConNF.TypeIndex) \u2192 \u03b2 < \u2191\u03b1 \u2192 Set (ConNF.Pretangle \u03b2)\n\u22a2 ConNF.Pretangle.toCoe a = ConNF.Pretangle.toCoe b \u2194 a = b", "dependency": [1, 69, 279, 69, 279]}, "ConNF.Pretangle.ofCoe_inj": {"natural_language_statement": "`ConNF.Pretangle.ofCoe_inj` is a theorem in Lean 4 that states the injectivity of the `ConNF.Pretangle.ofCoe` function in the context of Constructive Ordinal Notation (ConNF). This theorem asserts that two pretangles `a` and `b` are equal if and only if their images under the `ConNF.Pretangle.ofCoe` function are equal.", "formal_statement": "@[simp]example [ConNF.Params ] {\u03b1 : ConNF.\u039b} {a : ConNF.Pretangle \u2191\u03b1} {b : ConNF.Pretangle \u2191\u03b1} :ConNF.Pretangle.ofCoe a = ConNF.Pretangle.ofCoe b \u2194 a = b := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03b1 : ConNF.\u039b\na b : ConNF.Pretangle \u2191\u03b1\n\u22a2 ConNF.Pretangle.ofCoe a = ConNF.Pretangle.ofCoe b \u2194 a = b", "dependency": [1, 279, 279]}, "ConNF.Pretangle.coe_ext": {"natural_language_statement": "The theorem `ConNF.Pretangle.coe_ext` states that two pretangles are equal if and only if they have the same members at each type level, corresponding to restrictions of the pretangles to each type level. This theorem is crucial for proving the extensionality axiom in the context of Constructive Ordinal Notation.", "formal_statement": "example [ConNF.Params ] {\u03b1 : ConNF.\u039b} {a : ConNF.Pretangle \u2191\u03b1} {b : ConNF.Pretangle \u2191\u03b1} :a = b \u2194 \u2200 (\u03b2 : ConNF.TypeIndex) (h\u03b2 : \u03b2 < \u2191\u03b1) (t : ConNF.Pretangle \u03b2), t \u2208 ConNF.Pretangle.ofCoe a \u03b2 h\u03b2 \u2194 t \u2208 ConNF.Pretangle.ofCoe b \u03b2 h\u03b2 := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03b1 : ConNF.\u039b\na b : ConNF.Pretangle \u2191\u03b1\n\u22a2 a = b \u2194\n    \u2200 (\u03b2 : ConNF.TypeIndex) (h\u03b2 : \u03b2 < \u2191\u03b1) (t : ConNF.Pretangle \u03b2),\n      t \u2208 ConNF.Pretangle.ofCoe a \u03b2 h\u03b2 \u2194 t \u2208 ConNF.Pretangle.ofCoe b \u03b2 h\u03b2", "dependency": [1, 279, 279, 279]}, "ConNF.Tree.toBot_ofBot": {"natural_language_statement": "In the context of Constructive Ordinal Notation (ConNF), the theorem `ConNF.Tree.toBot_ofBot` states that the function `ConNF.Tree.toBot`, which maps an `\u03b1`-tree of `\u03c4` to a `\u22a5`-tree of `\u03c4`, is the left inverse of the function `ConNF.Tree.ofBot`, which maps a `\u22a5`-tree of `\u03c4` to an `\u03b1`-tree of `\u03c4`.", "formal_statement": "@[simp]example [ConNF.Params ] {\u03c4 : Type u} (a : ConNF.Tree \u03c4 \u22a5 ) :ConNF.Tree.toBot (ConNF.Tree.ofBot a) = a := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03c4 : Type u\na : ConNF.Tree \u03c4 \u22a5\n\u22a2 ConNF.Tree.toBot (ConNF.Tree.ofBot a) = a", "dependency": [1, 289]}, "ConNF.Tree.ofBot_toBot": {"natural_language_statement": "The theorem `ConNF.Tree.ofBot_toBot` states that the function `ConNF.Tree.ofBot` is the left inverse of the function `ConNF.Tree.toBot`. This means that for any element `a` of type `\u03c4`, applying `ConNF.Tree.toBot` to `a` and then applying `ConNF.Tree.ofBot` to the result will return the original element `a`.", "formal_statement": "@[simp]example [ConNF.Params ] {\u03c4 : Type u} (a : \u03c4) :ConNF.Tree.ofBot (ConNF.Tree.toBot a) = a := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03c4 : Type u\na : \u03c4\n\u22a2 ConNF.Tree.ofBot (ConNF.Tree.toBot a) = a", "dependency": [1]}, "ConNF.Tree.toBot_inj": {"natural_language_statement": "`ConNF.Tree.toBot_inj` is a theorem in Lean 4 that states the injectivity of the function `ConNF.Tree.toBot` in the context of Constructive Ordinal Notation (ConNF). Specifically, it asserts that for any two elements `a` and `b` of the same type `\u03c4`, the equation `ConNF.Tree.toBot a = ConNF.Tree.toBot b` holds if and only if `a = b`.", "formal_statement": "@[simp]example [ConNF.Params ] {\u03c4 : Type u} {a : \u03c4} {b : \u03c4} :ConNF.Tree.toBot a = ConNF.Tree.toBot b \u2194 a = b := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03c4 : Type u\na b : \u03c4\n\u22a2 ConNF.Tree.toBot a = ConNF.Tree.toBot b \u2194 a = b", "dependency": [1]}, "ConNF.Tree.ofBot_inj": {"natural_language_statement": "In the context of Constructive Ordinal Notation (ConNF), an `\u03b1`-tree of `\u03c4` is defined as a function from `\u03b1`-extended type indices to `\u03c4`. This function maps each `\u03b1`-extended type index to a value of type `\u03c4`. The theorem `ConNF.Tree.ofBot_inj` states that for any two `\u22a5`-trees `a` and `b` of type `\u03c4`, the equation `ConNF.Tree.ofBot a = ConNF.Tree.ofBot b` holds if and only if `a = b`.", "formal_statement": "@[simp]example [ConNF.Params ] {\u03c4 : Type u} {a : ConNF.Tree \u03c4 \u22a5 } {b : ConNF.Tree \u03c4 \u22a5 } :ConNF.Tree.ofBot a = ConNF.Tree.ofBot b \u2194 a = b := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03c4 : Type u\na b : ConNF.Tree \u03c4 \u22a5\n\u22a2 ConNF.Tree.ofBot a = ConNF.Tree.ofBot b \u2194 a = b", "dependency": [1, 289, 289]}, "ConNF.Tree.ext": {"natural_language_statement": "Function `ConNF.Tree.ext` is an extensionality theorem for trees in the context of Constructive Ordinal Notation (ConNF). It states that if two trees `a` and `b` of type `\u03c4` and index `\u03b1` are equal at every extended index `A`, then the trees themselves are equal.", "formal_statement": "example [ConNF.Params ] {\u03c4 : Type u} {\u03b1 : ConNF.TypeIndex} (a : ConNF.Tree \u03c4 \u03b1) (b : ConNF.Tree \u03c4 \u03b1) (h : \u2200 (A : ConNF.ExtendedIndex \u03b1), a A = b A) :a = b := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03c4 : Type u\n\u03b1 : ConNF.TypeIndex\na b : ConNF.Tree \u03c4 \u03b1\nh : \u2200 (A : ConNF.ExtendedIndex \u03b1), a A = b A\n\u22a2 a = b", "dependency": [1, 289, 289, 61]}, "ConNF.Tree.mul_apply": {"natural_language_statement": "In the context of Constructive Ordinal Notation (ConNF), an `\u03b1`-tree of `\u03c4` is defined as a function from `\u03b1`-extended type indices to `\u03c4`. This function maps each `\u03b1`-extended type index to a value of type `\u03c4`. Given two `\u03b1`-trees `a` and `a'` of type `\u03c4`, and an `\u03b1`-extended type index `A`, the multiplication of `a` and `a'` at `A` is equal to the product of `a A` and `a' A`.", "formal_statement": "@[simp]example [ConNF.Params ] {\u03c4 : Type u} [Group \u03c4] {\u03b1 : ConNF.TypeIndex} (a : ConNF.Tree \u03c4 \u03b1) (a' : ConNF.Tree \u03c4 \u03b1) (A : ConNF.ExtendedIndex \u03b1) :(a * a') A = a A * a' A := by sorry", "full_tactic_state": "inst\u271d\u00b9 : ConNF.Params\n\u03c4 : Type u\ninst\u271d : Group \u03c4\n\u03b1 : ConNF.TypeIndex\na a' : ConNF.Tree \u03c4 \u03b1\nA : ConNF.ExtendedIndex \u03b1\n\u22a2 (a * a') A = a A * a' A", "dependency": [1, 40, 289, 289, 61]}, "ConNF.Tree.inv_apply": {"natural_language_statement": "In the context of Constructive Ordinal Notation (ConNF), the inverse of a `\u03c4`-tree `a` at an `\u03b1`-extended type index `A` is equal to the inverse of the value of `a` at `A`.", "formal_statement": "@[simp]example [ConNF.Params ] {\u03c4 : Type u} [Group \u03c4] {\u03b1 : ConNF.TypeIndex} (a : ConNF.Tree \u03c4 \u03b1) (A : ConNF.ExtendedIndex \u03b1) :a\u207b\u00b9 A = (a A)\u207b\u00b9 := by sorry", "full_tactic_state": "inst\u271d\u00b9 : ConNF.Params\n\u03c4 : Type u\ninst\u271d : Group \u03c4\n\u03b1 : ConNF.TypeIndex\na : ConNF.Tree \u03c4 \u03b1\nA : ConNF.ExtendedIndex \u03b1\n\u22a2 a\u207b\u00b9 A = (a A)\u207b\u00b9", "dependency": [1, 40, 289, 61]}, "ConNF.Tree.toBot_mul": {"natural_language_statement": "The theorem `ConNF.Tree.toBot_mul` states that in the context of Constructive Ordinal Notation (ConNF), the function `ConNF.Tree.toBot` applied to the product of two elements `a` and `a'` of a group `\u03c4` is equal to the product of `ConNF.Tree.toBot` applied to `a` and `ConNF.Tree.toBot` applied to `a'`.", "formal_statement": "@[simp]example [ConNF.Params ] {\u03c4 : Type u} [Group \u03c4] (a : \u03c4) (a' : \u03c4) :ConNF.Tree.toBot (a * a') = ConNF.Tree.toBot a * ConNF.Tree.toBot a' := by sorry", "full_tactic_state": "inst\u271d\u00b9 : ConNF.Params\n\u03c4 : Type u\ninst\u271d : Group \u03c4\na a' : \u03c4\n\u22a2 ConNF.Tree.toBot (a * a') = ConNF.Tree.toBot a * ConNF.Tree.toBot a'", "dependency": [1, 40]}, "ConNF.Tree.ofBot_mul": {"natural_language_statement": "In the context of Constructive Ordinal Notation (ConNF), an `\u03b1`-tree of `\u03c4` is defined as a function from `\u03b1`-extended type indices to `\u03c4`. This function maps each `\u03b1`-extended type index to a value of type `\u03c4`. Given two `\u22a5`-trees `a` and `a'` of type `\u03c4`, where `\u03c4` is a group, the theorem `ConNF.Tree.ofBot_mul` states that the `\u22a5`-tree of the product of `a` and `a'` is equal to the product of the `\u22a5`-trees of `a` and `a'`.", "formal_statement": "@[simp]example [ConNF.Params ] {\u03c4 : Type u} [Group \u03c4] (a : ConNF.Tree \u03c4 \u22a5 ) (a' : ConNF.Tree \u03c4 \u22a5 ) :ConNF.Tree.ofBot (a * a') = ConNF.Tree.ofBot a * ConNF.Tree.ofBot a' := by sorry", "full_tactic_state": "inst\u271d\u00b9 : ConNF.Params\n\u03c4 : Type u\ninst\u271d : Group \u03c4\na a' : ConNF.Tree \u03c4 \u22a5\n\u22a2 ConNF.Tree.ofBot (a * a') = ConNF.Tree.ofBot a * ConNF.Tree.ofBot a'", "dependency": [1, 40, 289, 289]}, "ConNF.Tree.toBot_inv": {"natural_language_statement": "The theorem `ConNF.Tree.toBot_inv` states that for any group element `a`, the inverse of `ConNF.Tree.toBot a` is equal to `ConNF.Tree.toBot` of the inverse of `a`.", "formal_statement": "@[simp]example [ConNF.Params ] {\u03c4 : Type u} [Group \u03c4] (a : \u03c4) :ConNF.Tree.toBot a\u207b\u00b9 = (ConNF.Tree.toBot a)\u207b\u00b9 := by sorry", "full_tactic_state": "inst\u271d\u00b9 : ConNF.Params\n\u03c4 : Type u\ninst\u271d : Group \u03c4\na : \u03c4\n\u22a2 ConNF.Tree.toBot a\u207b\u00b9 = (ConNF.Tree.toBot a)\u207b\u00b9", "dependency": [1, 40]}, "ConNF.Tree.ofBot_inv": {"natural_language_statement": "The theorem `ConNF.Tree.ofBot_inv` states that in the context of Constructive Ordinal Notation (ConNF), the inverse of an `\u03b1`-tree of `\u03c4` (where `\u03c4` is a group) evaluated at `\u22a5` is equal to the inverse of the `\u03b1`-tree evaluated at `\u22a5`.", "formal_statement": "@[simp]example [ConNF.Params ] {\u03c4 : Type u} [Group \u03c4] (a : ConNF.Tree \u03c4 \u22a5 ) :ConNF.Tree.ofBot a\u207b\u00b9 = (ConNF.Tree.ofBot a)\u207b\u00b9 := by sorry", "full_tactic_state": "inst\u271d\u00b9 : ConNF.Params\n\u03c4 : Type u\ninst\u271d : Group \u03c4\na : ConNF.Tree \u03c4 \u22a5\n\u22a2 ConNF.Tree.ofBot a\u207b\u00b9 = (ConNF.Tree.ofBot a)\u207b\u00b9", "dependency": [1, 40, 289]}, "Quiver.Hom.comp_toPath": {"natural_language_statement": "Function `Quiver.Hom.toPath` converts a single arrow in a quiver into a path of length one. Function `Quiver.Path.comp` composes two paths in a quiver. Given a path from vertex `a` to vertex `b` and a path from vertex `b` to vertex `c`, it returns a path from vertex `a` to vertex `c`. Function `Quiver.Path.cons` takes a path from `a` to `b` and an arrow from `b` to `c`, and returns a path from `a` to `c`. The theorem `Quiver.Hom.comp_toPath` states that the composition of a path `p` from `a` to `b` and an arrow `e` from `b` to `c` is equal to the path obtained by extending `p` with `e`.", "formal_statement": "@[simp]example {V : Type u_1} [Quiver V] {a : V} {b : V} {c : V} {p : Quiver.Path a b} {e : b \u27f6 c} :Quiver.Path.comp p (Quiver.Hom.toPath e) = Quiver.Path.cons p e := by sorry", "full_tactic_state": "V : Type u_1\ninst\u271d : Quiver V\na b c : V\np : Quiver.Path a b\ne : b \u27f6 c\n\u22a2 Quiver.Path.comp p (Quiver.Hom.toPath e) = Quiver.Path.cons p e", "dependency": [75, 76, 135, 74, 301]}, "Quiver.Hom.comp_toPath_comp": {"natural_language_statement": "Function `Quiver.Hom.comp_toPath_comp` states that for any path `p` from vertex `a` to vertex `b`, any arrow `e` from vertex `b` to vertex `c`, and any path `q` from vertex `c` to vertex `d`, the composition of `p` with the composition of `e` and `q` is equal to the composition of the path obtained by extending `p` with `e` and `q`.", "formal_statement": "@[simp]example {V : Type u_1} [Quiver V] {a : V} {b : V} {c : V} {d : V} {p : Quiver.Path a b} {e : b \u27f6 c} {q : Quiver.Path c d} :Quiver.Path.comp p (Quiver.Path.comp (Quiver.Hom.toPath e) q) = Quiver.Path.comp (Quiver.Path.cons p e) q := by sorry", "full_tactic_state": "V : Type u_1\ninst\u271d : Quiver V\na b c d : V\np : Quiver.Path a b\ne : b \u27f6 c\nq : Quiver.Path c d\n\u22a2 Quiver.Path.comp p (Quiver.Path.comp (Quiver.Hom.toPath e) q) = Quiver.Path.comp (Quiver.Path.cons p e) q", "dependency": [75, 76, 76, 135, 135, 74, 135, 301]}, "ConNF.Tree.comp_def": {"natural_language_statement": "Function `ConNF.Tree.comp` defines the derivative functor in the context of Constructive Ordinal Notation (ConNF). Given a path `A` from type index `\u03b1` to type index `\u03b2` and an `\u03b1`-tree `a` of type `\u03c4`, it returns a `\u03b2`-tree of type `\u03c4` by applying `a` to the composition of `A` with any `\u03b2`-extended type index `B`.", "formal_statement": "example [ConNF.Params ] {\u03c4 : Type u} {\u03b1 : ConNF.TypeIndex} {\u03b2 : ConNF.TypeIndex} (A : Quiver.Path \u03b1 \u03b2) (a : ConNF.Tree \u03c4 \u03b1) :ConNF.Tree.comp A a = fun (B : Quiver.Path \u03b2 \u22a5 ) => a (Quiver.Path.comp A B) := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03c4 : Type u\n\u03b1 \u03b2 : ConNF.TypeIndex\nA : Quiver.Path \u03b1 \u03b2\na : ConNF.Tree \u03c4 \u03b1\n\u22a2 ConNF.Tree.comp A a = fun B => a (Quiver.Path.comp A B)", "dependency": [1, 76, 289, 304, 76, 135]}, "ConNF.Tree.comp_apply": {"natural_language_statement": "Evaluating the derivative of a structural group element along a path is the same as evaluating the original element along the composition of the paths.", "formal_statement": "@[simp]example [ConNF.Params ] {\u03c4 : Type u} {\u03b1 : ConNF.TypeIndex} {\u03b2 : ConNF.TypeIndex} (a : ConNF.Tree \u03c4 \u03b1) (A : Quiver.Path \u03b1 \u03b2) (B : ConNF.ExtendedIndex \u03b2) :ConNF.Tree.comp A a B = a (Quiver.Path.comp A B) := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03c4 : Type u\n\u03b1 \u03b2 : ConNF.TypeIndex\na : ConNF.Tree \u03c4 \u03b1\nA : Quiver.Path \u03b1 \u03b2\nB : ConNF.ExtendedIndex \u03b2\n\u22a2 ConNF.Tree.comp A a B = a (Quiver.Path.comp A B)", "dependency": [1, 289, 76, 61, 304, 135]}, "ConNF.Tree.comp_nil": {"natural_language_statement": "Function `ConNF.Tree.comp` defines the derivative functor in the context of Constructive Ordinal Notation (ConNF). Given a path `A` from type index `\u03b1` to type index `\u03b2` and an `\u03b1`-tree `a` of type `\u03c4`, it returns a `\u03b2`-tree of type `\u03c4` by applying `a` to the composition of `A` with any `\u03b2`-extended type index `B`. The theorem `ConNF.Tree.comp_nil` states that the derivative along the empty path `Quiver.Path.nil` does nothing, meaning it returns the original tree `a`.", "formal_statement": "@[simp]example [ConNF.Params ] {\u03c4 : Type u} {\u03b1 : ConNF.TypeIndex} (a : ConNF.Tree \u03c4 \u03b1) :ConNF.Tree.comp Quiver.Path.nil a = a := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03c4 : Type u\n\u03b1 : ConNF.TypeIndex\na : ConNF.Tree \u03c4 \u03b1\n\u22a2 ConNF.Tree.comp Quiver.Path.nil a = a", "dependency": [1, 289, 304]}, "ConNF.Tree.comp_cons": {"natural_language_statement": "In the context of Constructive Ordinal Notation (ConNF), given an `\u03b1`-tree `a` of type `\u03c4`, a path `p` from `\u03b1` to `\u03b2`, and an arrow `h` from `\u03b2` to `\u03b3`, the derivative functor `ConNF.Tree.comp` applied to the composition of `p` and `h` is equal to the derivative functor applied to `h` followed by the derivative functor applied to `p` and `a`.", "formal_statement": "example [ConNF.Params ] {\u03c4 : Type u} {\u03b1 : ConNF.TypeIndex} {\u03b2 : ConNF.TypeIndex} (a : ConNF.Tree \u03c4 \u03b1) (p : Quiver.Path \u03b1 \u03b2) {\u03b3 : ConNF.TypeIndex} (h : \u03b3 < \u03b2) :ConNF.Tree.comp (Quiver.Path.cons p h) a = ConNF.Tree.comp (Quiver.Hom.toPath h) (ConNF.Tree.comp p a) := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03c4 : Type u\n\u03b1 \u03b2 : ConNF.TypeIndex\na : ConNF.Tree \u03c4 \u03b1\np : Quiver.Path \u03b1 \u03b2\n\u03b3 : ConNF.TypeIndex\nh : \u03b3 < \u03b2\n\u22a2 ConNF.Tree.comp (Quiver.Path.cons p h) a = ConNF.Tree.comp (Quiver.Hom.toPath h) (ConNF.Tree.comp p a)", "dependency": [1, 289, 76, 304, 301, 304, 74, 304]}, "ConNF.Tree.comp_comp": {"natural_language_statement": "The theorem `ConNF.Tree.comp_comp` establishes the functoriality of the derivative map in the context of Constructive Ordinal Notation (ConNF). It states that for any path `p` from type index `\u03b1` to type index `\u03b2`, and any path `q` from type index `\u03b2` to type index `\u03b3`, the composition of the derivative maps corresponding to `p` and `q` is equal to the derivative map corresponding to the composition of `p` and `q`.", "formal_statement": "example [ConNF.Params ] {\u03c4 : Type u} {\u03b1 : ConNF.TypeIndex} {\u03b2 : ConNF.TypeIndex} {\u03b3 : ConNF.TypeIndex} (a : ConNF.Tree \u03c4 \u03b1) (p : Quiver.Path \u03b1 \u03b2) (q : Quiver.Path \u03b2 \u03b3) :ConNF.Tree.comp q (ConNF.Tree.comp p a) = ConNF.Tree.comp (Quiver.Path.comp p q) a := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03c4 : Type u\n\u03b1 \u03b2 \u03b3 : ConNF.TypeIndex\na : ConNF.Tree \u03c4 \u03b1\np : Quiver.Path \u03b1 \u03b2\nq : Quiver.Path \u03b2 \u03b3\n\u22a2 ConNF.Tree.comp q (ConNF.Tree.comp p a) = ConNF.Tree.comp (Quiver.Path.comp p q) a", "dependency": [1, 289, 76, 76, 304, 304, 304, 135]}, "ConNF.Tree.comp_mul": {"natural_language_statement": "The theorem `ConNF.Tree.comp_mul` states that in the context of Constructive Ordinal Notation (ConNF), the derivative functor preserves multiplication. Specifically, given two trees `a\u2081` and `a\u2082` of the same type index `\u03b1` and a path `A` from `\u03b1` to another type index `\u03b2`, the derivative of the product `a\u2081 * a\u2082` along `A` is equal to the product of the derivatives of `a\u2081` and `a\u2082` along `A`.", "formal_statement": "example [ConNF.Params ] {\u03c4 : Type u} [Group \u03c4] {\u03b1 : ConNF.TypeIndex} {\u03b2 : ConNF.TypeIndex} (a\u2081 : ConNF.Tree \u03c4 \u03b1) (a\u2082 : ConNF.Tree \u03c4 \u03b1) (A : Quiver.Path \u03b1 \u03b2) :ConNF.Tree.comp A (a\u2081 * a\u2082) = ConNF.Tree.comp A a\u2081 * ConNF.Tree.comp A a\u2082 := by sorry", "full_tactic_state": "inst\u271d\u00b9 : ConNF.Params\n\u03c4 : Type u\ninst\u271d : Group \u03c4\n\u03b1 \u03b2 : ConNF.TypeIndex\na\u2081 a\u2082 : ConNF.Tree \u03c4 \u03b1\nA : Quiver.Path \u03b1 \u03b2\n\u22a2 ConNF.Tree.comp A (a\u2081 * a\u2082) = ConNF.Tree.comp A a\u2081 * ConNF.Tree.comp A a\u2082", "dependency": [1, 40, 289, 289, 76, 304, 304, 304]}, "ConNF.Tree.comp_inv": {"natural_language_statement": "The theorem `ConNF.Tree.comp_inv` states that in the context of Constructive Ordinal Notation (ConNF), the derivative map preserves inverses. Specifically, if `a` is an `\u03b1`-tree of type `\u03c4` and `A` is a path from type index `\u03b1` to type index `\u03b2`, then the inverse of the `\u03b2`-tree obtained by composing `a` with `A` is equal to the `\u03b2`-tree obtained by composing the inverse of `a` with `A`.", "formal_statement": "example [ConNF.Params ] {\u03c4 : Type u} [Group \u03c4] {\u03b1 : ConNF.TypeIndex} {\u03b2 : ConNF.TypeIndex} (a : ConNF.Tree \u03c4 \u03b1) (A : Quiver.Path \u03b1 \u03b2) :(ConNF.Tree.comp A a)\u207b\u00b9 = ConNF.Tree.comp A a\u207b\u00b9 := by sorry", "full_tactic_state": "inst\u271d\u00b9 : ConNF.Params\n\u03c4 : Type u\ninst\u271d : Group \u03c4\n\u03b1 \u03b2 : ConNF.TypeIndex\na : ConNF.Tree \u03c4 \u03b1\nA : Quiver.Path \u03b1 \u03b2\n\u22a2 (ConNF.Tree.comp A a)\u207b\u00b9 = ConNF.Tree.comp A a\u207b\u00b9", "dependency": [1, 40, 289, 76, 304, 304]}, "ConNF.Tree.comp_bot": {"natural_language_statement": "Function `ConNF.Tree.comp` defines the derivative functor in the context of Constructive Ordinal Notation (ConNF). Given a path `A` from type index `\u03b1` to type index `\u22a5` and an `\u03b1`-tree `a` of type `\u03c4`, it returns a `\u22a5`-tree of type `\u03c4` by applying `a` to the composition of `A` with any `\u22a5`-extended type index `B`.", "formal_statement": "@[simp]example [ConNF.Params ] {\u03c4 : Type u} {\u03b1 : ConNF.TypeIndex} (a : ConNF.Tree \u03c4 \u03b1) (A : Quiver.Path \u03b1 \u22a5 ) :ConNF.Tree.comp A a = ConNF.Tree.toBot (a A) := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03c4 : Type u\n\u03b1 : ConNF.TypeIndex\na : ConNF.Tree \u03c4 \u03b1\nA : Quiver.Path \u03b1 \u22a5\n\u22a2 ConNF.Tree.comp A a = ConNF.Tree.toBot (a A)", "dependency": [1, 289, 76, 304]}, "ConNF.Tree.toBot_smul": {"natural_language_statement": "Function `ConNF.Tree.toBot_smul` simplifies the expression `ConNF.Tree.toBot a \u2022 x` to `a \u2022 x`, where `a` is an element of a group `\u03c4` and `x` is an element of a type `X` with a multiplicative action of `\u03c4`.", "formal_statement": "@[simp]example [ConNF.Params ] {\u03c4 : Type u} [Group \u03c4] {X : Type u_1} [MulAction \u03c4 X] (a : \u03c4) (x : X) :ConNF.Tree.toBot a \u2022 x = a \u2022 x := by sorry", "full_tactic_state": "inst\u271d\u00b2 : ConNF.Params\n\u03c4 : Type u\ninst\u271d\u00b9 : Group \u03c4\nX : Type u_1\ninst\u271d : MulAction \u03c4 X\na : \u03c4\nx : X\n\u22a2 ConNF.Tree.toBot a \u2022 x = a \u2022 x", "dependency": [1, 40, 56]}, "ConNF.Tree.ofBot_smul": {"natural_language_statement": "`ConNF.Tree.ofBot_smul` is a theorem in Lean 4 that states that for a ConNF Params structure with a `\u03c4` which is a group and a `X` which is a type with a `\u03c4`-multiplication action, the `ConNF.Tree.ofBot` function applied to `a : ConNF.Tree \u03c4 \u22a5` and then multiplied by `x : X` yields the same result as `a \u2022 x`. In other words, the `ConNF.Tree.ofBot` function applied to an empty tree returns the tree itself when applied to a group action.", "formal_statement": "@[simp]example [ConNF.Params ] {\u03c4 : Type u} [Group \u03c4] {X : Type u_1} [MulAction \u03c4 X] (a : ConNF.Tree \u03c4 \u22a5 ) (x : X) :ConNF.Tree.ofBot a \u2022 x = a \u2022 x := by sorry", "full_tactic_state": "inst\u271d\u00b2 : ConNF.Params\n\u03c4 : Type u\ninst\u271d\u00b9 : Group \u03c4\nX : Type u_1\ninst\u271d : MulAction \u03c4 X\na : ConNF.Tree \u03c4 \u22a5\nx : X\n\u22a2 ConNF.Tree.ofBot a \u2022 x = a \u2022 x", "dependency": [1, 40, 56, 289]}, "ConNF.Tree.toBot_inv_smul": {"natural_language_statement": "The theorem `ConNF.Tree.toBot_inv_smul` states that for a group `\u03c4` acting on a type `X`, the inverse of the action of `ConNF.Tree.toBot a` on `x` is equal to the action of the inverse of `a` on `x`.", "formal_statement": "@[simp]example [ConNF.Params ] {\u03c4 : Type u} [Group \u03c4] {X : Type u_1} [MulAction \u03c4 X] (a : \u03c4) (x : X) :(ConNF.Tree.toBot a)\u207b\u00b9 \u2022 x = a\u207b\u00b9 \u2022 x := by sorry", "full_tactic_state": "inst\u271d\u00b2 : ConNF.Params\n\u03c4 : Type u\ninst\u271d\u00b9 : Group \u03c4\nX : Type u_1\ninst\u271d : MulAction \u03c4 X\na : \u03c4\nx : X\n\u22a2 (ConNF.Tree.toBot a)\u207b\u00b9 \u2022 x = a\u207b\u00b9 \u2022 x", "dependency": [1, 40, 56]}, "ConNF.Tree.ofBot_inv_smul": {"natural_language_statement": "The theorem `ConNF.Tree.ofBot_inv_smul` states that in the context of Constructive Ordinal Notation (ConNF), given a tree `a` of type `\u22a5` and an element `x` of a type `X` with a multiplicative action by a group `\u03c4`, the action of the inverse of the tree `a` on `x` is equal to the action of the inverse of `a` on `x`.", "formal_statement": "@[simp]example [ConNF.Params ] {\u03c4 : Type u} [Group \u03c4] {X : Type u_1} [MulAction \u03c4 X] (a : ConNF.Tree \u03c4 \u22a5 ) (x : X) :(ConNF.Tree.ofBot a)\u207b\u00b9 \u2022 x = a\u207b\u00b9 \u2022 x := by sorry", "full_tactic_state": "inst\u271d\u00b2 : ConNF.Params\n\u03c4 : Type u\ninst\u271d\u00b9 : Group \u03c4\nX : Type u_1\ninst\u271d : MulAction \u03c4 X\na : ConNF.Tree \u03c4 \u22a5\nx : X\n\u22a2 (ConNF.Tree.ofBot a)\u207b\u00b9 \u2022 x = a\u207b\u00b9 \u2022 x", "dependency": [1, 40, 56, 289]}, "ConNF.StructPerm.smul_nearLitter_fst": {"natural_language_statement": "In the context of Constructive Ordinal Notation (ConNF), a *structural permutation* on a proper type index `\u03b1` is a near-litter permutation for each `\u03b1`-extended index. This represents how the permutation acts along each path down the type levels in the model. The theorem `ConNF.StructPerm.smul_nearLitter_fst` states that when a structural permutation `\u03c0` acts on a near-litter `N`, the first component of the resulting near-litter is equal to `\u03c0` acting on the first component of `N`.", "formal_statement": "@[simp]example [ConNF.Params ] (\u03c0 : ConNF.StructPerm \u22a5 ) (N : ConNF.NearLitter) :(\u03c0 \u2022 N).fst = \u03c0 \u2022 N.fst := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03c0 : ConNF.StructPerm \u22a5\nN : ConNF.NearLitter\n\u22a2 (\u03c0 \u2022 N).fst = \u03c0 \u2022 N.fst", "dependency": [1, 55]}, "ConNF.StructPerm.smul_nearLitter_coe": {"natural_language_statement": "In the context of Constructive Ordinal Notation (ConNF), a *structural permutation* on a proper type index `\u03b1` is a near-litter permutation for each `\u03b1`-extended index. This represents how the permutation acts along each path down the type levels in the model. Note that we define structural permutations as trees of near-litter permutations. The theorem `ConNF.StructPerm.smul_nearLitter_coe` states that for a structural permutation `\u03c0` and a near-litter `N`, the action of `\u03c0` on `N` (denoted as `\u03c0 \u2022 N`) is equal to the action of `\u03c0` on the underlying set of `N` (denoted as `\u03c0 \u2022 \u2191N`).", "formal_statement": "example [ConNF.Params ] (\u03c0 : ConNF.StructPerm \u22a5 ) (N : ConNF.NearLitter) :\u2191(\u03c0 \u2022 N) = \u03c0 \u2022 \u2191N := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03c0 : ConNF.StructPerm \u22a5\nN : ConNF.NearLitter\n\u22a2 \u03c0 \u2022 N = \u03c0 \u2022 N", "dependency": [1, 55]}, "ConNF.StructPerm.comp_bot_smul_atom": {"natural_language_statement": "`ConNF.StructPerm.comp_bot_smul_atom` is a theorem in the context of Constructive Ordinal Notation (ConNF) in Lean 4. It states that for any structural permutation `\u03c0` on a proper type index `\u03b1`, any extended index `A` from `\u03b1` to the base type `\u22a5`, and any atom `a`, the derivative functor `ConNF.Tree.comp A \u03c0` applied to `a` is equal to `\u03c0 A` applied to `a`.", "formal_statement": "@[simp]example [ConNF.Params ] {\u03b1 : ConNF.TypeIndex} (\u03c0 : ConNF.StructPerm \u03b1) (A : ConNF.ExtendedIndex \u03b1) (a : ConNF.Atom) :ConNF.Tree.comp A \u03c0 \u2022 a = \u03c0 A \u2022 a := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03b1 : ConNF.TypeIndex\n\u03c0 : ConNF.StructPerm \u03b1\nA : ConNF.ExtendedIndex \u03b1\na : ConNF.Atom\n\u22a2 ConNF.Tree.comp A \u03c0 \u2022 a = \u03c0 A \u2022 a", "dependency": [1, 55, 61, 304]}, "ConNF.StructPerm.comp_bot_smul_litter": {"natural_language_statement": "The theorem `ConNF.StructPerm.comp_bot_smul_litter` states that for any structural permutation `\u03c0` on a proper type index `\u03b1`, any extended index `A` from `\u03b1` to the base type `\u22a5`, and any litter `L`, the derivative functor `ConNF.Tree.comp A \u03c0` applied to `L` is equal to `\u03c0 A` applied to `L`.", "formal_statement": "@[simp]example [ConNF.Params ] {\u03b1 : ConNF.TypeIndex} (\u03c0 : ConNF.StructPerm \u03b1) (A : ConNF.ExtendedIndex \u03b1) (L : ConNF.Litter) :ConNF.Tree.comp A \u03c0 \u2022 L = \u03c0 A \u2022 L := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03b1 : ConNF.TypeIndex\n\u03c0 : ConNF.StructPerm \u03b1\nA : ConNF.ExtendedIndex \u03b1\nL : ConNF.Litter\n\u22a2 ConNF.Tree.comp A \u03c0 \u2022 L = \u03c0 A \u2022 L", "dependency": [1, 55, 61, 304]}, "ConNF.StructPerm.comp_bot_smul_nearLitter": {"natural_language_statement": "The theorem `ConNF.StructPerm.comp_bot_smul_nearLitter` states that for any structural permutation `\u03c0` on a proper type index `\u03b1`, any extended index `A` from `\u03b1` to the base type `\u22a5`, and any near-litter permutation `N`, the derivative functor `ConNF.Tree.comp A \u03c0` applied to `N` is equal to `\u03c0 A` applied to `N`.", "formal_statement": "@[simp]example [ConNF.Params ] {\u03b1 : ConNF.TypeIndex} (\u03c0 : ConNF.StructPerm \u03b1) (A : ConNF.ExtendedIndex \u03b1) (N : ConNF.NearLitter) :ConNF.Tree.comp A \u03c0 \u2022 N = \u03c0 A \u2022 N := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03b1 : ConNF.TypeIndex\n\u03c0 : ConNF.StructPerm \u03b1\nA : ConNF.ExtendedIndex \u03b1\nN : ConNF.NearLitter\n\u22a2 ConNF.Tree.comp A \u03c0 \u2022 N = \u03c0 A \u2022 N", "dependency": [1, 55, 61, 304]}, "ConNF.StructPerm.one_pretangleAction": {"natural_language_statement": "The theorem `ConNF.StructPerm.one_pretangleAction` states that the action of the identity permutation on a pretangle in the context of Constructive Ordinal Notation (ConNF) results in the same pretangle.", "formal_statement": "example [ConNF.Params ] {\u03b1 : ConNF.TypeIndex} (t : ConNF.Pretangle \u03b1) :ConNF.StructPerm.pretangleAction 1 t = t := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03b1 : ConNF.TypeIndex\nt : ConNF.Pretangle \u03b1\n\u22a2 ConNF.StructPerm.pretangleAction 1 t = t", "dependency": [1, 279, 322]}, "ConNF.StructPerm.mul_pretangleAction": {"natural_language_statement": "The theorem `ConNF.StructPerm.mul_pretangleAction` states that the action of the product of two structural permutations on a pretangle is equal to the action of the first permutation on the action of the second permutation on the pretangle.", "formal_statement": "example [ConNF.Params ] {\u03b1 : ConNF.TypeIndex} (\u03c0\u2081 : ConNF.StructPerm \u03b1) (\u03c0\u2082 : ConNF.StructPerm \u03b1) (t : ConNF.Pretangle \u03b1) :ConNF.StructPerm.pretangleAction (\u03c0\u2081 * \u03c0\u2082) t = ConNF.StructPerm.pretangleAction \u03c0\u2081 (ConNF.StructPerm.pretangleAction \u03c0\u2082 t) := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03b1 : ConNF.TypeIndex\n\u03c0\u2081 \u03c0\u2082 : ConNF.StructPerm \u03b1\nt : ConNF.Pretangle \u03b1\n\u22a2 ConNF.StructPerm.pretangleAction (\u03c0\u2081 * \u03c0\u2082) t =\n    ConNF.StructPerm.pretangleAction \u03c0\u2081 (ConNF.StructPerm.pretangleAction \u03c0\u2082 t)", "dependency": [1, 55, 55, 279, 322, 322, 322]}, "ConNF.StructPerm.smul_eq": {"natural_language_statement": "The theorem `ConNF.StructPerm.smul_eq` states that the action of a *structural permutation* on a *pretangle* in the context of Constructive Ordinal Notation (ConNF) is equivalent to the specific function `ConNF.StructPerm.pretangleAction`. This theorem is crucial for establishing the equivalence between the actions of *structural permutations* and the model of the theory of types without extensionality.", "formal_statement": "example [ConNF.Params ] {\u03b1 : ConNF.TypeIndex} (\u03c0 : ConNF.StructPerm \u03b1) (t : ConNF.Pretangle \u03b1) :\u03c0 \u2022 t = ConNF.StructPerm.pretangleAction \u03c0 t := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03b1 : ConNF.TypeIndex\n\u03c0 : ConNF.StructPerm \u03b1\nt : ConNF.Pretangle \u03b1\n\u22a2 \u03c0 \u2022 t = ConNF.StructPerm.pretangleAction \u03c0 t", "dependency": [1, 55, 279, 322]}, "ConNF.Address.ext_iff": {"natural_language_statement": "The theorem `ConNF.Address.ext_iff` states that two `ConNF.Address` objects are equal if and only if their paths and values are equal.", "formal_statement": "example :\u2200 {inst : ConNF.Params } {\u03b1 : ConNF.TypeIndex} (x y : ConNF.Address \u03b1), x = y \u2194 x.path = y.path \u2227 x.value = y.value := by sorry", "full_tactic_state": "\u22a2 \u2200 {inst : ConNF.Params} {\u03b1 : ConNF.TypeIndex} (x y : ConNF.Address \u03b1), x = y \u2194 x.path = y.path \u2227 x.value = y.value", "dependency": [1, 60]}, "ConNF.Address.ext": {"natural_language_statement": "The theorem `ConNF.Address.ext` states that two `ConNF.Address` objects are equal if and only if their `path` and `value` components are equal. This is a property of extensionality for the `ConNF.Address` structure.", "formal_statement": "example :\u2200 {inst : ConNF.Params } {\u03b1 : ConNF.TypeIndex} (x y : ConNF.Address \u03b1), x.path = y.path \u2192 x.value = y.value \u2192 x = y := by sorry", "full_tactic_state": "\u22a2 \u2200 {inst : ConNF.Params} {\u03b1 : ConNF.TypeIndex} (x y : ConNF.Address \u03b1), x.path = y.path \u2192 x.value = y.value \u2192 x = y", "dependency": [1, 60]}, "ConNF.mk_address": {"natural_language_statement": "In the context of Constructive Ordinal Notation (ConNF), the theorem `ConNF.mk_address` states that the cardinality of the set of addresses for a given type `\u03b1` is equal to the cardinality of the type `\u03bc`. This means that there are as many addresses as there are elements in the type `\u03bc`.", "formal_statement": "@[simp]example [ConNF.Params ] (\u03b1 : ConNF.TypeIndex) :Cardinal.mk (ConNF.Address \u03b1) = Cardinal.mk ConNF.\u03bc := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03b1 : ConNF.TypeIndex\n\u22a2 Cardinal.mk (ConNF.Address \u03b1) = Cardinal.mk ConNF.\u03bc", "dependency": [1, 29, 60, 29]}, "ConNF.StructPerm.smul_address": {"natural_language_statement": "Function `ConNF.StructPerm.smul_address` defines the action of a *structural permutation* on an *address* in the context of Constructive Ordinal Notation (ConNF). A *structural permutation* on a proper type index `\u03b1` is a near-litter permutation for each `\u03b1`-extended index, representing how the permutation acts along each path down the type levels in the model. An *address* represents an object in the base type (the atom or near-litter) together with the path detailing how we descend from type `\u03b1` to type `\u22a5` by looking at elements of elements and so on in the model.", "formal_statement": "example [ConNF.Params ] {\u03b1 : ConNF.TypeIndex} {\u03c0 : ConNF.StructPerm \u03b1} {c : ConNF.Address \u03b1} :\u03c0 \u2022 c = { path := c.path, value := \u03c0 c.path \u2022 c.value } := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03b1 : ConNF.TypeIndex\n\u03c0 : ConNF.StructPerm \u03b1\nc : ConNF.Address \u03b1\n\u22a2 \u03c0 \u2022 c = { path := c.path, value := \u03c0 c.path \u2022 c.value }", "dependency": [1, 55, 60]}, "ConNF.StructPerm.smul_address_eq_iff": {"natural_language_statement": "In the context of Constructive Ordinal Notation (ConNF), a *structural permutation* on a proper type index `\u03b1` is a near-litter permutation for each `\u03b1`-extended index. This represents how the permutation acts along each path down the type levels in the model. Note that we define structural permutations as trees of near-litter permutations. Structure `ConNF.Address` represents an object in the base type (the atom or near-litter) together with the path detailing how we descend from type `\u03b1` to type `\u22a5` by looking at elements of elements and so on in the model. The theorem `ConNF.StructPerm.smul_address_eq_iff` states that for a structural permutation `\u03c0` on a proper type index `\u03b1` and an address `c` of type `\u03b1`, `\u03c0 \u2022 c = c` if and only if `\u03c0 c.path \u2022 c.value = c.value`.", "formal_statement": "@[simp]example [ConNF.Params ] {\u03b1 : ConNF.TypeIndex} {\u03c0 : ConNF.StructPerm \u03b1} {c : ConNF.Address \u03b1} :\u03c0 \u2022 c = c \u2194 \u03c0 c.path \u2022 c.value = c.value := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03b1 : ConNF.TypeIndex\n\u03c0 : ConNF.StructPerm \u03b1\nc : ConNF.Address \u03b1\n\u22a2 \u03c0 \u2022 c = c \u2194 \u03c0 c.path \u2022 c.value = c.value", "dependency": [1, 55, 60]}, "ConNF.StructPerm.smul_address_eq_smul_iff": {"natural_language_statement": "The theorem `ConNF.StructPerm.smul_address_eq_smul_iff` states that for any two structural permutations `\u03c0` and `\u03c0'` of the same type index `\u03b1`, and any address `c` of type `\u03b1`, the equation `\u03c0 \u2022 c = \u03c0' \u2022 c` holds if and only if `\u03c0 c.path \u2022 c.value = \u03c0' c.path \u2022 c.value`, where `c.path` and `c.value` are the path and value components of the address `c`, respectively.", "formal_statement": "@[simp]example [ConNF.Params ] {\u03b1 : ConNF.TypeIndex} {\u03c0 : ConNF.StructPerm \u03b1} {\u03c0' : ConNF.StructPerm \u03b1} {c : ConNF.Address \u03b1} :\u03c0 \u2022 c = \u03c0' \u2022 c \u2194 \u03c0 c.path \u2022 c.value = \u03c0' c.path \u2022 c.value := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03b1 : ConNF.TypeIndex\n\u03c0 \u03c0' : ConNF.StructPerm \u03b1\nc : ConNF.Address \u03b1\n\u22a2 \u03c0 \u2022 c = \u03c0' \u2022 c \u2194 \u03c0 c.path \u2022 c.value = \u03c0' c.path \u2022 c.value", "dependency": [1, 55, 55, 60]}, "ConNF.NearLitterPerm.smul_address": {"natural_language_statement": "The theorem `ConNF.NearLitterPerm.smul_address` states that for any near-litter permutation `\u03c0` and an address `c` in the base type `\u22a5`, the action of `\u03c0` on `c` results in a new address with the same path as `c` but with the value component transformed by `\u03c0`.", "formal_statement": "example [ConNF.Params ] {\u03c0 : ConNF.NearLitterPerm} {c : ConNF.Address \u22a5 } :\u03c0 \u2022 c = { path := c.path, value := \u03c0 \u2022 c.value } := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03c0 : ConNF.NearLitterPerm\nc : ConNF.Address \u22a5\n\u22a2 \u03c0 \u2022 c = { path := c.path, value := \u03c0 \u2022 c.value }", "dependency": [1, 60]}, "ConNF.NearLitterPerm.smul_address_eq_iff": {"natural_language_statement": "The theorem `ConNF.NearLitterPerm.smul_address_eq_iff` states that for a near-litter permutation `\u03c0` and an address `c`, the action of `\u03c0` on `c` is equal to `c` if and only if the action of `\u03c0` on the value of `c` is equal to the value of `c`.", "formal_statement": "@[simp]example [ConNF.Params ] {\u03c0 : ConNF.NearLitterPerm} {c : ConNF.Address \u22a5 } :\u03c0 \u2022 c = c \u2194 \u03c0 \u2022 c.value = c.value := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03c0 : ConNF.NearLitterPerm\nc : ConNF.Address \u22a5\n\u22a2 \u03c0 \u2022 c = c \u2194 \u03c0 \u2022 c.value = c.value", "dependency": [1, 60]}, "ConNF.NearLitterPerm.smul_address_eq_smul_iff": {"natural_language_statement": "The theorem `ConNF.NearLitterPerm.smul_address_eq_smul_iff` states that for two near-litter permutations `\u03c0` and `\u03c0'` and an address `c`, the equation `\u03c0 \u2022 c = \u03c0' \u2022 c` holds if and only if `\u03c0 \u2022 c.value = \u03c0' \u2022 c.value`, where `c.value` is the value of the address `c`.", "formal_statement": "@[simp]example [ConNF.Params ] {\u03c0 : ConNF.NearLitterPerm} {\u03c0' : ConNF.NearLitterPerm} {c : ConNF.Address \u22a5 } :\u03c0 \u2022 c = \u03c0' \u2022 c \u2194 \u03c0 \u2022 c.value = \u03c0' \u2022 c.value := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03c0 \u03c0' : ConNF.NearLitterPerm\nc : ConNF.Address \u22a5\n\u22a2 \u03c0 \u2022 c = \u03c0' \u2022 c \u2194 \u03c0 \u2022 c.value = \u03c0' \u2022 c.value", "dependency": [1, 60]}, "ConNF.Support.ext_iff": {"natural_language_statement": "Structure `ConNF.Support` represents a function from an initial segment of `\u03ba` to the type of addresses in the context of Constructive Ordinal Notation (ConNF). It ensures that for any two near-litters `N\u2081` and `N\u2082` that are near the same litter, any atoms in their symmetric difference are included in the enumeration. The theorem `ConNF.Support.ext_iff` states that two instances of `ConNF.Support` are equal if and only if their enumerations are equal.", "formal_statement": "example :\u2200 {inst : ConNF.Params } {\u03b1 : ConNF.TypeIndex} (x y : ConNF.Support \u03b1), x = y \u2194 x.enum = y.enum := by sorry", "full_tactic_state": "\u22a2 \u2200 {inst : ConNF.Params} {\u03b1 : ConNF.TypeIndex} (x y : ConNF.Support \u03b1), x = y \u2194 x.enum = y.enum", "dependency": [1, 58]}, "ConNF.Support.ext": {"natural_language_statement": "Function `ConNF.Support.ext` is an extensionality theorem for the `ConNF.Support` structure in the context of Constructive Ordinal Notation (ConNF). It states that if two `ConNF.Support` structures have the same enumeration, then they are equal.", "formal_statement": "example :\u2200 {inst : ConNF.Params } {\u03b1 : ConNF.TypeIndex} (x y : ConNF.Support \u03b1), x.enum = y.enum \u2192 x = y := by sorry", "full_tactic_state": "\u22a2 \u2200 {inst : ConNF.Params} {\u03b1 : ConNF.TypeIndex} (x y : ConNF.Support \u03b1), x.enum = y.enum \u2192 x = y", "dependency": [1, 58]}, "ConNF.Support.small": {"natural_language_statement": "In the context of Constructive Ordinal Notation (ConNF), a `ConNF.Support` structure represents a function from an initial segment of `\u03ba` to the type of addresses, ensuring that for any two near-litters `N\u2081` and `N\u2082` that are near the same litter, any atoms in their symmetric difference are included in the enumeration. The theorem `ConNF.Support.small` asserts that the cardinality of the carrier set of an `\u03b1`-enumeration `E`, which consists of all elements `c` of type `\u03b1` that can be expressed as `E.f i h` for some `i < E.max`, is strictly less than the cardinality of the type `ConNF.\u03ba`.", "formal_statement": "example [ConNF.Params ] {\u03b1 : ConNF.TypeIndex} (S : ConNF.Support \u03b1) :ConNF.Small (ConNF.Enumeration.carrier S.enum) := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03b1 : ConNF.TypeIndex\nS : ConNF.Support \u03b1\n\u22a2 ConNF.Small (ConNF.Enumeration.carrier S.enum)", "dependency": [1, 58, 233, 70]}, "ConNF.Support.mem_iff": {"natural_language_statement": "The theorem `ConNF.Support.mem_iff` states that an element `c` of type `ConNF.Address \u03b1` is a member of a `ConNF.Support` structure `S` if and only if there exists an element `i` of type `ConNF.\u03ba` that is less than the maximum element of `S`, and `c` is equal to the function `ConNF.Support.f` applied to `S`, `i`, and a proof that `i` is less than the maximum element of `S`.", "formal_statement": "example [ConNF.Params ] {\u03b1 : ConNF.TypeIndex} (c : ConNF.Address \u03b1) (S : ConNF.Support \u03b1) :c \u2208 S \u2194 \u2203 (i : ConNF.\u03ba) (h : i < ConNF.Support.max S), c = ConNF.Support.f S i h := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03b1 : ConNF.TypeIndex\nc : ConNF.Address \u03b1\nS : ConNF.Support \u03b1\n\u22a2 c \u2208 S \u2194 \u2203 i, \u2203 (h : i < ConNF.Support.max S), c = ConNF.Support.f S i h", "dependency": [1, 60, 58, 338, 339]}, "ConNF.Support.smul_max": {"natural_language_statement": "The theorem `ConNF.Support.smul_max` states that the maximum element of a `ConNF.Support` structure, which represents a function from an initial segment of `\u03ba` to the type of addresses in the context of Constructive Ordinal Notation (ConNF), is invariant under the action of a structural permutation.", "formal_statement": "@[simp]example [ConNF.Params ] {\u03b1 : ConNF.TypeIndex} (\u03c0 : ConNF.StructPerm \u03b1) (S : ConNF.Support \u03b1) :ConNF.Support.max (\u03c0 \u2022 S) = ConNF.Support.max S := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03b1 : ConNF.TypeIndex\n\u03c0 : ConNF.StructPerm \u03b1\nS : ConNF.Support \u03b1\n\u22a2 ConNF.Support.max (\u03c0 \u2022 S) = ConNF.Support.max S", "dependency": [1, 55, 58, 338, 338]}, "ConNF.Support.smul_f": {"natural_language_statement": "In the context of Constructive Ordinal Notation (ConNF), the function `ConNF.Support.f` takes a `ConNF.Support` structure `S`, an element `i` of type `ConNF.\u03ba`, and a proof that `i` is less than the maximum element of `S`. It returns an element of type `ConNF.Address \u03b1`, which represents an object in the base type (the atom or near-litter) together with the path detailing how we descend from type `\u03b1` to type `\u22a5` by looking at elements of elements and so on in the model. The theorem `ConNF.Support.smul_f` states that applying a structural permutation `\u03c0` to a `ConNF.Support` structure `S` and then applying `ConNF.Support.f` to the result is equivalent to first applying `ConNF.Support.f` to `S` and then applying the permutation `\u03c0` to the result.", "formal_statement": "@[simp]example [ConNF.Params ] {\u03b1 : ConNF.TypeIndex} (\u03c0 : ConNF.StructPerm \u03b1) (S : ConNF.Support \u03b1) (i : ConNF.\u03ba) (hi : i < ConNF.Support.max S) :ConNF.Support.f (\u03c0 \u2022 S) i hi = \u03c0 \u2022 ConNF.Support.f S i hi := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03b1 : ConNF.TypeIndex\n\u03c0 : ConNF.StructPerm \u03b1\nS : ConNF.Support \u03b1\ni : ConNF.\u03ba\nhi : i < ConNF.Support.max S\n\u22a2 ConNF.Support.f (\u03c0 \u2022 S) i hi = \u03c0 \u2022 ConNF.Support.f S i hi", "dependency": [1, 55, 58, 338, 339, 339]}, "ConNF.Support.smul_mem_smul": {"natural_language_statement": "The theorem `ConNF.Support.smul_mem_smul` states that for any initial segment `\u03b1` of the type `\u03ba`, any support function `S` defined on `\u03b1`, any address `c` that is in the support of `S`, and any structural permutation `\u03c0`, the address `\u03c0 \u2022 c` is also in the support of the support function `\u03c0 \u2022 S`. This is a crucial result in the proof of the main theorem of Constructive Ordinal Notation (ConNF), which states that the natural numbers are well-ordered.", "formal_statement": "example [ConNF.Params ] {\u03b1 : ConNF.TypeIndex} {S : ConNF.Support \u03b1} {c : ConNF.Address \u03b1} (h : c \u2208 S) (\u03c0 : ConNF.StructPerm \u03b1) :\u03c0 \u2022 c \u2208 \u03c0 \u2022 S := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03b1 : ConNF.TypeIndex\nS : ConNF.Support \u03b1\nc : ConNF.Address \u03b1\nh : c \u2208 S\n\u03c0 : ConNF.StructPerm \u03b1\n\u22a2 \u03c0 \u2022 c \u2208 \u03c0 \u2022 S", "dependency": [1, 58, 60, 55]}, "ConNF.Support.smul_eq_of_smul_eq": {"natural_language_statement": "The theorem `ConNF.Support.smul_eq_of_smul_eq` states that if a structural permutation `\u03c0` leaves a support `S` invariant (i.e., `\u03c0 \u2022 S = S`), then `\u03c0` also leaves any address `c` in `S` invariant (i.e., `\u03c0 \u2022 c = c`).", "formal_statement": "example [ConNF.Params ] {\u03b1 : ConNF.TypeIndex} {S : ConNF.Support \u03b1} {\u03c0 : ConNF.StructPerm \u03b1} (hS : \u03c0 \u2022 S = S) {c : ConNF.Address \u03b1} (hc : c \u2208 S) :\u03c0 \u2022 c = c := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03b1 : ConNF.TypeIndex\nS : ConNF.Support \u03b1\n\u03c0 : ConNF.StructPerm \u03b1\nhS : \u03c0 \u2022 S = S\nc : ConNF.Address \u03b1\nhc : c \u2208 S\n\u22a2 \u03c0 \u2022 c = c", "dependency": [1, 58, 55, 60]}, "ConNF.Support.singleton_enum": {"natural_language_statement": "Function `ConNF.Support.singleton` is a constructor for the `ConNF.Support` structure, which represents a function from an initial segment of `\u03ba` to the type of addresses in the context of Constructive Ordinal Notation (ConNF). It ensures that for any two near-litters `N\u2081` and `N\u2082` that are near the same litter, any atoms in their symmetric difference are included in the enumeration. Given an address `c` of type `ConNF.Address \u03b1`, `ConNF.Support.singleton c` returns a `ConNF.Support \u03b1` structure where the enumeration `enum` is defined as `\u27e81, fun _ _ => c\u27e9`, meaning it maps all elements of `\u03ba` less than `1` to the address `c`.", "formal_statement": "@[simp]example [ConNF.Params ] {\u03b1 : ConNF.TypeIndex} (c : ConNF.Address \u03b1) :(ConNF.Support.singleton c).enum = { max := 1, f := fun (x : ConNF.\u03ba) (x : x < 1) => c } := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03b1 : ConNF.TypeIndex\nc : ConNF.Address \u03b1\n\u22a2 (ConNF.Support.singleton c).enum = { max := 1, f := fun x x => c }", "dependency": [1, 60, 345]}, "ConNF.Support.mem_singleton_iff": {"natural_language_statement": "The theorem `ConNF.Support.mem_singleton_iff` states that for any two addresses `c` and `d` of the same type `\u03b1` in the context of Constructive Ordinal Notation (ConNF), `c` is an element of the singleton support structure `ConNF.Support.singleton d` if and only if `c` is equal to `d`.", "formal_statement": "@[simp]example [ConNF.Params ] {\u03b1 : ConNF.TypeIndex} (c : ConNF.Address \u03b1) (d : ConNF.Address \u03b1) :c \u2208 ConNF.Support.singleton d \u2194 c = d := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03b1 : ConNF.TypeIndex\nc d : ConNF.Address \u03b1\n\u22a2 c \u2208 ConNF.Support.singleton d \u2194 c = d", "dependency": [1, 60, 60, 345]}, "ConNF.mk_support": {"natural_language_statement": "The theorem `ConNF.mk_support` states that the cardinality of the set of supports for a given type index `\u03b1` in the context of Constructive Ordinal Notation (ConNF) is equal to the cardinality of the type `\u03bc`. This means that there are exactly as many supports as there are elements in the type `\u03bc`.", "formal_statement": "@[simp]example [ConNF.Params ] {\u03b1 : ConNF.TypeIndex} :Cardinal.mk (ConNF.Support \u03b1) = Cardinal.mk ConNF.\u03bc := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03b1 : ConNF.TypeIndex\n\u22a2 Cardinal.mk (ConNF.Support \u03b1) = Cardinal.mk ConNF.\u03bc", "dependency": [1, 29, 58, 29]}, "ConNF.Support.IsCompletion.smul": {"natural_language_statement": "The theorem `ConNF.Support.IsCompletion.smul` states that if `S` is a completion of an enumeration of addresses `E`, and `\u03c0` is a structural permutation, then `\u03c0 \u2022 S` is a completion of `\u03c0 \u2022 E`.", "formal_statement": "example [ConNF.Params ] {\u03b1 : ConNF.TypeIndex} {S : ConNF.Support \u03b1} {E : ConNF.Enumeration (ConNF.Address \u03b1)} (h : ConNF.Support.IsCompletion S E) (\u03c0 : ConNF.StructPerm \u03b1) :ConNF.Support.IsCompletion (\u03c0 \u2022 S) (\u03c0 \u2022 E) := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03b1 : ConNF.TypeIndex\nS : ConNF.Support \u03b1\nE : ConNF.Enumeration (ConNF.Address \u03b1)\nh : ConNF.Support.IsCompletion S E\n\u03c0 : ConNF.StructPerm \u03b1\n\u22a2 ConNF.Support.IsCompletion (\u03c0 \u2022 S) (\u03c0 \u2022 E)", "dependency": [1, 58, 59, 60, 349, 55, 349]}, "ConNF.nearLitter_not_mem_completionToAdd": {"natural_language_statement": "The theorem `ConNF.nearLitter_not_mem_completionToAdd` states that a near-litter address does not belong to the completion of a set `s` of addresses. This is part of the construction of the natural numbers in the context of Constructive Ordinal Notation (ConNF). The completion of a set `s` is the set of addresses that need to be added to `s` to make it a \"support\" in the ConNF model. A \"support\" is a set of addresses that satisfies certain properties related to the structure of the ConNF model. The theorem shows that near-litter addresses are not added to the completion of a set `s` to make it a support, which is a key step in the proof of the natural number representation in ConNF.", "formal_statement": "example [ConNF.Params ] {\u03b1 : ConNF.TypeIndex} (A : ConNF.ExtendedIndex \u03b1) (N : ConNF.NearLitter) (s : Set (ConNF.Address \u03b1)) :{ path := A, value := Sum.inr N } \u2209 ConNF.completionToAdd s := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03b1 : ConNF.TypeIndex\nA : ConNF.ExtendedIndex \u03b1\nN : ConNF.NearLitter\ns : Set (ConNF.Address \u03b1)\n\u22a2 { path := A, value := Sum.inr N } \u2209 ConNF.completionToAdd s", "dependency": [1, 61, 69, 60, 65, 351]}, "ConNF.completionToAdd'_small": {"natural_language_statement": "In the context of Constructive Ordinal Notation (ConNF), the function `ConNF.completionToAdd'` is used to define the addition operation on natural numbers. This function takes a set `s` of `ConNF.Address` objects and an `ConNF.ExtendedIndex` object `A`, and returns a set of `ConNF.Atom` objects. The theorem `ConNF.completionToAdd'_small` states that if the set `s` is small (i.e., its cardinality is strictly less than the cardinality of the type `ConNF.\u03ba`), then the set returned by `ConNF.completionToAdd'` is also small.", "formal_statement": "example [ConNF.Params ] {\u03b1 : ConNF.TypeIndex} (s : Set (ConNF.Address \u03b1)) (hs : ConNF.Small s) (A : ConNF.ExtendedIndex \u03b1) :ConNF.Small (ConNF.completionToAdd' s A) := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03b1 : ConNF.TypeIndex\ns : Set (ConNF.Address \u03b1)\nhs : ConNF.Small s\nA : ConNF.ExtendedIndex \u03b1\n\u22a2 ConNF.Small (ConNF.completionToAdd' s A)", "dependency": [1, 69, 60, 233, 61, 233, 353]}, "ConNF.completionToAdd_eq_completionToAdd'": {"natural_language_statement": "The theorem `ConNF.completionToAdd_eq_completionToAdd'` establishes an equality between two sets of addresses. Specifically, it relates the set of addresses `ConNF.completionToAdd s` (which adds new addresses to a set `s` to make it a \"support\") with the union of sets obtained by applying the function `ConNF.completionToAdd'` to `s` for each `ConNF.ExtendedIndex \u03b1`. The function `ConNF.completionToAdd'` takes a set `s` and an `ConNF.ExtendedIndex \u03b1` object `A`, and returns a set of `ConNF.Atom` objects, which are used to define the addition operation on natural numbers in the context of Constructive Ordinal Notation (ConNF). The equality established by the theorem means that the set obtained by adding new addresses to `s` to make it a \"support\" can be equivalently described by taking the union of sets generated by applying `ConNF.completionToAdd'` to `s` for each possible `ConNF.ExtendedIndex \u03b1`.", "formal_statement": "example [ConNF.Params ] {\u03b1 : ConNF.TypeIndex} (s : Set (ConNF.Address \u03b1)) :ConNF.completionToAdd s = \u22c3 (A : ConNF.ExtendedIndex \u03b1), (fun (x : ConNF.Atom) => { path := A, value := Sum.inl x }) '' ConNF.completionToAdd' s A := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03b1 : ConNF.TypeIndex\ns : Set (ConNF.Address \u03b1)\n\u22a2 ConNF.completionToAdd s = \u22c3 A, (fun x => { path := A, value := Sum.inl x }) '' ConNF.completionToAdd' s A", "dependency": [1, 69, 60, 351, 61, 67, 353]}, "ConNF.completionToAdd_small": {"natural_language_statement": "In the context of Constructive Ordinal Notation (ConNF), the theorem `ConNF.completionToAdd_small` states that the set of addresses that need to be added to a given set `s` of addresses to make it a \"support\" (a set of addresses that satisfies certain properties related to the structure of the ConNF model) is small, meaning its cardinality is strictly less than the cardinality of the type `ConNF.\u03ba`.", "formal_statement": "example [ConNF.Params ] {\u03b1 : ConNF.TypeIndex} (s : Set (ConNF.Address \u03b1)) (hs : ConNF.Small s) :ConNF.Small (ConNF.completionToAdd s) := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03b1 : ConNF.TypeIndex\ns : Set (ConNF.Address \u03b1)\nhs : ConNF.Small s\n\u22a2 ConNF.Small (ConNF.completionToAdd s)", "dependency": [1, 69, 60, 233, 233, 351]}, "ConNF.mem_completeEnum": {"natural_language_statement": "The theorem `ConNF.mem_completeEnum` states that an address `c` belongs to the complete enumeration of an `\u03b1`-enumeration `E` if and only if `c` belongs to `E` or `c` belongs to the completion of `E` with respect to the addition operation defined in the context of Constructive Ordinal Notation (ConNF).", "formal_statement": "@[simp]example [ConNF.Params ] {\u03b1 : ConNF.TypeIndex} (E : ConNF.Enumeration (ConNF.Address \u03b1)) (c : ConNF.Address \u03b1) :c \u2208 ConNF.completeEnum E \u2194 c \u2208 E \u2228 c \u2208 ConNF.completionToAdd (ConNF.Enumeration.carrier E) := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03b1 : ConNF.TypeIndex\nE : ConNF.Enumeration (ConNF.Address \u03b1)\nc : ConNF.Address \u03b1\n\u22a2 c \u2208 ConNF.completeEnum E \u2194 c \u2208 E \u2228 c \u2208 ConNF.completionToAdd (ConNF.Enumeration.carrier E)", "dependency": [1, 59, 60, 60, 357, 351, 70]}, "ConNF.Support.complete_isCompletion": {"natural_language_statement": "The theorem `ConNF.Support.complete_isCompletion` states that the function `ConNF.Support.complete`, which extends an enumeration to a support in the context of Constructive Ordinal Notation (ConNF), ensures that for any two near-litters `N\u2081` and `N\u2082` that are near the same litter, any atoms in their symmetric difference are included in the enumeration.", "formal_statement": "example [ConNF.Params ] {\u03b1 : ConNF.TypeIndex} (E : ConNF.Enumeration (ConNF.Address \u03b1)) :ConNF.Support.IsCompletion (ConNF.Support.complete E) E := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03b1 : ConNF.TypeIndex\nE : ConNF.Enumeration (ConNF.Address \u03b1)\n\u22a2 ConNF.Support.IsCompletion (ConNF.Support.complete E) E", "dependency": [1, 59, 60, 349, 359]}, "ConNF.Support.IsSum.smul": {"natural_language_statement": "Function `ConNF.Support.IsSum.smul` proves that if `S` is a sum of `S\u2081` and `S\u2082`, and `\u03c0` is a structural permutation, then `\u03c0 \u2022 S` is a sum of `\u03c0 \u2022 S\u2081` and `\u03c0 \u2022 S\u2082`.", "formal_statement": "example [ConNF.Params ] {\u03b1 : ConNF.TypeIndex} {S : ConNF.Support \u03b1} {S\u2081 : ConNF.Support \u03b1} {S\u2082 : ConNF.Support \u03b1} (h : ConNF.Support.IsSum S S\u2081 S\u2082) (\u03c0 : ConNF.StructPerm \u03b1) :ConNF.Support.IsSum (\u03c0 \u2022 S) (\u03c0 \u2022 S\u2081) (\u03c0 \u2022 S\u2082) := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03b1 : ConNF.TypeIndex\nS S\u2081 S\u2082 : ConNF.Support \u03b1\nh : ConNF.Support.IsSum S S\u2081 S\u2082\n\u03c0 : ConNF.StructPerm \u03b1\n\u22a2 ConNF.Support.IsSum (\u03c0 \u2022 S) (\u03c0 \u2022 S\u2081) (\u03c0 \u2022 S\u2082)", "dependency": [1, 58, 58, 58, 361, 55, 361]}, "ConNF.Support.exists_isSum": {"natural_language_statement": "Given two `ConNF.Support` objects `S\u2081` and `S\u2082`, there exists a `ConNF.Support` object `S` such that `S` is the sum of `S\u2081` and `S\u2082`.", "formal_statement": "example [ConNF.Params ] {\u03b1 : ConNF.TypeIndex} (S\u2081 : ConNF.Support \u03b1) (S\u2082 : ConNF.Support \u03b1) :\u2203 (S : ConNF.Support \u03b1), ConNF.Support.IsSum S S\u2081 S\u2082 := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03b1 : ConNF.TypeIndex\nS\u2081 S\u2082 : ConNF.Support \u03b1\n\u22a2 \u2203 S, ConNF.Support.IsSum S S\u2081 S\u2082", "dependency": [1, 58, 58, 58, 361]}, "ConNF.someOfMkLt_spec": {"natural_language_statement": "Function `ConNF.someOfMkLt` noncomputably chooses an element from the complement of a set `s` in a type `\u03b2`, given that the cardinality of `s` is less than the cardinality of `\u03b2`. The theorem `ConNF.someOfMkLt_spec` states that the chosen element does not belong to the set `s`.", "formal_statement": "example {\u03b2 : Type u} {s : Set \u03b2} {h : Cardinal.mk \u2191s < Cardinal.mk \u03b2} :ConNF.someOfMkLt s h \u2209 s := by sorry", "full_tactic_state": "\u03b2 : Type u\ns : Set \u03b2\nh : Cardinal.mk \u2191s < Cardinal.mk \u03b2\n\u22a2 ConNF.someOfMkLt s h \u2209 s", "dependency": [69, 29, 29, 364]}, "ConNF.mk_image\u2082_le": {"natural_language_statement": "Function `ConNF.mk_image\u2082_le` proves that the cardinality of the range of a function `f : (x : \u03b1) \u2192 p x \u2192 \u03b2` is less than or equal to the cardinality of the domain `{x : \u03b1 // p x}`.", "formal_statement": "example {\u03b1 : Type u} {\u03b2 : Type u} {p : \u03b1 \u2192 Prop } (f : (x : \u03b1) \u2192 p x \u2192 \u03b2) :Cardinal.mk { y : \u03b2 // \u2203 (z : \u03b1) (h : p z), f z h = y } \u2264 Cardinal.mk { x : \u03b1 // p x } := by sorry", "full_tactic_state": "\u03b1 \u03b2 : Type u\np : \u03b1 \u2192 Prop\nf : (x : \u03b1) \u2192 p x \u2192 \u03b2\n\u22a2 Cardinal.mk { y // \u2203 z, \u2203 (h : p z), f z h = y } \u2264 Cardinal.mk { x // p x }", "dependency": [29, 29]}, "ConNF.chooseWfCore_spec": {"natural_language_statement": "Function `ConNF.chooseWfCore` is a noncomputable function that, given a type `\u03b1`, a type `\u03b2`, a relation `r` on `\u03b1`, a function `deny` from `\u03b1` to sets of `\u03b2`, a proof `h` that for each `x` in `\u03b1`, the cardinality of the set of `y` such that `r y x` plus the cardinality of `deny x` is less than the cardinality of `\u03b2`, an element `x` of `\u03b1`, and a function `f` from the set of `y` such that `r y x` to `\u03b2`, returns an element of `\u03b2` that is not in the union of the image of `f` and `deny x`.", "formal_statement": "example {\u03b1 : Type u} {\u03b2 : Type u} {r : \u03b1 \u2192 \u03b1 \u2192 Prop } {deny : \u03b1 \u2192 Set \u03b2} {h : \u2200 (x : \u03b1), Cardinal.mk { y : \u03b1 // r y x } + Cardinal.mk \u2191(deny x) < Cardinal.mk \u03b2} (x : \u03b1) (f : (y : \u03b1) \u2192 r y x \u2192 \u03b2) :ConNF.chooseWfCore deny h x f \u2209 {z : \u03b2 | \u2203 (y : \u03b1) (h : r y x), f y h = z} \u222a deny x := by sorry", "full_tactic_state": "\u03b1 \u03b2 : Type u\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ndeny : \u03b1 \u2192 Set \u03b2\nh : \u2200 (x : \u03b1), Cardinal.mk { y // r y x } + Cardinal.mk \u2191(deny x) < Cardinal.mk \u03b2\nx : \u03b1\nf : (y : \u03b1) \u2192 r y x \u2192 \u03b2\n\u22a2 ConNF.chooseWfCore deny h x f \u2209 {z | \u2203 y, \u2203 (h : r y x), f y h = z} \u222a deny x", "dependency": [69, 29, 29, 29, 367]}, "ConNF.chooseWf_spec": {"natural_language_statement": "Function `ConNF.chooseWf` constructs an injective function `f` such that `f x \u2209 deny x`.", "formal_statement": "example {\u03b1 : Type u} {\u03b2 : Type u} {r : \u03b1 \u2192 \u03b1 \u2192 Prop } [hwf : IsWellOrder \u03b1 r] {deny : \u03b1 \u2192 Set \u03b2} {h : \u2200 (x : \u03b1), Cardinal.mk { y : \u03b1 // r y x } + Cardinal.mk \u2191(deny x) < Cardinal.mk \u03b2} (x : \u03b1) :ConNF.chooseWf deny h x \u2209 {z : \u03b2 | \u2203 (y : \u03b1) (_ : r y x), ConNF.chooseWf deny h y = z} \u222a deny x := by sorry", "full_tactic_state": "\u03b1 \u03b2 : Type u\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\nhwf : IsWellOrder \u03b1 r\ndeny : \u03b1 \u2192 Set \u03b2\nh : \u2200 (x : \u03b1), Cardinal.mk { y // r y x } + Cardinal.mk \u2191(deny x) < Cardinal.mk \u03b2\nx : \u03b1\n\u22a2 ConNF.chooseWf deny h x \u2209 {z | \u2203 y, \u2203 (_ : r y x), ConNF.chooseWf deny h y = z} \u222a deny x", "dependency": [15, 69, 29, 29, 29, 369, 369]}, "ConNF.chooseWf_not_mem_deny": {"natural_language_statement": "Function `ConNF.chooseWf` constructs an injective function `f` such that `f x \u2209 deny x`.", "formal_statement": "example {\u03b1 : Type u} {\u03b2 : Type u} {r : \u03b1 \u2192 \u03b1 \u2192 Prop } [IsWellOrder \u03b1 r] {deny : \u03b1 \u2192 Set \u03b2} {h : \u2200 (x : \u03b1), Cardinal.mk { y : \u03b1 // r y x } + Cardinal.mk \u2191(deny x) < Cardinal.mk \u03b2} (x : \u03b1) :ConNF.chooseWf deny h x \u2209 deny x := by sorry", "full_tactic_state": "\u03b1 \u03b2 : Type u\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ninst\u271d : IsWellOrder \u03b1 r\ndeny : \u03b1 \u2192 Set \u03b2\nh : \u2200 (x : \u03b1), Cardinal.mk { y // r y x } + Cardinal.mk \u2191(deny x) < Cardinal.mk \u03b2\nx : \u03b1\n\u22a2 ConNF.chooseWf deny h x \u2209 deny x", "dependency": [15, 69, 29, 29, 29, 369]}, "ConNF.chooseWf_ne_of_r": {"natural_language_statement": "Function `ConNF.chooseWf_ne_of_r` is a proof that for any two elements `x\u2081` and `x\u2082` of a well-ordered type `\u03b1`, if `r x\u2081 x\u2082` (meaning `x\u2081` is less than `x\u2082` under the well-order `r`), then `ConNF.chooseWf deny h x\u2081` (which is an injective function `f` such that `f x \u2209 deny x`, where `deny` is a function that maps `\u03b1` to sets of `\u03b2` elements and `h` is a condition on the cardinality of the sets `{y : \u03b1 // r y x}` and `deny x`) is not equal to `ConNF.chooseWf deny h x\u2082`. This result is crucial for showing that Conant's N-free construction can be applied to any well-ordered set.", "formal_statement": "example {\u03b1 : Type u} {\u03b2 : Type u} {r : \u03b1 \u2192 \u03b1 \u2192 Prop } [_inst : IsWellOrder \u03b1 r] {deny : \u03b1 \u2192 Set \u03b2} {h : \u2200 (x : \u03b1), Cardinal.mk { y : \u03b1 // r y x } + Cardinal.mk \u2191(deny x) < Cardinal.mk \u03b2} (x\u2081 : \u03b1) (x\u2082 : \u03b1) (hx : r x\u2081 x\u2082) :ConNF.chooseWf deny h x\u2081 \u2260 ConNF.chooseWf deny h x\u2082 := by sorry", "full_tactic_state": "\u03b1 \u03b2 : Type u\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\n_inst : IsWellOrder \u03b1 r\ndeny : \u03b1 \u2192 Set \u03b2\nh : \u2200 (x : \u03b1), Cardinal.mk { y // r y x } + Cardinal.mk \u2191(deny x) < Cardinal.mk \u03b2\nx\u2081 x\u2082 : \u03b1\nhx : r x\u2081 x\u2082\n\u22a2 ConNF.chooseWf deny h x\u2081 \u2260 ConNF.chooseWf deny h x\u2082", "dependency": [15, 69, 29, 29, 29, 369, 369]}, "ConNF.chooseWf_injective": {"natural_language_statement": "Function `ConNF.chooseWf` constructs an injective function `f` such that `f x \u2209 deny x`. The theorem `ConNF.chooseWf_injective` proves that this function is indeed injective.", "formal_statement": "example {\u03b1 : Type u} {\u03b2 : Type u} {r : \u03b1 \u2192 \u03b1 \u2192 Prop } [inst : IsWellOrder \u03b1 r] {deny : \u03b1 \u2192 Set \u03b2} {h : \u2200 (x : \u03b1), Cardinal.mk { y : \u03b1 // r y x } + Cardinal.mk \u2191(deny x) < Cardinal.mk \u03b2} :Function.Injective (ConNF.chooseWf deny h) := by sorry", "full_tactic_state": "\u03b1 \u03b2 : Type u\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ninst : IsWellOrder \u03b1 r\ndeny : \u03b1 \u2192 Set \u03b2\nh : \u2200 (x : \u03b1), Cardinal.mk { y // r y x } + Cardinal.mk \u2191(deny x) < Cardinal.mk \u03b2\n\u22a2 Function.Injective (ConNF.chooseWf deny h)", "dependency": [15, 69, 29, 29, 29, 89, 369]}, "ConNF.mk_invImage_lt": {"natural_language_statement": "In the context of Constructive Ordinal Notation (ConNF), the theorem `ConNF.mk_invImage_lt` asserts that for any tangle `t` at level `\u03b2`, the cardinality of the set of all tangles less than `t` is strictly less than the cardinality of the type `\u03bc`. This result is crucial for establishing the well-foundedness of the `<` relation on tangles within the ConNF framework.", "formal_statement": "example [ConNF.Params ] {\u03b2 : ConNF.TypeIndex} [ConNF.TangleData \u03b2] [ConNF.PositionedTangles \u03b2] (t : ConNF.Tangle \u03b2) :Cardinal.mk { t' : ConNF.Tangle \u03b2 // t' < t } < Cardinal.mk ConNF.\u03bc := by sorry", "full_tactic_state": "inst\u271d\u00b2 : ConNF.Params\n\u03b2 : ConNF.TypeIndex\ninst\u271d\u00b9 : ConNF.TangleData \u03b2\ninst\u271d : ConNF.PositionedTangles \u03b2\nt : ConNF.Tangle \u03b2\n\u22a2 Cardinal.mk { t' // t' < t } < Cardinal.mk ConNF.\u03bc", "dependency": [1, 39, 72, 29, 29]}, "ConNF.mk_invImage_le": {"natural_language_statement": "In the context of Constructive Ordinal Notation (ConNF), the theorem `ConNF.mk_invImage_le` asserts that the cardinality of the set of tangles `t'` at level `\u03b3` such that the position of `t'` is less than or equal to the position of a given tangle `t` at level `\u03b2`, is strictly less than the cardinality of the type `\u03bc`. This result is crucial for establishing the well-foundedness of the ConNF hierarchy.", "formal_statement": "example [ConNF.Params ] {\u03b2 : ConNF.TypeIndex} (\u03b3 : ConNF.\u039b) [ConNF.TangleData \u03b2] [ConNF.PositionedTangles \u03b2] [ConNF.TangleData \u2191\u03b3] [ConNF.PositionedTangles \u2191\u03b3] (t : ConNF.Tangle \u03b2) :Cardinal.mk { t' : ConNF.Tangle \u2191\u03b3 // ConNF.pos t' \u2264 ConNF.pos t } < Cardinal.mk ConNF.\u03bc := by sorry", "full_tactic_state": "inst\u271d\u2074 : ConNF.Params\n\u03b2 : ConNF.TypeIndex\n\u03b3 : ConNF.\u039b\ninst\u271d\u00b3 : ConNF.TangleData \u03b2\ninst\u271d\u00b2 : ConNF.PositionedTangles \u03b2\ninst\u271d\u00b9 : ConNF.TangleData \u2191\u03b3\ninst\u271d : ConNF.PositionedTangles \u2191\u03b3\nt : ConNF.Tangle \u03b2\n\u22a2 Cardinal.mk { t' // ConNF.pos t' \u2264 ConNF.pos t } < Cardinal.mk ConNF.\u03bc", "dependency": [1, 39, 72, 39, 72, 29, 29]}, "ConNF.mk_fuzzDeny": {"natural_language_statement": "Function `ConNF.fuzzDeny` defines a set of elements of type `ConNF.\u03bc` that the function `ConNF.fuzz` cannot assign to a given tangle `t` of type `ConNF.Tangle \u03b2` in the context of Constructive Ordinal Notation (ConNF). This set is the union of two subsets: one for near-litters and one for atoms. The theorem `ConNF.mk_fuzzDeny` asserts that the sum of the cardinality of the set of tangles less than `t` and the cardinality of the set `ConNF.fuzzDeny \u03b3 t` is less than the cardinality of `ConNF.\u03bc`.", "formal_statement": "example [ConNF.Params ] {\u03b2 : ConNF.TypeIndex} {\u03b3 : ConNF.\u039b} [ConNF.TangleData \u03b2] [ConNF.PositionedTangles \u03b2] [ConNF.TangleData \u2191\u03b3] [ConNF.PositionedTangles \u2191\u03b3] [ConNF.TypedObjects \u03b3] (t : ConNF.Tangle \u03b2) :Cardinal.mk { t' : ConNF.Tangle \u03b2 // t' < t } + Cardinal.mk \u2191(ConNF.fuzzDeny \u03b3 t) < Cardinal.mk ConNF.\u03bc := by sorry", "full_tactic_state": "inst\u271d\u2075 : ConNF.Params\n\u03b2 : ConNF.TypeIndex\n\u03b3 : ConNF.\u039b\ninst\u271d\u2074 : ConNF.TangleData \u03b2\ninst\u271d\u00b3 : ConNF.PositionedTangles \u03b2\ninst\u271d\u00b2 : ConNF.TangleData \u2191\u03b3\ninst\u271d\u00b9 : ConNF.PositionedTangles \u2191\u03b3\ninst\u271d : ConNF.TypedObjects \u03b3\nt : ConNF.Tangle \u03b2\n\u22a2 Cardinal.mk { t' // t' < t } + Cardinal.mk \u2191(ConNF.fuzzDeny \u03b3 t) < Cardinal.mk ConNF.\u03bc", "dependency": [1, 39, 72, 39, 72, 73, 29, 29, 376, 29]}, "ConNF.fuzz_\u03b2": {"natural_language_statement": "Function `ConNF.fuzz` is a noncomputable function defined in the context of Constructive Ordinal Notation (ConNF) in Lean 4. It takes as input a tangle `t` of type `\u03b2` and returns a `Litter` object. The `Litter` object is defined as a 4-tuple consisting of a `Wf` object, a type index `\u03b2`, a `\u039b` object `\u03b3`, and a proof that `\u03b2` is not equal to `\u03b3`. The `Wf` object is chosen using the `chooseWf` function, which selects an element from a nonempty set. The `chooseWf` function is applied to the set `fuzzDeny \u03b3`, which is defined using the `mk_fuzzDeny` function. The `mk_fuzzDeny` function takes a tangle `t` of type `\u03b2` and returns a `Wf` object. The `Litter` object is then constructed using the chosen `Wf` object, the type index `\u03b2`, the `\u039b` object `\u03b3`, and the proof that `\u03b2` is not equal to `\u03b3`.", "formal_statement": "@[simp]example [ConNF.Params ] {\u03b2 : ConNF.TypeIndex} {\u03b3 : ConNF.\u039b} [ConNF.TangleData \u03b2] [ConNF.PositionedTangles \u03b2] [ConNF.TangleData \u2191\u03b3] [ConNF.PositionedTangles \u2191\u03b3] [ConNF.TypedObjects \u03b3] (h\u03b2\u03b3 : \u03b2 \u2260 \u2191\u03b3) (t : ConNF.Tangle \u03b2) :(ConNF.fuzz h\u03b2\u03b3 t).\u03b2 = \u03b2 := by sorry", "full_tactic_state": "inst\u271d\u2075 : ConNF.Params\n\u03b2 : ConNF.TypeIndex\n\u03b3 : ConNF.\u039b\ninst\u271d\u2074 : ConNF.TangleData \u03b2\ninst\u271d\u00b3 : ConNF.PositionedTangles \u03b2\ninst\u271d\u00b2 : ConNF.TangleData \u2191\u03b3\ninst\u271d\u00b9 : ConNF.PositionedTangles \u2191\u03b3\ninst\u271d : ConNF.TypedObjects \u03b3\nh\u03b2\u03b3 : \u03b2 \u2260 \u2191\u03b3\nt : ConNF.Tangle \u03b2\n\u22a2 (ConNF.fuzz h\u03b2\u03b3 t).\u03b2 = \u03b2", "dependency": [1, 39, 72, 39, 72, 73, 78]}, "ConNF.fuzz_\u03b3": {"natural_language_statement": "Function `ConNF.fuzz` is a noncomputable function defined in the context of Constructive Ordinal Notation (ConNF) in Lean 4. It takes as input a tangle `t` of type `\u03b2` and returns a `Litter` object. The `Litter` object is defined as a 4-tuple consisting of a `Wf` object, a type index `\u03b2`, a `\u039b` object `\u03b3`, and a proof that `\u03b2` is not equal to `\u03b3`. The `Wf` object is chosen using the `chooseWf` function, which selects an element from a nonempty set. The `chooseWf` function is applied to the set `fuzzDeny \u03b3`, which is defined using the `mk_fuzzDeny` function. The `mk_fuzzDeny` function takes a tangle `t` of type `\u03b2` and returns a `Wf` object. The `Litter` object is then constructed using the chosen `Wf` object, the type index `\u03b2`, the `\u039b` object `\u03b3`, and the proof that `\u03b2` is not equal to `\u03b3`.", "formal_statement": "@[simp]example [ConNF.Params ] {\u03b2 : ConNF.TypeIndex} {\u03b3 : ConNF.\u039b} [ConNF.TangleData \u03b2] [ConNF.PositionedTangles \u03b2] [ConNF.TangleData \u2191\u03b3] [ConNF.PositionedTangles \u2191\u03b3] [ConNF.TypedObjects \u03b3] (h\u03b2\u03b3 : \u03b2 \u2260 \u2191\u03b3) (t : ConNF.Tangle \u03b2) :(ConNF.fuzz h\u03b2\u03b3 t).\u03b3 = \u03b3 := by sorry", "full_tactic_state": "inst\u271d\u2075 : ConNF.Params\n\u03b2 : ConNF.TypeIndex\n\u03b3 : ConNF.\u039b\ninst\u271d\u2074 : ConNF.TangleData \u03b2\ninst\u271d\u00b3 : ConNF.PositionedTangles \u03b2\ninst\u271d\u00b2 : ConNF.TangleData \u2191\u03b3\ninst\u271d\u00b9 : ConNF.PositionedTangles \u2191\u03b3\ninst\u271d : ConNF.TypedObjects \u03b3\nh\u03b2\u03b3 : \u03b2 \u2260 \u2191\u03b3\nt : ConNF.Tangle \u03b2\n\u22a2 (ConNF.fuzz h\u03b2\u03b3 t).\u03b3 = \u03b3", "dependency": [1, 39, 72, 39, 72, 73, 78]}, "ConNF.fuzz_congr_\u03b2": {"natural_language_statement": "In the context of Constructive Ordinal Notation (ConNF) in Lean 4, the theorem `ConNF.fuzz_congr_\u03b2` asserts that for any two tangles `t` and `t'` of types `\u03b2` and `\u03b2'` respectively, if the `fuzz` function applied to `t` and `t'` yields the same `Litter` object, then `\u03b2` must be equal to `\u03b2'`.", "formal_statement": "example [ConNF.Params ] {\u03b2 : ConNF.TypeIndex} {\u03b3 : ConNF.\u039b} [ConNF.TangleData \u03b2] [ConNF.PositionedTangles \u03b2] [ConNF.TangleData \u2191\u03b3] [ConNF.PositionedTangles \u2191\u03b3] [ConNF.TypedObjects \u03b3] {\u03b2' : ConNF.TypeIndex} {\u03b3' : ConNF.\u039b} [ConNF.TangleData \u03b2'] [ConNF.PositionedTangles \u03b2'] [ConNF.TangleData \u2191\u03b3'] [ConNF.PositionedTangles \u2191\u03b3'] [ConNF.TypedObjects \u03b3'] {h\u03b2\u03b3 : \u03b2 \u2260 \u2191\u03b3} {h\u03b2\u03b3' : \u03b2' \u2260 \u2191\u03b3'} {t : ConNF.Tangle \u03b2} {t' : ConNF.Tangle \u03b2'} (h : ConNF.fuzz h\u03b2\u03b3 t = ConNF.fuzz h\u03b2\u03b3' t') :\u03b2 = \u03b2' := by sorry", "full_tactic_state": "inst\u271d\u00b9\u2070 : ConNF.Params\n\u03b2 : ConNF.TypeIndex\n\u03b3 : ConNF.\u039b\ninst\u271d\u2079 : ConNF.TangleData \u03b2\ninst\u271d\u2078 : ConNF.PositionedTangles \u03b2\ninst\u271d\u2077 : ConNF.TangleData \u2191\u03b3\ninst\u271d\u2076 : ConNF.PositionedTangles \u2191\u03b3\ninst\u271d\u2075 : ConNF.TypedObjects \u03b3\n\u03b2' : ConNF.TypeIndex\n\u03b3' : ConNF.\u039b\ninst\u271d\u2074 : ConNF.TangleData \u03b2'\ninst\u271d\u00b3 : ConNF.PositionedTangles \u03b2'\ninst\u271d\u00b2 : ConNF.TangleData \u2191\u03b3'\ninst\u271d\u00b9 : ConNF.PositionedTangles \u2191\u03b3'\ninst\u271d : ConNF.TypedObjects \u03b3'\nh\u03b2\u03b3 : \u03b2 \u2260 \u2191\u03b3\nh\u03b2\u03b3' : \u03b2' \u2260 \u2191\u03b3'\nt : ConNF.Tangle \u03b2\nt' : ConNF.Tangle \u03b2'\nh : ConNF.fuzz h\u03b2\u03b3 t = ConNF.fuzz h\u03b2\u03b3' t'\n\u22a2 \u03b2 = \u03b2'", "dependency": [1, 39, 72, 39, 72, 73, 39, 72, 39, 72, 73, 78, 78]}, "ConNF.fuzz_congr_\u03b3": {"natural_language_statement": "In the context of Constructive Ordinal Notation (ConNF) in Lean 4, the theorem `ConNF.fuzz_congr_\u03b3` asserts that for any two tangles `t` and `t'` of types `\u03b2` and `\u03b2'` respectively, if the `fuzz` function outputs the same `Litter` object for both tangles, then the type indices `\u03b3` and `\u03b3'` must be equal.", "formal_statement": "example [ConNF.Params ] {\u03b2 : ConNF.TypeIndex} {\u03b3 : ConNF.\u039b} [ConNF.TangleData \u03b2] [ConNF.PositionedTangles \u03b2] [ConNF.TangleData \u2191\u03b3] [ConNF.PositionedTangles \u2191\u03b3] [ConNF.TypedObjects \u03b3] {\u03b2' : ConNF.TypeIndex} {\u03b3' : ConNF.\u039b} [ConNF.TangleData \u03b2'] [ConNF.PositionedTangles \u03b2'] [ConNF.TangleData \u2191\u03b3'] [ConNF.PositionedTangles \u2191\u03b3'] [ConNF.TypedObjects \u03b3'] {h\u03b2\u03b3 : \u03b2 \u2260 \u2191\u03b3} {h\u03b2\u03b3' : \u03b2' \u2260 \u2191\u03b3'} {t : ConNF.Tangle \u03b2} {t' : ConNF.Tangle \u03b2'} (h : ConNF.fuzz h\u03b2\u03b3 t = ConNF.fuzz h\u03b2\u03b3' t') :\u03b3 = \u03b3' := by sorry", "full_tactic_state": "inst\u271d\u00b9\u2070 : ConNF.Params\n\u03b2 : ConNF.TypeIndex\n\u03b3 : ConNF.\u039b\ninst\u271d\u2079 : ConNF.TangleData \u03b2\ninst\u271d\u2078 : ConNF.PositionedTangles \u03b2\ninst\u271d\u2077 : ConNF.TangleData \u2191\u03b3\ninst\u271d\u2076 : ConNF.PositionedTangles \u2191\u03b3\ninst\u271d\u2075 : ConNF.TypedObjects \u03b3\n\u03b2' : ConNF.TypeIndex\n\u03b3' : ConNF.\u039b\ninst\u271d\u2074 : ConNF.TangleData \u03b2'\ninst\u271d\u00b3 : ConNF.PositionedTangles \u03b2'\ninst\u271d\u00b2 : ConNF.TangleData \u2191\u03b3'\ninst\u271d\u00b9 : ConNF.PositionedTangles \u2191\u03b3'\ninst\u271d : ConNF.TypedObjects \u03b3'\nh\u03b2\u03b3 : \u03b2 \u2260 \u2191\u03b3\nh\u03b2\u03b3' : \u03b2' \u2260 \u2191\u03b3'\nt : ConNF.Tangle \u03b2\nt' : ConNF.Tangle \u03b2'\nh : ConNF.fuzz h\u03b2\u03b3 t = ConNF.fuzz h\u03b2\u03b3' t'\n\u22a2 \u03b3 = \u03b3'", "dependency": [1, 39, 72, 39, 72, 73, 39, 72, 39, 72, 73, 78, 78]}, "ConNF.fuzz_injective": {"natural_language_statement": "The function `ConNF.fuzz_injective` is a theorem in the Constructive Ordinal Notation (ConNF) context in Lean 4. It claims that the function `ConNF.fuzz` is injective. This function `ConNF.fuzz` takes a tangle `t` of type `\u03b2` and returns a `Litter` object, which is defined as a 4-tuple consisting of a `Wf` object, a type index `\u03b2`, a `\u039b` object `\u03b3`, and a proof that `\u03b2` is not equal to `\u03b3`. The `Litter` object is constructed using a chosen `Wf` object, the type index `\u03b2`, the `\u039b` object `\u03b3`, and the proof that `\u03b2` is not equal to `\u03b3`. The theorem `ConNF.fuzz_injective` asserts that for any `\u03b2` and `\u03b3` of different types, the `ConNF.fuzz` function is injective, meaning that if it maps two different tangles to the same `Litter`, then those tangles must be identical.", "formal_statement": "example [ConNF.Params ] {\u03b2 : ConNF.TypeIndex} {\u03b3 : ConNF.\u039b} [ConNF.TangleData \u03b2] [ConNF.PositionedTangles \u03b2] [ConNF.TangleData \u2191\u03b3] [ConNF.PositionedTangles \u2191\u03b3] [ConNF.TypedObjects \u03b3] (h\u03b2\u03b3 : \u03b2 \u2260 \u2191\u03b3) :Function.Injective (ConNF.fuzz h\u03b2\u03b3) := by sorry", "full_tactic_state": "inst\u271d\u2075 : ConNF.Params\n\u03b2 : ConNF.TypeIndex\n\u03b3 : ConNF.\u039b\ninst\u271d\u2074 : ConNF.TangleData \u03b2\ninst\u271d\u00b3 : ConNF.PositionedTangles \u03b2\ninst\u271d\u00b2 : ConNF.TangleData \u2191\u03b3\ninst\u271d\u00b9 : ConNF.PositionedTangles \u2191\u03b3\ninst\u271d : ConNF.TypedObjects \u03b3\nh\u03b2\u03b3 : \u03b2 \u2260 \u2191\u03b3\n\u22a2 Function.Injective (ConNF.fuzz h\u03b2\u03b3)", "dependency": [1, 39, 72, 39, 72, 73, 89, 78]}, "ConNF.fuzz_not_mem_deny": {"natural_language_statement": "Function `ConNF.fuzz` in the context of Constructive Ordinal Notation (ConNF) in Lean 4 takes as input a tangle `t` of type `\u03b2` and returns a `Litter` object. The `Litter` object is defined as a 4-tuple consisting of a `Wf` object, a type index `\u03b2`, a `\u039b` object `\u03b3`, and a proof that `\u03b2` is not equal to `\u03b3`. The `Wf` object is chosen using the `chooseWf` function, which selects an element from a nonempty set. The `chooseWf` function is applied to the set `fuzzDeny \u03b3`, which is defined using the `mk_fuzzDeny` function. The `mk_fuzzDeny` function takes a tangle `t` of type `\u03b2` and returns a `Wf` object. The `Litter` object is then constructed using the chosen `Wf` object, the type index `\u03b2`, the `\u039b` object `\u03b3`, and the proof that `\u03b2` is not equal to `\u03b3`. The theorem `ConNF.fuzz_not_mem_deny` states that the position `\u03bd` of the `Litter` object returned by `ConNF.fuzz` does not belong to the set `ConNF.fuzzDeny \u03b3 t`, which is the union of two subsets: one for near-litters and one for atoms.", "formal_statement": "example [ConNF.Params ] {\u03b2 : ConNF.TypeIndex} {\u03b3 : ConNF.\u039b} [ConNF.TangleData \u03b2] [ConNF.PositionedTangles \u03b2] [ConNF.TangleData \u2191\u03b3] [ConNF.PositionedTangles \u2191\u03b3] [ConNF.TypedObjects \u03b3] (h\u03b2\u03b3 : \u03b2 \u2260 \u2191\u03b3) (t : ConNF.Tangle \u03b2) :(ConNF.fuzz h\u03b2\u03b3 t).\u03bd \u2209 ConNF.fuzzDeny \u03b3 t := by sorry", "full_tactic_state": "inst\u271d\u2075 : ConNF.Params\n\u03b2 : ConNF.TypeIndex\n\u03b3 : ConNF.\u039b\ninst\u271d\u2074 : ConNF.TangleData \u03b2\ninst\u271d\u00b3 : ConNF.PositionedTangles \u03b2\ninst\u271d\u00b2 : ConNF.TangleData \u2191\u03b3\ninst\u271d\u00b9 : ConNF.PositionedTangles \u2191\u03b3\ninst\u271d : ConNF.TypedObjects \u03b3\nh\u03b2\u03b3 : \u03b2 \u2260 \u2191\u03b3\nt : ConNF.Tangle \u03b2\n\u22a2 (ConNF.fuzz h\u03b2\u03b3 t).\u03bd \u2209 ConNF.fuzzDeny \u03b3 t", "dependency": [1, 39, 72, 39, 72, 73, 78, 376]}, "ConNF.pos_lt_pos_fuzz": {"natural_language_statement": "The `ConNF.fuzz` function is a noncomputable function that takes a tangle `t` of type `\u03b2` and returns a `Litter` object. The `Litter` object is defined as a 4-tuple consisting of a `Wf` object, a type index `\u03b2`, a `\u039b` object `\u03b3`, and a proof that `\u03b2` is not equal to `\u03b3`. The `Wf` object is chosen using the `chooseWf` function, which selects an element from a nonempty set. The `chooseWf` function is applied to the set `fuzzDeny \u03b3`, which is defined using the `mk_fuzzDeny` function. The `mk_fuzzDeny` function takes a tangle `t` of type `\u03b2` and returns a `Wf` object. The `Litter` object is then constructed using the chosen `Wf` object, the type index `\u03b2`, the `\u039b` object `\u03b3`, and the proof that `\u03b2` is not equal to `\u03b3`. The theorem `ConNF.pos_lt_pos_fuzz` proves that for any tangle `t` of type `\u03b2` and any atom `a` such that `a.1 = fuzz h\u03b2\u03b3 t`, the position of `t` is less than the position of `a`.", "formal_statement": "example [ConNF.Params ] {\u03b2 : ConNF.TypeIndex} {\u03b3 : ConNF.\u039b} [ConNF.TangleData \u03b2] [ConNF.PositionedTangles \u03b2] [ConNF.TangleData \u2191\u03b3] [ConNF.PositionedTangles \u2191\u03b3] [ConNF.TypedObjects \u03b3] (h\u03b2\u03b3 : \u03b2 \u2260 \u2191\u03b3) (t : ConNF.Tangle \u03b2) (a : ConNF.Atom) (ha : a.1 = ConNF.fuzz h\u03b2\u03b3 t) :ConNF.pos t < ConNF.pos a := by sorry", "full_tactic_state": "inst\u271d\u2075 : ConNF.Params\n\u03b2 : ConNF.TypeIndex\n\u03b3 : ConNF.\u039b\ninst\u271d\u2074 : ConNF.TangleData \u03b2\ninst\u271d\u00b3 : ConNF.PositionedTangles \u03b2\ninst\u271d\u00b2 : ConNF.TangleData \u2191\u03b3\ninst\u271d\u00b9 : ConNF.PositionedTangles \u2191\u03b3\ninst\u271d : ConNF.TypedObjects \u03b3\nh\u03b2\u03b3 : \u03b2 \u2260 \u2191\u03b3\nt : ConNF.Tangle \u03b2\na : ConNF.Atom\nha : a.1 = ConNF.fuzz h\u03b2\u03b3 t\n\u22a2 ConNF.pos t < ConNF.pos a", "dependency": [1, 39, 72, 39, 72, 73, 78]}, "ConNF.Allowable.toStructPerm_smul": {"natural_language_statement": "The theorem `ConNF.Allowable.toStructPerm_smul` states that for any allowable permutation `\u03c1` on a proper type index `\u03b1`, the action of `\u03c1` on an element `x` of a type `X` that has a multiplicative action by the structural permutations at level `\u03b1` is equivalent to the action of the structural permutation `ConNF.Allowable.toStructPerm \u03c1` on `x`.", "formal_statement": "example [ConNF.Params ] {\u03b1 : ConNF.TypeIndex} [ConNF.TangleData \u03b1] {X : Type u_1} [MulAction (ConNF.StructPerm \u03b1) X] (\u03c1 : ConNF.Allowable \u03b1) (x : X) :\u03c1 \u2022 x = ConNF.Allowable.toStructPerm \u03c1 \u2022 x := by sorry", "full_tactic_state": "inst\u271d\u00b2 : ConNF.Params\n\u03b1 : ConNF.TypeIndex\ninst\u271d\u00b9 : ConNF.TangleData \u03b1\nX : Type u_1\ninst\u271d : MulAction (ConNF.StructPerm \u03b1) X\n\u03c1 : ConNF.Allowable \u03b1\nx : X\n\u22a2 \u03c1 \u2022 x = ConNF.Allowable.toStructPerm \u03c1 \u2022 x", "dependency": [1, 39, 56, 55]}, "ConNF.Allowable.smul_support_max": {"natural_language_statement": "The `ConNF.Allowable.smul_support_max` theorem states that for any allowable permutation `\u03c1` at level `\u03b1`, the maximum element of the support of `\u03c1` acting on a support `S` is equal to the maximum element of `S`. This theorem is used in the context of Constructive Ordinal Notation (ConNF), which is a form of ordinal notation based on a combinatorial game. The theorem is a fundamental property of the support of allowable permutations in the ConNF model.", "formal_statement": "@[simp]example [ConNF.Params ] {\u03b1 : ConNF.TypeIndex} [ConNF.TangleData \u03b1] (\u03c1 : ConNF.Allowable \u03b1) (S : ConNF.Support \u03b1) :ConNF.Support.max (\u03c1 \u2022 S) = ConNF.Support.max S := by sorry", "full_tactic_state": "inst\u271d\u00b9 : ConNF.Params\n\u03b1 : ConNF.TypeIndex\ninst\u271d : ConNF.TangleData \u03b1\n\u03c1 : ConNF.Allowable \u03b1\nS : ConNF.Support \u03b1\n\u22a2 ConNF.Support.max (\u03c1 \u2022 S) = ConNF.Support.max S", "dependency": [1, 39, 58, 338, 338]}, "ConNF.Allowable.smul_support_f": {"natural_language_statement": "In the context of Constructive Ordinal Notation (ConNF), the theorem `ConNF.Allowable.smul_support_f` states that for any allowable permutation `\u03c1` at level `\u03b1`, and any `ConNF.Support` structure `S` at level `\u03b1`, the function `ConNF.Support.f` applied to `\u03c1 \u2022 S`, `i`, and `hi` (where `i` is less than the maximum element of `S`) is equal to `\u03c1` applied to `ConNF.Support.f` applied to `S`, `i`, and `hi`.", "formal_statement": "@[simp]example [ConNF.Params ] {\u03b1 : ConNF.TypeIndex} [ConNF.TangleData \u03b1] (\u03c1 : ConNF.Allowable \u03b1) (S : ConNF.Support \u03b1) (i : ConNF.\u03ba) (hi : i < ConNF.Support.max S) :ConNF.Support.f (\u03c1 \u2022 S) i hi = \u03c1 \u2022 ConNF.Support.f S i hi := by sorry", "full_tactic_state": "inst\u271d\u00b9 : ConNF.Params\n\u03b1 : ConNF.TypeIndex\ninst\u271d : ConNF.TangleData \u03b1\n\u03c1 : ConNF.Allowable \u03b1\nS : ConNF.Support \u03b1\ni : ConNF.\u03ba\nhi : i < ConNF.Support.max S\n\u22a2 ConNF.Support.f (\u03c1 \u2022 S) i hi = \u03c1 \u2022 ConNF.Support.f S i hi", "dependency": [1, 39, 58, 338, 339, 339]}, "ConNF.Allowable.smul_mem_smul_support": {"natural_language_statement": "In the context of Constructive Ordinal Notation (ConNF), the theorem `ConNF.Allowable.smul_mem_smul_support` asserts that if an address `c` is a member of a support `S`, and `\u03c1` is an allowable permutation, then the image of `c` under `\u03c1` (denoted as `\u03c1 \u2022 c`) is also a member of the image of `S` under `\u03c1` (denoted as `\u03c1 \u2022 S`).", "formal_statement": "example [ConNF.Params ] {\u03b1 : ConNF.TypeIndex} [ConNF.TangleData \u03b1] {S : ConNF.Support \u03b1} {c : ConNF.Address \u03b1} (h : c \u2208 S) (\u03c1 : ConNF.Allowable \u03b1) :\u03c1 \u2022 c \u2208 \u03c1 \u2022 S := by sorry", "full_tactic_state": "inst\u271d\u00b9 : ConNF.Params\n\u03b1 : ConNF.TypeIndex\ninst\u271d : ConNF.TangleData \u03b1\nS : ConNF.Support \u03b1\nc : ConNF.Address \u03b1\nh : c \u2208 S\n\u03c1 : ConNF.Allowable \u03b1\n\u22a2 \u03c1 \u2022 c \u2208 \u03c1 \u2022 S", "dependency": [1, 39, 58, 60]}, "ConNF.Allowable.smul_eq_of_smul_support_eq": {"natural_language_statement": "The theorem `ConNF.Allowable.smul_eq_of_smul_support_eq` asserts that if a support `S` is invariant under the action of an allowable permutation `\u03c1` (i.e., `\u03c1 \u2022 S = S`), then for any address `c` in this support, the action of `\u03c1` on `c` leaves `c` unchanged (i.e., `\u03c1 \u2022 c = c`). This theorem is crucial in establishing the correctness of the construction of natural numbers in the context of Constructive Ordinal Notation (ConNF).", "formal_statement": "example [ConNF.Params ] {\u03b1 : ConNF.TypeIndex} [ConNF.TangleData \u03b1] {S : ConNF.Support \u03b1} {\u03c1 : ConNF.Allowable \u03b1} (hS : \u03c1 \u2022 S = S) {c : ConNF.Address \u03b1} (hc : c \u2208 S) :\u03c1 \u2022 c = c := by sorry", "full_tactic_state": "inst\u271d\u00b9 : ConNF.Params\n\u03b1 : ConNF.TypeIndex\ninst\u271d : ConNF.TangleData \u03b1\nS : ConNF.Support \u03b1\n\u03c1 : ConNF.Allowable \u03b1\nhS : \u03c1 \u2022 S = S\nc : ConNF.Address \u03b1\nhc : c \u2208 S\n\u22a2 \u03c1 \u2022 c = c", "dependency": [1, 39, 58, 60]}, "ConNF.Allowable.support_isCompletion_smul": {"natural_language_statement": "The theorem `ConNF.Allowable.support_isCompletion_smul` states that if `S` is a completion of an enumeration of addresses `E`, and `\u03c1` is an allowable permutation, then `\u03c1 \u2022 S` is a completion of the enumeration `\u03c1 \u2022 E`.", "formal_statement": "example [ConNF.Params ] {\u03b1 : ConNF.TypeIndex} [ConNF.TangleData \u03b1] {S : ConNF.Support \u03b1} {E : ConNF.Enumeration (ConNF.Address \u03b1)} (h : ConNF.Support.IsCompletion S E) (\u03c1 : ConNF.Allowable \u03b1) :ConNF.Support.IsCompletion (\u03c1 \u2022 S) (\u03c1 \u2022 E) := by sorry", "full_tactic_state": "inst\u271d\u00b9 : ConNF.Params\n\u03b1 : ConNF.TypeIndex\ninst\u271d : ConNF.TangleData \u03b1\nS : ConNF.Support \u03b1\nE : ConNF.Enumeration (ConNF.Address \u03b1)\nh : ConNF.Support.IsCompletion S E\n\u03c1 : ConNF.Allowable \u03b1\n\u22a2 ConNF.Support.IsCompletion (\u03c1 \u2022 S) (\u03c1 \u2022 E)", "dependency": [1, 39, 58, 59, 60, 349, 349]}, "ConNF.Allowable.support_isSum_smul": {"natural_language_statement": "The theorem `ConNF.Allowable.support_isSum_smul` states that if `S`, `S\u2081`, and `S\u2082` are `ConNF.Support` objects such that `S` is the sum of `S\u2081` and `S\u2082`, and `\u03c1` is an allowable permutation, then `\u03c1 \u2022 S` is the sum of `\u03c1 \u2022 S\u2081` and `\u03c1 \u2022 S\u2082`.", "formal_statement": "example [ConNF.Params ] {\u03b1 : ConNF.TypeIndex} [ConNF.TangleData \u03b1] {S : ConNF.Support \u03b1} {S\u2081 : ConNF.Support \u03b1} {S\u2082 : ConNF.Support \u03b1} (h : ConNF.Support.IsSum S S\u2081 S\u2082) (\u03c1 : ConNF.Allowable \u03b1) :ConNF.Support.IsSum (\u03c1 \u2022 S) (\u03c1 \u2022 S\u2081) (\u03c1 \u2022 S\u2082) := by sorry", "full_tactic_state": "inst\u271d\u00b9 : ConNF.Params\n\u03b1 : ConNF.TypeIndex\ninst\u271d : ConNF.TangleData \u03b1\nS S\u2081 S\u2082 : ConNF.Support \u03b1\nh : ConNF.Support.IsSum S S\u2081 S\u2082\n\u03c1 : ConNF.Allowable \u03b1\n\u22a2 ConNF.Support.IsSum (\u03c1 \u2022 S) (\u03c1 \u2022 S\u2081) (\u03c1 \u2022 S\u2082)", "dependency": [1, 39, 58, 58, 58, 361, 361]}, "ConNF.Allowable.smul_address": {"natural_language_statement": "Function `ConNF.Allowable.smul_address` defines the action of an allowable permutation on an address in the context of Constructive Ordinal Notation (ConNF). Given an allowable permutation `\u03c1` at level `\u03b1` and an address `c` at level `\u03b1`, the result of the action `\u03c1 \u2022 c` is a new address with the same path as `c` but with the value component transformed by the action of `\u03c1` on the path of `c`.", "formal_statement": "example [ConNF.Params ] {\u03b1 : ConNF.TypeIndex} [ConNF.TangleData \u03b1] {\u03c1 : ConNF.Allowable \u03b1} {c : ConNF.Address \u03b1} :\u03c1 \u2022 c = { path := c.path, value := ConNF.Allowable.toStructPerm \u03c1 c.path \u2022 c.value } := by sorry", "full_tactic_state": "inst\u271d\u00b9 : ConNF.Params\n\u03b1 : ConNF.TypeIndex\ninst\u271d : ConNF.TangleData \u03b1\n\u03c1 : ConNF.Allowable \u03b1\nc : ConNF.Address \u03b1\n\u22a2 \u03c1 \u2022 c = { path := c.path, value := ConNF.Allowable.toStructPerm \u03c1 c.path \u2022 c.value }", "dependency": [1, 39, 60]}, "ConNF.Allowable.smul_address_eq_iff": {"natural_language_statement": "The theorem `ConNF.Allowable.smul_address_eq_iff` states that for an allowable permutation `\u03c1` acting on an address `c` in the context of Constructive Ordinal Notation (ConNF), the action of `\u03c1` on `c` results in the same address `c` if and only if the action of `\u03c1` on the path component of `c` results in the same value component of `c`.", "formal_statement": "@[simp]example [ConNF.Params ] {\u03b1 : ConNF.TypeIndex} [ConNF.TangleData \u03b1] {\u03c1 : ConNF.Allowable \u03b1} {c : ConNF.Address \u03b1} :\u03c1 \u2022 c = c \u2194 ConNF.Allowable.toStructPerm \u03c1 c.path \u2022 c.value = c.value := by sorry", "full_tactic_state": "inst\u271d\u00b9 : ConNF.Params\n\u03b1 : ConNF.TypeIndex\ninst\u271d : ConNF.TangleData \u03b1\n\u03c1 : ConNF.Allowable \u03b1\nc : ConNF.Address \u03b1\n\u22a2 \u03c1 \u2022 c = c \u2194 ConNF.Allowable.toStructPerm \u03c1 c.path \u2022 c.value = c.value", "dependency": [1, 39, 60]}, "ConNF.Allowable.smul_address_eq_smul_iff": {"natural_language_statement": "The theorem `ConNF.Allowable.smul_address_eq_smul_iff` states that for any two allowable permutations `\u03c1` and `\u03c1'` at level `\u03b1`, and any address `c` at level `\u03b1`, the equation `\u03c1 \u2022 c = \u03c1' \u2022 c` holds if and only if the equation `ConNF.Allowable.toStructPerm \u03c1 c.path \u2022 c.value = ConNF.Allowable.toStructPerm \u03c1' c.path \u2022 c.value` holds.", "formal_statement": "@[simp]example [ConNF.Params ] {\u03b1 : ConNF.TypeIndex} [ConNF.TangleData \u03b1] {\u03c1 : ConNF.Allowable \u03b1} {\u03c1' : ConNF.Allowable \u03b1} {c : ConNF.Address \u03b1} :\u03c1 \u2022 c = \u03c1' \u2022 c \u2194 ConNF.Allowable.toStructPerm \u03c1 c.path \u2022 c.value = ConNF.Allowable.toStructPerm \u03c1' c.path \u2022 c.value := by sorry", "full_tactic_state": "inst\u271d\u00b9 : ConNF.Params\n\u03b1 : ConNF.TypeIndex\ninst\u271d : ConNF.TangleData \u03b1\n\u03c1 \u03c1' : ConNF.Allowable \u03b1\nc : ConNF.Address \u03b1\n\u22a2 \u03c1 \u2022 c = \u03c1' \u2022 c \u2194 ConNF.Allowable.toStructPerm \u03c1 c.path \u2022 c.value = ConNF.Allowable.toStructPerm \u03c1' c.path \u2022 c.value", "dependency": [1, 39, 60]}, "ConNF.support_supports": {"natural_language_statement": "The theorem `ConNF.support_supports` asserts that for any tangle `t` at level `\u03b1` in the context of Constructive Ordinal Notation (ConNF), the set of atoms in the small support of `t` supports `t` under the action of the allowable permutations at level `\u03b1`.", "formal_statement": "example [ConNF.Params ] {\u03b1 : ConNF.TypeIndex} [ConNF.TangleData \u03b1] (t : ConNF.Tangle \u03b1) :MulAction.Supports (ConNF.Allowable \u03b1) (ConNF.Enumeration.carrier (ConNF.TangleData.Tangle.support t).enum) t := by sorry", "full_tactic_state": "inst\u271d\u00b9 : ConNF.Params\n\u03b1 : ConNF.TypeIndex\ninst\u271d : ConNF.TangleData \u03b1\nt : ConNF.Tangle \u03b1\n\u22a2 MulAction.Supports (ConNF.Allowable \u03b1) (ConNF.Enumeration.carrier (ConNF.TangleData.Tangle.support t).enum) t", "dependency": [1, 39, 68, 70, 395]}, "NearLitterPerm.ofBot_smul": {"natural_language_statement": "The theorem `NearLitterPerm.ofBot_smul` states that in the context of Constructive Ordinal Notation (ConNF), for any allowable finite sequence of litters `\u03c0` at the bottom level (represented by `\u22a5`), the action of the corresponding near-litter permutation `NearLitterPerm.ofBot \u03c0` on an element `x` of a type `X` that is equipped with a multiplicative action of `ConNF.NearLitterPerm` is equivalent to the action of `\u03c0` on `x`. This is a simplification statement that helps in understanding the relationship between the bottom-level allowable finite sequences and their corresponding near-litter permutations within the ConNF framework.", "formal_statement": "@[simp]example [ConNF.Params ] {X : Type u_1} [MulAction ConNF.NearLitterPerm X] (\u03c0 : ConNF.Allowable \u22a5 ) (x : X) :NearLitterPerm.ofBot \u03c0 \u2022 x = \u03c0 \u2022 x := by sorry", "full_tactic_state": "inst\u271d\u00b9 : ConNF.Params\nX : Type u_1\ninst\u271d : MulAction ConNF.NearLitterPerm X\n\u03c0 : ConNF.Allowable \u22a5\nx : X\n\u22a2 NearLitterPerm.ofBot \u03c0 \u2022 x = \u03c0 \u2022 x", "dependency": [1, 56]}, "ConNF.pos_lt_pos": {"natural_language_statement": "Class `ConNF.Position \u03b1 \u03b2` represents an injective function from `\u03b1` to `\u03b2`, which can be thought of as a way to \"position\" elements of `\u03b1` within a larger type `\u03b2`. Given two elements `c` and `d` of `\u03b1`, the theorem `ConNF.pos_lt_pos` states that `ConNF.pos c < ConNF.pos d` if and only if `c < d`.", "formal_statement": "example {\u03b1 : Type u_2} {\u03b2 : Type u_1} [ConNF.Position \u03b1 \u03b2] [LT \u03b2] (c : \u03b1) (d : \u03b1) :ConNF.pos c < ConNF.pos d \u2194 c < d := by sorry", "full_tactic_state": "\u03b1 : Type u_2\n\u03b2 : Type u_1\ninst\u271d\u00b9 : ConNF.Position \u03b1 \u03b2\ninst\u271d : LT \u03b2\nc d : \u03b1\n\u22a2 ConNF.pos c < ConNF.pos d \u2194 c < d", "dependency": [398, 6]}, "ConNF.isWellOrder_invImage": {"natural_language_statement": "If `r` is a well order on `\u03b2` and `f` is an injective function from `\u03b1` to `\u03b2`, then the inverse image of `r` under `f` is a well order on `\u03b1`.", "formal_statement": "example {\u03b1 : Type u_2} {\u03b2 : Type u_1} {r : \u03b2 \u2192 \u03b2 \u2192 Prop } (h : IsWellOrder \u03b2 r) (f : \u03b1 \u2192 \u03b2) (hf : Function.Injective f) :IsWellOrder \u03b1 (InvImage r f) := by sorry", "full_tactic_state": "\u03b1 : Type u_2\n\u03b2 : Type u_1\nr : \u03b2 \u2192 \u03b2 \u2192 Prop\nh : IsWellOrder \u03b2 r\nf : \u03b1 \u2192 \u03b2\nhf : Function.Injective f\n\u22a2 IsWellOrder \u03b1 (InvImage r f)", "dependency": [15, 89, 15, 96]}, "ConNF.CodingFunction.mem_iff": {"natural_language_statement": "The theorem `ConNF.CodingFunction.mem_iff` in the context of Constructive Ordinal Notation (ConNF) states that for a given coding function `\u03c7` at type level `\u03b2` and a support `S`, the support `S` is an element of the coding function `\u03c7` if and only if the decoding of `S` by `\u03c7` is defined. This is a fundamental property of the relationship between supports and coding functions in ConNF.", "formal_statement": "example [ConNF.Params ] [ConNF.Level] [ConNF.FOAAssumptions] {\u03b2 : ConNF.\u039b} [ConNF.LeLevel \u2191\u03b2] {\u03c7 : ConNF.CodingFunction \u03b2} {S : ConNF.Support \u2191\u03b2} :S \u2208 \u03c7 \u2194 (\u03c7.decode S).Dom := by sorry", "full_tactic_state": "inst\u271d\u00b3 : ConNF.Params\ninst\u271d\u00b2 : ConNF.Level\ninst\u271d\u00b9 : ConNF.FOAAssumptions\n\u03b2 : ConNF.\u039b\ninst\u271d : ConNF.LeLevel \u2191\u03b2\n\u03c7 : ConNF.CodingFunction \u03b2\nS : ConNF.Support \u2191\u03b2\n\u22a2 S \u2208 \u03c7 \u2194 (\u03c7.decode S).Dom", "dependency": [1, 402, 403, 58]}, "ConNF.CodingFunction.mem_iff_of_mem": {"natural_language_statement": "Given a `CodingFunction` \u03c7 and two `Support`s S and T in the context of Constructive Ordinal Notation (ConNF), this theorem states that T is in the domain of \u03c7 if and only if there exists an `Allowable` \u03c1 such that T is the image of S under the action of \u03c1. This theorem is crucial for proving the bijectivity of the coding function.", "formal_statement": "example [ConNF.Params ] [ConNF.Level] [ConNF.FOAAssumptions] {\u03b2 : ConNF.\u039b} [ConNF.LeLevel \u2191\u03b2] {\u03c7 : ConNF.CodingFunction \u03b2} {S : ConNF.Support \u2191\u03b2} {T : ConNF.Support \u2191\u03b2} (h : S \u2208 \u03c7) :T \u2208 \u03c7 \u2194 \u2203 (\u03c1 : ConNF.Allowable \u2191\u03b2), T = \u03c1 \u2022 S := by sorry", "full_tactic_state": "inst\u271d\u00b3 : ConNF.Params\ninst\u271d\u00b2 : ConNF.Level\ninst\u271d\u00b9 : ConNF.FOAAssumptions\n\u03b2 : ConNF.\u039b\ninst\u271d : ConNF.LeLevel \u2191\u03b2\n\u03c7 : ConNF.CodingFunction \u03b2\nS T : ConNF.Support \u2191\u03b2\nh : S \u2208 \u03c7\n\u22a2 T \u2208 \u03c7 \u2194 \u2203 \u03c1, T = \u03c1 \u2022 S", "dependency": [1, 402, 403, 58, 58]}, "ConNF.CodingFunction.smul_mem": {"natural_language_statement": "In the context of Constructive Ordinal Notation (ConNF), given a type index `\u03b2` that is less than or equal to the type index `\u03b1`, a `CodingFunction` `\u03c7` with domain `S`, and an `Allowable` `\u03c1`, the theorem `smul_mem` ensures that the scaling of `S` by `\u03c1` results in another element within the domain of `\u03c7`. This property is crucial for establishing the correctness of the ConNF construction.", "formal_statement": "example [ConNF.Params ] [ConNF.Level] [ConNF.FOAAssumptions] {\u03b2 : ConNF.\u039b} [ConNF.LeLevel \u2191\u03b2] {\u03c7 : ConNF.CodingFunction \u03b2} {S : ConNF.Support \u2191\u03b2} (\u03c1 : ConNF.Allowable \u2191\u03b2) (h : S \u2208 \u03c7) :\u03c1 \u2022 S \u2208 \u03c7 := by sorry", "full_tactic_state": "inst\u271d\u00b3 : ConNF.Params\ninst\u271d\u00b2 : ConNF.Level\ninst\u271d\u00b9 : ConNF.FOAAssumptions\n\u03b2 : ConNF.\u039b\ninst\u271d : ConNF.LeLevel \u2191\u03b2\n\u03c7 : ConNF.CodingFunction \u03b2\nS : ConNF.Support \u2191\u03b2\n\u03c1 : ConNF.Allowable \u2191\u03b2\nh : S \u2208 \u03c7\n\u22a2 \u03c1 \u2022 S \u2208 \u03c7", "dependency": [1, 402, 403, 58]}, "ConNF.CodingFunction.mem_of_smul_mem": {"natural_language_statement": "In the context of Constructive Ordinal Notation (ConNF), the theorem `ConNF.CodingFunction.mem_of_smul_mem` asserts that for any `CodingFunction` `\u03c7` at level `\u03b2`, if `\u03c1 \u2022 S` (where `\u03c1` is an `Allowable` and `S` is a `Support`) is in the domain of `\u03c7`, then `S` itself must also be in the domain of `\u03c7`.", "formal_statement": "example [ConNF.Params ] [ConNF.Level] [ConNF.FOAAssumptions] {\u03b2 : ConNF.\u039b} [ConNF.LeLevel \u2191\u03b2] {\u03c7 : ConNF.CodingFunction \u03b2} {S : ConNF.Support \u2191\u03b2} {\u03c1 : ConNF.Allowable \u2191\u03b2} (h : \u03c1 \u2022 S \u2208 \u03c7) :S \u2208 \u03c7 := by sorry", "full_tactic_state": "inst\u271d\u00b3 : ConNF.Params\ninst\u271d\u00b2 : ConNF.Level\ninst\u271d\u00b9 : ConNF.FOAAssumptions\n\u03b2 : ConNF.\u039b\ninst\u271d : ConNF.LeLevel \u2191\u03b2\n\u03c7 : ConNF.CodingFunction \u03b2\nS : ConNF.Support \u2191\u03b2\n\u03c1 : ConNF.Allowable \u2191\u03b2\nh : \u03c1 \u2022 S \u2208 \u03c7\n\u22a2 S \u2208 \u03c7", "dependency": [1, 402, 403, 58]}, "ConNF.CodingFunction.exists_mem": {"natural_language_statement": "In the context of Constructive Ordinal Notation (ConNF), a `CodingFunction` is a structure that represents a partial function from `Support \u03b2` to `Tangle \u03b2`, where `\u03b2` is a type index in the context of ConNF. The structure ensures that the domain of this partial function is nonempty, and that it satisfies certain properties related to the action of `Allowable \u03b2` on `Support \u03b2`. The theorem `ConNF.CodingFunction.exists_mem` states that for any `CodingFunction` `\u03c7`, there exists a `Support` `S` that is a member of `\u03c7`.", "formal_statement": "example [ConNF.Params ] [ConNF.Level] [ConNF.FOAAssumptions] {\u03b2 : ConNF.\u039b} [ConNF.LeLevel \u2191\u03b2] (\u03c7 : ConNF.CodingFunction \u03b2) :\u2203 (S : ConNF.Support \u2191\u03b2), S \u2208 \u03c7 := by sorry", "full_tactic_state": "inst\u271d\u00b3 : ConNF.Params\ninst\u271d\u00b2 : ConNF.Level\ninst\u271d\u00b9 : ConNF.FOAAssumptions\n\u03b2 : ConNF.\u039b\ninst\u271d : ConNF.LeLevel \u2191\u03b2\n\u03c7 : ConNF.CodingFunction \u03b2\n\u22a2 \u2203 S, S \u2208 \u03c7", "dependency": [1, 402, 403, 58]}, "ConNF.CodingFunction.supports_decode": {"natural_language_statement": "The `ConNF.CodingFunction.supports_decode` theorem states that for each `\u03b2` (a type index in the context of Constructive Ordinal Notation, ConNF) and for each `CodingFunction` `\u03c7` defined on `\u03b2`, if `S` is a `ConNF.Support` (a function from an initial segment of `\u03ba` to the type of addresses in ConNF), and if `S` is an element of `\u03c7`, then the action of `ConNF.Allowable \u2191\u03b2` (the set of allowable ordinals at level `\u03b2`) supports (`MulAction.Supports`) the `ConNF.Enumeration.carrier` (the set of elements `c` of type `\u03b1` that can be expressed as `S.enum.f i h` for some `i < S.enum.max`) of `S.enum` (an `\u03b1`-enumeration defined by `S`).", "formal_statement": "example [ConNF.Params ] [ConNF.Level] [ConNF.FOAAssumptions] {\u03b2 : ConNF.\u039b} [ConNF.LeLevel \u2191\u03b2] {\u03c7 : ConNF.CodingFunction \u03b2} (S : ConNF.Support \u2191\u03b2) (hS : S \u2208 \u03c7) :MulAction.Supports (ConNF.Allowable \u2191\u03b2) (ConNF.Enumeration.carrier S.enum) ((\u03c7.decode S).get hS) := by sorry", "full_tactic_state": "inst\u271d\u00b3 : ConNF.Params\ninst\u271d\u00b2 : ConNF.Level\ninst\u271d\u00b9 : ConNF.FOAAssumptions\n\u03b2 : ConNF.\u039b\ninst\u271d : ConNF.LeLevel \u2191\u03b2\n\u03c7 : ConNF.CodingFunction \u03b2\nS : ConNF.Support \u2191\u03b2\nhS : S \u2208 \u03c7\n\u22a2 MulAction.Supports (ConNF.Allowable \u2191\u03b2) (ConNF.Enumeration.carrier S.enum) ((\u03c7.decode S).get hS)", "dependency": [1, 402, 403, 58, 68, 70]}, "ConNF.CodingFunction.ext": {"natural_language_statement": "In the context of Constructive Ordinal Notation (ConNF), a `CodingFunction` is a structure that represents a partial function from `Support \u03b2` to `Tangle \u03b2`, where `\u03b2` is a type index in the context of ConNF. This theorem states that two `CodingFunction`s are equal if they decode a single ordered support to the same tangle.", "formal_statement": "example [ConNF.Params ] [ConNF.Level] [ConNF.FOAAssumptions] {\u03b2 : ConNF.\u039b} [ConNF.LeLevel \u2191\u03b2] {\u03c7\u2081 : ConNF.CodingFunction \u03b2} {\u03c7\u2082 : ConNF.CodingFunction \u03b2} (S : ConNF.Support \u2191\u03b2) (h\u2081 : S \u2208 \u03c7\u2081) (h\u2082 : S \u2208 \u03c7\u2082) (h : (\u03c7\u2081.decode S).get h\u2081 = (\u03c7\u2082.decode S).get h\u2082) :\u03c7\u2081 = \u03c7\u2082 := by sorry", "full_tactic_state": "inst\u271d\u00b3 : ConNF.Params\ninst\u271d\u00b2 : ConNF.Level\ninst\u271d\u00b9 : ConNF.FOAAssumptions\n\u03b2 : ConNF.\u039b\ninst\u271d : ConNF.LeLevel \u2191\u03b2\n\u03c7\u2081 \u03c7\u2082 : ConNF.CodingFunction \u03b2\nS : ConNF.Support \u2191\u03b2\nh\u2081 : S \u2208 \u03c7\u2081\nh\u2082 : S \u2208 \u03c7\u2082\nh : (\u03c7\u2081.decode S).get h\u2081 = (\u03c7\u2082.decode S).get h\u2082\n\u22a2 \u03c7\u2081 = \u03c7\u2082", "dependency": [1, 402, 403, 403, 58]}, "ConNF.CodingFunction.smul_supports": {"natural_language_statement": "In the context of Constructive Ordinal Notation (ConNF), the theorem `ConNF.CodingFunction.smul_supports` states that if a set `s` supports an element `b` under the action of a monoid `G`, and `\u03c1` is an element of `G`, then `\u03c1 \u2022 s` also supports `\u03c1 \u2022 b` under the same action.", "formal_statement": "example [ConNF.Params ] [ConNF.Level] [ConNF.FOAAssumptions] {\u03b2 : ConNF.\u039b} [ConNF.LeLevel \u2191\u03b2] {S : ConNF.Support \u2191\u03b2} {t : ConNF.Tangle \u2191\u03b2} (h : MulAction.Supports (ConNF.Allowable \u2191\u03b2) (ConNF.Enumeration.carrier S.enum) t) (\u03c1 : ConNF.Allowable \u2191\u03b2) :MulAction.Supports (ConNF.Allowable \u2191\u03b2) (ConNF.Enumeration.carrier (\u03c1 \u2022 S).enum) (\u03c1 \u2022 t) := by sorry", "full_tactic_state": "inst\u271d\u00b3 : ConNF.Params\ninst\u271d\u00b2 : ConNF.Level\ninst\u271d\u00b9 : ConNF.FOAAssumptions\n\u03b2 : ConNF.\u039b\ninst\u271d : ConNF.LeLevel \u2191\u03b2\nS : ConNF.Support \u2191\u03b2\nt : ConNF.Tangle \u2191\u03b2\nh : MulAction.Supports (ConNF.Allowable \u2191\u03b2) (ConNF.Enumeration.carrier S.enum) t\n\u03c1 : ConNF.Allowable \u2191\u03b2\n\u22a2 MulAction.Supports (ConNF.Allowable \u2191\u03b2) (ConNF.Enumeration.carrier (\u03c1 \u2022 S).enum) (\u03c1 \u2022 t)", "dependency": [1, 402, 58, 68, 70, 68, 70]}, "ConNF.CodingFunction.decode_congr": {"natural_language_statement": "In the context of Constructive Ordinal Notation (ConNF), a `CodingFunction` is a structure that represents a partial function from `Support \u03b2` to `Tangle \u03b2`, where `\u03b2` is a type index in the context of ConNF. The structure ensures that the domain of this partial function is nonempty, and that it satisfies certain properties related to the action of `Allowable \u03b2` on `Support \u03b2`. The theorem `ConNF.CodingFunction.decode_congr` states that for any two `CodingFunction`s `\u03c7` with supports `S\u2081` and `S\u2082`, if `S\u2081` and `S\u2082` are equal, then the decodings of `S\u2081` and `S\u2082` are also equal.", "formal_statement": "example [ConNF.Params ] [ConNF.Level] [ConNF.FOAAssumptions] {\u03b2 : ConNF.\u039b} [ConNF.LeLevel \u2191\u03b2] {\u03c7 : ConNF.CodingFunction \u03b2} {S\u2081 : ConNF.Support \u2191\u03b2} {S\u2082 : ConNF.Support \u2191\u03b2} {h\u2081 : S\u2081 \u2208 \u03c7} {h\u2082 : S\u2082 \u2208 \u03c7} (h : S\u2081 = S\u2082) :(\u03c7.decode S\u2081).get h\u2081 = (\u03c7.decode S\u2082).get h\u2082 := by sorry", "full_tactic_state": "inst\u271d\u00b3 : ConNF.Params\ninst\u271d\u00b2 : ConNF.Level\ninst\u271d\u00b9 : ConNF.FOAAssumptions\n\u03b2 : ConNF.\u039b\ninst\u271d : ConNF.LeLevel \u2191\u03b2\n\u03c7 : ConNF.CodingFunction \u03b2\nS\u2081 S\u2082 : ConNF.Support \u2191\u03b2\nh\u2081 : S\u2081 \u2208 \u03c7\nh\u2082 : S\u2082 \u2208 \u03c7\nh : S\u2081 = S\u2082\n\u22a2 (\u03c7.decode S\u2081).get h\u2081 = (\u03c7.decode S\u2082).get h\u2082", "dependency": [1, 402, 403, 58, 58]}, "ConNF.CodingFunction.code_decode": {"natural_language_statement": "In the context of Constructive Ordinal Notation (ConNF), the theorem `ConNF.CodingFunction.code_decode` states that for any ordered support `S` and tangle `t` that it supports, the decoding of the coding function `ConNF.CodingFunction.code S t h` with respect to `S` yields a partial value that is defined and equals `t`.", "formal_statement": "@[simp]example [ConNF.Params ] [ConNF.Level] [ConNF.FOAAssumptions] {\u03b2 : ConNF.\u039b} [ConNF.LeLevel \u2191\u03b2] (S : ConNF.Support \u2191\u03b2) (t : ConNF.Tangle \u2191\u03b2) (h : MulAction.Supports (ConNF.Allowable \u2191\u03b2) (ConNF.Enumeration.carrier S.enum) t) :(ConNF.CodingFunction.code S t h).decode S = Part.some t := by sorry", "full_tactic_state": "inst\u271d\u00b3 : ConNF.Params\ninst\u271d\u00b2 : ConNF.Level\ninst\u271d\u00b9 : ConNF.FOAAssumptions\n\u03b2 : ConNF.\u039b\ninst\u271d : ConNF.LeLevel \u2191\u03b2\nS : ConNF.Support \u2191\u03b2\nt : ConNF.Tangle \u2191\u03b2\nh : MulAction.Supports (ConNF.Allowable \u2191\u03b2) (ConNF.Enumeration.carrier S.enum) t\n\u22a2 (ConNF.CodingFunction.code S t h).decode S = Part.some t", "dependency": [1, 402, 58, 68, 70, 414, 415]}, "ConNF.CodingFunction.mem_code_self": {"natural_language_statement": "In the context of Constructive Ordinal Notation (ConNF), a `CodingFunction` is a structure that represents a partial function from `Support \u03b2` to `Tangle \u03b2`, where `\u03b2` is a type index in the context of ConNF. The structure ensures that the domain of this partial function is nonempty, and that it satisfies certain properties related to the action of `Allowable \u03b2` on `Support \u03b2`. The function `ConNF.CodingFunction.code` produces such a coding function for a given ordered support and tangle it supports. The theorem `ConNF.CodingFunction.mem_code_self` states that for any ordered support `S` and tangle `t` it supports, the ordered support `S` is in the domain of the coding function produced by `ConNF.CodingFunction.code S t h`.", "formal_statement": "@[simp]example [ConNF.Params ] [ConNF.Level] [ConNF.FOAAssumptions] {\u03b2 : ConNF.\u039b} [ConNF.LeLevel \u2191\u03b2] {S : ConNF.Support \u2191\u03b2} {t : ConNF.Tangle \u2191\u03b2} {h : MulAction.Supports (ConNF.Allowable \u2191\u03b2) (ConNF.Enumeration.carrier S.enum) t} :S \u2208 ConNF.CodingFunction.code S t h := by sorry", "full_tactic_state": "inst\u271d\u00b3 : ConNF.Params\ninst\u271d\u00b2 : ConNF.Level\ninst\u271d\u00b9 : ConNF.FOAAssumptions\n\u03b2 : ConNF.\u039b\ninst\u271d : ConNF.LeLevel \u2191\u03b2\nS : ConNF.Support \u2191\u03b2\nt : ConNF.Tangle \u2191\u03b2\nh : MulAction.Supports (ConNF.Allowable \u2191\u03b2) (ConNF.Enumeration.carrier S.enum) t\n\u22a2 S \u2208 ConNF.CodingFunction.code S t h", "dependency": [1, 402, 58, 68, 70, 414]}, "ConNF.CodingFunction.mem_code": {"natural_language_statement": "In the context of Constructive Ordinal Notation (ConNF), a `CodingFunction` is a structure that represents a partial function from `Support \u03b2` to `Tangle \u03b2`, where `\u03b2` is a type index in the context of ConNF. The structure ensures that the domain of this partial function is nonempty, and that it satisfies certain properties related to the action of `Allowable \u03b2` on `Support \u03b2`. The function `ConNF.CodingFunction.mem_code` produces such a coding function for a given ordered support and tangle it supports.", "formal_statement": "@[simp]example [ConNF.Params ] [ConNF.Level] [ConNF.FOAAssumptions] {\u03b2 : ConNF.\u039b} [ConNF.LeLevel \u2191\u03b2] {S : ConNF.Support \u2191\u03b2} {t : ConNF.Tangle \u2191\u03b2} {h : MulAction.Supports (ConNF.Allowable \u2191\u03b2) (ConNF.Enumeration.carrier S.enum) t} (T : ConNF.Support \u2191\u03b2) :T \u2208 ConNF.CodingFunction.code S t h \u2194 \u2203 (\u03c1 : ConNF.Allowable \u2191\u03b2), T = \u03c1 \u2022 S := by sorry", "full_tactic_state": "inst\u271d\u00b3 : ConNF.Params\ninst\u271d\u00b2 : ConNF.Level\ninst\u271d\u00b9 : ConNF.FOAAssumptions\n\u03b2 : ConNF.\u039b\ninst\u271d : ConNF.LeLevel \u2191\u03b2\nS : ConNF.Support \u2191\u03b2\nt : ConNF.Tangle \u2191\u03b2\nh : MulAction.Supports (ConNF.Allowable \u2191\u03b2) (ConNF.Enumeration.carrier S.enum) t\nT : ConNF.Support \u2191\u03b2\n\u22a2 T \u2208 ConNF.CodingFunction.code S t h \u2194 \u2203 \u03c1, T = \u03c1 \u2022 S", "dependency": [1, 402, 58, 68, 70, 58, 414]}, "ConNF.CodingFunction.code_smul": {"natural_language_statement": "In the context of Constructive Ordinal Notation (ConNF), given an ordered support S and a tangle t supported by S, and an allowable \u03c1 that stabilizes the enumeration of S, the coding function from S to t will be the same as the coding function from \u03c1 \u2022 S to \u03c1 \u2022 t. This means that if an allowable permutation \u03c1 stabilizes the enumeration of the support S, then it also stabilizes the coding function.", "formal_statement": "example [ConNF.Params ] [ConNF.Level] [ConNF.FOAAssumptions] {\u03b2 : ConNF.\u039b} [ConNF.LeLevel \u2191\u03b2] (S : ConNF.Support \u2191\u03b2) (t : ConNF.Tangle \u2191\u03b2) (\u03c1 : ConNF.Allowable \u2191\u03b2) (h\u2081 : MulAction.Supports (ConNF.Allowable \u2191\u03b2) (ConNF.Enumeration.carrier (\u03c1 \u2022 S).enum) (\u03c1 \u2022 t)) (h\u2082 : MulAction.Supports (ConNF.Allowable \u2191\u03b2) (ConNF.Enumeration.carrier S.enum) t) :ConNF.CodingFunction.code (\u03c1 \u2022 S) (\u03c1 \u2022 t) h\u2081 = ConNF.CodingFunction.code S t h\u2082 := by sorry", "full_tactic_state": "inst\u271d\u00b3 : ConNF.Params\ninst\u271d\u00b2 : ConNF.Level\ninst\u271d\u00b9 : ConNF.FOAAssumptions\n\u03b2 : ConNF.\u039b\ninst\u271d : ConNF.LeLevel \u2191\u03b2\nS : ConNF.Support \u2191\u03b2\nt : ConNF.Tangle \u2191\u03b2\n\u03c1 : ConNF.Allowable \u2191\u03b2\nh\u2081 : MulAction.Supports (ConNF.Allowable \u2191\u03b2) (ConNF.Enumeration.carrier (\u03c1 \u2022 S).enum) (\u03c1 \u2022 t)\nh\u2082 : MulAction.Supports (ConNF.Allowable \u2191\u03b2) (ConNF.Enumeration.carrier S.enum) t\n\u22a2 ConNF.CodingFunction.code (\u03c1 \u2022 S) (\u03c1 \u2022 t) h\u2081 = ConNF.CodingFunction.code S t h\u2082", "dependency": [1, 402, 58, 68, 70, 68, 70, 414, 414]}, "ConNF.Spec.Specifies.smul": {"natural_language_statement": "The theorem `ConNF.Spec.Specifies.smul` asserts that the action of a scaling factor \u03c1 on a ConNF.Spec object \u03c3, represented by the operator `\u03c1 \u2022 S`, results in another ConNF.Spec object that specifies the same natural number as the original object \u03c3. This property is essential for ensuring that the construction of natural numbers in the context of ConNF is well-defined and consistent with the arithmetic operations.", "formal_statement": "example [ConNF.Params ] [ConNF.Level] [ConNF.FOAAssumptions] {\u03b2 : ConNF.\u039b} [i : ConNF.LeLevel \u2191\u03b2] {\u03c3 : ConNF.Spec \u03b2} {S : ConNF.Support \u2191\u03b2} (h : ConNF.Spec.Specifies \u03c3 S) (\u03c1 : ConNF.Allowable \u2191\u03b2) :ConNF.Spec.Specifies \u03c3 (\u03c1 \u2022 S) := by sorry", "full_tactic_state": "inst\u271d\u00b2 : ConNF.Params\ninst\u271d\u00b9 : ConNF.Level\ninst\u271d : ConNF.FOAAssumptions\n\u03b2 : ConNF.\u039b\ni : ConNF.LeLevel \u2191\u03b2\n\u03c3 : ConNF.Spec \u03b2\nS : ConNF.Support \u2191\u03b2\nh : ConNF.Spec.Specifies \u03c3 S\n\u03c1 : ConNF.Allowable \u2191\u03b2\n\u22a2 ConNF.Spec.Specifies \u03c3 (\u03c1 \u2022 S)", "dependency": [1, 402, 421, 58, 422, 422]}, "ConNF.NearLitterPerm.atomPerm_injective": {"natural_language_statement": "The theorem `ConNF.NearLitterPerm.atomPerm_injective` states that the map from the type of near-litter permutations to the type of permutations of atoms is injective. This means that if two near-litter permutations have the same action on atoms, they are equal.", "formal_statement": "example [ConNF.Params ] :Function.Injective ConNF.NearLitterPerm.atomPerm := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u22a2 Function.Injective ConNF.NearLitterPerm.atomPerm", "dependency": [1, 89]}, "ConNF.NearLitterPerm.ext": {"natural_language_statement": "The theorem `ConNF.NearLitterPerm.ext` is an extensionality result for near-litter permutations. It states that if two near-litter permutations have the same action on atoms, they are equal.", "formal_statement": "example [ConNF.Params ] {\u03c0 : ConNF.NearLitterPerm} {\u03c0' : ConNF.NearLitterPerm} (h : \u03c0.atomPerm = \u03c0'.atomPerm) :\u03c0 = \u03c0' := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03c0 \u03c0' : ConNF.NearLitterPerm\nh : \u03c0.atomPerm = \u03c0'.atomPerm\n\u22a2 \u03c0 = \u03c0'", "dependency": [1]}, "ConNF.NearLitterPerm.atomPerm_hMul": {"natural_language_statement": "The theorem `ConNF.NearLitterPerm.atomPerm_hMul` states that the atom permutation of the product of two near litter permutations is equal to the product of their atom permutations.", "formal_statement": "@[simp]example [ConNF.Params ] (\u03c0 : ConNF.NearLitterPerm) (\u03c0' : ConNF.NearLitterPerm) :(\u03c0 * \u03c0').atomPerm = \u03c0.atomPerm * \u03c0'.atomPerm := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03c0 \u03c0' : ConNF.NearLitterPerm\n\u22a2 (\u03c0 * \u03c0').atomPerm = \u03c0.atomPerm * \u03c0'.atomPerm", "dependency": [1]}, "ConNF.NearLitterPerm.atomPerm_div": {"natural_language_statement": "The theorem `ConNF.NearLitterPerm.atomPerm_div` states that the atom permutation of the division of two near litter permutations is equal to the division of their atom permutations.", "formal_statement": "@[simp]example [ConNF.Params ] (\u03c0 : ConNF.NearLitterPerm) (\u03c0' : ConNF.NearLitterPerm) :(\u03c0 / \u03c0').atomPerm = \u03c0.atomPerm / \u03c0'.atomPerm := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03c0 \u03c0' : ConNF.NearLitterPerm\n\u22a2 (\u03c0 / \u03c0').atomPerm = \u03c0.atomPerm / \u03c0'.atomPerm", "dependency": [1]}, "ConNF.NearLitterPerm.atomPerm_pow": {"natural_language_statement": "The theorem `ConNF.NearLitterPerm.atomPerm_pow` states that for a near litter permutation `\u03c0` and a natural number `n`, the `atomPerm` of `\u03c0` raised to the power `n` is equal to the `atomPerm` of `\u03c0` raised to the power `n`.", "formal_statement": "@[simp]example [ConNF.Params ] (\u03c0 : ConNF.NearLitterPerm) (n : \u2115 ) :(\u03c0 ^ n).atomPerm = \u03c0.atomPerm ^ n := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03c0 : ConNF.NearLitterPerm\nn : \u2115\n\u22a2 (\u03c0 ^ n).atomPerm = \u03c0.atomPerm ^ n", "dependency": [1]}, "ConNF.NearLitterPerm.atomPerm_zpow": {"natural_language_statement": "The theorem `ConNF.NearLitterPerm.atomPerm_zpow` states that for any near litter permutation `\u03c0` and any integer `n`, the atom permutation of `\u03c0` raised to the power `n` is equal to the atom permutation of `\u03c0` raised to the power `n`.", "formal_statement": "@[simp]example [ConNF.Params ] (\u03c0 : ConNF.NearLitterPerm) (n : \u2124 ) :(\u03c0 ^ n).atomPerm = \u03c0.atomPerm ^ n := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03c0 : ConNF.NearLitterPerm\nn : \u2124\n\u22a2 (\u03c0 ^ n).atomPerm = \u03c0.atomPerm ^ n", "dependency": [1]}, "ConNF.NearLitterPerm.litterPerm_hMul": {"natural_language_statement": "The theorem `ConNF.NearLitterPerm.litterPerm_hMul` states that the multiplication of two near litter permutations `\u03c0` and `\u03c0'` results in a near litter permutation whose litter permutation is the product of the litter permutations of `\u03c0` and `\u03c0'`.", "formal_statement": "@[simp]example [ConNF.Params ] (\u03c0 : ConNF.NearLitterPerm) (\u03c0' : ConNF.NearLitterPerm) :(\u03c0 * \u03c0').litterPerm = \u03c0.litterPerm * \u03c0'.litterPerm := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03c0 \u03c0' : ConNF.NearLitterPerm\n\u22a2 (\u03c0 * \u03c0').litterPerm = \u03c0.litterPerm * \u03c0'.litterPerm", "dependency": [1]}, "ConNF.NearLitterPerm.litterPerm_div": {"natural_language_statement": "The theorem `ConNF.NearLitterPerm.litterPerm_div` states that for two near litter permutations `\u03c0` and `\u03c0'`, the litter permutation of their quotient `\u03c0 / \u03c0'` is equal to the quotient of their litter permutations `\u03c0.litterPerm / \u03c0'.litterPerm`.", "formal_statement": "@[simp]example [ConNF.Params ] (\u03c0 : ConNF.NearLitterPerm) (\u03c0' : ConNF.NearLitterPerm) :(\u03c0 / \u03c0').litterPerm = \u03c0.litterPerm / \u03c0'.litterPerm := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03c0 \u03c0' : ConNF.NearLitterPerm\n\u22a2 (\u03c0 / \u03c0').litterPerm = \u03c0.litterPerm / \u03c0'.litterPerm", "dependency": [1]}, "ConNF.NearLitterPerm.litterPerm_pow": {"natural_language_statement": "The theorem `ConNF.NearLitterPerm.litterPerm_pow` states that for a near litter permutation `\u03c0` and a natural number `n`, the `litterPerm` of `\u03c0` raised to the power `n` is equal to the `litterPerm` of `\u03c0` raised to the power `n`.", "formal_statement": "@[simp]example [ConNF.Params ] (\u03c0 : ConNF.NearLitterPerm) (n : \u2115 ) :(\u03c0 ^ n).litterPerm = \u03c0.litterPerm ^ n := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03c0 : ConNF.NearLitterPerm\nn : \u2115\n\u22a2 (\u03c0 ^ n).litterPerm = \u03c0.litterPerm ^ n", "dependency": [1]}, "ConNF.NearLitterPerm.litterPerm_zpow": {"natural_language_statement": "The theorem `ConNF.NearLitterPerm.litterPerm_zpow` states that for a near litter permutation `\u03c0` and an integer `n`, the `litterPerm` of `\u03c0` raised to the power `n` is equal to the `litterPerm` of `\u03c0` raised to the power `n`.", "formal_statement": "@[simp]example [ConNF.Params ] (\u03c0 : ConNF.NearLitterPerm) (n : \u2124 ) :(\u03c0 ^ n).litterPerm = \u03c0.litterPerm ^ n := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03c0 : ConNF.NearLitterPerm\nn : \u2124\n\u22a2 (\u03c0 ^ n).litterPerm = \u03c0.litterPerm ^ n", "dependency": [1]}, "ConNF.NearLitterPerm.smul_nearLitter_fst": {"natural_language_statement": "The theorem `ConNF.NearLitterPerm.smul_nearLitter_fst` states that for any near-litter permutation `\u03c0` and near-litter `N`, the first component of the near-litter permutation action on `N` is equal to the action of `\u03c0` on the first component of `N`.", "formal_statement": "@[simp]example [ConNF.Params ] (\u03c0 : ConNF.NearLitterPerm) (N : ConNF.NearLitter) :(\u03c0 \u2022 N).fst = \u03c0 \u2022 N.fst := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03c0 : ConNF.NearLitterPerm\nN : ConNF.NearLitter\n\u22a2 (\u03c0 \u2022 N).fst = \u03c0 \u2022 N.fst", "dependency": [1]}, "ConNF.NearLitterPerm.smul_nearLitter_coe_preimage": {"natural_language_statement": "The theorem `ConNF.NearLitterPerm.smul_nearLitter_coe_preimage` states that for any near-litter permutation `\u03c0` and near-litter `N`, the set of atoms in the near-litter `\u03c0 \u2022 N` is the preimage of the set of atoms in `N` under the inverse of the atom permutation of `\u03c0`.", "formal_statement": "example [ConNF.Params ] (\u03c0 : ConNF.NearLitterPerm) (N : ConNF.NearLitter) :\u2191(\u03c0 \u2022 N) = \u21d1\u03c0.atomPerm\u207b\u00b9 \u207b\u00b9' \u2191N := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03c0 : ConNF.NearLitterPerm\nN : ConNF.NearLitter\n\u22a2 \u2191(\u03c0 \u2022 N) = \u21d1\u03c0.atomPerm\u207b\u00b9 \u207b\u00b9' \u2191N", "dependency": [1]}, "ConNF.NearLitterPerm.smul_nearLitter_coe": {"natural_language_statement": "The theorem `ConNF.NearLitterPerm.smul_nearLitter_coe` states that the action of a near-litter permutation on a near-litter is consistent with the pointwise action on its atoms.", "formal_statement": "example [ConNF.Params ] (\u03c0 : ConNF.NearLitterPerm) (N : ConNF.NearLitter) :\u2191(\u03c0 \u2022 N) = \u03c0 \u2022 \u2191N := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03c0 : ConNF.NearLitterPerm\nN : ConNF.NearLitter\n\u22a2 \u03c0 \u2022 N = \u03c0 \u2022 N", "dependency": [1]}, "ConNF.mk_litter": {"natural_language_statement": "In the context of Constructive Ordinal Notation (ConNF), the number of litters is equal to the cardinality of the type `\u03bc`.", "formal_statement": "@[simp]example [ConNF.Params ] :Cardinal.mk ConNF.Litter = Cardinal.mk ConNF.\u03bc := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u22a2 Cardinal.mk ConNF.Litter = Cardinal.mk ConNF.\u03bc", "dependency": [1, 29, 29]}, "ConNF.Small.lt": {"natural_language_statement": "The theorem `ConNF.Small.lt` states that if the cardinality of a set `s` is strictly less than the cardinality of the type `ConNF.\u03ba`, then the cardinality of `s` is less than the cardinality of `ConNF.\u03ba`.", "formal_statement": "example [ConNF.Params ] {\u03b1 : Type u} {s : Set \u03b1} :ConNF.Small s \u2192 Cardinal.mk \u2191s < Cardinal.mk ConNF.\u03ba := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03b1 : Type u\ns : Set \u03b1\n\u22a2 ConNF.Small s \u2192 Cardinal.mk \u2191s < Cardinal.mk ConNF.\u03ba", "dependency": [1, 69, 233, 29, 29]}, "ConNF.Set.Subsingleton.small": {"natural_language_statement": "In the context of Constructive Ordinal Notation (ConNF), if a set `s` is a `Subsingleton`, meaning it contains at most one element, then the cardinality of `s` is strictly less than the cardinality of the type `ConNF.\u03ba`.", "formal_statement": "example [ConNF.Params ] {\u03b1 : Type u} {s : Set \u03b1} (hs : Set.Subsingleton s) :ConNF.Small s := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03b1 : Type u\ns : Set \u03b1\nhs : Set.Subsingleton s\n\u22a2 ConNF.Small s", "dependency": [1, 69, 115, 233]}, "ConNF.small_singleton": {"natural_language_statement": "The theorem `ConNF.small_singleton` states that the cardinality of a singleton set is strictly less than the cardinality of the type `ConNF.\u03ba` in the context of Constructive Ordinal Notation (ConNF).", "formal_statement": "@[simp]example [ConNF.Params ] {\u03b1 : Type u} (x : \u03b1) :ConNF.Small {x} := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03b1 : Type u\nx : \u03b1\n\u22a2 ConNF.Small {x}", "dependency": [1, 233]}, "ConNF.small_setOf": {"natural_language_statement": "The theorem `ConNF.small_setOf` states that in the context of Constructive Ordinal Notation (ConNF), the cardinality of a set defined by a predicate is strictly less than the cardinality of the type `ConNF.\u03ba` if and only if the cardinality of the set of elements satisfying the predicate is strictly less than the cardinality of `ConNF.\u03ba`.", "formal_statement": "example [ConNF.Params ] {\u03b1 : Type u} (p : \u03b1 \u2192 Prop ) :(ConNF.Small fun (a : \u03b1) => p a) \u2194 ConNF.Small {a : \u03b1 | p a} := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03b1 : Type u\np : \u03b1 \u2192 Prop\n\u22a2 (ConNF.Small fun a => p a) \u2194 ConNF.Small {a | p a}", "dependency": [1, 233, 233]}, "ConNF.small_of_forall_not_mem": {"natural_language_statement": "The theorem `ConNF.small_of_forall_not_mem` states that if every element of a type `\u03b1` does not belong to a set `s`, then the set `s` is considered \"small\" in the context of Constructive Ordinal Notation (ConNF), meaning its cardinality is strictly less than the cardinality of the type `ConNF.\u03ba`.", "formal_statement": "example [ConNF.Params ] {\u03b1 : Type u} {s : Set \u03b1} (h : \u2200 (x : \u03b1), x \u2209 s) :ConNF.Small s := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03b1 : Type u\ns : Set \u03b1\nh : \u2200 (x : \u03b1), x \u2209 s\n\u22a2 ConNF.Small s", "dependency": [1, 69, 233]}, "ConNF.Small.mono": {"natural_language_statement": "In the context of Constructive Ordinal Notation (ConNF), a set is considered \"small\" if its cardinality is strictly less than the cardinality of the type `ConNF.\u03ba`. The theorem `ConNF.Small.mono` states that if a set `s` is a subset of another set `t`, and `t` is known to be small, then `s` must also be small. This property is known as the monotonicity of the smallness relation.", "formal_statement": "example [ConNF.Params ] {\u03b1 : Type u} {s : Set \u03b1} {t : Set \u03b1} (h : s \u2286 t) :ConNF.Small t \u2192 ConNF.Small s := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03b1 : Type u\ns t : Set \u03b1\nh : s \u2286 t\n\u22a2 ConNF.Small t \u2192 ConNF.Small s", "dependency": [1, 69, 69, 233, 233]}, "ConNF.Small.union": {"natural_language_statement": "In the context of Constructive Ordinal Notation (ConNF), the theorem `ConNF.Small.union` states that the union of two sets, each of which has a cardinality strictly less than the cardinality of the type `ConNF.\u03ba`, also has a cardinality strictly less than the cardinality of `ConNF.\u03ba`.", "formal_statement": "example [ConNF.Params ] {\u03b1 : Type u} {s : Set \u03b1} {t : Set \u03b1} (hs : ConNF.Small s) (ht : ConNF.Small t) :ConNF.Small (s \u222a t) := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03b1 : Type u\ns t : Set \u03b1\nhs : ConNF.Small s\nht : ConNF.Small t\n\u22a2 ConNF.Small (s \u222a t)", "dependency": [1, 69, 69, 233, 233, 233]}, "ConNF.Small.symmDiff": {"natural_language_statement": "`ConNF.Small.symmDiff` is a theorem in Lean 4 that states that the symmetric difference of two sets, each of which has a cardinality strictly less than the cardinality of the type `ConNF.\u03ba`, also has a cardinality strictly less than the cardinality of `ConNF.\u03ba`.", "formal_statement": "example [ConNF.Params ] {\u03b1 : Type u} {s : Set \u03b1} {t : Set \u03b1} (hs : ConNF.Small s) (ht : ConNF.Small t) :ConNF.Small (symmDiff s t) := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03b1 : Type u\ns t : Set \u03b1\nhs : ConNF.Small s\nht : ConNF.Small t\n\u22a2 ConNF.Small (symmDiff s t)", "dependency": [1, 69, 69, 233, 233, 233, 62]}, "ConNF.Small.symmDiff_iff": {"natural_language_statement": "The theorem `ConNF.Small.symmDiff_iff` states that in the context of Constructive Ordinal Notation (ConNF), the symmetric difference of two sets `s` and `t` is small (i.e., its cardinality is strictly less than the cardinality of the type `ConNF.\u03ba`) if and only if both `s` and `t` are small.", "formal_statement": "example [ConNF.Params ] {\u03b1 : Type u} {s : Set \u03b1} {t : Set \u03b1} (hs : ConNF.Small s) :ConNF.Small t \u2194 ConNF.Small (symmDiff s t) := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03b1 : Type u\ns t : Set \u03b1\nhs : ConNF.Small s\n\u22a2 ConNF.Small t \u2194 ConNF.Small (symmDiff s t)", "dependency": [1, 69, 69, 233, 233, 233, 62]}, "ConNF.small_iUnion": {"natural_language_statement": "In the context of Constructive Ordinal Notation (ConNF), the theorem `ConNF.small_iUnion` states that if the cardinality of an index set `\u03b9` is strictly less than the cardinality of the type `ConNF.\u03ba`, and each element of `\u03b9` is mapped to a set whose cardinality is strictly less than the cardinality of `ConNF.\u03ba`, then the cardinality of the union of these sets is also strictly less than the cardinality of `ConNF.\u03ba`.", "formal_statement": "example [ConNF.Params ] {\u03b9 : Type u} {\u03b1 : Type u} (h\u03b9 : Cardinal.mk \u03b9 < Cardinal.mk ConNF.\u03ba) {f : \u03b9 \u2192 Set \u03b1} (hf : \u2200 (i : \u03b9), ConNF.Small (f i)) :ConNF.Small (\u22c3 (i : \u03b9), f i) := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03b9 \u03b1 : Type u\nh\u03b9 : Cardinal.mk \u03b9 < Cardinal.mk ConNF.\u03ba\nf : \u03b9 \u2192 Set \u03b1\nhf : \u2200 (i : \u03b9), ConNF.Small (f i)\n\u22a2 ConNF.Small (\u22c3 i, f i)", "dependency": [1, 29, 29, 69, 233, 233]}, "ConNF.small_iUnion_Prop": {"natural_language_statement": "In the context of Constructive Ordinal Notation (ConNF), the theorem `ConNF.small_iUnion_Prop` states that if the cardinality of each set in a family of sets is strictly less than the cardinality of the type `ConNF.\u03ba`, then the cardinality of the union of these sets is also strictly less than the cardinality of `ConNF.\u03ba`.", "formal_statement": "example [ConNF.Params ] {\u03b1 : Type u} {p : Prop } {f : p \u2192 Set \u03b1} (hf : \u2200 (i : p), ConNF.Small (f i)) :ConNF.Small (\u22c3 (i : p), f i) := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03b1 : Type u\np : Prop\nf : p \u2192 Set \u03b1\nhf : \u2200 (i : p), ConNF.Small (f i)\n\u22a2 ConNF.Small (\u22c3 (i : p), f i)", "dependency": [1, 69, 233, 233]}, "ConNF.Small.bUnion": {"natural_language_statement": "The theorem `ConNF.Small.bUnion` states that if `s` is a set whose cardinality is strictly less than the cardinality of `ConNF.\u03ba`, and for each `i` in `s`, `f i hi` is a set whose cardinality is also strictly less than the cardinality of `ConNF.\u03ba`, then the cardinality of the union of all `f i hi` for `i` in `s` is also strictly less than the cardinality of `ConNF.\u03ba`.", "formal_statement": "example [ConNF.Params ] {\u03b9 : Type u} {\u03b1 : Type u} {s : Set \u03b9} (hs : ConNF.Small s) {f : (i : \u03b9) \u2192 i \u2208 s \u2192 Set \u03b1} (hf : \u2200 (i : \u03b9) (hi : i \u2208 s), ConNF.Small (f i hi)) :ConNF.Small (\u22c3 (i : \u03b9), \u22c3 (hi : i \u2208 s), f i hi) := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03b9 \u03b1 : Type u\ns : Set \u03b9\nhs : ConNF.Small s\nf : (i : \u03b9) \u2192 i \u2208 s \u2192 Set \u03b1\nhf : \u2200 (i : \u03b9) (hi : i \u2208 s), ConNF.Small (f i hi)\n\u22a2 ConNF.Small (\u22c3 i, \u22c3 (hi : i \u2208 s), f i hi)", "dependency": [1, 69, 233, 69, 233, 233]}, "ConNF.Small.image": {"natural_language_statement": "The theorem `ConNF.Small.image` states that if a set `s` is small (i.e., its cardinality is strictly less than the cardinality of the type `ConNF.\u03ba`), then the image of `s` under any function `f` is also small.", "formal_statement": "example [ConNF.Params ] {\u03b1 : Type u} {\u03b2 : Type u} {f : \u03b1 \u2192 \u03b2} {s : Set \u03b1} :ConNF.Small s \u2192 ConNF.Small (f '' s) := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03b1 \u03b2 : Type u\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\n\u22a2 ConNF.Small s \u2192 ConNF.Small (f '' s)", "dependency": [1, 69, 233, 233]}, "ConNF.Small.preimage": {"natural_language_statement": "The theorem `ConNF.Small.preimage` states that if `f` is an injective function and `s` is a small set, then the preimage of `s` under `f` is also small.", "formal_statement": "example [ConNF.Params ] {\u03b1 : Type u} {\u03b2 : Type u} {f : \u03b1 \u2192 \u03b2} {s : Set \u03b2} (h : Function.Injective f) :ConNF.Small s \u2192 ConNF.Small (f \u207b\u00b9' s) := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03b1 \u03b2 : Type u\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b2\nh : Function.Injective f\n\u22a2 ConNF.Small s \u2192 ConNF.Small (f \u207b\u00b9' s)", "dependency": [1, 69, 89, 233, 233]}, "ConNF.Small.image_subset": {"natural_language_statement": "In the context of Constructive Ordinal Notation (ConNF), a set is considered \"small\" if its cardinality is strictly less than the cardinality of the type `ConNF.\u03ba`. The theorem `ConNF.Small.image_subset` states that if the image of a set `s` under an injective function `f` is contained within a small set `t`, then `s` itself is also small.", "formal_statement": "example [ConNF.Params ] {\u03b1 : Type u} {\u03b2 : Type u} {s : Set \u03b1} {t : Set \u03b2} (f : \u03b1 \u2192 \u03b2) (h : Function.Injective f) :ConNF.Small t \u2192 f '' s \u2286 t \u2192 ConNF.Small s := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03b1 \u03b2 : Type u\ns : Set \u03b1\nt : Set \u03b2\nf : \u03b1 \u2192 \u03b2\nh : Function.Injective f\n\u22a2 ConNF.Small t \u2192 f '' s \u2286 t \u2192 ConNF.Small s", "dependency": [1, 69, 69, 89, 233, 233]}, "ConNF.Small.pFun_image": {"natural_language_statement": "The theorem `ConNF.Small.pFun_image` states that if the cardinality of a set `s` is strictly less than the cardinality of the type `ConNF.\u03ba`, and `f` is a partial function from `\u03b1` to `\u03b2`, then the cardinality of the image of `s` under `f` is also strictly less than the cardinality of `ConNF.\u03ba`.", "formal_statement": "example [ConNF.Params ] {\u03b1 : Type u} {\u03b2 : Type u} {s : Set \u03b1} (h : ConNF.Small s) {f : \u03b1 \u2192. \u03b2} :ConNF.Small (PFun.image f s) := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03b1 \u03b2 : Type u\ns : Set \u03b1\nh : ConNF.Small s\nf : \u03b1 \u2192. \u03b2\n\u22a2 ConNF.Small (PFun.image f s)", "dependency": [1, 69, 233, 233, 453]}, "ConNF.isNear_refl": {"natural_language_statement": "The theorem `ConNF.isNear_refl` states that any set is near itself in the context of Constructive Ordinal Notation (ConNF). This means that the symmetric difference of a set with itself, denoted as `s \u2206 s`, is considered \"small\" according to the `ConNF.Small` predicate. This is a fundamental property of the `ConNF.IsNear` relation, indicating that it is reflexive.", "formal_statement": "example [ConNF.Params ] {\u03b1 : Type u} (s : Set \u03b1) :ConNF.IsNear s s := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03b1 : Type u\ns : Set \u03b1\n\u22a2 ConNF.IsNear s s", "dependency": [1, 69, 455]}, "ConNF.isNear_rfl": {"natural_language_statement": "The `ConNF.isNear_rfl` theorem is a version of the `is_near_refl` lemma that does not require the set `s` to be given explicitly. The value of `s` will be inferred automatically by the elaborator.", "formal_statement": "example [ConNF.Params ] {\u03b1 : Type u} {s : Set \u03b1} :ConNF.IsNear s s := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03b1 : Type u\ns : Set \u03b1\n\u22a2 ConNF.IsNear s s", "dependency": [1, 69, 455]}, "ConNF.IsNear.symm": {"natural_language_statement": "In the context of Constructive Ordinal Notation (ConNF), two sets `s` and `t` are considered \"near\" if their symmetric difference, denoted as `s \u2206 t`, is considered \"small\" according to the `ConNF.Small` predicate. This theorem states that if `s` is near `t`, then `t` is also near `s`.", "formal_statement": "example [ConNF.Params ] {\u03b1 : Type u} {s : Set \u03b1} {t : Set \u03b1} (h : ConNF.IsNear s t) :ConNF.IsNear t s := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03b1 : Type u\ns t : Set \u03b1\nh : ConNF.IsNear s t\n\u22a2 ConNF.IsNear t s", "dependency": [1, 69, 69, 455, 455]}, "ConNF.isNear_comm": {"natural_language_statement": "`s` is near `t` if and only if `t` is near `s`.", "formal_statement": "example [ConNF.Params ] {\u03b1 : Type u} {s : Set \u03b1} {t : Set \u03b1} :ConNF.IsNear s t \u2194 ConNF.IsNear t s := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03b1 : Type u\ns t : Set \u03b1\n\u22a2 ConNF.IsNear s t \u2194 ConNF.IsNear t s", "dependency": [1, 69, 69, 455, 455]}, "ConNF.IsNear.trans": {"natural_language_statement": "In the context of Constructive Ordinal Notation (ConNF), the property of two sets being \"near\" each other is transitive. This means that if set `s` is near set `t`, and set `t` is near set `u`, then set `s` is also near set `u`.", "formal_statement": "example [ConNF.Params ] {\u03b1 : Type u} {s : Set \u03b1} {t : Set \u03b1} {u : Set \u03b1} (hst : ConNF.IsNear s t) (htu : ConNF.IsNear t u) :ConNF.IsNear s u := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03b1 : Type u\ns t u : Set \u03b1\nhst : ConNF.IsNear s t\nhtu : ConNF.IsNear t u\n\u22a2 ConNF.IsNear s u", "dependency": [1, 69, 69, 69, 455, 455, 455]}, "ConNF.IsNear.image": {"natural_language_statement": "Function `ConNF.IsNear.image` proves that if two sets are \"near\" each other in the context of Constructive Ordinal Notation (ConNF), then their images under an arbitrary function are also \"near\".", "formal_statement": "example [ConNF.Params ] {\u03b1 : Type u} {\u03b2 : Type u} {s : Set \u03b1} {t : Set \u03b1} (f : \u03b1 \u2192 \u03b2) (h : ConNF.IsNear s t) :ConNF.IsNear (f '' s) (f '' t) := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03b1 \u03b2 : Type u\ns t : Set \u03b1\nf : \u03b1 \u2192 \u03b2\nh : ConNF.IsNear s t\n\u22a2 ConNF.IsNear (f '' s) (f '' t)", "dependency": [1, 69, 69, 455, 455]}, "ConNF.isNear_of_small": {"natural_language_statement": "The theorem `ConNF.isNear_of_small` states that if two sets `s` and `t` are both considered \"small\" in the context of Constructive Ordinal Notation (ConNF), then they are considered \"near\" each other according to the `ConNF.IsNear` predicate.", "formal_statement": "example [ConNF.Params ] {\u03b1 : Type u} {s : Set \u03b1} {t : Set \u03b1} (hs : ConNF.Small s) (ht : ConNF.Small t) :ConNF.IsNear s t := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03b1 : Type u\ns t : Set \u03b1\nhs : ConNF.Small s\nht : ConNF.Small t\n\u22a2 ConNF.IsNear s t", "dependency": [1, 69, 69, 233, 233, 455]}, "ConNF.Small.isNear_iff": {"natural_language_statement": "The theorem `ConNF.Small.isNear_iff` states that for two sets `s` and `t` in the context of Constructive Ordinal Notation (ConNF), if `s` is considered \"small\" (i.e., its cardinality is strictly less than the cardinality of the type `ConNF.\u03ba`), then `t` is considered \"small\" if and only if `s` and `t` are \"near\" each other (i.e., their symmetric difference is considered \"small\").", "formal_statement": "example [ConNF.Params ] {\u03b1 : Type u} {s : Set \u03b1} {t : Set \u03b1} (hs : ConNF.Small s) :ConNF.Small t \u2194 ConNF.IsNear s t := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03b1 : Type u\ns t : Set \u03b1\nhs : ConNF.Small s\n\u22a2 ConNF.Small t \u2194 ConNF.IsNear s t", "dependency": [1, 69, 69, 233, 233, 455]}, "ConNF.IsNear.\u03ba_le": {"natural_language_statement": "The theorem `ConNF.IsNear.\u03ba_le` states that if two sets `s` and `t` are \"near\" each other in the context of Constructive Ordinal Notation (ConNF), and the cardinality of `ConNF.\u03ba` is less than or equal to the cardinality of `s`, then the cardinality of `ConNF.\u03ba` is also less than or equal to the cardinality of `t`.", "formal_statement": "example [ConNF.Params ] {\u03b1 : Type u} {s : Set \u03b1} {t : Set \u03b1} (h : ConNF.IsNear s t) (hs : Cardinal.mk ConNF.\u03ba \u2264 Cardinal.mk \u2191s) :Cardinal.mk ConNF.\u03ba \u2264 Cardinal.mk \u2191t := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03b1 : Type u\ns t : Set \u03b1\nh : ConNF.IsNear s t\nhs : Cardinal.mk ConNF.\u03ba \u2264 Cardinal.mk \u2191s\n\u22a2 Cardinal.mk ConNF.\u03ba \u2264 Cardinal.mk \u2191t", "dependency": [1, 69, 69, 455, 29, 29, 29, 29]}, "ConNF.IsNear.mk_inter": {"natural_language_statement": "The theorem `ConNF.IsNear.mk_inter` states that if two sets `s` and `t` are \"near\" each other in the context of Constructive Ordinal Notation (ConNF), and the cardinality of `s` is at least the cardinality of `ConNF.\u03ba`, then the cardinality of the intersection of `s` and `t` is also at least the cardinality of `ConNF.\u03ba`.", "formal_statement": "example [ConNF.Params ] {\u03b1 : Type u} {s : Set \u03b1} {t : Set \u03b1} (h : ConNF.IsNear s t) (hs : Cardinal.mk ConNF.\u03ba \u2264 Cardinal.mk \u2191s) :Cardinal.mk ConNF.\u03ba \u2264 Cardinal.mk \u2191(s \u2229 t) := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03b1 : Type u\ns t : Set \u03b1\nh : ConNF.IsNear s t\nhs : Cardinal.mk ConNF.\u03ba \u2264 Cardinal.mk \u2191s\n\u22a2 Cardinal.mk ConNF.\u03ba \u2264 Cardinal.mk \u2191(s \u2229 t)", "dependency": [1, 69, 69, 455, 29, 29, 29, 29]}, "ConNF.isNearLitter_litterSet": {"natural_language_statement": "The litter set corresponding to a given litter `L` in the context of Constructive Ordinal Notation (ConNF) is a near-litter to litter `L`.", "formal_statement": "example [ConNF.Params ] (L : ConNF.Litter) :ConNF.IsNearLitter L (ConNF.litterSet L) := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\nL : ConNF.Litter\n\u22a2 ConNF.IsNearLitter L (ConNF.litterSet L)", "dependency": [1, 466, 467]}, "ConNF.isNear_litterSet": {"natural_language_statement": "The theorem `ConNF.isNear_litterSet` states that in the context of Constructive Ordinal Notation (ConNF), a set `s` of type `ConNF.Atom` is near a litter `L` if and only if `s` has a small symmetric difference with the litter set of `L`.", "formal_statement": "@[simp]example [ConNF.Params ] {L : ConNF.Litter} {s : Set ConNF.Atom} :ConNF.IsNear (ConNF.litterSet L) s \u2194 ConNF.IsNearLitter L s := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\nL : ConNF.Litter\ns : Set ConNF.Atom\n\u22a2 ConNF.IsNear (ConNF.litterSet L) s \u2194 ConNF.IsNearLitter L s", "dependency": [1, 69, 455, 467, 466]}, "ConNF.IsNearLitter.near": {"natural_language_statement": "The theorem `ConNF.IsNearLitter.near` states that if two sets `s` and `t` are both \"near\" a litter `L` in the context of Constructive Ordinal Notation (ConNF), then `s` and `t` are also \"near\" each other. This is a consequence of the transitivity of the \"nearness\" relation.", "formal_statement": "example [ConNF.Params ] {L : ConNF.Litter} {s : Set ConNF.Atom} {t : Set ConNF.Atom} (hs : ConNF.IsNearLitter L s) (ht : ConNF.IsNearLitter L t) :ConNF.IsNear s t := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\nL : ConNF.Litter\ns t : Set ConNF.Atom\nhs : ConNF.IsNearLitter L s\nht : ConNF.IsNearLitter L t\n\u22a2 ConNF.IsNear s t", "dependency": [1, 69, 69, 466, 466, 455]}, "ConNF.IsNearLitter.mk_eq_\u03ba": {"natural_language_statement": "The theorem `ConNF.IsNearLitter.mk_eq_\u03ba` states that if a set `s` of type `ConNF.Atom` is near a litter `L` in the context of Constructive Ordinal Notation (ConNF), then the cardinality of `s` is equal to the cardinality of `ConNF.\u03ba`.", "formal_statement": "example [ConNF.Params ] {L : ConNF.Litter} {s : Set ConNF.Atom} (hs : ConNF.IsNearLitter L s) :Cardinal.mk \u2191s = Cardinal.mk ConNF.\u03ba := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\nL : ConNF.Litter\ns : Set ConNF.Atom\nhs : ConNF.IsNearLitter L s\n\u22a2 Cardinal.mk \u2191s = Cardinal.mk ConNF.\u03ba", "dependency": [1, 69, 466, 29, 29]}, "ConNF.IsNearLitter.nonempty": {"natural_language_statement": "Given a litter `L` and a set `s` of atoms, if `s` is near `L`, then `s` is nonempty.", "formal_statement": "example [ConNF.Params ] {L : ConNF.Litter} {s : Set ConNF.Atom} (hs : ConNF.IsNearLitter L s) :Set.Nonempty s := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\nL : ConNF.Litter\ns : Set ConNF.Atom\nhs : ConNF.IsNearLitter L s\n\u22a2 Set.Nonempty s", "dependency": [1, 69, 466, 83]}, "ConNF.isNearLitter_litterSet_iff": {"natural_language_statement": "A litter set is only a near-litter to itself.", "formal_statement": "@[simp]example [ConNF.Params ] {L\u2081 : ConNF.Litter} {L\u2082 : ConNF.Litter} :ConNF.IsNearLitter L\u2081 (ConNF.litterSet L\u2082) \u2194 L\u2081 = L\u2082 := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\nL\u2081 L\u2082 : ConNF.Litter\n\u22a2 ConNF.IsNearLitter L\u2081 (ConNF.litterSet L\u2082) \u2194 L\u2081 = L\u2082", "dependency": [1, 466, 467]}, "ConNF.IsNearLitter.unique": {"natural_language_statement": "In the context of Constructive Ordinal Notation (ConNF), a set is near at most one litter.", "formal_statement": "example [ConNF.Params ] {L\u2081 : ConNF.Litter} {L\u2082 : ConNF.Litter} {s : Set ConNF.Atom} (h\u2081 : ConNF.IsNearLitter L\u2081 s) (h\u2082 : ConNF.IsNearLitter L\u2082 s) :L\u2081 = L\u2082 := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\nL\u2081 L\u2082 : ConNF.Litter\ns : Set ConNF.Atom\nh\u2081 : ConNF.IsNearLitter L\u2081 s\nh\u2082 : ConNF.IsNearLitter L\u2082 s\n\u22a2 L\u2081 = L\u2082", "dependency": [1, 69, 466, 466]}, "ConNF.mk_nearLitter'": {"natural_language_statement": "The theorem `ConNF.mk_nearLitter'` states that the number of near-litters to a given litter `L` in the context of Constructive Ordinal Notation (ConNF) is equal to the cardinality of the type `\u03bc`.", "formal_statement": "@[simp]example [ConNF.Params ] (L : ConNF.Litter) :Cardinal.mk { s : Set ConNF.Atom // ConNF.IsNearLitter L s } = Cardinal.mk ConNF.\u03bc := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\nL : ConNF.Litter\n\u22a2 Cardinal.mk { s // ConNF.IsNearLitter L s } = Cardinal.mk ConNF.\u03bc", "dependency": [1, 29, 69, 466, 29]}, "ConNF.NearLitter.ext": {"natural_language_statement": "The theorem `ConNF.NearLitter.ext` in Lean 4 is an extensionality theorem for the `ConNF.NearLitter` structure. It states that two `ConNF.NearLitter` objects are equal if their underlying sets are equal.", "formal_statement": "example [ConNF.Params ] {N\u2081 : ConNF.NearLitter} {N\u2082 : ConNF.NearLitter} (h\u2082 : \u2191N\u2081 = \u2191N\u2082) :N\u2081 = N\u2082 := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\nN\u2081 N\u2082 : ConNF.NearLitter\nh\u2082 : N\u2081 = N\u2082\n\u22a2 N\u2081 = N\u2082", "dependency": [1]}, "ConNF.NearLitter.nonempty": {"natural_language_statement": "The theorem `ConNF.NearLitter.nonempty` asserts that every `NearLitter` in the context of Constructive Ordinal Notation (ConNF) is nonempty, meaning it contains at least one element.", "formal_statement": "example [ConNF.Params ] (N : ConNF.NearLitter) :Nonempty \u21a5N := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\nN : ConNF.NearLitter\n\u22a2 Nonempty \u21a5N", "dependency": [1, 212]}, "ConNF.NearLitter.toProd_fst": {"natural_language_statement": "The function `ConNF.NearLitter.toProd` reinterprets a near-litter as a product of a litter and a set of atoms. The first component of this product is equal to the first component of the near-litter.", "formal_statement": "@[simp]example [ConNF.Params ] (N : ConNF.NearLitter) :(ConNF.NearLitter.toProd N).1 = N.fst := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\nN : ConNF.NearLitter\n\u22a2 (ConNF.NearLitter.toProd N).1 = N.fst", "dependency": [1, 478]}, "ConNF.NearLitter.toProd_snd": {"natural_language_statement": "Function `ConNF.NearLitter.toProd` reinterprets a near-litter as a product of a litter and a set of atoms. The second component of this product is equal to the set of atoms in the near-litter.", "formal_statement": "@[simp]example [ConNF.Params ] (N : ConNF.NearLitter) :(ConNF.NearLitter.toProd N).2 = \u2191N.snd := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\nN : ConNF.NearLitter\n\u22a2 (ConNF.NearLitter.toProd N).2 = \u2191N.snd", "dependency": [1, 478]}, "ConNF.NearLitter.toProd_injective": {"natural_language_statement": "Function `ConNF.NearLitter.toProd` is injective.", "formal_statement": "example [ConNF.Params ] :Function.Injective ConNF.NearLitter.toProd := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u22a2 Function.Injective ConNF.NearLitter.toProd", "dependency": [1, 89]}, "ConNF.NearLitter.isNearLitter": {"natural_language_statement": "A near-litter `N` is near a given litter `L` if and only if `N` has first projection `L`.", "formal_statement": "@[simp]example [ConNF.Params ] (N : ConNF.NearLitter) (L : ConNF.Litter) :ConNF.IsNearLitter L \u2191N \u2194 N.fst = L := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\nN : ConNF.NearLitter\nL : ConNF.Litter\n\u22a2 ConNF.IsNearLitter L \u2191N \u2194 N.fst = L", "dependency": [1, 466]}, "ConNF.Litter.toNearLitter_fst": {"natural_language_statement": "The function `ConNF.Litter.toNearLitter` converts a litter in the context of Constructive Ordinal Notation (ConNF) to its corresponding near-litter. A near-litter is defined as a pair consisting of a litter and a subset of that litter, satisfying certain properties. The function `ConNF.Litter.toNearLitter` simply wraps a litter with its litter set to form a near-litter. The theorem `ConNF.Litter.toNearLitter_fst` states that the first component of the resulting near-litter is equal to the original litter.", "formal_statement": "@[simp]example [ConNF.Params ] (L : ConNF.Litter) :(ConNF.Litter.toNearLitter L).fst = L := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\nL : ConNF.Litter\n\u22a2 (ConNF.Litter.toNearLitter L).fst = L", "dependency": [1, 483]}, "ConNF.Litter.coe_toNearLitter": {"natural_language_statement": "The theorem `ConNF.Litter.coe_toNearLitter` states that the set corresponding to a given litter `L` in the context of Constructive Ordinal Notation (ConNF) is equal to the set of all atoms `a` such that the first projection of `a` is equal to `L`.", "formal_statement": "@[simp]example [ConNF.Params ] (L : ConNF.Litter) :\u2191(ConNF.Litter.toNearLitter L) = ConNF.litterSet L := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\nL : ConNF.Litter\n\u22a2 \u2191(ConNF.Litter.toNearLitter L) = ConNF.litterSet L", "dependency": [1, 483, 467]}, "ConNF.Litter.toNearLitter_injective": {"natural_language_statement": "The theorem `ConNF.Litter.toNearLitter_injective` states that the function `ConNF.Litter.toNearLitter` from `ConNF.Litter` to `ConNF.NearLitter` is injective. This means that if two `ConNF.Litter`s map to the same `ConNF.NearLitter`, then they must be the same `ConNF.Litter`.", "formal_statement": "example [ConNF.Params ] :Function.Injective ConNF.Litter.toNearLitter := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u22a2 Function.Injective ConNF.Litter.toNearLitter", "dependency": [1, 89]}, "ConNF.mk_nearLitter": {"natural_language_statement": "In the context of Constructive Ordinal Notation (ConNF), the number of near-litters is equal to the cardinality of the type `\u03bc`.", "formal_statement": "@[simp]example [ConNF.Params ] :Cardinal.mk ConNF.NearLitter = Cardinal.mk ConNF.\u03bc := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u22a2 Cardinal.mk ConNF.NearLitter = Cardinal.mk ConNF.\u03bc", "dependency": [1, 29, 29]}, "ConNF.mem_localCardinal": {"natural_language_statement": "The theorem `ConNF.mem_localCardinal` states that a near-litter `N` belongs to the local cardinal of a litter `L` if and only if the first component of `N` is equal to `L`.", "formal_statement": "@[simp]example [ConNF.Params ] {L : ConNF.Litter} {N : ConNF.NearLitter} :N \u2208 ConNF.localCardinal L \u2194 N.fst = L := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\nL : ConNF.Litter\nN : ConNF.NearLitter\n\u22a2 N \u2208 ConNF.localCardinal L \u2194 N.fst = L", "dependency": [1, 81]}, "ConNF.localCardinal_nonempty": {"natural_language_statement": "The theorem `ConNF.localCardinal_nonempty` states that for any litter `L` in the context of Constructive Ordinal Notation (ConNF), the local cardinal of `L` is non-empty. This means that there exists at least one near-litter `N` such that the first component of `N` is equal to `L`.", "formal_statement": "example [ConNF.Params ] (L : ConNF.Litter) :Set.Nonempty (ConNF.localCardinal L) := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\nL : ConNF.Litter\n\u22a2 Set.Nonempty (ConNF.localCardinal L)", "dependency": [1, 83, 81]}, "ConNF.localCardinal_disjoint": {"natural_language_statement": "The theorem `ConNF.localCardinal_disjoint` states that the local cardinals defined in the context of Constructive Ordinal Notation (ConNF) are pairwise disjoint. This means that for any two distinct local cardinals, their intersection is empty.", "formal_statement": "example [ConNF.Params ] :Pairwise (Disjoint on ConNF.localCardinal) := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u22a2 Pairwise (Disjoint on ConNF.localCardinal)", "dependency": [1, 490]}, "ConNF.localCardinal_injective": {"natural_language_statement": "In the context of Constructive Ordinal Notation (ConNF), the theorem `ConNF.localCardinal_injective` states that the function `ConNF.localCardinal` is injective. This means that if `ConNF.localCardinal x = ConNF.localCardinal y`, then `x = y`.", "formal_statement": "example [ConNF.Params ] :Function.Injective ConNF.localCardinal := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u22a2 Function.Injective ConNF.localCardinal", "dependency": [1, 89]}, "ConNF.Litter.toNearLitter_mem_localCardinal": {"natural_language_statement": "The theorem `ConNF.Litter.toNearLitter_mem_localCardinal` states that for any litter `L` in the context of Constructive Ordinal Notation (ConNF), the near-litter formed by wrapping `L` with its litter set is an element of the local cardinal of `L`. The local cardinal of a litter `L` is defined as the set of all near-litters `N` such that the first component of `N` is equal to `L`.", "formal_statement": "example [ConNF.Params ] (L : ConNF.Litter) :ConNF.Litter.toNearLitter L \u2208 ConNF.localCardinal L := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\nL : ConNF.Litter\n\u22a2 ConNF.Litter.toNearLitter L \u2208 ConNF.localCardinal L", "dependency": [1, 483, 81]}, "ConNF.mk_localCardinal": {"natural_language_statement": "The theorem `ConNF.mk_localCardinal` states that the cardinality of the local cardinal of a given litter `L` in the context of Constructive Ordinal Notation (ConNF) is equal to the cardinality of the type `ConNF.\u03bc`.", "formal_statement": "@[simp]example [ConNF.Params ] (L : ConNF.Litter) :Cardinal.mk \u2191(ConNF.localCardinal L) = Cardinal.mk ConNF.\u03bc := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\nL : ConNF.Litter\n\u22a2 Cardinal.mk \u2191(ConNF.localCardinal L) = Cardinal.mk ConNF.\u03bc", "dependency": [1, 29, 81, 29]}, "ConNF.NearLitter.IsLitter.eq_fst_toNearLitter": {"natural_language_statement": "The theorem `ConNF.NearLitter.IsLitter.eq_fst_toNearLitter` states that if a near-litter `N` is of the form `L.toNearLitter` for some litter `L`, then `N` is equal to `ConNF.Litter.toNearLitter L`, where `L` is the first component of `N`.", "formal_statement": "example [ConNF.Params ] {N : ConNF.NearLitter} (h : ConNF.NearLitter.IsLitter N) :N = ConNF.Litter.toNearLitter N.fst := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\nN : ConNF.NearLitter\nh : ConNF.NearLitter.IsLitter N\n\u22a2 N = ConNF.Litter.toNearLitter N.fst", "dependency": [1, 495, 483]}, "ConNF.NearLitter.IsLitter.litterSet_eq": {"natural_language_statement": "The theorem `ConNF.NearLitter.IsLitter.litterSet_eq` states that for any near-litter `N` that is also a litter (i.e., `N` is of the form `L.toNearLitter` for some litter `L`), the set of all atoms `a` such that the first projection of `a` is equal to `L` is equal to the near-litter `N` itself.", "formal_statement": "example [ConNF.Params ] {N : ConNF.NearLitter} (h : ConNF.NearLitter.IsLitter N) :ConNF.litterSet N.fst = \u2191N.snd := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\nN : ConNF.NearLitter\nh : ConNF.NearLitter.IsLitter N\n\u22a2 ConNF.litterSet N.fst = \u2191N.snd", "dependency": [1, 495, 467]}, "ConNF.NearLitter.IsLitter.exists_litter_eq": {"natural_language_statement": "The theorem `ConNF.NearLitter.IsLitter.exists_litter_eq` states that if a near-litter `N` is of the form `L.toNearLitter` for some litter `L`, then there exists a litter `L` such that `N` is equal to `L.toNearLitter`.", "formal_statement": "example [ConNF.Params ] {N : ConNF.NearLitter} (h : ConNF.NearLitter.IsLitter N) :\u2203 (L : ConNF.Litter), N = ConNF.Litter.toNearLitter L := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\nN : ConNF.NearLitter\nh : ConNF.NearLitter.IsLitter N\n\u22a2 \u2203 L, N = ConNF.Litter.toNearLitter L", "dependency": [1, 495, 483]}, "ConNF.NearLitter.not_isLitter": {"natural_language_statement": "The theorem `ConNF.NearLitter.not_isLitter` states that if a near-litter `N` is not of the form `L.toNearLitter` for some litter `L`, then the set of atoms `a` such that the first projection of `a` is equal to `N.fst` is not equal to the near-litter `N.snd`.", "formal_statement": "example [ConNF.Params ] {N : ConNF.NearLitter} (h : \u00ac ConNF.NearLitter.IsLitter N) :ConNF.litterSet N.fst \u2260 \u2191N.snd := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\nN : ConNF.NearLitter\nh : \u00acConNF.NearLitter.IsLitter N\n\u22a2 ConNF.litterSet N.fst \u2260 \u2191N.snd", "dependency": [1, 495, 467]}, "ConNF.NearLitter.not_isLitter'": {"natural_language_statement": "In the context of Constructive Ordinal Notation (ConNF), the theorem `ConNF.NearLitter.not_isLitter'` states that if a near-litter `N` is not of the form `L.toNearLitter` for some litter `L`, then the near-litter obtained by wrapping the litter part of `N` (i.e., `N.fst.toNearLitter`) is not equal to `N` itself.", "formal_statement": "example [ConNF.Params ] {N : ConNF.NearLitter} (h : \u00ac ConNF.NearLitter.IsLitter N) :ConNF.Litter.toNearLitter N.fst \u2260 N := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\nN : ConNF.NearLitter\nh : \u00acConNF.NearLitter.IsLitter N\n\u22a2 ConNF.Litter.toNearLitter N.fst \u2260 N", "dependency": [1, 495, 483]}, "ConNF.mk_nearLitter''": {"natural_language_statement": "The size of each near-litter in the context of Constructive Ordinal Notation (ConNF) is equal to the cardinality of the type `\u03ba`.", "formal_statement": "@[simp]example [ConNF.Params ] (N : ConNF.NearLitter) :Cardinal.mk \u21a5N = Cardinal.mk ConNF.\u03ba := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\nN : ConNF.NearLitter\n\u22a2 Cardinal.mk \u21a5N = Cardinal.mk ConNF.\u03ba", "dependency": [1, 29, 29]}, "ConNF.symmDiff_union_inter": {"natural_language_statement": "The theorem `ConNF.symmDiff_union_inter` states that for any two sets `a` and `b`, the symmetric difference of `a` and `b` union the intersection of `a` and `b` is equal to the union of `a` and `b`.", "formal_statement": "example {\u03b1 : Type u_1} {a : Set \u03b1} {b : Set \u03b1} :symmDiff a b \u222a a \u2229 b = a \u222a b := by sorry", "full_tactic_state": "\u03b1 : Type u_1\na b : Set \u03b1\n\u22a2 symmDiff a b \u222a a \u2229 b = a \u222a b", "dependency": [69, 69, 62]}, "ConNF.noMaxOrder_of_ordinal_type_eq": {"natural_language_statement": "The theorem `ConNF.noMaxOrder_of_ordinal_type_eq` states that if the ordinal type of a well-ordered infinite set is a limit ordinal, then the set has no maximum order.", "formal_statement": "example {\u03b1 : Type u} [Preorder \u03b1] [Infinite \u03b1] [IsWellOrder \u03b1 fun (x x_1 : \u03b1) => x < x_1] (h : Ordinal.IsLimit (Ordinal.type fun (x x_1 : \u03b1) => x < x_1)) :NoMaxOrder \u03b1 := by sorry", "full_tactic_state": "\u03b1 : Type u\ninst\u271d\u00b2 : Preorder \u03b1\ninst\u271d\u00b9 : Infinite \u03b1\ninst\u271d : IsWellOrder \u03b1 fun x x_1 => x < x_1\nh : Ordinal.IsLimit (Ordinal.type fun x x_1 => x < x_1)\n\u22a2 NoMaxOrder \u03b1", "dependency": [4, 239, 15, 24, 26, 503]}, "ConNF.typein_add_lt_of_type_eq_ord": {"natural_language_statement": "The theorem `ConNF.typein_add_lt_of_type_eq_ord` in Lean 4 allows us to show that the sum of the order types of two elements in an infinite well-ordered type is strictly less than the type of the well-order itself, provided that the type's cardinality equals its own ordinal type. This theorem is crucial for constructing the Conway's nimber type, which is an important part of combinatorial game theory.", "formal_statement": "example {\u03b1 : Type u_1} [Infinite \u03b1] [LinearOrder \u03b1] [IsWellOrder \u03b1 fun (x x_1 : \u03b1) => x < x_1] (h : (Ordinal.type fun (x x_1 : \u03b1) => x < x_1) = Cardinal.ord (Cardinal.mk \u03b1)) (x : \u03b1) (y : \u03b1) :Ordinal.typein (fun (x x_1 : \u03b1) => x < x_1) x + Ordinal.typein (fun (x x_1 : \u03b1) => x < x_1) y < Ordinal.type fun (x x_1 : \u03b1) => x < x_1 := by sorry", "full_tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : Infinite \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : IsWellOrder \u03b1 fun x x_1 => x < x_1\nh : (Ordinal.type fun x x_1 => x < x_1) = Cardinal.ord (Cardinal.mk \u03b1)\nx y : \u03b1\n\u22a2 Ordinal.typein (fun x x_1 => x < x_1) x + Ordinal.typein (fun x x_1 => x < x_1) y < Ordinal.type fun x x_1 => x < x_1", "dependency": [239, 2, 15, 26, 27, 29, 36, 36, 26]}, "IsWellFounded.not_lt_bot": {"natural_language_statement": "Function `IsWellFounded.bot` is a noncomputable function that takes a type `\u03b1`, a relation `r` on `\u03b1`, and a proof that `r` is well-founded, and returns an element of `\u03b1`. It does this by finding the minimal element of `\u03b1` with respect to `r` using the well-foundedness of `r`. The theorem `IsWellFounded.not_lt_bot` states that for any element `x` of `\u03b1`, the relation `r` does not hold between `x` and `IsWellFounded.bot \u03b1 r`.", "formal_statement": "example (\u03b1 : Type u_1) [Nonempty \u03b1] (r : \u03b1 \u2192 \u03b1 \u2192 Prop ) [IsWellFounded \u03b1 r] (x : \u03b1) :\u00ac r x (IsWellFounded.bot \u03b1 r) := by sorry", "full_tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9 : Nonempty \u03b1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ninst\u271d : IsWellFounded \u03b1 r\nx : \u03b1\n\u22a2 \u00acr x (IsWellFounded.bot \u03b1 r)", "dependency": [212, 18, 506]}, "Ordinal.typein_eq_zero_iff": {"natural_language_statement": "Function `Ordinal.typein` computes the order type of an element `x` within a well-ordered type `\u03b1`, using the relation `r` to determine the order. The theorem `Ordinal.typein_eq_zero_iff` states that `Ordinal.typein r x = 0` if and only if `x` is the smallest element of `\u03b1` with respect to `r`.", "formal_statement": "example {\u03b1 : Type u_1} {r : \u03b1 \u2192 \u03b1 \u2192 Prop } [Nonempty \u03b1] [IsWellOrder \u03b1 r] {x : \u03b1} :Ordinal.typein r x = 0 \u2194 \u2200 (y : \u03b1), y \u2260 x \u2192 r x y := by sorry", "full_tactic_state": "\u03b1 : Type u_1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ninst\u271d\u00b9 : Nonempty \u03b1\ninst\u271d : IsWellOrder \u03b1 r\nx : \u03b1\n\u22a2 Ordinal.typein r x = 0 \u2194 \u2200 (y : \u03b1), y \u2260 x \u2192 r x y", "dependency": [212, 15, 36]}, "Ordinal.typein_bot": {"natural_language_statement": "The theorem `Ordinal.typein_bot` states that the order type of the smallest element in a well-ordered set is 0.", "formal_statement": "example {\u03b1 : Type u_1} [Nonempty \u03b1] [LinearOrder \u03b1] [IsWellOrder \u03b1 fun (x x_1 : \u03b1) => x < x_1] :Ordinal.typein (fun (x x_1 : \u03b1) => x < x_1) (IsWellFounded.bot \u03b1 fun (x x_1 : \u03b1) => x < x_1) = 0 := by sorry", "full_tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : Nonempty \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : IsWellOrder \u03b1 fun x x_1 => x < x_1\n\u22a2 Ordinal.typein (fun x x_1 => x < x_1) (IsWellFounded.bot \u03b1 fun x x_1 => x < x_1) = 0", "dependency": [212, 2, 15, 36, 506]}, "ConNF.aleph0_le_mk_\u039b": {"natural_language_statement": "In the context of Constructive Ordinal Notation (ConNF), the theorem `ConNF.aleph0_le_mk_\u039b` states that the smallest infinite cardinal number, denoted as `\u2135\u2080`, is less than or equal to the cardinality of the type `ConNF.\u039b`.", "formal_statement": "example [ConNF.Params ] :Cardinal.aleph0 \u2264 Cardinal.mk ConNF.\u039b := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u22a2 Cardinal.aleph0 \u2264 Cardinal.mk ConNF.\u039b", "dependency": [1, 510, 29]}, "ConNF.mk_\u039b_ne_zero": {"natural_language_statement": "In the context of Constructive Ordinal Notation (ConNF), the theorem `ConNF.mk_\u039b_ne_zero` asserts that the cardinality of the type `ConNF.\u039b`, denoted as `Cardinal.mk ConNF.\u039b`, is not equal to zero. This means that there exists at least one element in the type `ConNF.\u039b`.", "formal_statement": "example [ConNF.Params ] :Cardinal.mk ConNF.\u039b \u2260 0 := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u22a2 Cardinal.mk ConNF.\u039b \u2260 0", "dependency": [1, 29]}, "ConNF.\u03ba_typein_zero": {"natural_language_statement": "The theorem `ConNF.\u03ba_typein_zero` states that in the context of Constructive Ordinal Notation (ConNF), the order type of `0` within the well-ordered type `ConNF.\u03ba` is `0`.", "formal_statement": "@[simp]example [ConNF.Params ] :Ordinal.typein (fun (x x_1 : ConNF.\u03ba) => x < x_1) 0 = 0 := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u22a2 Ordinal.typein (fun x x_1 => x < x_1) 0 = 0", "dependency": [1, 36]}, "ConNF.\u03ba_le_zero_iff": {"natural_language_statement": "The theorem `ConNF.\u03ba_le_zero_iff` states that in the context of Constructive Ordinal Notation (ConNF), for any ordinal `i` of type `ConNF.\u03ba`, `i` is less than or equal to `0` if and only if `i` is equal to `0`.", "formal_statement": "example [ConNF.Params ] (i : ConNF.\u03ba) :i \u2264 0 \u2194 i = 0 := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\ni : ConNF.\u03ba\n\u22a2 i \u2264 0 \u2194 i = 0", "dependency": [1]}, "ConNF.\u03ba_not_lt_zero": {"natural_language_statement": "The theorem `ConNF.\u03ba_not_lt_zero` states that in the context of Constructive Ordinal Notation (ConNF), for any element `i` of the type `ConNF.\u03ba`, it cannot be less than zero.", "formal_statement": "example [ConNF.Params ] (i : ConNF.\u03ba) :\u00ac i < 0 := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\ni : ConNF.\u03ba\n\u22a2 \u00aci < 0", "dependency": [1]}, "ConNF.\u03ba_pos": {"natural_language_statement": "The theorem `ConNF.\u03ba_pos` states that in the context of Constructive Ordinal Notation (ConNF), for any element `i` of the type `ConNF.\u03ba`, the value `0` is less than or equal to `i`.", "formal_statement": "example [ConNF.Params ] (i : ConNF.\u03ba) :0 \u2264 i := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\ni : ConNF.\u03ba\n\u22a2 0 \u2264 i", "dependency": [1]}, "ConNF.\u03ba_add_eq_zero_iff": {"natural_language_statement": "The theorem `ConNF.\u03ba_add_eq_zero_iff` states that in the context of Constructive Ordinal Notation (ConNF), for any two ordinals `i` and `j` of type `ConNF.\u03ba`, the sum `i + j` equals zero if and only if both `i` and `j` are zero.", "formal_statement": "@[simp]example [ConNF.Params ] (i : ConNF.\u03ba) (j : ConNF.\u03ba) :i + j = 0 \u2194 i = 0 \u2227 j = 0 := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\ni j : ConNF.\u03ba\n\u22a2 i + j = 0 \u2194 i = 0 \u2227 j = 0", "dependency": [1]}, "ConNF.\u03ba_succ_typein": {"natural_language_statement": "The theorem `ConNF.\u03ba_succ_typein` states that the order type of the successor of an element `i` in the well-ordered type `ConNF.\u03ba` is equal to the order type of `i` plus one.", "formal_statement": "@[simp]example [ConNF.Params ] (i : ConNF.\u03ba) :Ordinal.typein (fun (x x_1 : ConNF.\u03ba) => x < x_1) (Order.succ i) = Ordinal.typein (fun (x x_1 : ConNF.\u03ba) => x < x_1) i + 1 := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\ni : ConNF.\u03ba\n\u22a2 Ordinal.typein (fun x x_1 => x < x_1) (Order.succ i) = Ordinal.typein (fun x x_1 => x < x_1) i + 1", "dependency": [1, 36, 518, 36]}, "ConNF.\u03ba_zero_lt_one": {"natural_language_statement": "In the context of Constructive Ordinal Notation (ConNF), it is proven that 0 is less than 1.", "formal_statement": "example [ConNF.Params ] :0 < 1 := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u22a2 0 < 1", "dependency": [1]}, "ConNF.\u03ba_lt_one_iff": {"natural_language_statement": "The theorem `ConNF.\u03ba_lt_one_iff` states that in the context of Constructive Ordinal Notation (ConNF), for any ordinal `i` of type `ConNF.\u03ba`, the inequality `i < 1` holds if and only if `i` is equal to `0`.", "formal_statement": "@[simp]example [ConNF.Params ] (i : ConNF.\u03ba) :i < 1 \u2194 i = 0 := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\ni : ConNF.\u03ba\n\u22a2 i < 1 \u2194 i = 0", "dependency": [1]}, "ConNF.\u03ba_le_self_add": {"natural_language_statement": "In the context of Constructive Ordinal Notation (ConNF), the theorem `ConNF.\u03ba_le_self_add` states that for any two ordinals `i` and `j` of type `ConNF.\u03ba`, the ordinal `i` is less than or equal to the sum of `i` and `j`.", "formal_statement": "example [ConNF.Params ] (i : ConNF.\u03ba) (j : ConNF.\u03ba) :i \u2264 i + j := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\ni j : ConNF.\u03ba\n\u22a2 i \u2264 i + j", "dependency": [1]}, "ConNF.\u03ba_add_sub_cancel": {"natural_language_statement": "The theorem `ConNF.\u03ba_add_sub_cancel` states that in the context of Constructive Ordinal Notation (ConNF), for any two elements `i` and `j` of type `ConNF.\u03ba`, the expression `i + j - i` simplifies to `j`.", "formal_statement": "example [ConNF.Params ] (i : ConNF.\u03ba) (j : ConNF.\u03ba) :i + j - i = j := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\ni j : ConNF.\u03ba\n\u22a2 i + j - i = j", "dependency": [1]}, "ConNF.\u03ba_sub_lt": {"natural_language_statement": "The theorem `ConNF.\u03ba_sub_lt` states that if `i < j + k` and `j \u2264 i`, then `i - j < k` in the context of Constructive Ordinal Notation (ConNF).", "formal_statement": "example [ConNF.Params ] {i : ConNF.\u03ba} {j : ConNF.\u03ba} {k : ConNF.\u03ba} (h\u2081 : i < j + k) (h\u2082 : j \u2264 i) :i - j < k := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\ni j k : ConNF.\u03ba\nh\u2081 : i < j + k\nh\u2082 : j \u2264 i\n\u22a2 i - j < k", "dependency": [1]}, "ConNF.mk_typeIndex": {"natural_language_statement": "The cardinality of `ConNF.TypeIndex` is equal to the cardinality of `ConNF.\u039b`.", "formal_statement": "@[simp]example [ConNF.Params ] :Cardinal.mk ConNF.TypeIndex = Cardinal.mk ConNF.\u039b := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u22a2 Cardinal.mk ConNF.TypeIndex = Cardinal.mk ConNF.\u039b", "dependency": [1, 29, 29]}, "ConNF.card_Iio_lt": {"natural_language_statement": "Function `ConNF.card_Iio_lt` proves that the cardinality of the set of all elements less than a given element `x` in the type `ConNF.\u03bc` is strictly less than the cardinality of `ConNF.\u03bc`.", "formal_statement": "example [ConNF.Params ] (x : ConNF.\u03bc) :Cardinal.mk \u2191(Set.Iio x) < Cardinal.mk ConNF.\u03bc := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\nx : ConNF.\u03bc\n\u22a2 Cardinal.mk \u2191(Set.Iio x) < Cardinal.mk ConNF.\u03bc", "dependency": [1, 29, 526, 29]}, "ConNF.card_Iic_lt": {"natural_language_statement": "In the context of Constructive Ordinal Notation (ConNF), for any element `x` of type `ConNF.\u03bc`, the cardinality of the set of all elements less than or equal to `x` is strictly less than the cardinality of `ConNF.\u03bc`.", "formal_statement": "example [ConNF.Params ] (x : ConNF.\u03bc) :Cardinal.mk \u2191(Set.Iic x) < Cardinal.mk ConNF.\u03bc := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\nx : ConNF.\u03bc\n\u22a2 Cardinal.mk \u2191(Set.Iic x) < Cardinal.mk ConNF.\u03bc", "dependency": [1, 29, 528, 29]}, "ConNF.mk_atom": {"natural_language_statement": "Function `ConNF.mk_atom` proves that the cardinality of the type `ConNF.Atom` is equal to the cardinality of the type `ConNF.\u03bc` in the context of Constructive Ordinal Notation (ConNF).", "formal_statement": "@[simp]example [ConNF.Params ] :Cardinal.mk ConNF.Atom = Cardinal.mk ConNF.\u03bc := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u22a2 Cardinal.mk ConNF.Atom = Cardinal.mk ConNF.\u03bc", "dependency": [1, 29, 29]}, "ConNF.mem_litterSet": {"natural_language_statement": "The theorem `ConNF.mem_litterSet` states that an atom `a` belongs to the litter set `ConNF.litterSet L` if and only if the first projection of `a` is equal to `L`.", "formal_statement": "@[simp]example [ConNF.Params ] {a : ConNF.Atom} {L : ConNF.Litter} :a \u2208 ConNF.litterSet L \u2194 a.1 = L := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\na : ConNF.Atom\nL : ConNF.Litter\n\u22a2 a \u2208 ConNF.litterSet L \u2194 a.1 = L", "dependency": [1, 467]}, "ConNF.mk_litterSet": {"natural_language_statement": "In the context of Constructive Ordinal Notation (ConNF), each litter set has the same cardinality as the type `\u03ba`.", "formal_statement": "@[simp]example [ConNF.Params ] (L : ConNF.Litter) :Cardinal.mk \u2191(ConNF.litterSet L) = Cardinal.mk ConNF.\u03ba := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\nL : ConNF.Litter\n\u22a2 Cardinal.mk \u2191(ConNF.litterSet L) = Cardinal.mk ConNF.\u03ba", "dependency": [1, 29, 467, 29]}, "ConNF.litterSet_nonempty": {"natural_language_statement": "The theorem `ConNF.litterSet_nonempty` states that for any given litter `L` in the context of Constructive Ordinal Notation (ConNF), the set of all atoms `a` such that the first projection of `a` is equal to `L` is nonempty. This means there exists at least one such atom.", "formal_statement": "example [ConNF.Params ] (L : ConNF.Litter) :Nonempty \u2191(ConNF.litterSet L) := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\nL : ConNF.Litter\n\u22a2 Nonempty \u2191(ConNF.litterSet L)", "dependency": [1, 212, 467]}, "ConNF.pairwise_disjoint_litterSet": {"natural_language_statement": "In the context of Constructive Ordinal Notation (ConNF), the theorem `ConNF.pairwise_disjoint_litterSet` states that the litter sets of litters with different indices are pairwise disjoint. This means that for any two litters with different indices, their litter sets do not share any common elements. This property is crucial in ensuring that the construction of natural numbers using ConNF is well-defined and consistent.", "formal_statement": "example [ConNF.Params ] :Pairwise (Disjoint on ConNF.litterSet) := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u22a2 Pairwise (Disjoint on ConNF.litterSet)", "dependency": [1, 490]}, "ConNF.eq_of_mem_litterSet_of_mem_litterSet": {"natural_language_statement": "The theorem `ConNF.eq_of_mem_litterSet_of_mem_litterSet` states that if an atom `a` belongs to two different litter sets `ConNF.litterSet L\u2081` and `ConNF.litterSet L\u2082`, then the litters `L\u2081` and `L\u2082` must be equal.", "formal_statement": "example [ConNF.Params ] {a : ConNF.Atom} {L\u2081 : ConNF.Litter} {L\u2082 : ConNF.Litter} (hi : a \u2208 ConNF.litterSet L\u2081) (hj : a \u2208 ConNF.litterSet L\u2082) :L\u2081 = L\u2082 := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\na : ConNF.Atom\nL\u2081 L\u2082 : ConNF.Litter\nhi : a \u2208 ConNF.litterSet L\u2081\nhj : a \u2208 ConNF.litterSet L\u2082\n\u22a2 L\u2081 = L\u2082", "dependency": [1, 467, 467]}, "ConNF.litterSet_symmDiff_litterSet": {"natural_language_statement": "The theorem `ConNF.litterSet_symmDiff_litterSet` states that for two different litters `L\u2081` and `L\u2082`, the symmetric difference of the sets `ConNF.litterSet L\u2081` and `ConNF.litterSet L\u2082` is equal to their union.", "formal_statement": "example [ConNF.Params ] {L\u2081 : ConNF.Litter} {L\u2082 : ConNF.Litter} (h : L\u2081 \u2260 L\u2082) :symmDiff (ConNF.litterSet L\u2081) (ConNF.litterSet L\u2082) = ConNF.litterSet L\u2081 \u222a ConNF.litterSet L\u2082 := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\nL\u2081 L\u2082 : ConNF.Litter\nh : L\u2081 \u2260 L\u2082\n\u22a2 symmDiff (ConNF.litterSet L\u2081) (ConNF.litterSet L\u2082) = ConNF.litterSet L\u2081 \u222a ConNF.litterSet L\u2082", "dependency": [1, 62, 467, 467, 467, 467]}, "WithBot.coe_ne_coe": {"natural_language_statement": "The theorem `WithBot.coe_ne_coe` states that for any two elements `a` and `b` of a type `\u03b1`, the inequality `\u2191a \u2260 \u2191b` holds if and only if `a \u2260 b`.", "formal_statement": "example {\u03b1 : Type u_1} {a : \u03b1} {b : \u03b1} :\u2191a \u2260 \u2191b \u2194 a \u2260 b := by sorry", "full_tactic_state": "\u03b1 : Type u_1\na b : \u03b1\n\u22a2 a \u2260 b \u2194 a \u2260 b", "dependency": []}, "Ordinal.IsLimit.isSuccLimit": {"natural_language_statement": "The theorem `Ordinal.IsLimit.isSuccLimit` states that if an ordinal is a limit ordinal, then it is also a successor limit in the order sense.", "formal_statement": "example {o : Ordinal } (h : Ordinal.IsLimit o) :Order.IsSuccLimit o := by sorry", "full_tactic_state": "o : Ordinal.{?u.2}\nh : Ordinal.IsLimit o\n\u22a2 Order.IsSuccLimit o", "dependency": [25, 24, 538]}, "csupr_neg": {"natural_language_statement": "In a complete lattice, if the proposition `p` is false, then the supremum of the function `f` over `p` is equal to the bottom element of the lattice.", "formal_statement": "example {\u03b1 : Type u_1} [CompleteLattice \u03b1] {p : Prop } {f : p \u2192 \u03b1} (hp : \u00ac p) :\u2a06 (h : p), f h = \u22a5 := by sorry", "full_tactic_state": "\u03b1 : Type u_1\ninst\u271d : CompleteLattice \u03b1\np : Prop\nf : p \u2192 \u03b1\nhp : \u00acp\n\u22a2 \u2a06 (h : p), f h = \u22a5", "dependency": [540]}, "Set.compl_eq_empty": {"natural_language_statement": "The complement of a set `s` is equal to the empty set if and only if `s` is equal to the universal set.", "formal_statement": "@[simp]example {\u03b1 : Type u_1} {s : Set \u03b1} :s\u1d9c = \u2205 \u2194 s = Set.univ := by sorry", "full_tactic_state": "\u03b1 : Type u_1\ns : Set \u03b1\n\u22a2 s\u1d9c = \u2205 \u2194 s = Set.univ", "dependency": [69]}, "Set.compl_eq_univ": {"natural_language_statement": "The complement of a set `s` is equal to the universal set if and only if `s` is the empty set.", "formal_statement": "@[simp]example {\u03b1 : Type u_1} {s : Set \u03b1} :s\u1d9c = Set.univ \u2194 s = \u2205 := by sorry", "full_tactic_state": "\u03b1 : Type u_1\ns : Set \u03b1\n\u22a2 s\u1d9c = Set.univ \u2194 s = \u2205", "dependency": [69]}, "Set.image_sUnion": {"natural_language_statement": "The theorem `Set.image_sUnion` states that for any function `f` and any set of sets `S`, the image of the union of all sets in `S` under `f` is equal to the union of the images of each set in `S` under `f`.", "formal_statement": "example {\u03b1 : Type u_1} {\u03b2 : Type u_2} (f : \u03b1 \u2192 \u03b2) (S : Set (Set \u03b1)) :f '' \u22c3\u2080 S = \u22c3 s \u2208 S, f '' s := by sorry", "full_tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : \u03b1 \u2192 \u03b2\nS : Set (Set \u03b1)\n\u22a2 f '' \u22c3\u2080 S = \u22c3 s \u2208 S, f '' s", "dependency": [69, 69]}, "Set.iUnion_pos": {"natural_language_statement": "The theorem `Set.iUnion_pos` states that if `p` is a true proposition, then the union of the sets `f h` for all `h : p` is equal to `f hp`, where `hp` is a proof of `p`.", "formal_statement": "@[simp]example {\u03b1 : Type u_1} {p : Prop } {f : p \u2192 Set \u03b1} (hp : p) :\u22c3 (h : p), f h = f hp := by sorry", "full_tactic_state": "\u03b1 : Type u_1\np : Prop\nf : p \u2192 Set \u03b1\nhp : p\n\u22a2 \u22c3 (h : p), f h = f hp", "dependency": [69]}, "Set.iUnion_neg'": {"natural_language_statement": "The theorem `Set.iUnion_neg'` states that if `p` is a false proposition, then the union of sets indexed by `p` is the empty set.", "formal_statement": "@[simp]example {\u03b1 : Type u_1} {p : Prop } {f : p \u2192 Set \u03b1} (hp : \u00ac p) :\u22c3 (h : p), f h = \u2205 := by sorry", "full_tactic_state": "\u03b1 : Type u_1\np : Prop\nf : p \u2192 Set \u03b1\nhp : \u00acp\n\u22a2 \u22c3 (h : p), f h = \u2205", "dependency": [69]}, "Set.empty_symmDiff": {"natural_language_statement": "The symmetric difference between the empty set and any set `s` is equal to `s`.", "formal_statement": "@[simp]example {\u03b1 : Type u_1} (s : Set \u03b1) :symmDiff \u2205 s = s := by sorry", "full_tactic_state": "\u03b1 : Type u_1\ns : Set \u03b1\n\u22a2 symmDiff \u2205 s = s", "dependency": [69, 62]}, "Set.symmDiff_empty": {"natural_language_statement": "The symmetric difference of a set `s` and the empty set is equal to `s`.", "formal_statement": "@[simp]example {\u03b1 : Type u_1} (s : Set \u03b1) :symmDiff s \u2205 = s := by sorry", "full_tactic_state": "\u03b1 : Type u_1\ns : Set \u03b1\n\u22a2 symmDiff s \u2205 = s", "dependency": [69, 62]}, "Cardinal.nonempty_compl_of_mk_lt_mk": {"natural_language_statement": "If the cardinality of a set `s` is less than the cardinality of the type `\u03b1`, then the complement of `s` is nonempty.", "formal_statement": "example {\u03b1 : Type u} {s : Set \u03b1} (h : Cardinal.mk \u2191s < Cardinal.mk \u03b1) :Set.Nonempty s\u1d9c := by sorry", "full_tactic_state": "\u03b1 : Type u\ns : Set \u03b1\nh : Cardinal.mk \u2191s < Cardinal.mk \u03b1\n\u22a2 Set.Nonempty s\u1d9c", "dependency": [69, 29, 29, 83]}, "PiProp.vadd_def": {"natural_language_statement": "Function `PiProp.vadd_def` defines the vector addition operation `+\u1d65` for a dependent function type `(i : I) \u2192 f i`, where `f : I \u2192 Type v` and `x : (i : I) \u2192 f i`. It states that for any `s : \u03b1` and `x : (i : I) \u2192 f i`, the vector addition `s +\u1d65 x` is equal to the function that maps each `i : I` to `s +\u1d65 x i`.", "formal_statement": "example {I : Prop } {f : I \u2192 Type v} (x : (i : I) \u2192 f i) {\u03b1 : Type u_1} [(i : I) \u2192 VAdd \u03b1 (f i)] (s : \u03b1) :s +\u1d65 x = fun (i : I) => s +\u1d65 x i := by sorry", "full_tactic_state": "I : Prop\nf : I \u2192 Type v\nx : (i : I) \u2192 f i\n\u03b1 : Type u_1\ninst\u271d : (i : I) \u2192 VAdd \u03b1 (f i)\ns : \u03b1\n\u22a2 s +\u1d65 x = fun i => s +\u1d65 x i", "dependency": [557]}, "PiProp.smul_def": {"natural_language_statement": "`PiProp.smul_def` is a theorem in Lean 4 that defines the scalar multiplication of an element `s : \u03b1` with a dependent function `x : (i : I) \u2192 f i`, where `f : I \u2192 Type v` and `SMul \u03b1 (f i)` for each `i : I`. The theorem states that `s \u2022 x` is equal to the function that maps each `i : I` to `s \u2022 x i`.", "formal_statement": "example {I : Prop } {f : I \u2192 Type v} (x : (i : I) \u2192 f i) {\u03b1 : Type u_1} [(i : I) \u2192 SMul \u03b1 (f i)] (s : \u03b1) :s \u2022 x = fun (i : I) => s \u2022 x i := by sorry", "full_tactic_state": "I : Prop\nf : I \u2192 Type v\nx : (i : I) \u2192 f i\n\u03b1 : Type u_1\ninst\u271d : (i : I) \u2192 SMul \u03b1 (f i)\ns : \u03b1\n\u22a2 s \u2022 x = fun i => s \u2022 x i", "dependency": [57]}, "PiProp.vadd_apply": {"natural_language_statement": "`PiProp.vadd_apply` is a theorem in Lean 4 that states that for a dependent function `x : (i : I) \u2192 f i`, the vector addition `s +\u1d65 x` applied to an index `i` is equal to the vector addition of `s` and `x i`.", "formal_statement": "@[simp]example {I : Prop } {f : I \u2192 Type v} (x : (i : I) \u2192 f i) (i : I) {\u03b1 : Type u_1} [(i : I) \u2192 VAdd \u03b1 (f i)] (s : \u03b1) :(s +\u1d65 x) i = s +\u1d65 x i := by sorry", "full_tactic_state": "I : Prop\nf : I \u2192 Type v\nx : (i : I) \u2192 f i\ni : I\n\u03b1 : Type u_1\ninst\u271d : (i : I) \u2192 VAdd \u03b1 (f i)\ns : \u03b1\n\u22a2 (s +\u1d65 x) i = s +\u1d65 x i", "dependency": [557]}, "PiProp.smul_apply": {"natural_language_statement": "The `PiProp.smul_apply` theorem states that for any indexed family of types `f : I \u2192 Type v` and any scalar `s : \u03b1`, the application of the scalar multiplication to an element `x : (i : I) \u2192 f i` at an index `i : I` is equal to the scalar multiplication of `x i` by `s`.", "formal_statement": "@[simp]example {I : Prop } {f : I \u2192 Type v} (x : (i : I) \u2192 f i) (i : I) {\u03b1 : Type u_1} [(i : I) \u2192 SMul \u03b1 (f i)] (s : \u03b1) :(s \u2022 x) i = s \u2022 x i := by sorry", "full_tactic_state": "I : Prop\nf : I \u2192 Type v\nx : (i : I) \u2192 f i\ni : I\n\u03b1 : Type u_1\ninst\u271d : (i : I) \u2192 SMul \u03b1 (f i)\ns : \u03b1\n\u22a2 (s \u2022 x) i = s \u2022 x i", "dependency": [57]}, "PiProp.vadd_apply'": {"natural_language_statement": "The theorem `PiProp.vadd_apply'` states that for any indexed family of types `f : I \u2192 Type v` and `g : I \u2192 Type u_1`, where each `f i` has a vector addition operation with each `g i`, the vector addition of a dependent function `s : (i : I) \u2192 f i` and a dependent function `x : (i : I) \u2192 g i` at an index `i : I` is equal to the vector addition of `s i` and `x i`.", "formal_statement": "@[simp]example {I : Prop } {f : I \u2192 Type v} (i : I) {g : I \u2192 Type u_1} [(i : I) \u2192 VAdd (f i) (g i)] (s : (i : I) \u2192 f i) (x : (i : I) \u2192 g i) :(s +\u1d65 x) i = s i +\u1d65 x i := by sorry", "full_tactic_state": "I : Prop\nf : I \u2192 Type v\ni : I\ng : I \u2192 Type u_1\ninst\u271d : (i : I) \u2192 VAdd (f i) (g i)\ns : (i : I) \u2192 f i\nx : (i : I) \u2192 g i\n\u22a2 (s +\u1d65 x) i = s i +\u1d65 x i", "dependency": [557]}, "PiProp.smul_apply'": {"natural_language_statement": "The `PiProp.smul_apply'` theorem states that for any indexed family of types `f : I \u2192 Type v` and `g : I \u2192 Type u_1`, where `SMul (f i) (g i)` is defined for each `i : I`, and given `s : (i : I) \u2192 f i` and `x : (i : I) \u2192 g i`, the `i`-th component of `s \u2022 x` is equal to `s i \u2022 x i`.", "formal_statement": "@[simp]example {I : Prop } {f : I \u2192 Type v} (i : I) {g : I \u2192 Type u_1} [(i : I) \u2192 SMul (f i) (g i)] (s : (i : I) \u2192 f i) (x : (i : I) \u2192 g i) :(s \u2022 x) i = s i \u2022 x i := by sorry", "full_tactic_state": "I : Prop\nf : I \u2192 Type v\ni : I\ng : I \u2192 Type u_1\ninst\u271d : (i : I) \u2192 SMul (f i) (g i)\ns : (i : I) \u2192 f i\nx : (i : I) \u2192 g i\n\u22a2 (s \u2022 x) i = s i \u2022 x i", "dependency": [57]}, "PiProp.has_faithful_vadd_at": {"natural_language_statement": "The theorem `PiProp.has_faithful_vadd_at` states that if each `f i` has a faithful vector addition operation for each `i : I`, then the type `(i : I) \u2192 f i` also has a faithful vector addition operation. This theorem is a special case of the more general `PiProp.has_faithful_vadd` which applies when `I` is a type instead of a proposition. The proof of `PiProp.has_faithful_vadd_at` is straightforward, using the `faithfulVAdd_at` lemma which is applied to each `i : I`.", "formal_statement": "example {I : Prop } {f : I \u2192 Type v} {\u03b1 : Type u_1} [(i : I) \u2192 VAdd \u03b1 (f i)] [\u2200 (i : I), Nonempty (f i)] (i : I) [FaithfulVAdd \u03b1 (f i)] :FaithfulVAdd \u03b1 ((i : I) \u2192 f i) := by sorry", "full_tactic_state": "I : Prop\nf : I \u2192 Type v\n\u03b1 : Type u_1\ninst\u271d\u00b2 : (i : I) \u2192 VAdd \u03b1 (f i)\ninst\u271d\u00b9 : \u2200 (i : I), Nonempty (f i)\ni : I\ninst\u271d : FaithfulVAdd \u03b1 (f i)\n\u22a2 FaithfulVAdd \u03b1 ((i : I) \u2192 f i)", "dependency": [557, 212, 564, 564]}, "PiProp.faithfulSMul_at": {"natural_language_statement": "The theorem `PiProp.faithfulSMul_at` states that if `f i` has a faithful scalar action for a given `i`, then the product type `\u03a0 i, f i` also has a faithful scalar action. This is not an instance because the index `i` cannot be inferred from the context.", "formal_statement": "example {I : Prop } {f : I \u2192 Type v} {\u03b1 : Type u_1} [(i : I) \u2192 SMul \u03b1 (f i)] [\u2200 (i : I), Nonempty (f i)] (i : I) [FaithfulSMul \u03b1 (f i)] :FaithfulSMul \u03b1 ((i : I) \u2192 f i) := by sorry", "full_tactic_state": "I : Prop\nf : I \u2192 Type v\n\u03b1 : Type u_1\ninst\u271d\u00b2 : (i : I) \u2192 SMul \u03b1 (f i)\ninst\u271d\u00b9 : \u2200 (i : I), Nonempty (f i)\ni : I\ninst\u271d : FaithfulSMul \u03b1 (f i)\n\u22a2 FaithfulSMul \u03b1 ((i : I) \u2192 f i)", "dependency": [57, 212, 566, 566]}, "PiProp.addAction.proof_2": {"natural_language_statement": "`PiProp.addAction` is a proof that for any type `I` (which in Lean 4 is interpreted as a logical proposition), for any family of types `f : I \u2192 Type u_1`, and for any additive monoid `\u03b1` with an additive action on each `f i`, the addition operation on `\u03b1` and the action of `\u03b1` on `f i` commute. This is a property that if holds for any `x`, `x_1` from `\u03b1` and `x_2` from `(i : I) \u2192 f i`, then `x + x_1 +\u1d65 x_2` equals `x +\u1d65 (x_1 +\u1d65 x_2)`. This property is used to define an additive action on the Pi type `(i : I) \u2192 f i` when `\u03b1` is an additive monoid.", "formal_statement": "example {I : Prop } {f : I \u2192 Type u_1} (\u03b1 : Type u_2) {m : AddMonoid \u03b1} [(i : I) \u2192 AddAction \u03b1 (f i)] :\u2200 (x x_1 : \u03b1) (x_2 : (i : I) \u2192 f i), x + x_1 +\u1d65 x_2 = x +\u1d65 (x_1 +\u1d65 x_2) := by sorry", "full_tactic_state": "I : Prop\nf : I \u2192 Type u_1\n\u03b1 : Type u_2\nm : AddMonoid \u03b1\ninst\u271d : (i : I) \u2192 AddAction \u03b1 (f i)\n\u22a2 \u2200 (x x_1 : \u03b1) (x_2 : (i : I) \u2192 f i), x + x_1 +\u1d65 x_2 = x +\u1d65 (x_1 +\u1d65 x_2)", "dependency": [31, 568]}, "PiProp.addAction'.proof_2": {"natural_language_statement": "`PiProp.addAction'.proof_2` is a proof of the associativity of the `+\u1d65` operation in a family of types parameterized by a proposition `I`, where each type is equipped with an `AddMonoid` and `AddAction` instance. The theorem asserts that for any two elements of the `I \u2192 f i` type (which is a product type over `f i` for all `i : I`) and an element of the `I \u2192 g i` type, the operation `+\u1d65` is associative. This property is inherent to the `AddAction` instances on each `f i` acting on each `g i`.", "formal_statement": "example {I : Prop } {f : I \u2192 Type u_2} {g : I \u2192 Type u_1} {m : (i : I) \u2192 AddMonoid (f i)} [(i : I) \u2192 AddAction (f i) (g i)] :\u2200 (x x_1 : (i : I) \u2192 f i) (x_2 : (i : I) \u2192 g i), x + x_1 +\u1d65 x_2 = x +\u1d65 (x_1 +\u1d65 x_2) := by sorry", "full_tactic_state": "I : Prop\nf : I \u2192 Type u_2\ng : I \u2192 Type u_1\nm : (i : I) \u2192 AddMonoid (f i)\ninst\u271d : (i : I) \u2192 AddAction (f i) (g i)\n\u22a2 \u2200 (x x_1 : (i : I) \u2192 f i) (x_2 : (i : I) \u2192 g i), x + x_1 +\u1d65 x_2 = x +\u1d65 (x_1 +\u1d65 x_2)", "dependency": [31, 568]}, "Equiv.orderIso_apply": {"natural_language_statement": "Function `Equiv.orderIso` constructs an order isomorphism between two types `\u03b1` and `\u03b2` given an equivalence `e : \u03b1 \u2243 \u03b2` and a partial order on `\u03b2`. The application of this order isomorphism to an element `a : \u03b1` is equivalent to applying the equivalence `e` to `a`.", "formal_statement": "@[simp]example {\u03b1 : Type u_2} {\u03b2 : Type u_1} (e : \u03b1 \u2243 \u03b2) [LE \u03b2] (a : \u03b1) :(Equiv.orderIso e) a = e a := by sorry", "full_tactic_state": "\u03b1 : Type u_2\n\u03b2 : Type u_1\ne : \u03b1 \u2243 \u03b2\ninst\u271d : LE \u03b2\na : \u03b1\n\u22a2 (Equiv.orderIso e) a = e a", "dependency": [5, 571]}, "Set.neg_sUnion": {"natural_language_statement": "The negation of the union of a set of sets is equal to the union of the negation of each set in the set of sets.", "formal_statement": "@[simp]example {\u03b1 : Type u_1} [InvolutiveNeg \u03b1] (S : Set (Set \u03b1)) :- \u22c3\u2080 S = \u22c3 s \u2208 S, - s := by sorry", "full_tactic_state": "\u03b1 : Type u_1\ninst\u271d : InvolutiveNeg \u03b1\nS : Set (Set \u03b1)\n\u22a2 -\u22c3\u2080 S = \u22c3 s \u2208 S, -s", "dependency": [573, 69, 69]}, "Set.inv_sUnion": {"natural_language_statement": "The theorem `Set.inv_sUnion` states that the inverse of the union of a set of sets is equal to the union of the inverses of each set in the set of sets.", "formal_statement": "@[simp]example {\u03b1 : Type u_1} [InvolutiveInv \u03b1] (S : Set (Set \u03b1)) :(\u22c3\u2080 S)\u207b\u00b9 = \u22c3 s \u2208 S, s\u207b\u00b9 := by sorry", "full_tactic_state": "\u03b1 : Type u_1\ninst\u271d : InvolutiveInv \u03b1\nS : Set (Set \u03b1)\n\u22a2 (\u22c3\u2080 S)\u207b\u00b9 = \u22c3 s \u2208 S, s\u207b\u00b9", "dependency": [576, 69, 69]}, "Set.addActionNonempty.proof_1": {"natural_language_statement": "The function `fun (a : { s : Set \u03b2 // Set.Nonempty s }) => \u2191a` is injective.", "formal_statement": "example {\u03b2 : Type u_1} :Function.Injective fun (a : { s : Set \u03b2 // Set.Nonempty s }) => \u2191a := by sorry", "full_tactic_state": "\u03b2 : Type u_1\n\u22a2 Function.Injective fun a => a", "dependency": [89, 69, 83]}, "Equiv.symm_trans": {"natural_language_statement": "The theorem `Equiv.symm_trans` states that for any two equivalences `f : \u03b1 \u2243 \u03b2` and `g : \u03b2 \u2243 \u03b3`, the inverse of their composition `f.trans g` is equal to the composition of their inverses `g.symm.trans f.symm`.", "formal_statement": "@[simp]example {\u03b1 : Type u_1} {\u03b2 : Type u_2} {\u03b3 : Type u_3} (f : \u03b1 \u2243 \u03b2) (g : \u03b2 \u2243 \u03b3) :(f.trans g).symm = g.symm.trans f.symm := by sorry", "full_tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nf : \u03b1 \u2243 \u03b2\ng : \u03b2 \u2243 \u03b3\n\u22a2 (f.trans g).symm = g.symm.trans f.symm", "dependency": []}, "PiProp.addSemigroup.proof_1": {"natural_language_statement": "`PiProp.addSemigroup.proof_1` is a proof of the associativity of addition in a product of additive semigroups.", "formal_statement": "example {I : Prop } {f : I \u2192 Type u_1} [(i : I) \u2192 AddSemigroup (f i)] (a : (i : I) \u2192 f i) (b : (i : I) \u2192 f i) (c : (i : I) \u2192 f i) :a + b + c = a + (b + c) := by sorry", "full_tactic_state": "I : Prop\nf : I \u2192 Type u_1\ninst\u271d : (i : I) \u2192 AddSemigroup (f i)\na b c : (i : I) \u2192 f i\n\u22a2 a + b + c = a + (b + c)", "dependency": [32]}, "PiProp.addCommSemigroup.proof_1": {"natural_language_statement": "The `PiProp.addCommSemigroup.proof_1` theorem is a proof that the binary operation `+` on the set `(I \u2192 Type u_1)` of functions from a type `I` to a type `Type u_1`, where each `f i` is an `AddCommSemigroup`, is commutative. This is because `+` is defined pointwise on the components of the functions, and for each `i`, the operation `+` on `f i` is commutative by the `AddCommSemigroup` assumption.", "formal_statement": "example {I : Prop } {f : I \u2192 Type u_1} [(i : I) \u2192 AddCommSemigroup (f i)] (a : (i : I) \u2192 f i) (b : (i : I) \u2192 f i) :a + b = b + a := by sorry", "full_tactic_state": "I : Prop\nf : I \u2192 Type u_1\ninst\u271d : (i : I) \u2192 AddCommSemigroup (f i)\na b : (i : I) \u2192 f i\n\u22a2 a + b = b + a", "dependency": [581]}, "PiProp.addZeroClass.proof_1": {"natural_language_statement": "The theorem `PiProp.addZeroClass.proof_1` states that for any type family `f : I \u2192 Type u_1` where each `f i` is an `AddZeroClass`, the zero element of the product type `(i : I) \u2192 f i` (denoted as `0`) added to any element `a` of the product type results in `a`.", "formal_statement": "example {I : Prop } {f : I \u2192 Type u_1} [(i : I) \u2192 AddZeroClass (f i)] (a : (i : I) \u2192 f i) :0 + a = a := by sorry", "full_tactic_state": "I : Prop\nf : I \u2192 Type u_1\ninst\u271d : (i : I) \u2192 AddZeroClass (f i)\na : (i : I) \u2192 f i\n\u22a2 0 + a = a", "dependency": [583]}, "PiProp.addZeroClass.proof_2": {"natural_language_statement": "`PiProp.addZeroClass.proof_2` is a proof of the statement that for any type family `f : I \u2192 Type u_1` where each `f i` is an `AddZeroClass`, and any dependent function `a : (i : I) \u2192 f i`, the equation `a + 0 = a` holds.", "formal_statement": "example {I : Prop } {f : I \u2192 Type u_1} [(i : I) \u2192 AddZeroClass (f i)] (a : (i : I) \u2192 f i) :a + 0 = a := by sorry", "full_tactic_state": "I : Prop\nf : I \u2192 Type u_1\ninst\u271d : (i : I) \u2192 AddZeroClass (f i)\na : (i : I) \u2192 f i\n\u22a2 a + 0 = a", "dependency": [583]}, "PiProp.addMonoid.proof_4": {"natural_language_statement": "The theorem `PiProp.addMonoid.proof_4` in Lean 4 is a part of the proof that the Pi-type `(I \u2192 f i)` forms an additive monoid when each `f i` is an additive monoid. It asserts that the addition of a natural number `n` to each element of a function-type `(i : I) \u2192 f i` at each index `i`, followed by the addition of a function-type `(i : I) \u2192 f i` itself, results in the function-type being unchanged when `n = 1`. This is essentially the property that the addition of `1` to a natural number `n` results in a function that is the identity function on `f i` at each index `i`.", "formal_statement": "example {I : Prop } {f : I \u2192 Type u_1} [inst : (i : I) \u2192 AddMonoid (f i)] (n : \u2115 ) (a : (i : I) \u2192 f i) :(fun (n : \u2115 ) (x : (i : I) \u2192 f i) (i : I) => n \u2022 x i) (n + 1) a = a + (fun (n : \u2115 ) (x : (i : I) \u2192 f i) (i : I) => n \u2022 x i) n a := by sorry", "full_tactic_state": "I : Prop\nf : I \u2192 Type u_1\ninst : (i : I) \u2192 AddMonoid (f i)\nn : \u2115\na : (i : I) \u2192 f i\n\u22a2 (fun n x i => n \u2022 x i) (n + 1) a = a + (fun n x i => n \u2022 x i) n a", "dependency": [31]}, "PiProp.addMonoid.proof_1": {"natural_language_statement": "`PiProp.addMonoid.proof_1` is a proof that for any type `I` and any family of types `f : I \u2192 Type u_1`, if each `f i` is an `AddMonoid`, then the addition defined pointwise on the product type `(i : I) \u2192 f i` satisfies the property of an additive monoid that `0 + a = a`. This is one of the axioms of an additive monoid, stating that the zero element, when added to any element, results in the original element.", "formal_statement": "example {I : Prop } {f : I \u2192 Type u_1} [inst : (i : I) \u2192 AddMonoid (f i)] (a : (i : I) \u2192 f i) :0 + a = a := by sorry", "full_tactic_state": "I : Prop\nf : I \u2192 Type u_1\ninst : (i : I) \u2192 AddMonoid (f i)\na : (i : I) \u2192 f i\n\u22a2 0 + a = a", "dependency": [31]}, "PiProp.addMonoid.proof_2": {"natural_language_statement": "The theorem `PiProp.addMonoid.proof_2` states that for any family of types `f : I \u2192 Type u_1` where each `f i` is an additive monoid, the sum of any function `a : (i : I) \u2192 f i` with the zero function is equal to `a`.", "formal_statement": "example {I : Prop } {f : I \u2192 Type u_1} [inst : (i : I) \u2192 AddMonoid (f i)] (a : (i : I) \u2192 f i) :a + 0 = a := by sorry", "full_tactic_state": "I : Prop\nf : I \u2192 Type u_1\ninst : (i : I) \u2192 AddMonoid (f i)\na : (i : I) \u2192 f i\n\u22a2 a + 0 = a", "dependency": [31]}, "PiProp.addMonoid.proof_3": {"natural_language_statement": "`PiProp.addMonoid.proof_3` proves that for any type family `f : I \u2192 Type u_1` where each `f i` is an additive monoid, and any `a : (i : I) \u2192 f i`, the operation `(fun (n : \u2115) (x : (i : I) \u2192 f i) (i : I) \u21a6 n \u2022 x i)` applied to `0` and `a` results in `0`.", "formal_statement": "example {I : Prop } {f : I \u2192 Type u_1} [inst : (i : I) \u2192 AddMonoid (f i)] (a : (i : I) \u2192 f i) :(fun (n : \u2115 ) (x : (i : I) \u2192 f i) (i : I) => n \u2022 x i) 0 a = 0 := by sorry", "full_tactic_state": "I : Prop\nf : I \u2192 Type u_1\ninst : (i : I) \u2192 AddMonoid (f i)\na : (i : I) \u2192 f i\n\u22a2 (fun n x i => n \u2022 x i) 0 a = 0", "dependency": [31]}, "PiProp.addCommMonoid.proof_1": {"natural_language_statement": "`PiProp.addCommMonoid.proof_1` is a proof that for any family of additive commutative monoids, the Pi type of that family is also an additive commutative monoid, where the addition operation is defined component-wise. This is essentially stating that the addition operation in the Pi type is commutative.", "formal_statement": "example {I : Prop } {f : I \u2192 Type u_1} [(i : I) \u2192 AddCommMonoid (f i)] (a : (i : I) \u2192 f i) (b : (i : I) \u2192 f i) :a + b = b + a := by sorry", "full_tactic_state": "I : Prop\nf : I \u2192 Type u_1\ninst\u271d : (i : I) \u2192 AddCommMonoid (f i)\na b : (i : I) \u2192 f i\n\u22a2 a + b = b + a", "dependency": [590]}, "PiProp.subNegMonoid.proof_2": {"natural_language_statement": "Given a type I, the Pi type (I \u2192 Type u_1) is also a SubNegMonoid if each component type (f i) is a SubNegMonoid. The theorem `PiProp.subNegMonoid.proof_2` is a part of the proof that the Pi type (I \u2192 Type u_1) is a SubNegMonoid. The theorem states that for any element a of the type (I \u2192 Type u_1), multiplying a by 0 using the integer scalar multiplication `zsmulRec` (which is a recursive version of `zsmul`) results in the same value as multiplying a by 0 using `zsmulRec`. This is the second part of the proof that `zsmulRec 0 a` is equal to `zsmulRec 0 a`, which is a trivial equality and does not require any further simplification.", "formal_statement": "example {I : Prop } {f : I \u2192 Type u_1} [inst : (i : I) \u2192 SubNegMonoid (f i)] :\u2200 (a : (i : I) \u2192 f i), zsmulRec 0 a = zsmulRec 0 a := by sorry", "full_tactic_state": "I : Prop\nf : I \u2192 Type u_1\ninst : (i : I) \u2192 SubNegMonoid (f i)\n\u22a2 \u2200 (a : (i : I) \u2192 f i), zsmulRec 0 a = zsmulRec 0 a", "dependency": [592]}, "PiProp.subNegMonoid.proof_1": {"natural_language_statement": "The theorem `PiProp.subNegMonoid.proof_1` states that for any type family `f : I \u2192 Type u_1` where each `f i` is a `SubNegMonoid`, the subtraction operation on the Pi type `(i : I) \u2192 f i` is equivalent to addition with the negation of the second operand.", "formal_statement": "example {I : Prop } {f : I \u2192 Type u_1} [inst : (i : I) \u2192 SubNegMonoid (f i)] (a : (i : I) \u2192 f i) (b : (i : I) \u2192 f i) :a - b = a + - b := by sorry", "full_tactic_state": "I : Prop\nf : I \u2192 Type u_1\ninst : (i : I) \u2192 SubNegMonoid (f i)\na b : (i : I) \u2192 f i\n\u22a2 a - b = a + -b", "dependency": [592]}, "PiProp.subNegMonoid.proof_4": {"natural_language_statement": "The `PiProp.subNegMonoid.proof_4` theorem is a proof of the property that `zsmulRec (Int.negSucc n) a` equals itself, which is a part of extending the `SubNegMonoid` class to the pi-type `\u2200 i, f i` where each `f i` is a `SubNegMonoid`. This theorem ensures that the negation operation `zsmulRec` on negative integers satisfies the properties required by the `SubNegMonoid` class.", "formal_statement": "example {I : Prop } {f : I \u2192 Type u_1} [inst : (i : I) \u2192 SubNegMonoid (f i)] :\u2200 (n : \u2115 ) (a : (i : I) \u2192 f i), zsmulRec (Int.negSucc n) a = zsmulRec (Int.negSucc n) a := by sorry", "full_tactic_state": "I : Prop\nf : I \u2192 Type u_1\ninst : (i : I) \u2192 SubNegMonoid (f i)\n\u22a2 \u2200 (n : \u2115) (a : (i : I) \u2192 f i), zsmulRec (Int.negSucc n) a = zsmulRec (Int.negSucc n) a", "dependency": [592, 54, 54]}, "PiProp.subNegMonoid.proof_3": {"natural_language_statement": "The proof `PiProp.subNegMonoid.proof_3` is a part of the proof that the Pi type (a dependent function type) of `SubNegMonoid`s is itself a `SubNegMonoid`. This proof is specifically for the case when the exponent in the zsmul (scalar multiplication by an integer) is a natural number with a successor (i.e., a whole number plus one). It asserts that for any natural number `n` and any dependent function `a` (an element of the Pi type), the zsmul operation using `Int.ofNat (Nat.succ n)` (which represents the successor of `n` as an integer) on `a` is equal to itself, which is a trivial statement in the context of the successor operation. This proof is part of the construction of the `SubNegMonoid` instance for the Pi type, which is necessary for the development of the Lean mathematical library.", "formal_statement": "example {I : Prop } {f : I \u2192 Type u_1} [inst : (i : I) \u2192 SubNegMonoid (f i)] :\u2200 (n : \u2115 ) (a : (i : I) \u2192 f i), zsmulRec (Int.ofNat (Nat.succ n)) a = zsmulRec (Int.ofNat (Nat.succ n)) a := by sorry", "full_tactic_state": "I : Prop\nf : I \u2192 Type u_1\ninst : (i : I) \u2192 SubNegMonoid (f i)\n\u22a2 \u2200 (n : \u2115) (a : (i : I) \u2192 f i), zsmulRec (Int.ofNat (Nat.succ n)) a = zsmulRec (Int.ofNat (Nat.succ n)) a", "dependency": [592, 50, 53, 50, 53]}, "PiProp.hasInvolutiveNeg.proof_1": {"natural_language_statement": "The theorem `PiProp.hasInvolutiveNeg.proof_1` states that for any family of types `f : I \u2192 Type u_1` where each type `f i` has an involutive negation, the negation of a dependent function `a : (i : I) \u2192 f i` is equal to the function itself, i.e., `- - a = a`.", "formal_statement": "example {I : Prop } {f : I \u2192 Type u_1} [(i : I) \u2192 InvolutiveNeg (f i)] (a : (i : I) \u2192 f i) :- - a = a := by sorry", "full_tactic_state": "I : Prop\nf : I \u2192 Type u_1\ninst\u271d : (i : I) \u2192 InvolutiveNeg (f i)\na : (i : I) \u2192 f i\n\u22a2 - -a = a", "dependency": [573]}, "PiProp.subtractionMonoid.proof_1": {"natural_language_statement": "This theorem states that, for any function `x` from a type `I` to a family of types `f i`, where each `f i` is a `SubtractionMonoid`, the negation of `x` is equal to `x` itself. This property only holds under certain conditions, specifically when the domain `I` is a proposition, which means it contains only two elements: `True` and `False`. In this context, `x`, being a function from a proposition to a type, essentially represents a single value when evaluated at `True` or `False`. The negation of `x`, which in the context of `SubtractionMonoid` is defined as `-x`, results in the same value as `x`, as indicated by the equation `- - x = x`. This behavior aligns with the properties of `SubtractionMonoid`, where negating a number twice returns the original number, and thus, negating a function from a proposition to a `SubtractionMonoid` type results in the same function.", "formal_statement": "example {I : Prop } {f : I \u2192 Type u_1} [inst : (i : I) \u2192 SubtractionMonoid (f i)] (x : (i : I) \u2192 f i) :- - x = x := by sorry", "full_tactic_state": "I : Prop\nf : I \u2192 Type u_1\ninst : (i : I) \u2192 SubtractionMonoid (f i)\nx : (i : I) \u2192 f i\n\u22a2 - -x = x", "dependency": [599]}, "PiProp.subtractionMonoid.proof_2": {"natural_language_statement": "`PiProp.subtractionMonoid.proof_2` is a proof of the property for the negation operation in the `SubtractionMonoid` class in Lean 4. It states that for any two elements `a` and `b` in the product type `(i : I) \u2192 f i`, where each component `f i` is a subtraction monoid, the negation of the sum `- (a + b)` is equal to the sum of the negations `- b + - a`. This property is crucial for establishing the full subtraction monoid structure in the product type.", "formal_statement": "example {I : Prop } {f : I \u2192 Type u_1} [inst : (i : I) \u2192 SubtractionMonoid (f i)] (a : (i : I) \u2192 f i) (b : (i : I) \u2192 f i) :- (a + b) = - b + - a := by sorry", "full_tactic_state": "I : Prop\nf : I \u2192 Type u_1\ninst : (i : I) \u2192 SubtractionMonoid (f i)\na b : (i : I) \u2192 f i\n\u22a2 -(a + b) = -b + -a", "dependency": [599]}, "PiProp.subtractionMonoid.proof_3": {"natural_language_statement": "In mathematics, the concept of subtraction is defined as the inverse of addition. In an algebraic structure where addition is commutative, subtraction is well-defined as a binary operation, and the structure is known as a commutative group. The `SubtractionMonoid` class in Lean 4 represents a type `G` that extends an additive monoid with additional operations, including subtraction. Given an instance of `SubtractionMonoid` for a type `G`, we can define a subtraction operation `a - b` on elements of `G` using the `Sub.sub` function. The theorem `PiProp.subtractionMonoid.proof_3` asserts that for a type `G` that is a `SubtractionMonoid`, in a pointwise manner, if the sum of two elements `a` and `b` of type `G` is equal to zero, then `a` must be equal to `b`. This theorem is crucial for establishing the uniqueness of negation in a `SubtractionMonoid`, which is part of the definition of a `SubtractionMonoid`.", "formal_statement": "example {I : Prop } {f : I \u2192 Type u_1} [inst : (i : I) \u2192 SubtractionMonoid (f i)] (a : (i : I) \u2192 f i) (b : (i : I) \u2192 f i) (h : a + b = 0) :- a = b := by sorry", "full_tactic_state": "I : Prop\nf : I \u2192 Type u_1\ninst : (i : I) \u2192 SubtractionMonoid (f i)\na b : (i : I) \u2192 f i\nh : a + b = 0\n\u22a2 -a = b", "dependency": [599]}, "PiProp.subtractionCommMonoid.proof_1": {"natural_language_statement": "`PiProp.subtractionCommMonoid.proof_1` is a proof of the commutativity of addition in a product of subtraction commutative monoids.", "formal_statement": "example {I : Prop } {f : I \u2192 Type u_1} [(i : I) \u2192 SubtractionCommMonoid (f i)] (a : (i : I) \u2192 f i) (b : (i : I) \u2192 f i) :a + b = b + a := by sorry", "full_tactic_state": "I : Prop\nf : I \u2192 Type u_1\ninst\u271d : (i : I) \u2192 SubtractionCommMonoid (f i)\na b : (i : I) \u2192 f i\n\u22a2 a + b = b + a", "dependency": [603]}, "PiProp.addGroup.proof_1": {"natural_language_statement": "Function `PiProp.addGroup.proof_1` is a proof that for any type family `f : I \u2192 Type u_1` where each `f i` is an additive group, the sum of any element `a : (i : I) \u2192 f i` with itself is equal to zero.", "formal_statement": "example {I : Prop } {f : I \u2192 Type u_1} [(i : I) \u2192 AddGroup (f i)] (a : (i : I) \u2192 f i) :- a + a = 0 := by sorry", "full_tactic_state": "I : Prop\nf : I \u2192 Type u_1\ninst\u271d : (i : I) \u2192 AddGroup (f i)\na : (i : I) \u2192 f i\n\u22a2 -a + a = 0", "dependency": [605]}, "PiProp.addCommGroup.proof_1": {"natural_language_statement": "Function `PiProp.addCommGroup.proof_1` is a proof of the commutativity of addition in a product of additive commutative groups.", "formal_statement": "example {I : Prop } {f : I \u2192 Type u_1} [(i : I) \u2192 AddCommGroup (f i)] (a : (i : I) \u2192 f i) (b : (i : I) \u2192 f i) :a + b = b + a := by sorry", "full_tactic_state": "I : Prop\nf : I \u2192 Type u_1\ninst\u271d : (i : I) \u2192 AddCommGroup (f i)\na b : (i : I) \u2192 f i\n\u22a2 a + b = b + a", "dependency": [607]}, "PiProp.AddLeftCancelSemigroup.proof_1": {"natural_language_statement": "Function `PiProp.AddLeftCancelSemigroup.proof_1` proves that if `a`, `b`, and `c` are elements of a family of additive left-cancellative semigroups, and `a + b = a + c`, then `b = c`.", "formal_statement": "example {I : Prop } {f : I \u2192 Type u_1} [inst : (i : I) \u2192 AddLeftCancelSemigroup (f i)] (a : (i : I) \u2192 f i) (b : (i : I) \u2192 f i) (c : (i : I) \u2192 f i) (h : a + b = a + c) :b = c := by sorry", "full_tactic_state": "I : Prop\nf : I \u2192 Type u_1\ninst : (i : I) \u2192 AddLeftCancelSemigroup (f i)\na b c : (i : I) \u2192 f i\nh : a + b = a + c\n\u22a2 b = c", "dependency": [609]}, "PiProp.AddRightCancelSemigroup.proof_1": {"natural_language_statement": "`PiProp.AddRightCancelSemigroup.proof_1` is a proof that for any family of types `f : I \u2192 Type u_1`, if each `f i` is an `AddRightCancelSemigroup`, then the type `(i : I) \u2192 f i` is also an `AddRightCancelSemigroup`.", "formal_statement": "example {I : Prop } {f : I \u2192 Type u_1} [inst : (i : I) \u2192 AddRightCancelSemigroup (f i)] (a : (i : I) \u2192 f i) (b : (i : I) \u2192 f i) (c : (i : I) \u2192 f i) (h : a + b = c + b) :a = c := by sorry", "full_tactic_state": "I : Prop\nf : I \u2192 Type u_1\ninst : (i : I) \u2192 AddRightCancelSemigroup (f i)\na b c : (i : I) \u2192 f i\nh : a + b = c + b\n\u22a2 a = c", "dependency": [611]}, "PiProp.AddLeftCancelMonoid.proof_5": {"natural_language_statement": "The theorem `PiProp.AddLeftCancelMonoid.proof_5` states that for an indexed family of additive left-cancellative monoids, the `n+1`th multiple of an element `x` is equal to `x` plus the `n`th multiple of `x`.", "formal_statement": "example {I : Prop } {f : I \u2192 Type u_1} [(i : I) \u2192 AddLeftCancelMonoid (f i)] (n : \u2115 ) (x : (i : I) \u2192 f i) :AddMonoid.nsmul (n + 1) x = x + AddMonoid.nsmul n x := by sorry", "full_tactic_state": "I : Prop\nf : I \u2192 Type u_1\ninst\u271d : (i : I) \u2192 AddLeftCancelMonoid (f i)\nn : \u2115\nx : (i : I) \u2192 f i\n\u22a2 AddMonoid.nsmul (n + 1) x = x + AddMonoid.nsmul n x", "dependency": [613, 34, 34]}, "PiProp.AddLeftCancelMonoid.proof_1": {"natural_language_statement": "The theorem `PiProp.AddLeftCancelMonoid.proof_1` states that if you have a dependent family of types `f : I \u2192 Type u_1`, each of which is an additive left-cancellative monoid (a monoid where `a + b = a + c` implies `b = c`), then for any `a : (i : I) \u2192 f i` and `b : (i : I) \u2192 f i` and `c : (i : I) \u2192 f i`, if `a + b = a + c`, then `b = c`. This is a generalization of the property of left-cancellative monoids to dependent families of types.", "formal_statement": "example {I : Prop } {f : I \u2192 Type u_1} [(i : I) \u2192 AddLeftCancelMonoid (f i)] (a : (i : I) \u2192 f i) (b : (i : I) \u2192 f i) (c : (i : I) \u2192 f i) :a + b = a + c \u2192 b = c := by sorry", "full_tactic_state": "I : Prop\nf : I \u2192 Type u_1\ninst\u271d : (i : I) \u2192 AddLeftCancelMonoid (f i)\na b c : (i : I) \u2192 f i\n\u22a2 a + b = a + c \u2192 b = c", "dependency": [613]}, "PiProp.AddLeftCancelMonoid.proof_4": {"natural_language_statement": "The theorem `PiProp.AddLeftCancelMonoid.proof_4` states that for any type family `f : I \u2192 Type u_1` where each `f i` is an additive left-cancellative monoid, the zeroth power of any element `x : (i : I) \u2192 f i` is equal to zero.", "formal_statement": "example {I : Prop } {f : I \u2192 Type u_1} [(i : I) \u2192 AddLeftCancelMonoid (f i)] (x : (i : I) \u2192 f i) :AddMonoid.nsmul 0 x = 0 := by sorry", "full_tactic_state": "I : Prop\nf : I \u2192 Type u_1\ninst\u271d : (i : I) \u2192 AddLeftCancelMonoid (f i)\nx : (i : I) \u2192 f i\n\u22a2 AddMonoid.nsmul 0 x = 0", "dependency": [613, 34]}, "PiProp.AddLeftCancelMonoid.proof_2": {"natural_language_statement": "The proof provided for the theorem stating that for any type family indexed by a proposition $I$, the additive monoid structure on the product type $(\\prod_{i : I} f_i)$ is an additive left-cancel monoid. This requires the proof that the sum of the zero element with any element of the product type is equal to that element (i.e., $0 + a = a$). This theorem is derived from the instance of `AddLeftCancelMonoid` for each $f_i$, which ensures that within each component of the product, the sum of zero with any element is equal to that element. Hence, the proof is completed by using the `pi_zero` (which states that the zero vector is the constant function mapping to the zero of each component) and `pi_add` (which states that addition in the product is done component-wise).", "formal_statement": "example {I : Prop } {f : I \u2192 Type u_1} [(i : I) \u2192 AddLeftCancelMonoid (f i)] (a : (i : I) \u2192 f i) :0 + a = a := by sorry", "full_tactic_state": "I : Prop\nf : I \u2192 Type u_1\ninst\u271d : (i : I) \u2192 AddLeftCancelMonoid (f i)\na : (i : I) \u2192 f i\n\u22a2 0 + a = a", "dependency": [613]}, "PiProp.AddLeftCancelMonoid.proof_3": {"natural_language_statement": "The theorem `PiProp.AddLeftCancelMonoid.proof_3` is a part of the `PiProp` class which is used to define a monoid structure on the type `(I \u2192 Type u_1)` where `I` is a type and `u_1` is a universe level. The theorem states that for any dependent function `a : (i : I) \u2192 f i` where `f i` are additive left-cancellative monoids, the sum of `a` and the zero function is equal to `a`.", "formal_statement": "example {I : Prop } {f : I \u2192 Type u_1} [(i : I) \u2192 AddLeftCancelMonoid (f i)] (a : (i : I) \u2192 f i) :a + 0 = a := by sorry", "full_tactic_state": "I : Prop\nf : I \u2192 Type u_1\ninst\u271d : (i : I) \u2192 AddLeftCancelMonoid (f i)\na : (i : I) \u2192 f i\n\u22a2 a + 0 = a", "dependency": [613]}, "PiProp.AddRightCancelMonoid.proof_1": {"natural_language_statement": "Function `PiProp.AddRightCancelMonoid.proof_1` is a proof that for any family of types `f : I \u2192 Type u_1` where each `f i` is an `AddRightCancelMonoid`, the product type `(i : I) \u2192 f i` is also an `AddRightCancelMonoid`. Specifically, it proves that for any `a, b, c : (i : I) \u2192 f i`, if `a + b = c + b`, then `a = c`.", "formal_statement": "example {I : Prop } {f : I \u2192 Type u_1} [(i : I) \u2192 AddRightCancelMonoid (f i)] (a : (i : I) \u2192 f i) (b : (i : I) \u2192 f i) (c : (i : I) \u2192 f i) :a + b = c + b \u2192 a = c := by sorry", "full_tactic_state": "I : Prop\nf : I \u2192 Type u_1\ninst\u271d : (i : I) \u2192 AddRightCancelMonoid (f i)\na b c : (i : I) \u2192 f i\n\u22a2 a + b = c + b \u2192 a = c", "dependency": [620]}, "PiProp.AddRightCancelMonoid.proof_2": {"natural_language_statement": "The theorem `PiProp.AddRightCancelMonoid.proof_2` states that for any family of types `f : I \u2192 Type u_1`, where each `f i` is an additive right-cancellative monoid, the zero element added to any element `a : (i : I) \u2192 f i` is equal to `a`.", "formal_statement": "example {I : Prop } {f : I \u2192 Type u_1} [(i : I) \u2192 AddRightCancelMonoid (f i)] (a : (i : I) \u2192 f i) :0 + a = a := by sorry", "full_tactic_state": "I : Prop\nf : I \u2192 Type u_1\ninst\u271d : (i : I) \u2192 AddRightCancelMonoid (f i)\na : (i : I) \u2192 f i\n\u22a2 0 + a = a", "dependency": [620]}, "PiProp.AddRightCancelMonoid.proof_4": {"natural_language_statement": "`PiProp.AddRightCancelMonoid.proof_4` is a proof of the statement that for any type family `f : I \u2192 Type u_1` where each `f i` is an additive right-cancellative monoid, the zero scalar multiplication of any element `x : (i : I) \u2192 f i` is equal to zero.", "formal_statement": "example {I : Prop } {f : I \u2192 Type u_1} [(i : I) \u2192 AddRightCancelMonoid (f i)] (x : (i : I) \u2192 f i) :AddMonoid.nsmul 0 x = 0 := by sorry", "full_tactic_state": "I : Prop\nf : I \u2192 Type u_1\ninst\u271d : (i : I) \u2192 AddRightCancelMonoid (f i)\nx : (i : I) \u2192 f i\n\u22a2 AddMonoid.nsmul 0 x = 0", "dependency": [620, 34]}, "PiProp.AddRightCancelMonoid.proof_3": {"natural_language_statement": "The theorem `PiProp.AddRightCancelMonoid.proof_3` states that for any family of types `f : I \u2192 Type u_1`, where each `f i` is an additive right-cancellative monoid, the sum of any element `a : (i : I) \u2192 f i` with the zero element of the product type is equal to `a`.", "formal_statement": "example {I : Prop } {f : I \u2192 Type u_1} [(i : I) \u2192 AddRightCancelMonoid (f i)] (a : (i : I) \u2192 f i) :a + 0 = a := by sorry", "full_tactic_state": "I : Prop\nf : I \u2192 Type u_1\ninst\u271d : (i : I) \u2192 AddRightCancelMonoid (f i)\na : (i : I) \u2192 f i\n\u22a2 a + 0 = a", "dependency": [620]}, "PiProp.AddRightCancelMonoid.proof_5": {"natural_language_statement": "Function `PiProp.AddRightCancelMonoid.proof_5` is a proof of the property that the `n+1`th multiple of an element `x` in a product of additive right-cancellative monoids is equal to `x` plus the `n`th multiple of `x`.", "formal_statement": "example {I : Prop } {f : I \u2192 Type u_1} [(i : I) \u2192 AddRightCancelMonoid (f i)] (n : \u2115 ) (x : (i : I) \u2192 f i) :AddMonoid.nsmul (n + 1) x = x + AddMonoid.nsmul n x := by sorry", "full_tactic_state": "I : Prop\nf : I \u2192 Type u_1\ninst\u271d : (i : I) \u2192 AddRightCancelMonoid (f i)\nn : \u2115\nx : (i : I) \u2192 f i\n\u22a2 AddMonoid.nsmul (n + 1) x = x + AddMonoid.nsmul n x", "dependency": [620, 34, 34]}, "PiProp.AddCancelMonoid.proof_1": {"natural_language_statement": "Class `AddCancelMonoid` represents an additive monoid where addition is cancellative on both sides, meaning if `a + b = c + b`, then `a = c`. This is useful to define the sum over the empty set, so `AddRightCancelMonoid` is not enough.", "formal_statement": "example {I : Prop } {f : I \u2192 Type u_1} [(i : I) \u2192 AddCancelMonoid (f i)] (a : (i : I) \u2192 f i) (b : (i : I) \u2192 f i) (c : (i : I) \u2192 f i) :a + b = c + b \u2192 a = c := by sorry", "full_tactic_state": "I : Prop\nf : I \u2192 Type u_1\ninst\u271d : (i : I) \u2192 AddCancelMonoid (f i)\na b c : (i : I) \u2192 f i\n\u22a2 a + b = c + b \u2192 a = c", "dependency": [627]}, "PiProp.AddCancelCommMonoid.proof_1": {"natural_language_statement": "`PiProp.AddCancelCommMonoid.proof_1` is a proof of the commutativity of addition in a product of additive cancellative commutative monoids.", "formal_statement": "example {I : Prop } {f : I \u2192 Type u_1} [(i : I) \u2192 AddCancelCommMonoid (f i)] (a : (i : I) \u2192 f i) (b : (i : I) \u2192 f i) :a + b = b + a := by sorry", "full_tactic_state": "I : Prop\nf : I \u2192 Type u_1\ninst\u271d : (i : I) \u2192 AddCancelCommMonoid (f i)\na b : (i : I) \u2192 f i\n\u22a2 a + b = b + a", "dependency": [629]}, "Nat.odd_succ": {"natural_language_statement": "The theorem `Nat.odd_succ` states that for any natural number `n`, the successor of `n` is odd if and only if `n` is not odd.", "formal_statement": "example {n : \u2115 } :Odd (Nat.succ n) \u2194 \u00ac Odd n := by sorry", "full_tactic_state": "n : \u2115\n\u22a2 Odd (Nat.succ n) \u2194 \u00acOdd n", "dependency": [631, 53, 631]}, "Nat.not_even": {"natural_language_statement": "A natural number is odd if and only if it is not even.", "formal_statement": "example {n : \u2115 } :\u00ac Even n \u2194 Odd n := by sorry", "full_tactic_state": "n : \u2115\n\u22a2 \u00acEven n \u2194 Odd n", "dependency": [639, 631]}, "Nat.not_odd": {"natural_language_statement": "A natural number is not odd if and only if it is even.", "formal_statement": "example {n : \u2115 } :\u00ac Odd n \u2194 Even n := by sorry", "full_tactic_state": "n : \u2115\n\u22a2 \u00acOdd n \u2194 Even n", "dependency": [631, 639]}, "AddAction.forall_mem_image": {"natural_language_statement": "The theorem `AddAction.forall_mem_image` states that for any function `f : \u03b1 \u2192 \u03b2`, a set `s : Set \u03b1`, and a property `p : \u03b2 \u2192 Prop`, the statement \"for all `y` in the image of `s` under `f`, `p y` holds\" is equivalent to \"for all `x` in `s`, `p (f x)` holds\".", "formal_statement": "example {\u03b1 : Type u_3} {\u03b2 : Type u_4} {f : \u03b1 \u2192 \u03b2} {s : Set \u03b1} {p : \u03b2 \u2192 Prop } :(\u2200 y \u2208 f '' s, p y) \u2194 \u2200 \u2983x : \u03b1\u2984, x \u2208 s \u2192 p (f x) := by sorry", "full_tactic_state": "\u03b1 : Type u_3\n\u03b2 : Type u_4\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\np : \u03b2 \u2192 Prop\n\u22a2 (\u2200 y \u2208 f '' s, p y) \u2194 \u2200 \u2983x : \u03b1\u2984, x \u2208 s \u2192 p (f x)", "dependency": [69]}, "MulAction.forall_mem_image": {"natural_language_statement": "Given a function `f : \u03b1 \u2192 \u03b2` and a set `s : Set \u03b1`, the statement `\u2200 y \u2208 f '' s, p y` is equivalent to `\u2200 \u2983x : \u03b1\u2984, x \u2208 s \u2192 p (f x)`.", "formal_statement": "example {\u03b1 : Type u_3} {\u03b2 : Type u_4} {f : \u03b1 \u2192 \u03b2} {s : Set \u03b1} {p : \u03b2 \u2192 Prop } :(\u2200 y \u2208 f '' s, p y) \u2194 \u2200 \u2983x : \u03b1\u2984, x \u2208 s \u2192 p (f x) := by sorry", "full_tactic_state": "\u03b1 : Type u_3\n\u03b2 : Type u_4\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\np : \u03b2 \u2192 Prop\n\u22a2 (\u2200 y \u2208 f '' s, p y) \u2194 \u2200 \u2983x : \u03b1\u2984, x \u2208 s \u2192 p (f x)", "dependency": [69]}, "PartialPerm.coe_symm_mk": {"natural_language_statement": "The theorem `PartialPerm.coe_symm_mk` states that for a partial permutation defined by a function `f`, an inverse function `g`, and a domain `s`, the inverse function of the partial permutation is indeed `g`.", "formal_statement": "@[simp]example {\u03b1 : Type u_1} (f : \u03b1 \u2192 \u03b1) (g : \u03b1 \u2192 \u03b1) (s : Set \u03b1) (ml : \u2200 \u2983x : \u03b1\u2984, x \u2208 s \u2192 f x \u2208 s) (mr : \u2200 \u2983x : \u03b1\u2984, x \u2208 s \u2192 g x \u2208 s) (il : \u2200 \u2983x : \u03b1\u2984, x \u2208 s \u2192 g (f x) = x) (ir : \u2200 \u2983x : \u03b1\u2984, x \u2208 s \u2192 f (g x) = x) :(PartialPerm.symm { toFun := f, invFun := g, domain := s, toFun_domain' := ml, invFun_domain' := mr, left_inv' := il, right_inv' := ir }).toFun = g := by sorry", "full_tactic_state": "\u03b1 : Type u_1\nf g : \u03b1 \u2192 \u03b1\ns : Set \u03b1\nml : \u2200 \u2983x : \u03b1\u2984, x \u2208 s \u2192 f x \u2208 s\nmr : \u2200 \u2983x : \u03b1\u2984, x \u2208 s \u2192 g x \u2208 s\nil : \u2200 \u2983x : \u03b1\u2984, x \u2208 s \u2192 g (f x) = x\nir : \u2200 \u2983x : \u03b1\u2984, x \u2208 s \u2192 f (g x) = x\n\u22a2 (PartialPerm.symm\n        { toFun := f, invFun := g, domain := s, toFun_domain' := ml, invFun_domain' := mr, left_inv' := il,\n          right_inv' := ir }).toFun =\n    g", "dependency": [69, 644]}, "PartialPerm.toFun_as_coe": {"natural_language_statement": "The theorem `PartialPerm.toFun_as_coe` states that the function `toFun` of a partial permutation `\u03c0` is equal to itself when considered as a coercion to a function.", "formal_statement": "@[simp]example {\u03b1 : Type u_1} (\u03c0 : PartialPerm \u03b1) :\u03c0.toFun = \u03c0.toFun := by sorry", "full_tactic_state": "\u03b1 : Type u_1\n\u03c0 : PartialPerm \u03b1\n\u22a2 \u03c0.toFun = \u03c0.toFun", "dependency": [645]}, "PartialPerm.invFun_as_coe": {"natural_language_statement": "Function `invFun` of a partial permutation `\u03c0` is equal to the function `toFun` of its inverse `symm \u03c0`.", "formal_statement": "@[simp]example {\u03b1 : Type u_1} (\u03c0 : PartialPerm \u03b1) :\u03c0.invFun = (PartialPerm.symm \u03c0).toFun := by sorry", "full_tactic_state": "\u03b1 : Type u_1\n\u03c0 : PartialPerm \u03b1\n\u22a2 \u03c0.invFun = (PartialPerm.symm \u03c0).toFun", "dependency": [645, 644]}, "PartialPerm.map_domain": {"natural_language_statement": "Given a partial permutation `\u03c0` and an element `x` in its domain, the image of `x` under `\u03c0` is also in its domain.", "formal_statement": "@[simp]example {\u03b1 : Type u_1} (\u03c0 : PartialPerm \u03b1) {x : \u03b1} (h : x \u2208 \u03c0.domain) :\u03c0.toFun x \u2208 \u03c0.domain := by sorry", "full_tactic_state": "\u03b1 : Type u_1\n\u03c0 : PartialPerm \u03b1\nx : \u03b1\nh : x \u2208 \u03c0.domain\n\u22a2 \u03c0.toFun x \u2208 \u03c0.domain", "dependency": [645]}, "PartialPerm.iterate_domain": {"natural_language_statement": "The theorem `PartialPerm.iterate_domain` states that if `x` is in the domain of a partial permutation `\u03c0` and `n` is a natural number, then the `n`th iterate of `\u03c0` applied to `x` is also in the domain of `\u03c0`.", "formal_statement": "@[simp]example {\u03b1 : Type u_1} (\u03c0 : PartialPerm \u03b1) {x : \u03b1} (h : x \u2208 \u03c0.domain) {n : \u2115 } :\u03c0.toFun^[ n] x \u2208 \u03c0.domain := by sorry", "full_tactic_state": "\u03b1 : Type u_1\n\u03c0 : PartialPerm \u03b1\nx : \u03b1\nh : x \u2208 \u03c0.domain\nn : \u2115\n\u22a2 \u03c0.toFun^[n] x \u2208 \u03c0.domain", "dependency": [645]}, "PartialPerm.left_inv": {"natural_language_statement": "`PartialPerm.left_inv` states that for a partial permutation `\u03c0`, if `x` is in the domain of `\u03c0`, then the inverse of `\u03c0` applied to `\u03c0` applied to `x` equals `x`.", "formal_statement": "@[simp]example {\u03b1 : Type u_1} (\u03c0 : PartialPerm \u03b1) {x : \u03b1} (h : x \u2208 \u03c0.domain) :(PartialPerm.symm \u03c0).toFun (\u03c0.toFun x) = x := by sorry", "full_tactic_state": "\u03b1 : Type u_1\n\u03c0 : PartialPerm \u03b1\nx : \u03b1\nh : x \u2208 \u03c0.domain\n\u22a2 (PartialPerm.symm \u03c0).toFun (\u03c0.toFun x) = x", "dependency": [645, 644]}, "PartialPerm.right_inv": {"natural_language_statement": "Function `PartialPerm.right_inv` states that for any partial permutation `\u03c0` and any element `x` in the domain of `\u03c0`, applying `\u03c0` to the result of applying the inverse of `\u03c0` to `x` yields `x`.", "formal_statement": "@[simp]example {\u03b1 : Type u_1} (\u03c0 : PartialPerm \u03b1) {x : \u03b1} (h : x \u2208 \u03c0.domain) :\u03c0.toFun ((PartialPerm.symm \u03c0).toFun x) = x := by sorry", "full_tactic_state": "\u03b1 : Type u_1\n\u03c0 : PartialPerm \u03b1\nx : \u03b1\nh : x \u2208 \u03c0.domain\n\u22a2 \u03c0.toFun ((PartialPerm.symm \u03c0).toFun x) = x", "dependency": [645, 644]}, "PartialPerm.symm_domain": {"natural_language_statement": "The domain of a partial permutation and its inverse are the same.", "formal_statement": "@[simp]example {\u03b1 : Type u_1} (\u03c0 : PartialPerm \u03b1) :(PartialPerm.symm \u03c0).domain = \u03c0.domain := by sorry", "full_tactic_state": "\u03b1 : Type u_1\n\u03c0 : PartialPerm \u03b1\n\u22a2 (PartialPerm.symm \u03c0).domain = \u03c0.domain", "dependency": [645, 644]}, "PartialPerm.symm_symm": {"natural_language_statement": "Function `PartialPerm.symm_symm` states that the inverse of the inverse of a partial permutation is the original partial permutation.", "formal_statement": "@[simp]example {\u03b1 : Type u_1} (\u03c0 : PartialPerm \u03b1) :PartialPerm.symm (PartialPerm.symm \u03c0) = \u03c0 := by sorry", "full_tactic_state": "\u03b1 : Type u_1\n\u03c0 : PartialPerm \u03b1\n\u22a2 PartialPerm.symm (PartialPerm.symm \u03c0) = \u03c0", "dependency": [645, 644, 644]}, "PartialPerm.eq_symm_apply": {"natural_language_statement": "Function `eq_symm_apply` states that for a partial permutation `\u03c0`, if `x` and `y` are both in the domain of `\u03c0`, then `x` equals the inverse of `\u03c0` applied to `y` if and only if `\u03c0` applied to `x` equals `y`.", "formal_statement": "example {\u03b1 : Type u_1} (\u03c0 : PartialPerm \u03b1) {x : \u03b1} {y : \u03b1} (hx : x \u2208 \u03c0.domain) (hy : y \u2208 \u03c0.domain) :x = (PartialPerm.symm \u03c0).toFun y \u2194 \u03c0.toFun x = y := by sorry", "full_tactic_state": "\u03b1 : Type u_1\n\u03c0 : PartialPerm \u03b1\nx y : \u03b1\nhx : x \u2208 \u03c0.domain\nhy : y \u2208 \u03c0.domain\n\u22a2 x = (PartialPerm.symm \u03c0).toFun y \u2194 \u03c0.toFun x = y", "dependency": [645, 644]}, "PartialPerm.mapsTo": {"natural_language_statement": "The function `PartialPerm.toFun` maps the domain of the partial permutation `\u03c0` to itself.", "formal_statement": "example {\u03b1 : Type u_1} (\u03c0 : PartialPerm \u03b1) :Set.MapsTo \u03c0.toFun \u03c0.domain \u03c0.domain := by sorry", "full_tactic_state": "\u03b1 : Type u_1\n\u03c0 : PartialPerm \u03b1\n\u22a2 Set.MapsTo \u03c0.toFun \u03c0.domain \u03c0.domain", "dependency": [645, 656]}, "PartialPerm.leftInvOn": {"natural_language_statement": "Function `PartialPerm.leftInvOn` proves that the inverse of a partial permutation `\u03c0` is indeed a left inverse to `\u03c0` on the domain of `\u03c0`.", "formal_statement": "example {\u03b1 : Type u_1} (\u03c0 : PartialPerm \u03b1) :Set.LeftInvOn (PartialPerm.symm \u03c0).toFun \u03c0.toFun \u03c0.domain := by sorry", "full_tactic_state": "\u03b1 : Type u_1\n\u03c0 : PartialPerm \u03b1\n\u22a2 Set.LeftInvOn (PartialPerm.symm \u03c0).toFun \u03c0.toFun \u03c0.domain", "dependency": [645, 658, 644]}, "PartialPerm.rightInvOn": {"natural_language_statement": "Function `PartialPerm.rightInvOn` proves that the inverse of a partial permutation `\u03c0` is indeed a right inverse on the domain of `\u03c0`.", "formal_statement": "example {\u03b1 : Type u_1} (\u03c0 : PartialPerm \u03b1) :Set.RightInvOn (PartialPerm.symm \u03c0).toFun \u03c0.toFun \u03c0.domain := by sorry", "full_tactic_state": "\u03b1 : Type u_1\n\u03c0 : PartialPerm \u03b1\n\u22a2 Set.RightInvOn (PartialPerm.symm \u03c0).toFun \u03c0.toFun \u03c0.domain", "dependency": [645, 660, 644]}, "PartialPerm.invOn": {"natural_language_statement": "Function `PartialPerm.invOn` proves that the inverse of a partial permutation `\u03c0` is indeed an inverse on the domain of `\u03c0`.", "formal_statement": "example {\u03b1 : Type u_1} (\u03c0 : PartialPerm \u03b1) :Set.InvOn (PartialPerm.symm \u03c0).toFun \u03c0.toFun \u03c0.domain \u03c0.domain := by sorry", "full_tactic_state": "\u03b1 : Type u_1\n\u03c0 : PartialPerm \u03b1\n\u22a2 Set.InvOn (PartialPerm.symm \u03c0).toFun \u03c0.toFun \u03c0.domain \u03c0.domain", "dependency": [645, 662, 644]}, "PartialPerm.injOn": {"natural_language_statement": "The function `toFun` of a partial permutation `\u03c0` is injective on its domain.", "formal_statement": "example {\u03b1 : Type u_1} (\u03c0 : PartialPerm \u03b1) :Set.InjOn \u03c0.toFun \u03c0.domain := by sorry", "full_tactic_state": "\u03b1 : Type u_1\n\u03c0 : PartialPerm \u03b1\n\u22a2 Set.InjOn \u03c0.toFun \u03c0.domain", "dependency": [645, 111]}, "PartialPerm.bijOn": {"natural_language_statement": "Function `PartialPerm.bijOn` proves that a partial permutation `\u03c0` is bijective between its domain and itself.", "formal_statement": "example {\u03b1 : Type u_1} (\u03c0 : PartialPerm \u03b1) :Set.BijOn \u03c0.toFun \u03c0.domain \u03c0.domain := by sorry", "full_tactic_state": "\u03b1 : Type u_1\n\u03c0 : PartialPerm \u03b1\n\u22a2 Set.BijOn \u03c0.toFun \u03c0.domain \u03c0.domain", "dependency": [645, 665]}, "PartialPerm.surjOn": {"natural_language_statement": "The theorem `PartialPerm.surjOn` states that for any partial permutation `\u03c0` of a set `\u03b1`, the function `\u03c0.toFun` is surjective on the domain `\u03c0.domain`.", "formal_statement": "example {\u03b1 : Type u_1} (\u03c0 : PartialPerm \u03b1) :Set.SurjOn \u03c0.toFun \u03c0.domain \u03c0.domain := by sorry", "full_tactic_state": "\u03b1 : Type u_1\n\u03c0 : PartialPerm \u03b1\n\u22a2 Set.SurjOn \u03c0.toFun \u03c0.domain \u03c0.domain", "dependency": [645, 667]}, "PartialPerm.copy_toFun": {"natural_language_statement": "Function `PartialPerm.copy` is used to create a copy of a `PartialPerm` object, which represents a partial permutation of a subset of a type. It provides better definitional equalities for the function and its inverse, as well as the domain of the permutation. The theorem `PartialPerm.copy_toFun` states that the function of the copy is equal to the function of the original partial permutation.", "formal_statement": "@[simp]example {\u03b1 : Type u_1} (\u03c0 : PartialPerm \u03b1) (f : \u03b1 \u2192 \u03b1) (hf : \u03c0.toFun = f) (g : \u03b1 \u2192 \u03b1) (hg : (PartialPerm.symm \u03c0).toFun = g) (s : Set \u03b1) (hs : \u03c0.domain = s) :(PartialPerm.copy \u03c0 f hf g hg s hs).toFun = f := by sorry", "full_tactic_state": "\u03b1 : Type u_1\n\u03c0 : PartialPerm \u03b1\nf : \u03b1 \u2192 \u03b1\nhf : \u03c0.toFun = f\ng : \u03b1 \u2192 \u03b1\nhg : (PartialPerm.symm \u03c0).toFun = g\ns : Set \u03b1\nhs : \u03c0.domain = s\n\u22a2 (PartialPerm.copy \u03c0 f hf g hg s hs).toFun = f", "dependency": [645, 644, 69, 669]}, "PartialPerm.copy_domain": {"natural_language_statement": "Function `PartialPerm.copy_domain` is used to create a copy of a `PartialPerm` object, which represents a partial permutation of a subset of a type. It provides better definitional equalities for the function and its inverse, as well as the domain of the permutation.", "formal_statement": "@[simp]example {\u03b1 : Type u_1} (\u03c0 : PartialPerm \u03b1) (f : \u03b1 \u2192 \u03b1) (hf : \u03c0.toFun = f) (g : \u03b1 \u2192 \u03b1) (hg : (PartialPerm.symm \u03c0).toFun = g) (s : Set \u03b1) (hs : \u03c0.domain = s) :(PartialPerm.copy \u03c0 f hf g hg s hs).domain = s := by sorry", "full_tactic_state": "\u03b1 : Type u_1\n\u03c0 : PartialPerm \u03b1\nf : \u03b1 \u2192 \u03b1\nhf : \u03c0.toFun = f\ng : \u03b1 \u2192 \u03b1\nhg : (PartialPerm.symm \u03c0).toFun = g\ns : Set \u03b1\nhs : \u03c0.domain = s\n\u22a2 (PartialPerm.copy \u03c0 f hf g hg s hs).domain = s", "dependency": [645, 644, 69, 669]}, "PartialPerm.copy_invFun": {"natural_language_statement": "Function `PartialPerm.copy` is used to create a copy of a `PartialPerm` object, which represents a partial permutation of a subset of a type. It provides better definitional equalities for the function and its inverse, as well as the domain of the permutation. The theorem `PartialPerm.copy_invFun` states that the inverse function of the copy is equal to the inverse function of the original partial permutation.", "formal_statement": "@[simp]example {\u03b1 : Type u_1} (\u03c0 : PartialPerm \u03b1) (f : \u03b1 \u2192 \u03b1) (hf : \u03c0.toFun = f) (g : \u03b1 \u2192 \u03b1) (hg : (PartialPerm.symm \u03c0).toFun = g) (s : Set \u03b1) (hs : \u03c0.domain = s) :(PartialPerm.copy \u03c0 f hf g hg s hs).invFun = g := by sorry", "full_tactic_state": "\u03b1 : Type u_1\n\u03c0 : PartialPerm \u03b1\nf : \u03b1 \u2192 \u03b1\nhf : \u03c0.toFun = f\ng : \u03b1 \u2192 \u03b1\nhg : (PartialPerm.symm \u03c0).toFun = g\ns : Set \u03b1\nhs : \u03c0.domain = s\n\u22a2 (PartialPerm.copy \u03c0 f hf g hg s hs).invFun = g", "dependency": [645, 644, 69, 669]}, "PartialPerm.copy_eq": {"natural_language_statement": "Function `PartialPerm.copy` is used to create a copy of a `PartialPerm` object, which represents a partial permutation of a subset of a type. It provides better definitional equalities for the function and its inverse, as well as the domain of the permutation.", "formal_statement": "example {\u03b1 : Type u_1} (\u03c0 : PartialPerm \u03b1) (f : \u03b1 \u2192 \u03b1) (hf : \u03c0.toFun = f) (g : \u03b1 \u2192 \u03b1) (hg : (PartialPerm.symm \u03c0).toFun = g) (s : Set \u03b1) (hs : \u03c0.domain = s) :PartialPerm.copy \u03c0 f hf g hg s hs = \u03c0 := by sorry", "full_tactic_state": "\u03b1 : Type u_1\n\u03c0 : PartialPerm \u03b1\nf : \u03b1 \u2192 \u03b1\nhf : \u03c0.toFun = f\ng : \u03b1 \u2192 \u03b1\nhg : (PartialPerm.symm \u03c0).toFun = g\ns : Set \u03b1\nhs : \u03c0.domain = s\n\u22a2 PartialPerm.copy \u03c0 f hf g hg s hs = \u03c0", "dependency": [645, 644, 69, 669]}, "PartialPerm.image_domain": {"natural_language_statement": "The image of the domain of a partial permutation is equal to the domain itself.", "formal_statement": "@[simp]example {\u03b1 : Type u_1} (\u03c0 : PartialPerm \u03b1) :\u03c0.toFun '' \u03c0.domain = \u03c0.domain := by sorry", "full_tactic_state": "\u03b1 : Type u_1\n\u03c0 : PartialPerm \u03b1\n\u22a2 \u03c0.toFun '' \u03c0.domain = \u03c0.domain", "dependency": [645]}, "PartialPerm.forall_mem_domain": {"natural_language_statement": "The statement `\u2200 y \u2208 \u03c0.domain, p y` is equivalent to `\u2200 x \u2208 \u03c0.domain, p (\u03c0.toFun x)`.", "formal_statement": "example {\u03b1 : Type u_1} (\u03c0 : PartialPerm \u03b1) {p : \u03b1 \u2192 Prop } :(\u2200 y \u2208 \u03c0.domain, p y) \u2194 \u2200 x \u2208 \u03c0.domain, p (\u03c0.toFun x) := by sorry", "full_tactic_state": "\u03b1 : Type u_1\n\u03c0 : PartialPerm \u03b1\np : \u03b1 \u2192 Prop\n\u22a2 (\u2200 y \u2208 \u03c0.domain, p y) \u2194 \u2200 x \u2208 \u03c0.domain, p (\u03c0.toFun x)", "dependency": [645]}, "PartialPerm.exists_mem_domain": {"natural_language_statement": "Given a partial permutation `\u03c0` and a property `p`, if there exists an element `y` in the domain of `\u03c0` such that `p y` holds, then there exists an element `x` in the domain of `\u03c0` such that `p (\u03c0.toFun x)` holds.", "formal_statement": "example {\u03b1 : Type u_1} (\u03c0 : PartialPerm \u03b1) {p : \u03b1 \u2192 Prop } :(\u2203 y \u2208 \u03c0.domain, p y) \u2194 \u2203 x \u2208 \u03c0.domain, p (\u03c0.toFun x) := by sorry", "full_tactic_state": "\u03b1 : Type u_1\n\u03c0 : PartialPerm \u03b1\np : \u03b1 \u2192 Prop\n\u22a2 (\u2203 y \u2208 \u03c0.domain, p y) \u2194 \u2203 x \u2208 \u03c0.domain, p (\u03c0.toFun x)", "dependency": [645]}, "PartialPerm.IsStable.apply_mem_iff": {"natural_language_statement": "Given a partial permutation `\u03c0` and a set `s`, if `\u03c0` is stable on `s`, then for any element `x` in the domain of `\u03c0`, `x` is in `s` if and only if its image under `\u03c0` is also in `s`.", "formal_statement": "example {\u03b1 : Type u_1} {\u03c0 : PartialPerm \u03b1} {s : Set \u03b1} {x : \u03b1} (h : PartialPerm.IsStable \u03c0 s) (hx : x \u2208 \u03c0.domain) :\u03c0.toFun x \u2208 s \u2194 x \u2208 s := by sorry", "full_tactic_state": "\u03b1 : Type u_1\n\u03c0 : PartialPerm \u03b1\ns : Set \u03b1\nx : \u03b1\nh : PartialPerm.IsStable \u03c0 s\nhx : x \u2208 \u03c0.domain\n\u22a2 \u03c0.toFun x \u2208 s \u2194 x \u2208 s", "dependency": [645, 69, 677]}, "PartialPerm.IsStable.symm_apply_mem_iff": {"natural_language_statement": "Function `PartialPerm.IsStable.symm_apply_mem_iff` states that for a partial permutation `\u03c0` that is stable on a set `s`, if `y` is in the domain of `\u03c0`, then `y` is in `s` if and only if its image under the inverse of `\u03c0` is also in `s`.", "formal_statement": "example {\u03b1 : Type u_1} {\u03c0 : PartialPerm \u03b1} {s : Set \u03b1} (h : PartialPerm.IsStable \u03c0 s) \u2983y : \u03b1\u2984 :y \u2208 \u03c0.domain \u2192 ((PartialPerm.symm \u03c0).toFun y \u2208 s \u2194 y \u2208 s) := by sorry", "full_tactic_state": "\u03b1 : Type u_1\n\u03c0 : PartialPerm \u03b1\ns : Set \u03b1\nh : PartialPerm.IsStable \u03c0 s\ny : \u03b1\n\u22a2 y \u2208 \u03c0.domain \u2192 ((PartialPerm.symm \u03c0).toFun y \u2208 s \u2194 y \u2208 s)", "dependency": [645, 69, 677, 644]}, "PartialPerm.IsStable.symm": {"natural_language_statement": "If a partial permutation `\u03c0` is stable on a set `s`, then its inverse `\u03c0.symm` is also stable on `s`.", "formal_statement": "example {\u03b1 : Type u_1} {\u03c0 : PartialPerm \u03b1} {s : Set \u03b1} (h : PartialPerm.IsStable \u03c0 s) :PartialPerm.IsStable (PartialPerm.symm \u03c0) s := by sorry", "full_tactic_state": "\u03b1 : Type u_1\n\u03c0 : PartialPerm \u03b1\ns : Set \u03b1\nh : PartialPerm.IsStable \u03c0 s\n\u22a2 PartialPerm.IsStable (PartialPerm.symm \u03c0) s", "dependency": [645, 69, 677, 677, 644]}, "PartialPerm.IsStable.symm_iff": {"natural_language_statement": "Function `PartialPerm.IsStable.symm_iff` states that a set `s` is preserved by the inverse of a partial permutation `\u03c0` if and only if `s` is preserved by `\u03c0` itself.", "formal_statement": "@[simp]example {\u03b1 : Type u_1} {\u03c0 : PartialPerm \u03b1} {s : Set \u03b1} :PartialPerm.IsStable (PartialPerm.symm \u03c0) s \u2194 PartialPerm.IsStable \u03c0 s := by sorry", "full_tactic_state": "\u03b1 : Type u_1\n\u03c0 : PartialPerm \u03b1\ns : Set \u03b1\n\u22a2 PartialPerm.IsStable (PartialPerm.symm \u03c0) s \u2194 PartialPerm.IsStable \u03c0 s", "dependency": [645, 69, 677, 644, 677]}, "PartialPerm.IsStable.mapsTo": {"natural_language_statement": "Function `PartialPerm.IsStable` checks if a set `s` is preserved by a partial permutation `\u03c0`, meaning that for any element `x` in the domain of `\u03c0`, `x` is in `s` if and only if its image under `\u03c0` is also in `s`. Function `Set.MapsTo` checks if the image of a set `s` under a function `f` is contained within another set `t`. The theorem `PartialPerm.IsStable.mapsTo` states that if a set `s` is preserved by a partial permutation `\u03c0`, then the image of the intersection of the domain of `\u03c0` and `s` under `\u03c0` is contained within the intersection of the domain of `\u03c0` and `s`.", "formal_statement": "example {\u03b1 : Type u_1} {\u03c0 : PartialPerm \u03b1} {s : Set \u03b1} (h : PartialPerm.IsStable \u03c0 s) :Set.MapsTo \u03c0.toFun (\u03c0.domain \u2229 s) (\u03c0.domain \u2229 s) := by sorry", "full_tactic_state": "\u03b1 : Type u_1\n\u03c0 : PartialPerm \u03b1\ns : Set \u03b1\nh : PartialPerm.IsStable \u03c0 s\n\u22a2 Set.MapsTo \u03c0.toFun (\u03c0.domain \u2229 s) (\u03c0.domain \u2229 s)", "dependency": [645, 69, 677, 656]}, "PartialPerm.IsStable.symm_mapsTo": {"natural_language_statement": "The theorem `PartialPerm.IsStable.symm_mapsTo` proves that the inverse of a partial permutation `\u03c0` maps elements of the intersection of its domain and a set `s` back into the intersection of its domain and `s`, assuming `s` is preserved by `\u03c0` (i.e., `s` is `\u03c0.IsStable`). This is a crucial property for understanding how partial permutations interact with sets, especially in the context where the set is preserved by the permutation.", "formal_statement": "example {\u03b1 : Type u_1} {\u03c0 : PartialPerm \u03b1} {s : Set \u03b1} (h : PartialPerm.IsStable \u03c0 s) :Set.MapsTo (PartialPerm.symm \u03c0).toFun (\u03c0.domain \u2229 s) (\u03c0.domain \u2229 s) := by sorry", "full_tactic_state": "\u03b1 : Type u_1\n\u03c0 : PartialPerm \u03b1\ns : Set \u03b1\nh : PartialPerm.IsStable \u03c0 s\n\u22a2 Set.MapsTo (PartialPerm.symm \u03c0).toFun (\u03c0.domain \u2229 s) (\u03c0.domain \u2229 s)", "dependency": [645, 69, 677, 656, 644]}, "PartialPerm.IsStable.restr_toFun": {"natural_language_statement": "Function `PartialPerm.IsStable.restr` restricts a partial permutation `\u03c0` to a subset `s` of its domain, where `s` is preserved by `\u03c0` in the sense that for any element `x` in the domain of `\u03c0`, `x` is in `s` if and only if its image under `\u03c0` is also in `s`. The result is a new partial permutation whose domain is the intersection of the original domain of `\u03c0` and `s`, and whose action on this domain is the same as that of `\u03c0`. The theorem `PartialPerm.IsStable.restr_toFun` states that the function `toFun` of the restricted partial permutation is equal to the function `toFun` of the original partial permutation.", "formal_statement": "@[simp]example {\u03b1 : Type u_1} {\u03c0 : PartialPerm \u03b1} {s : Set \u03b1} (h : PartialPerm.IsStable \u03c0 s) :(PartialPerm.IsStable.restr h).toFun = \u03c0.toFun := by sorry", "full_tactic_state": "\u03b1 : Type u_1\n\u03c0 : PartialPerm \u03b1\ns : Set \u03b1\nh : PartialPerm.IsStable \u03c0 s\n\u22a2 (PartialPerm.IsStable.restr h).toFun = \u03c0.toFun", "dependency": [645, 69, 677, 684]}, "PartialPerm.IsStable.restr_invFun": {"natural_language_statement": "Function `PartialPerm.IsStable.restr_invFun` states that the inverse function of the restriction of a partial permutation `\u03c0` to a set `s`, where `s` is preserved by `\u03c0`, is equal to the function of the inverse of `\u03c0`.", "formal_statement": "@[simp]example {\u03b1 : Type u_1} {\u03c0 : PartialPerm \u03b1} {s : Set \u03b1} (h : PartialPerm.IsStable \u03c0 s) :(PartialPerm.IsStable.restr h).invFun = (PartialPerm.symm \u03c0).toFun := by sorry", "full_tactic_state": "\u03b1 : Type u_1\n\u03c0 : PartialPerm \u03b1\ns : Set \u03b1\nh : PartialPerm.IsStable \u03c0 s\n\u22a2 (PartialPerm.IsStable.restr h).invFun = (PartialPerm.symm \u03c0).toFun", "dependency": [645, 69, 677, 684, 644]}, "PartialPerm.IsStable.restr_domain": {"natural_language_statement": "Function `PartialPerm.IsStable.restr_domain` states that the domain of a partial permutation `\u03c0` restricted to a subset `s` of its domain, where `s` is preserved by `\u03c0`, is equal to the intersection of the original domain of `\u03c0` and `s`.", "formal_statement": "@[simp]example {\u03b1 : Type u_1} {\u03c0 : PartialPerm \u03b1} {s : Set \u03b1} (h : PartialPerm.IsStable \u03c0 s) :(PartialPerm.IsStable.restr h).domain = \u03c0.domain \u2229 s := by sorry", "full_tactic_state": "\u03b1 : Type u_1\n\u03c0 : PartialPerm \u03b1\ns : Set \u03b1\nh : PartialPerm.IsStable \u03c0 s\n\u22a2 (PartialPerm.IsStable.restr h).domain = \u03c0.domain \u2229 s", "dependency": [645, 69, 677, 684]}, "PartialPerm.IsStable.image_eq": {"natural_language_statement": "Given a partial permutation `\u03c0` and a set `s`, if `\u03c0` is stable on `s`, the image of the intersection of the domain of `\u03c0` and `s` under `\u03c0` is equal to the intersection of the domain of `\u03c0` and `s`.", "formal_statement": "example {\u03b1 : Type u_1} {\u03c0 : PartialPerm \u03b1} {s : Set \u03b1} (h : PartialPerm.IsStable \u03c0 s) :\u03c0.toFun '' (\u03c0.domain \u2229 s) = \u03c0.domain \u2229 s := by sorry", "full_tactic_state": "\u03b1 : Type u_1\n\u03c0 : PartialPerm \u03b1\ns : Set \u03b1\nh : PartialPerm.IsStable \u03c0 s\n\u22a2 \u03c0.toFun '' (\u03c0.domain \u2229 s) = \u03c0.domain \u2229 s", "dependency": [645, 69, 677]}, "PartialPerm.IsStable.symm_image_eq": {"natural_language_statement": "Function `PartialPerm.IsStable.symm_image_eq` states that for a partial permutation `\u03c0` that is stable on a set `s`, the image of the intersection of the domain of `\u03c0` and `s` under the inverse of `\u03c0` is equal to the intersection of the domain of `\u03c0` and `s`.", "formal_statement": "example {\u03b1 : Type u_1} {\u03c0 : PartialPerm \u03b1} {s : Set \u03b1} (h : PartialPerm.IsStable \u03c0 s) :(PartialPerm.symm \u03c0).toFun '' (\u03c0.domain \u2229 s) = \u03c0.domain \u2229 s := by sorry", "full_tactic_state": "\u03b1 : Type u_1\n\u03c0 : PartialPerm \u03b1\ns : Set \u03b1\nh : PartialPerm.IsStable \u03c0 s\n\u22a2 (PartialPerm.symm \u03c0).toFun '' (\u03c0.domain \u2229 s) = \u03c0.domain \u2229 s", "dependency": [645, 69, 677, 644]}, "PartialPerm.IsStable.iff_preimage_eq": {"natural_language_statement": "Function `PartialPerm.IsStable` checks if a set `s` is preserved by a partial permutation `\u03c0`, meaning that for any element `x` in the domain of `\u03c0`, `x` is in `s` if and only if its image under `\u03c0` is also in `s`. The theorem `iff_preimage_eq` states that this condition is equivalent to the intersection of the domain of `\u03c0` and the preimage of `s` under `\u03c0.toFun` being equal to the intersection of the domain of `\u03c0` and `s`.", "formal_statement": "example {\u03b1 : Type u_1} {\u03c0 : PartialPerm \u03b1} {s : Set \u03b1} :PartialPerm.IsStable \u03c0 s \u2194 \u03c0.domain \u2229 \u03c0.toFun \u207b\u00b9' s = \u03c0.domain \u2229 s := by sorry", "full_tactic_state": "\u03b1 : Type u_1\n\u03c0 : PartialPerm \u03b1\ns : Set \u03b1\n\u22a2 PartialPerm.IsStable \u03c0 s \u2194 \u03c0.domain \u2229 \u03c0.toFun \u207b\u00b9' s = \u03c0.domain \u2229 s", "dependency": [645, 69, 677]}, "PartialPerm.IsStable.of_preimage_eq": {"natural_language_statement": "Given a partial permutation `\u03c0` and a set `s`, if the intersection of the domain of `\u03c0` and the preimage of `s` under `\u03c0` is equal to the intersection of the domain of `\u03c0` and `s`, then `s` is preserved by `\u03c0`.", "formal_statement": "example {\u03b1 : Type u_1} {\u03c0 : PartialPerm \u03b1} {s : Set \u03b1} :\u03c0.domain \u2229 \u03c0.toFun \u207b\u00b9' s = \u03c0.domain \u2229 s \u2192 PartialPerm.IsStable \u03c0 s := by sorry", "full_tactic_state": "\u03b1 : Type u_1\n\u03c0 : PartialPerm \u03b1\ns : Set \u03b1\n\u22a2 \u03c0.domain \u2229 \u03c0.toFun \u207b\u00b9' s = \u03c0.domain \u2229 s \u2192 PartialPerm.IsStable \u03c0 s", "dependency": [645, 69, 677]}, "PartialPerm.IsStable.preimage_eq": {"natural_language_statement": "Function `PartialPerm.IsStable.preimage_eq` is an alias of the forward direction of `PartialPerm.IsStable.iff_preimage_eq`. It states that if a partial permutation `\u03c0` is stable on a set `s`, then the intersection of the domain of `\u03c0` and the preimage of `s` under `\u03c0` is equal to the intersection of the domain of `\u03c0` and `s`.", "formal_statement": "example {\u03b1 : Type u_1} {\u03c0 : PartialPerm \u03b1} {s : Set \u03b1} :PartialPerm.IsStable \u03c0 s \u2192 \u03c0.domain \u2229 \u03c0.toFun \u207b\u00b9' s = \u03c0.domain \u2229 s := by sorry", "full_tactic_state": "\u03b1 : Type u_1\n\u03c0 : PartialPerm \u03b1\ns : Set \u03b1\n\u22a2 PartialPerm.IsStable \u03c0 s \u2192 \u03c0.domain \u2229 \u03c0.toFun \u207b\u00b9' s = \u03c0.domain \u2229 s", "dependency": [645, 69, 677]}, "PartialPerm.IsStable.iff_symm_preimage_eq": {"natural_language_statement": "The theorem `PartialPerm.IsStable.iff_symm_preimage_eq` states that a set `s` is preserved by a partial permutation `\u03c0` if and only if the intersection of the domain of `\u03c0` and the preimage of `s` under the inverse of `\u03c0` is equal to the intersection of the domain of `\u03c0` and `s`.", "formal_statement": "example {\u03b1 : Type u_1} {\u03c0 : PartialPerm \u03b1} {s : Set \u03b1} :PartialPerm.IsStable \u03c0 s \u2194 \u03c0.domain \u2229 (PartialPerm.symm \u03c0).toFun \u207b\u00b9' s = \u03c0.domain \u2229 s := by sorry", "full_tactic_state": "\u03b1 : Type u_1\n\u03c0 : PartialPerm \u03b1\ns : Set \u03b1\n\u22a2 PartialPerm.IsStable \u03c0 s \u2194 \u03c0.domain \u2229 (PartialPerm.symm \u03c0).toFun \u207b\u00b9' s = \u03c0.domain \u2229 s", "dependency": [645, 69, 677, 644]}, "PartialPerm.IsStable.symm_preimage_eq": {"natural_language_statement": "Function `PartialPerm.IsStable.symm_preimage_eq` is an alias of the forward direction of `PartialPerm.IsStable.iff_symm_preimage_eq`, which states that if a set `s` is preserved by a partial permutation `\u03c0`, then the intersection of the domain of `\u03c0` and the preimage of `s` under the inverse of `\u03c0` is equal to the intersection of the domain of `\u03c0` and `s`.", "formal_statement": "example {\u03b1 : Type u_1} {\u03c0 : PartialPerm \u03b1} {s : Set \u03b1} :PartialPerm.IsStable \u03c0 s \u2192 \u03c0.domain \u2229 (PartialPerm.symm \u03c0).toFun \u207b\u00b9' s = \u03c0.domain \u2229 s := by sorry", "full_tactic_state": "\u03b1 : Type u_1\n\u03c0 : PartialPerm \u03b1\ns : Set \u03b1\n\u22a2 PartialPerm.IsStable \u03c0 s \u2192 \u03c0.domain \u2229 (PartialPerm.symm \u03c0).toFun \u207b\u00b9' s = \u03c0.domain \u2229 s", "dependency": [645, 69, 677, 644]}, "PartialPerm.IsStable.of_symm_preimage_eq": {"natural_language_statement": "The theorem `PartialPerm.IsStable.of_symm_preimage_eq` is an alias of the reverse direction of `PartialPerm.IsStable.iff_symm_preimage_eq`. It states that if the intersection of the domain of a partial permutation `\u03c0` and the preimage of a set `s` under the inverse of `\u03c0` is equal to the intersection of the domain of `\u03c0` and `s`, then `s` is stable under `\u03c0`.", "formal_statement": "example {\u03b1 : Type u_1} {\u03c0 : PartialPerm \u03b1} {s : Set \u03b1} :\u03c0.domain \u2229 (PartialPerm.symm \u03c0).toFun \u207b\u00b9' s = \u03c0.domain \u2229 s \u2192 PartialPerm.IsStable \u03c0 s := by sorry", "full_tactic_state": "\u03b1 : Type u_1\n\u03c0 : PartialPerm \u03b1\ns : Set \u03b1\n\u22a2 \u03c0.domain \u2229 (PartialPerm.symm \u03c0).toFun \u207b\u00b9' s = \u03c0.domain \u2229 s \u2192 PartialPerm.IsStable \u03c0 s", "dependency": [645, 69, 644, 677]}, "PartialPerm.IsStable.compl": {"natural_language_statement": "If a partial permutation `\u03c0` is stable on a set `s`, then it is also stable on the complement of `s`.", "formal_statement": "example {\u03b1 : Type u_1} {\u03c0 : PartialPerm \u03b1} {s : Set \u03b1} (h : PartialPerm.IsStable \u03c0 s) :PartialPerm.IsStable \u03c0 s\u1d9c := by sorry", "full_tactic_state": "\u03b1 : Type u_1\n\u03c0 : PartialPerm \u03b1\ns : Set \u03b1\nh : PartialPerm.IsStable \u03c0 s\n\u22a2 PartialPerm.IsStable \u03c0 s\u1d9c", "dependency": [645, 69, 677, 677]}, "PartialPerm.IsStable.inter": {"natural_language_statement": "Function `PartialPerm.IsStable.inter` proves that if two sets `s` and `s'` are preserved by a partial permutation `\u03c0`, then their intersection `s \u2229 s'` is also preserved by `\u03c0`.", "formal_statement": "example {\u03b1 : Type u_1} {\u03c0 : PartialPerm \u03b1} {s : Set \u03b1} {s' : Set \u03b1} (h : PartialPerm.IsStable \u03c0 s) (h' : PartialPerm.IsStable \u03c0 s') :PartialPerm.IsStable \u03c0 (s \u2229 s') := by sorry", "full_tactic_state": "\u03b1 : Type u_1\n\u03c0 : PartialPerm \u03b1\ns s' : Set \u03b1\nh : PartialPerm.IsStable \u03c0 s\nh' : PartialPerm.IsStable \u03c0 s'\n\u22a2 PartialPerm.IsStable \u03c0 (s \u2229 s')", "dependency": [645, 69, 69, 677, 677, 677]}, "PartialPerm.IsStable.union": {"natural_language_statement": "Function `PartialPerm.IsStable.union` proves that if two sets `s` and `s'` are both preserved by a partial permutation `\u03c0`, then their union `s \u222a s'` is also preserved by `\u03c0`.", "formal_statement": "example {\u03b1 : Type u_1} {\u03c0 : PartialPerm \u03b1} {s : Set \u03b1} {s' : Set \u03b1} (h : PartialPerm.IsStable \u03c0 s) (h' : PartialPerm.IsStable \u03c0 s') :PartialPerm.IsStable \u03c0 (s \u222a s') := by sorry", "full_tactic_state": "\u03b1 : Type u_1\n\u03c0 : PartialPerm \u03b1\ns s' : Set \u03b1\nh : PartialPerm.IsStable \u03c0 s\nh' : PartialPerm.IsStable \u03c0 s'\n\u22a2 PartialPerm.IsStable \u03c0 (s \u222a s')", "dependency": [645, 69, 69, 677, 677, 677]}, "PartialPerm.IsStable.diff": {"natural_language_statement": "Function `PartialPerm.IsStable.diff` proves that if two sets `s` and `s'` are preserved by a partial permutation `\u03c0`, then their difference `s \\ s'` is also preserved by `\u03c0`.", "formal_statement": "example {\u03b1 : Type u_1} {\u03c0 : PartialPerm \u03b1} {s : Set \u03b1} {s' : Set \u03b1} (h : PartialPerm.IsStable \u03c0 s) (h' : PartialPerm.IsStable \u03c0 s') :PartialPerm.IsStable \u03c0 (s \\ s') := by sorry", "full_tactic_state": "\u03b1 : Type u_1\n\u03c0 : PartialPerm \u03b1\ns s' : Set \u03b1\nh : PartialPerm.IsStable \u03c0 s\nh' : PartialPerm.IsStable \u03c0 s'\n\u22a2 PartialPerm.IsStable \u03c0 (s \\ s')", "dependency": [645, 69, 69, 677, 677, 677]}, "PartialPerm.IsStable.leftInvOn_piecewise": {"natural_language_statement": "Given a partial permutation `\u03c0` and a set `s`, if both `\u03c0` and `\u03c0'` are stable on `s`, then the piecewise function defined by them and their inverses is a left inverse on the union of the domains of `\u03c0` and `\u03c0'` restricted to `s`.", "formal_statement": "example {\u03b1 : Type u_1} {\u03c0 : PartialPerm \u03b1} {s : Set \u03b1} {\u03c0' : PartialPerm \u03b1} [(i : \u03b1) \u2192 Decidable (i \u2208 s)] (h : PartialPerm.IsStable \u03c0 s) (h' : PartialPerm.IsStable \u03c0' s) :Set.LeftInvOn (Set.piecewise s (PartialPerm.symm \u03c0).toFun (PartialPerm.symm \u03c0').toFun) (Set.piecewise s \u03c0.toFun \u03c0'.toFun) (Set.ite s \u03c0.domain \u03c0'.domain) := by sorry", "full_tactic_state": "\u03b1 : Type u_1\n\u03c0 : PartialPerm \u03b1\ns : Set \u03b1\n\u03c0' : PartialPerm \u03b1\ninst\u271d : (i : \u03b1) \u2192 Decidable (i \u2208 s)\nh : PartialPerm.IsStable \u03c0 s\nh' : PartialPerm.IsStable \u03c0' s\n\u22a2 Set.LeftInvOn (Set.piecewise s (PartialPerm.symm \u03c0).toFun (PartialPerm.symm \u03c0').toFun)\n    (Set.piecewise s \u03c0.toFun \u03c0'.toFun) (Set.ite s \u03c0.domain \u03c0'.domain)", "dependency": [645, 69, 645, 14, 677, 677, 658, 700, 644, 644, 700, 701]}, "PartialPerm.IsStable.inter_eq_of_inter_eq_of_eqOn": {"natural_language_statement": "This theorem proves that, given two partial permutations `\u03c0` and `\u03c0'` of some type `\u03b1` which are stable on a set `s` (i.e., `s` is preserved by both permutations), and given that the intersection of the domains of `\u03c0` and `\u03c0'` with `s` is equal, and that `\u03c0` and `\u03c0'` are equal on the intersection of their domains with `s`, then the intersection of the domains of `\u03c0` and `s` is equal to the intersection of the domains of `\u03c0'` and `s`. This theorem helps in proving that the set `s` can be used as a domain for a larger partial permutation which is the union of `\u03c0` and `\u03c0'`, making the intersection of the domains of the resulting permutation and `s` equal to `s` itself.", "formal_statement": "example {\u03b1 : Type u_1} {\u03c0 : PartialPerm \u03b1} {s : Set \u03b1} {\u03c0' : PartialPerm \u03b1} (h : PartialPerm.IsStable \u03c0 s) (h' : PartialPerm.IsStable \u03c0' s) (hs : \u03c0.domain \u2229 s = \u03c0'.domain \u2229 s) (Heq : Set.EqOn \u03c0.toFun \u03c0'.toFun (\u03c0.domain \u2229 s)) :\u03c0.domain \u2229 s = \u03c0'.domain \u2229 s := by sorry", "full_tactic_state": "\u03b1 : Type u_1\n\u03c0 : PartialPerm \u03b1\ns : Set \u03b1\n\u03c0' : PartialPerm \u03b1\nh : PartialPerm.IsStable \u03c0 s\nh' : PartialPerm.IsStable \u03c0' s\nhs : \u03c0.domain \u2229 s = \u03c0'.domain \u2229 s\nHeq : Set.EqOn \u03c0.toFun \u03c0'.toFun (\u03c0.domain \u2229 s)\n\u22a2 \u03c0.domain \u2229 s = \u03c0'.domain \u2229 s", "dependency": [645, 69, 645, 677, 677, 703]}, "PartialPerm.IsStable.symm_eqOn_of_inter_eq_of_eqOn": {"natural_language_statement": "The theorem `PartialPerm.IsStable.symm_eqOn_of_inter_eq_of_eqOn` states that if a partial permutation `\u03c0` is stable on a set `s`, and `\u03c0` and `\u03c0'` are equal on the intersection of their domains with `s`, then the inverses of `\u03c0` and `\u03c0'` are equal on the intersection of their domains with `s`.", "formal_statement": "example {\u03b1 : Type u_1} {\u03c0 : PartialPerm \u03b1} {s : Set \u03b1} {\u03c0' : PartialPerm \u03b1} (h : PartialPerm.IsStable \u03c0 s) (hs : \u03c0.domain \u2229 s = \u03c0'.domain \u2229 s) (Heq : Set.EqOn \u03c0.toFun \u03c0'.toFun (\u03c0.domain \u2229 s)) :Set.EqOn (PartialPerm.symm \u03c0).toFun (PartialPerm.symm \u03c0').toFun (\u03c0.domain \u2229 s) := by sorry", "full_tactic_state": "\u03b1 : Type u_1\n\u03c0 : PartialPerm \u03b1\ns : Set \u03b1\n\u03c0' : PartialPerm \u03b1\nh : PartialPerm.IsStable \u03c0 s\nhs : \u03c0.domain \u2229 s = \u03c0'.domain \u2229 s\nHeq : Set.EqOn \u03c0.toFun \u03c0'.toFun (\u03c0.domain \u2229 s)\n\u22a2 Set.EqOn (PartialPerm.symm \u03c0).toFun (PartialPerm.symm \u03c0').toFun (\u03c0.domain \u2229 s)", "dependency": [645, 69, 645, 677, 703, 703, 644, 644]}, "PartialPerm.image_domain_inter_eq'": {"natural_language_statement": "Function `image_domain_inter_eq'` states that for a partial permutation `\u03c0` and a set `s`, the image of the intersection of the domain of `\u03c0` and `s` under `\u03c0` is equal to the intersection of the domain of `\u03c0` and the preimage of `s` under the inverse of `\u03c0`.", "formal_statement": "example {\u03b1 : Type u_1} (\u03c0 : PartialPerm \u03b1) (s : Set \u03b1) :\u03c0.toFun '' (\u03c0.domain \u2229 s) = \u03c0.domain \u2229 (PartialPerm.symm \u03c0).toFun \u207b\u00b9' s := by sorry", "full_tactic_state": "\u03b1 : Type u_1\n\u03c0 : PartialPerm \u03b1\ns : Set \u03b1\n\u22a2 \u03c0.toFun '' (\u03c0.domain \u2229 s) = \u03c0.domain \u2229 (PartialPerm.symm \u03c0).toFun \u207b\u00b9' s", "dependency": [645, 69, 644]}, "PartialPerm.image_domain_inter_eq": {"natural_language_statement": "The theorem `image_domain_inter_eq` states that for a partial permutation `\u03c0` and a set `s`, the image of the intersection of the domain of `\u03c0` and `s` under `\u03c0` is equal to the intersection of the domain of `\u03c0` and the preimage of the intersection of the domain of `\u03c0` and `s` under the inverse of `\u03c0`.", "formal_statement": "example {\u03b1 : Type u_1} (\u03c0 : PartialPerm \u03b1) (s : Set \u03b1) :\u03c0.toFun '' (\u03c0.domain \u2229 s) = \u03c0.domain \u2229 (PartialPerm.symm \u03c0).toFun \u207b\u00b9' (\u03c0.domain \u2229 s) := by sorry", "full_tactic_state": "\u03b1 : Type u_1\n\u03c0 : PartialPerm \u03b1\ns : Set \u03b1\n\u22a2 \u03c0.toFun '' (\u03c0.domain \u2229 s) = \u03c0.domain \u2229 (PartialPerm.symm \u03c0).toFun \u207b\u00b9' (\u03c0.domain \u2229 s)", "dependency": [645, 69, 644]}, "PartialPerm.image_eq_domain_inter_inv_preimage": {"natural_language_statement": "The image of a set `s` under a partial permutation `\u03c0` is equal to the intersection of the domain of `\u03c0` and the preimage of `s` under the inverse of `\u03c0`.", "formal_statement": "example {\u03b1 : Type u_1} (\u03c0 : PartialPerm \u03b1) {s : Set \u03b1} (h : s \u2286 \u03c0.domain) :\u03c0.toFun '' s = \u03c0.domain \u2229 (PartialPerm.symm \u03c0).toFun \u207b\u00b9' s := by sorry", "full_tactic_state": "\u03b1 : Type u_1\n\u03c0 : PartialPerm \u03b1\ns : Set \u03b1\nh : s \u2286 \u03c0.domain\n\u22a2 \u03c0.toFun '' s = \u03c0.domain \u2229 (PartialPerm.symm \u03c0).toFun \u207b\u00b9' s", "dependency": [645, 69, 644]}, "PartialPerm.symm_image_eq_domain_inter_preimage": {"natural_language_statement": "The theorem `PartialPerm.symm_image_eq_domain_inter_preimage` states that for a partial permutation `\u03c0` and a subset `s` of its domain, the image of `s` under the inverse of `\u03c0` is equal to the intersection of `\u03c0`'s domain with the preimage of `s` under `\u03c0`.", "formal_statement": "example {\u03b1 : Type u_1} (\u03c0 : PartialPerm \u03b1) {s : Set \u03b1} (h : s \u2286 \u03c0.domain) :(PartialPerm.symm \u03c0).toFun '' s = \u03c0.domain \u2229 \u03c0.toFun \u207b\u00b9' s := by sorry", "full_tactic_state": "\u03b1 : Type u_1\n\u03c0 : PartialPerm \u03b1\ns : Set \u03b1\nh : s \u2286 \u03c0.domain\n\u22a2 (PartialPerm.symm \u03c0).toFun '' s = \u03c0.domain \u2229 \u03c0.toFun \u207b\u00b9' s", "dependency": [645, 69, 644]}, "PartialPerm.symm_image_domain_inter_eq": {"natural_language_statement": "The theorem `PartialPerm.symm_image_domain_inter_eq` states that for a partial permutation `\u03c0` and a set `s`, the image of the intersection of the domain of `\u03c0` and `s` under the inverse of `\u03c0` is equal to the intersection of the domain of `\u03c0` and the preimage of the intersection of the domain of `\u03c0` and `s` under `\u03c0`.", "formal_statement": "example {\u03b1 : Type u_1} (\u03c0 : PartialPerm \u03b1) (s : Set \u03b1) :(PartialPerm.symm \u03c0).toFun '' (\u03c0.domain \u2229 s) = \u03c0.domain \u2229 \u03c0.toFun \u207b\u00b9' (\u03c0.domain \u2229 s) := by sorry", "full_tactic_state": "\u03b1 : Type u_1\n\u03c0 : PartialPerm \u03b1\ns : Set \u03b1\n\u22a2 (PartialPerm.symm \u03c0).toFun '' (\u03c0.domain \u2229 s) = \u03c0.domain \u2229 \u03c0.toFun \u207b\u00b9' (\u03c0.domain \u2229 s)", "dependency": [645, 69, 644]}, "PartialPerm.symm_image_domain_inter_eq'": {"natural_language_statement": "The theorem `PartialPerm.symm_image_domain_inter_eq'` states that for a partial permutation `\u03c0` and a set `s`, the image of the intersection of the domain of `\u03c0` and `s` under the inverse of `\u03c0` is equal to the intersection of the domain of `\u03c0` and the preimage of `s` under `\u03c0`.", "formal_statement": "example {\u03b1 : Type u_1} (\u03c0 : PartialPerm \u03b1) (s : Set \u03b1) :(PartialPerm.symm \u03c0).toFun '' (\u03c0.domain \u2229 s) = \u03c0.domain \u2229 \u03c0.toFun \u207b\u00b9' s := by sorry", "full_tactic_state": "\u03b1 : Type u_1\n\u03c0 : PartialPerm \u03b1\ns : Set \u03b1\n\u22a2 (PartialPerm.symm \u03c0).toFun '' (\u03c0.domain \u2229 s) = \u03c0.domain \u2229 \u03c0.toFun \u207b\u00b9' s", "dependency": [645, 69, 644]}, "PartialPerm.domain_inter_preimage_inv_preimage": {"natural_language_statement": "The theorem `domain_inter_preimage_inv_preimage` states that for a partial permutation `\u03c0` and a set `s`, the intersection of the domain of `\u03c0` with the preimage of the preimage of `s` under the inverse of `\u03c0` is equal to the intersection of the domain of `\u03c0` with `s`.", "formal_statement": "example {\u03b1 : Type u_1} (\u03c0 : PartialPerm \u03b1) (s : Set \u03b1) :\u03c0.domain \u2229 \u03c0.toFun \u207b\u00b9' ((PartialPerm.symm \u03c0).toFun \u207b\u00b9' s) = \u03c0.domain \u2229 s := by sorry", "full_tactic_state": "\u03b1 : Type u_1\n\u03c0 : PartialPerm \u03b1\ns : Set \u03b1\n\u22a2 \u03c0.domain \u2229 \u03c0.toFun \u207b\u00b9' ((PartialPerm.symm \u03c0).toFun \u207b\u00b9' s) = \u03c0.domain \u2229 s", "dependency": [645, 69, 644]}, "PartialPerm.domain_inter_preimage_domain_inter": {"natural_language_statement": "The theorem `domain_inter_preimage_domain_inter` states that for a partial permutation `\u03c0`, the intersection of its domain with the preimage of the intersection of its domain and a set `s` is equal to the intersection of its domain and the preimage of `s`.", "formal_statement": "example {\u03b1 : Type u_1} (\u03c0 : PartialPerm \u03b1) (s : Set \u03b1) :\u03c0.domain \u2229 \u03c0.toFun \u207b\u00b9' (\u03c0.domain \u2229 s) = \u03c0.domain \u2229 \u03c0.toFun \u207b\u00b9' s := by sorry", "full_tactic_state": "\u03b1 : Type u_1\n\u03c0 : PartialPerm \u03b1\ns : Set \u03b1\n\u22a2 \u03c0.domain \u2229 \u03c0.toFun \u207b\u00b9' (\u03c0.domain \u2229 s) = \u03c0.domain \u2229 \u03c0.toFun \u207b\u00b9' s", "dependency": [645, 69]}, "PartialPerm.domain_inter_inv_preimage_preimage": {"natural_language_statement": "The theorem `domain_inter_inv_preimage_preimage` states that for a partial permutation `\u03c0`, the intersection of its domain with the preimage of the preimage of a set `s` under `\u03c0` is equal to the intersection of its domain with `s`.", "formal_statement": "example {\u03b1 : Type u_1} (\u03c0 : PartialPerm \u03b1) (s : Set \u03b1) :\u03c0.domain \u2229 (PartialPerm.symm \u03c0).toFun \u207b\u00b9' (\u03c0.toFun \u207b\u00b9' s) = \u03c0.domain \u2229 s := by sorry", "full_tactic_state": "\u03b1 : Type u_1\n\u03c0 : PartialPerm \u03b1\ns : Set \u03b1\n\u22a2 \u03c0.domain \u2229 (PartialPerm.symm \u03c0).toFun \u207b\u00b9' (\u03c0.toFun \u207b\u00b9' s) = \u03c0.domain \u2229 s", "dependency": [645, 69, 644]}, "PartialPerm.symm_image_image_of_subset_domain": {"natural_language_statement": "The theorem `PartialPerm.symm_image_image_of_subset_domain` states that for a partial permutation `\u03c0` and a set `s` that is a subset of the domain of `\u03c0`, the image of `s` under `\u03c0` followed by the image of the result under the inverse of `\u03c0` is equal to `s`.", "formal_statement": "example {\u03b1 : Type u_1} (\u03c0 : PartialPerm \u03b1) {s : Set \u03b1} (h : s \u2286 \u03c0.domain) :(PartialPerm.symm \u03c0).toFun '' (\u03c0.toFun '' s) = s := by sorry", "full_tactic_state": "\u03b1 : Type u_1\n\u03c0 : PartialPerm \u03b1\ns : Set \u03b1\nh : s \u2286 \u03c0.domain\n\u22a2 (PartialPerm.symm \u03c0).toFun '' (\u03c0.toFun '' s) = s", "dependency": [645, 69, 644]}, "PartialPerm.image_symm_image_of_subset_domain": {"natural_language_statement": "The theorem `image_symm_image_of_subset_domain` states that for a partial permutation `\u03c0` and a set `s` that is a subset of the domain of `\u03c0`, the image of `s` under `\u03c0` followed by the image of the result under the inverse of `\u03c0` is equal to `s`.", "formal_statement": "example {\u03b1 : Type u_1} (\u03c0 : PartialPerm \u03b1) {s : Set \u03b1} (h : s \u2286 \u03c0.domain) :\u03c0.toFun '' ((PartialPerm.symm \u03c0).toFun '' s) = s := by sorry", "full_tactic_state": "\u03b1 : Type u_1\n\u03c0 : PartialPerm \u03b1\ns : Set \u03b1\nh : s \u2286 \u03c0.domain\n\u22a2 \u03c0.toFun '' ((PartialPerm.symm \u03c0).toFun '' s) = s", "dependency": [645, 69, 644]}, "PartialPerm.domain_subset_preimage_domain": {"natural_language_statement": "The domain of a partial permutation is a subset of the preimage of its domain under its forward function.", "formal_statement": "example {\u03b1 : Type u_1} {\u03c0 : PartialPerm \u03b1} :\u03c0.domain \u2286 \u03c0.toFun \u207b\u00b9' \u03c0.domain := by sorry", "full_tactic_state": "\u03b1 : Type u_1\n\u03c0 : PartialPerm \u03b1\n\u22a2 \u03c0.domain \u2286 \u03c0.toFun \u207b\u00b9' \u03c0.domain", "dependency": [645]}, "PartialPerm.symm_image_domain": {"natural_language_statement": "The image of the domain of a partial permutation under its inverse is equal to the domain itself.", "formal_statement": "example {\u03b1 : Type u_1} {\u03c0 : PartialPerm \u03b1} :(PartialPerm.symm \u03c0).toFun '' \u03c0.domain = \u03c0.domain := by sorry", "full_tactic_state": "\u03b1 : Type u_1\n\u03c0 : PartialPerm \u03b1\n\u22a2 (PartialPerm.symm \u03c0).toFun '' \u03c0.domain = \u03c0.domain", "dependency": [645, 644]}, "PartialPerm.ext": {"natural_language_statement": "Two partial permutations are equal if they have the same domain, the same function, and the same inverse function.", "formal_statement": "example {\u03b1 : Type u_1} {\u03c0 : PartialPerm \u03b1} {\u03c0' : PartialPerm \u03b1} (h : \u2200 (x : \u03b1), \u03c0.toFun x = \u03c0'.toFun x) (hsymm : \u2200 (x : \u03b1), (PartialPerm.symm \u03c0).toFun x = (PartialPerm.symm \u03c0').toFun x) (hs : \u03c0.domain = \u03c0'.domain) :\u03c0 = \u03c0' := by sorry", "full_tactic_state": "\u03b1 : Type u_1\n\u03c0 \u03c0' : PartialPerm \u03b1\nh : \u2200 (x : \u03b1), \u03c0.toFun x = \u03c0'.toFun x\nhsymm : \u2200 (x : \u03b1), (PartialPerm.symm \u03c0).toFun x = (PartialPerm.symm \u03c0').toFun x\nhs : \u03c0.domain = \u03c0'.domain\n\u22a2 \u03c0 = \u03c0'", "dependency": [645, 645, 644, 644]}, "PartialPerm.refl_domain": {"natural_language_statement": "The domain of the identity partial permutation is the universal set.", "formal_statement": "@[simp]example {\u03b1 : Type u_1} :(PartialPerm.refl \u03b1).domain = Set.univ := by sorry", "full_tactic_state": "\u03b1 : Type u_1\n\u22a2 (PartialPerm.refl \u03b1).domain = Set.univ", "dependency": [720]}, "PartialPerm.coe_refl": {"natural_language_statement": "The theorem `PartialPerm.coe_refl` states that the identity partial permutation on a type `\u03b1`, when coerced to a function, is equal to the identity function on `\u03b1`.", "formal_statement": "@[simp]example {\u03b1 : Type u_1} :(PartialPerm.refl \u03b1).toFun = id := by sorry", "full_tactic_state": "\u03b1 : Type u_1\n\u22a2 (PartialPerm.refl \u03b1).toFun = id", "dependency": [720]}, "PartialPerm.symm_refl": {"natural_language_statement": "The inverse of the identity partial permutation is itself.", "formal_statement": "@[simp]example {\u03b1 : Type u_1} :PartialPerm.symm (PartialPerm.refl \u03b1) = PartialPerm.refl \u03b1 := by sorry", "full_tactic_state": "\u03b1 : Type u_1\n\u22a2 PartialPerm.symm (PartialPerm.refl \u03b1) = PartialPerm.refl \u03b1", "dependency": [644, 720, 720]}, "PartialPerm.trans_invFun": {"natural_language_statement": "Function `PartialPerm.trans_invFun` states that the inverse of the composition of two partial permutations `\u03c0` and `\u03c0'` is equal to the composition of the inverses of `\u03c0` and `\u03c0'` in reverse order.", "formal_statement": "@[simp]example {\u03b1 : Type u_1} (\u03c0 : PartialPerm \u03b1) (\u03c0' : PartialPerm \u03b1) (h : \u03c0.domain = \u03c0'.domain) :\u2200 (a : \u03b1), (PartialPerm.trans \u03c0 \u03c0' h).invFun a = ((PartialPerm.symm \u03c0).toFun \u2218 (PartialPerm.symm \u03c0').toFun) a := by sorry", "full_tactic_state": "\u03b1 : Type u_1\n\u03c0 \u03c0' : PartialPerm \u03b1\nh : \u03c0.domain = \u03c0'.domain\n\u22a2 \u2200 (a : \u03b1), (PartialPerm.trans \u03c0 \u03c0' h).invFun a = ((PartialPerm.symm \u03c0).toFun \u2218 (PartialPerm.symm \u03c0').toFun) a", "dependency": [645, 645, 724, 644, 644]}, "PartialPerm.trans_toFun": {"natural_language_statement": "Function `PartialPerm.trans` composes two partial permutations if the domain of the first coincides with the domain of the second, resulting in a new partial permutation. The `toFun` of the resulting partial permutation is the composition of the `toFun`s of the two original partial permutations.", "formal_statement": "@[simp]example {\u03b1 : Type u_1} (\u03c0 : PartialPerm \u03b1) (\u03c0' : PartialPerm \u03b1) (h : \u03c0.domain = \u03c0'.domain) :\u2200 (a : \u03b1), (PartialPerm.trans \u03c0 \u03c0' h).toFun a = (\u03c0'.toFun \u2218 \u03c0.toFun) a := by sorry", "full_tactic_state": "\u03b1 : Type u_1\n\u03c0 \u03c0' : PartialPerm \u03b1\nh : \u03c0.domain = \u03c0'.domain\n\u22a2 \u2200 (a : \u03b1), (PartialPerm.trans \u03c0 \u03c0' h).toFun a = (\u03c0'.toFun \u2218 \u03c0.toFun) a", "dependency": [645, 645, 724]}, "PartialPerm.trans_domain": {"natural_language_statement": "`PartialPerm.trans_domain` states that the domain of the composition of two partial permutations is equal to the domain of the first partial permutation.", "formal_statement": "@[simp]example {\u03b1 : Type u_1} (\u03c0 : PartialPerm \u03b1) (\u03c0' : PartialPerm \u03b1) (h : \u03c0.domain = \u03c0'.domain) :(PartialPerm.trans \u03c0 \u03c0' h).domain = \u03c0.domain := by sorry", "full_tactic_state": "\u03b1 : Type u_1\n\u03c0 \u03c0' : PartialPerm \u03b1\nh : \u03c0.domain = \u03c0'.domain\n\u22a2 (PartialPerm.trans \u03c0 \u03c0' h).domain = \u03c0.domain", "dependency": [645, 645, 724]}, "PartialPerm.ofSet_domain": {"natural_language_statement": "The domain of the partial permutation `PartialPerm.ofSet s` is equal to the set `s`.", "formal_statement": "@[simp]example {\u03b1 : Type u_1} (s : Set \u03b1) :(PartialPerm.ofSet s).domain = s := by sorry", "full_tactic_state": "\u03b1 : Type u_1\ns : Set \u03b1\n\u22a2 (PartialPerm.ofSet s).domain = s", "dependency": [69, 728]}, "PartialPerm.coe_ofSet": {"natural_language_statement": "Function `PartialPerm.ofSet` constructs a partial permutation from a given set `s`. This partial permutation is the identity function on `s`, meaning it maps each element of `s` to itself, and its inverse also maps each element of `s` to itself. The domain of this partial permutation is `s`, and it is undefined outside of `s`.", "formal_statement": "@[simp]example {\u03b1 : Type u_1} (s : Set \u03b1) :(PartialPerm.ofSet s).toFun = id := by sorry", "full_tactic_state": "\u03b1 : Type u_1\ns : Set \u03b1\n\u22a2 (PartialPerm.ofSet s).toFun = id", "dependency": [69, 728]}, "PartialPerm.ofSet_symm": {"natural_language_statement": "Function `PartialPerm.ofSet_symm` states that the inverse of a partial permutation constructed from a set `s` is equal to the partial permutation itself.", "formal_statement": "@[simp]example {\u03b1 : Type u_1} (s : Set \u03b1) :PartialPerm.symm (PartialPerm.ofSet s) = PartialPerm.ofSet s := by sorry", "full_tactic_state": "\u03b1 : Type u_1\ns : Set \u03b1\n\u22a2 PartialPerm.symm (PartialPerm.ofSet s) = PartialPerm.ofSet s", "dependency": [69, 644, 728, 728]}, "PartialPerm.ofSet_univ": {"natural_language_statement": "Function `PartialPerm.ofSet` constructs a partial permutation from a given set `s`. This partial permutation is the identity function on `s`, meaning it maps each element of `s` to itself, and its inverse also maps each element of `s` to itself. The domain of this partial permutation is `s`, and it is undefined outside of `s`. When `s` is the universal set `univ`, the partial permutation `ofSet univ` is equivalent to the identity partial permutation `refl`.", "formal_statement": "@[simp]example {\u03b1 : Type u_1} :PartialPerm.ofSet Set.univ = PartialPerm.refl \u03b1 := by sorry", "full_tactic_state": "\u03b1 : Type u_1\n\u22a2 PartialPerm.ofSet Set.univ = PartialPerm.refl \u03b1", "dependency": [728, 720]}, "PartialPerm.coe_toPartialEquiv": {"natural_language_statement": "The theorem `PartialPerm.coe_toPartialEquiv` states that the coercion of a partial permutation `\u03c0` to a partial equivalence is equal to the function `toFun` of `\u03c0`.", "formal_statement": "@[simp]example {\u03b1 : Type u_1} (\u03c0 : PartialPerm \u03b1) :\u2191(PartialPerm.toPartialEquiv \u03c0) = \u03c0.toFun := by sorry", "full_tactic_state": "\u03b1 : Type u_1\n\u03c0 : PartialPerm \u03b1\n\u22a2 \u2191(PartialPerm.toPartialEquiv \u03c0) = \u03c0.toFun", "dependency": [645, 733]}, "PartialPerm.coe_toPartialEquiv_symm": {"natural_language_statement": "The theorem `PartialPerm.coe_toPartialEquiv_symm` states that for a partial permutation `\u03c0` of a type `\u03b1`, the inverse of the partial equivalence obtained from `\u03c0` is equal to the function representing the inverse of `\u03c0`.", "formal_statement": "@[simp]example {\u03b1 : Type u_1} (\u03c0 : PartialPerm \u03b1) :\u2191(PartialEquiv.symm (PartialPerm.toPartialEquiv \u03c0)) = (PartialPerm.symm \u03c0).toFun := by sorry", "full_tactic_state": "\u03b1 : Type u_1\n\u03c0 : PartialPerm \u03b1\n\u22a2 \u2191(PartialEquiv.symm (PartialPerm.toPartialEquiv \u03c0)) = (PartialPerm.symm \u03c0).toFun", "dependency": [645, 736, 733, 644]}, "PartialPerm.toPartialEquiv_source": {"natural_language_statement": "The function `PartialPerm.toPartialEquiv` converts a partial permutation `\u03c0` of a type `\u03b1` into a partial equivalence. The `source` of this partial equivalence is equal to the `domain` of the partial permutation `\u03c0`.", "formal_statement": "@[simp]example {\u03b1 : Type u_1} (\u03c0 : PartialPerm \u03b1) :(PartialPerm.toPartialEquiv \u03c0).source = \u03c0.domain := by sorry", "full_tactic_state": "\u03b1 : Type u_1\n\u03c0 : PartialPerm \u03b1\n\u22a2 (PartialPerm.toPartialEquiv \u03c0).source = \u03c0.domain", "dependency": [645, 733]}, "PartialPerm.toPartialEquiv_target": {"natural_language_statement": "Function `PartialPerm.toPartialEquiv` converts a partial permutation `\u03c0` of a type `\u03b1` into a partial equivalence. The `target` of this partial equivalence is equal to the `domain` of the partial permutation `\u03c0`.", "formal_statement": "@[simp]example {\u03b1 : Type u_1} (\u03c0 : PartialPerm \u03b1) :(PartialPerm.toPartialEquiv \u03c0).target = \u03c0.domain := by sorry", "full_tactic_state": "\u03b1 : Type u_1\n\u03c0 : PartialPerm \u03b1\n\u22a2 (PartialPerm.toPartialEquiv \u03c0).target = \u03c0.domain", "dependency": [645, 733]}, "PartialPerm.toPartialEquiv_refl": {"natural_language_statement": "Function `PartialPerm.toPartialEquiv_refl` states that converting the identity partial permutation to a partial equivalence yields the identity partial equivalence.", "formal_statement": "@[simp]example {\u03b1 : Type u_1} :PartialPerm.toPartialEquiv (PartialPerm.refl \u03b1) = PartialEquiv.refl \u03b1 := by sorry", "full_tactic_state": "\u03b1 : Type u_1\n\u22a2 PartialPerm.toPartialEquiv (PartialPerm.refl \u03b1) = PartialEquiv.refl \u03b1", "dependency": [733, 720, 740]}, "PartialPerm.toPartialEquiv_symm": {"natural_language_statement": "Function `PartialPerm.toPartialEquiv_symm` states that the inverse of a partial permutation, when converted to a partial equivalence, is equal to the inverse of the partial equivalence obtained from the original partial permutation.", "formal_statement": "@[simp]example {\u03b1 : Type u_1} (\u03c0 : PartialPerm \u03b1) :PartialPerm.toPartialEquiv (PartialPerm.symm \u03c0) = PartialEquiv.symm (PartialPerm.toPartialEquiv \u03c0) := by sorry", "full_tactic_state": "\u03b1 : Type u_1\n\u03c0 : PartialPerm \u03b1\n\u22a2 PartialPerm.toPartialEquiv (PartialPerm.symm \u03c0) = PartialEquiv.symm (PartialPerm.toPartialEquiv \u03c0)", "dependency": [645, 733, 644, 736, 733]}, "PartialPerm.toPartialEquiv_trans": {"natural_language_statement": "The theorem `PartialPerm.toPartialEquiv_trans` states that the composition of two partial permutations, when converted to partial equivalences, is equal to the composition of the partial equivalences themselves.", "formal_statement": "@[simp]example {\u03b1 : Type u_1} (\u03c0 : PartialPerm \u03b1) (\u03c0' : PartialPerm \u03b1) (h : \u03c0.domain = \u03c0'.domain) :PartialPerm.toPartialEquiv (PartialPerm.trans \u03c0 \u03c0' h) = PartialEquiv.trans (PartialPerm.toPartialEquiv \u03c0) (PartialPerm.toPartialEquiv \u03c0') := by sorry", "full_tactic_state": "\u03b1 : Type u_1\n\u03c0 \u03c0' : PartialPerm \u03b1\nh : \u03c0.domain = \u03c0'.domain\n\u22a2 PartialPerm.toPartialEquiv (PartialPerm.trans \u03c0 \u03c0' h) =\n    PartialEquiv.trans (PartialPerm.toPartialEquiv \u03c0) (PartialPerm.toPartialEquiv \u03c0')", "dependency": [645, 645, 733, 724, 743, 733, 733]}, "PartialPerm.eq_on_domain_refl": {"natural_language_statement": "The theorem `eq_on_domain_refl` states that a partial permutation is equal to itself on its domain.", "formal_statement": "example {\u03b1 : Type u_1} {\u03c0 : PartialPerm \u03b1} :\u03c0 \u2248 \u03c0 := by sorry", "full_tactic_state": "\u03b1 : Type u_1\n\u03c0 : PartialPerm \u03b1\n\u22a2 \u03c0 \u2248 \u03c0", "dependency": [645]}, "PartialPerm.EqOnDomain.domain_eq": {"natural_language_statement": "Two equivalent partial permutations have the same domain.", "formal_statement": "example {\u03b1 : Type u_1} {\u03c0 : PartialPerm \u03b1} {\u03c0' : PartialPerm \u03b1} (h : \u03c0 \u2248 \u03c0') :\u03c0.domain = \u03c0'.domain := by sorry", "full_tactic_state": "\u03b1 : Type u_1\n\u03c0 \u03c0' : PartialPerm \u03b1\nh : \u03c0 \u2248 \u03c0'\n\u22a2 \u03c0.domain = \u03c0'.domain", "dependency": [645, 645]}, "PartialPerm.EqOnDomain.symm_domain_eq": {"natural_language_statement": "`PartialPerm.EqOnDomain.symm_domain_eq` states that for two partial permutations `\u03c0` and `\u03c0'` that are equal on their domains, the domains of their inverses are also equal.", "formal_statement": "example {\u03b1 : Type u_1} {\u03c0 : PartialPerm \u03b1} {\u03c0' : PartialPerm \u03b1} (h : \u03c0 \u2248 \u03c0') :(PartialPerm.symm \u03c0).domain = (PartialPerm.symm \u03c0').domain := by sorry", "full_tactic_state": "\u03b1 : Type u_1\n\u03c0 \u03c0' : PartialPerm \u03b1\nh : \u03c0 \u2248 \u03c0'\n\u22a2 (PartialPerm.symm \u03c0).domain = (PartialPerm.symm \u03c0').domain", "dependency": [645, 645, 644, 644]}, "PartialPerm.EqOnDomain.eqOn": {"natural_language_statement": "Function `eqOn` checks if two partial permutations `\u03c0` and `\u03c0'` are equal on the domain of `\u03c0`.", "formal_statement": "example {\u03b1 : Type u_1} {\u03c0 : PartialPerm \u03b1} {\u03c0' : PartialPerm \u03b1} (h : \u03c0 \u2248 \u03c0') :Set.EqOn \u03c0.toFun \u03c0'.toFun \u03c0.domain := by sorry", "full_tactic_state": "\u03b1 : Type u_1\n\u03c0 \u03c0' : PartialPerm \u03b1\nh : \u03c0 \u2248 \u03c0'\n\u22a2 Set.EqOn \u03c0.toFun \u03c0'.toFun \u03c0.domain", "dependency": [645, 645, 703]}, "PartialPerm.EqOnDomain.symm'": {"natural_language_statement": "Function `PartialPerm.EqOnDomain.symm'` proves that if two partial permutations are equivalent, then their inverses are also equivalent.", "formal_statement": "example {\u03b1 : Type u_1} {\u03c0 : PartialPerm \u03b1} {\u03c0' : PartialPerm \u03b1} (h : \u03c0 \u2248 \u03c0') :PartialPerm.symm \u03c0 \u2248 PartialPerm.symm \u03c0' := by sorry", "full_tactic_state": "\u03b1 : Type u_1\n\u03c0 \u03c0' : PartialPerm \u03b1\nh : \u03c0 \u2248 \u03c0'\n\u22a2 PartialPerm.symm \u03c0 \u2248 PartialPerm.symm \u03c0'", "dependency": [645, 645, 644, 644]}, "PartialPerm.EqOnDomain.symm_eqOn": {"natural_language_statement": "If two partial permutations are equivalent, then their inverses are equal on the domain of the partial permutations.", "formal_statement": "example {\u03b1 : Type u_1} {\u03c0 : PartialPerm \u03b1} {\u03c0' : PartialPerm \u03b1} (h : \u03c0 \u2248 \u03c0') :Set.EqOn (PartialPerm.symm \u03c0).toFun (PartialPerm.symm \u03c0').toFun \u03c0.domain := by sorry", "full_tactic_state": "\u03b1 : Type u_1\n\u03c0 \u03c0' : PartialPerm \u03b1\nh : \u03c0 \u2248 \u03c0'\n\u22a2 Set.EqOn (PartialPerm.symm \u03c0).toFun (PartialPerm.symm \u03c0').toFun \u03c0.domain", "dependency": [645, 645, 703, 644, 644]}, "PartialPerm.EqOnDomain.domain_inter_preimage_eq": {"natural_language_statement": "Function `PartialPerm.EqOnDomain.domain_inter_preimage_eq` proves that the intersection of the domain of a partial permutation `\u03c0` and the preimage of a set `s` under `\u03c0.toFun` is equal to the intersection of the domain of an equivalent partial permutation `\u03c0'` and the preimage of `s` under `\u03c0'.toFun`.", "formal_statement": "example {\u03b1 : Type u_1} {\u03c0 : PartialPerm \u03b1} {\u03c0' : PartialPerm \u03b1} (h\u03c0 : \u03c0 \u2248 \u03c0') (s : Set \u03b1) :\u03c0.domain \u2229 \u03c0.toFun \u207b\u00b9' s = \u03c0'.domain \u2229 \u03c0'.toFun \u207b\u00b9' s := by sorry", "full_tactic_state": "\u03b1 : Type u_1\n\u03c0 \u03c0' : PartialPerm \u03b1\nh\u03c0 : \u03c0 \u2248 \u03c0'\ns : Set \u03b1\n\u22a2 \u03c0.domain \u2229 \u03c0.toFun \u207b\u00b9' s = \u03c0'.domain \u2229 \u03c0'.toFun \u207b\u00b9' s", "dependency": [645, 645, 69]}, "PartialPerm.EqOnDomain.eq": {"natural_language_statement": "The theorem `PartialPerm.EqOnDomain.eq` states that two equivalent partial permutations are equal when the domain and domain are univ.", "formal_statement": "example {\u03b1 : Type u_1} {\u03c0 : PartialPerm \u03b1} {\u03c0' : PartialPerm \u03b1} (h : \u03c0 \u2248 \u03c0') (h\u03c0 : \u03c0.domain = Set.univ) :\u03c0 = \u03c0' := by sorry", "full_tactic_state": "\u03b1 : Type u_1\n\u03c0 \u03c0' : PartialPerm \u03b1\nh : \u03c0 \u2248 \u03c0'\nh\u03c0 : \u03c0.domain = Set.univ\n\u22a2 \u03c0 = \u03c0'", "dependency": [645, 645]}, "PartialPerm.domain_mono": {"natural_language_statement": "For partial permutations `\u03c0` and `\u03c0'`, if `\u03c0 \u2264 \u03c0'`, then the domain of `\u03c0` is a subset of the domain of `\u03c0'`.", "formal_statement": "example {\u03b1 : Type u_1} {\u03c0 : PartialPerm \u03b1} {\u03c0' : PartialPerm \u03b1} (h : \u03c0 \u2264 \u03c0') :\u03c0.domain \u2286 \u03c0'.domain := by sorry", "full_tactic_state": "\u03b1 : Type u_1\n\u03c0 \u03c0' : PartialPerm \u03b1\nh : \u03c0 \u2264 \u03c0'\n\u22a2 \u03c0.domain \u2286 \u03c0'.domain", "dependency": [645, 645]}, "PartialPerm.eqOn_domain_of_le": {"natural_language_statement": "Given two partial permutations `\u03c0` and `\u03c0'`, if `\u03c0` is less than or equal to `\u03c0'`, then `\u03c0` and `\u03c0'` are equal on the domain of `\u03c0`.", "formal_statement": "example {\u03b1 : Type u_1} {\u03c0 : PartialPerm \u03b1} {\u03c0' : PartialPerm \u03b1} (h : \u03c0 \u2264 \u03c0') :Set.EqOn \u03c0.toFun \u03c0'.toFun \u03c0.domain := by sorry", "full_tactic_state": "\u03b1 : Type u_1\n\u03c0 \u03c0' : PartialPerm \u03b1\nh : \u03c0 \u2264 \u03c0'\n\u22a2 Set.EqOn \u03c0.toFun \u03c0'.toFun \u03c0.domain", "dependency": [645, 645, 703]}, "PartialPerm.le_of_eq_on_domain": {"natural_language_statement": "If two partial permutations `\u03c0` and `\u03c0'` are equal on their domains, then `\u03c0` is less than or equal to `\u03c0'`.", "formal_statement": "example {\u03b1 : Type u_1} {\u03c0 : PartialPerm \u03b1} {\u03c0' : PartialPerm \u03b1} (h : \u03c0 \u2248 \u03c0') :\u03c0 \u2264 \u03c0' := by sorry", "full_tactic_state": "\u03b1 : Type u_1\n\u03c0 \u03c0' : PartialPerm \u03b1\nh : \u03c0 \u2248 \u03c0'\n\u22a2 \u03c0 \u2264 \u03c0'", "dependency": [645, 645]}, "PartialPerm.apply_eq_of_le": {"natural_language_statement": "If `\u03c0 \u2264 \u03c0'` and `x \u2208 \u03c0.domain`, then `\u03c0'.toFun x = \u03c0.toFun x`.", "formal_statement": "example {\u03b1 : Type u_1} {\u03c0 : PartialPerm \u03b1} {\u03c0' : PartialPerm \u03b1} (h : \u03c0 \u2264 \u03c0') {x : \u03b1} (hx : x \u2208 \u03c0.domain) :\u03c0'.toFun x = \u03c0.toFun x := by sorry", "full_tactic_state": "\u03b1 : Type u_1\n\u03c0 \u03c0' : PartialPerm \u03b1\nh : \u03c0 \u2264 \u03c0'\nx : \u03b1\nhx : x \u2208 \u03c0.domain\n\u22a2 \u03c0'.toFun x = \u03c0.toFun x", "dependency": [645, 645]}, "PartialPerm.piecewise_domain": {"natural_language_statement": "Function `PartialPerm.piecewise` takes two partial permutations `\u03c0` and `\u03c0'` with disjoint domains and returns a new partial permutation that coincides with `\u03c0` on `\u03c0.domain` and with `\u03c0'` on `\u03c0'.domain`. The domain of the resulting partial permutation is the union of the domains of `\u03c0` and `\u03c0'`.", "formal_statement": "@[simp]example {\u03b1 : Type u_1} {\u03c0 : PartialPerm \u03b1} {\u03c0' : PartialPerm \u03b1} [(j : \u03b1) \u2192 Decidable (j \u2208 \u03c0.domain)] {h : Disjoint \u03c0.domain \u03c0'.domain} :(PartialPerm.piecewise \u03c0 \u03c0' h).domain = \u03c0.domain \u222a \u03c0'.domain := by sorry", "full_tactic_state": "\u03b1 : Type u_1\n\u03c0 \u03c0' : PartialPerm \u03b1\ninst\u271d : (j : \u03b1) \u2192 Decidable (j \u2208 \u03c0.domain)\nh : Disjoint \u03c0.domain \u03c0'.domain\n\u22a2 (PartialPerm.piecewise \u03c0 \u03c0' h).domain = \u03c0.domain \u222a \u03c0'.domain", "dependency": [645, 645, 14, 757, 759]}, "PartialPerm.mem_piecewise_domain_left": {"natural_language_statement": "Given two partial permutations `\u03c0` and `\u03c0'` with disjoint domains, if `x` is in the domain of `\u03c0`, then `x` is also in the domain of the piecewise composition of `\u03c0` and `\u03c0'`.", "formal_statement": "example {\u03b1 : Type u_1} {\u03c0 : PartialPerm \u03b1} {\u03c0' : PartialPerm \u03b1} [(j : \u03b1) \u2192 Decidable (j \u2208 \u03c0.domain)] {h : Disjoint \u03c0.domain \u03c0'.domain} {x : \u03b1} (hx : x \u2208 \u03c0.domain) :x \u2208 (PartialPerm.piecewise \u03c0 \u03c0' h).domain := by sorry", "full_tactic_state": "\u03b1 : Type u_1\n\u03c0 \u03c0' : PartialPerm \u03b1\ninst\u271d : (j : \u03b1) \u2192 Decidable (j \u2208 \u03c0.domain)\nh : Disjoint \u03c0.domain \u03c0'.domain\nx : \u03b1\nhx : x \u2208 \u03c0.domain\n\u22a2 x \u2208 (PartialPerm.piecewise \u03c0 \u03c0' h).domain", "dependency": [645, 645, 14, 757, 759]}, "PartialPerm.mem_piecewise_domain_right": {"natural_language_statement": "Given two partial permutations `\u03c0` and `\u03c0'` with disjoint domains, if `x` is in the domain of `\u03c0'`, then `x` is also in the domain of the piecewise composition of `\u03c0` and `\u03c0'`.", "formal_statement": "example {\u03b1 : Type u_1} {\u03c0 : PartialPerm \u03b1} {\u03c0' : PartialPerm \u03b1} [(j : \u03b1) \u2192 Decidable (j \u2208 \u03c0.domain)] {h : Disjoint \u03c0.domain \u03c0'.domain} {x : \u03b1} (hx : x \u2208 \u03c0'.domain) :x \u2208 (PartialPerm.piecewise \u03c0 \u03c0' h).domain := by sorry", "full_tactic_state": "\u03b1 : Type u_1\n\u03c0 \u03c0' : PartialPerm \u03b1\ninst\u271d : (j : \u03b1) \u2192 Decidable (j \u2208 \u03c0.domain)\nh : Disjoint \u03c0.domain \u03c0'.domain\nx : \u03b1\nhx : x \u2208 \u03c0'.domain\n\u22a2 x \u2208 (PartialPerm.piecewise \u03c0 \u03c0' h).domain", "dependency": [645, 645, 14, 757, 759]}, "PartialPerm.piecewise_apply_eq_left": {"natural_language_statement": "Function `PartialPerm.piecewise` takes two partial permutations `\u03c0` and `\u03c0'` with disjoint domains and returns a new partial permutation that coincides with `\u03c0` on `\u03c0.domain` and with `\u03c0'` on `\u03c0'.domain`. The theorem `PartialPerm.piecewise_apply_eq_left` states that if `x` is in the domain of `\u03c0`, then applying the piecewise permutation to `x` yields the same result as applying `\u03c0` to `x`.", "formal_statement": "example {\u03b1 : Type u_1} {\u03c0 : PartialPerm \u03b1} {\u03c0' : PartialPerm \u03b1} [(j : \u03b1) \u2192 Decidable (j \u2208 \u03c0.domain)] {h : Disjoint \u03c0.domain \u03c0'.domain} {x : \u03b1} (hx : x \u2208 \u03c0.domain) :(PartialPerm.piecewise \u03c0 \u03c0' h).toFun x = \u03c0.toFun x := by sorry", "full_tactic_state": "\u03b1 : Type u_1\n\u03c0 \u03c0' : PartialPerm \u03b1\ninst\u271d : (j : \u03b1) \u2192 Decidable (j \u2208 \u03c0.domain)\nh : Disjoint \u03c0.domain \u03c0'.domain\nx : \u03b1\nhx : x \u2208 \u03c0.domain\n\u22a2 (PartialPerm.piecewise \u03c0 \u03c0' h).toFun x = \u03c0.toFun x", "dependency": [645, 645, 14, 757, 759]}, "PartialPerm.piecewise_apply_eq_right": {"natural_language_statement": "The function `PartialPerm.piecewise` takes two partial permutations `\u03c0` and `\u03c0'` with disjoint domains and returns a new partial permutation that coincides with `\u03c0` on `\u03c0.domain` and with `\u03c0'` on `\u03c0'.domain`. The theorem `PartialPerm.piecewise_apply_eq_right` states that for any element `x` in the domain of `\u03c0'`, the function `(PartialPerm.piecewise \u03c0 \u03c0' h).toFun x` is equal to `\u03c0'.toFun x`.", "formal_statement": "example {\u03b1 : Type u_1} {\u03c0 : PartialPerm \u03b1} {\u03c0' : PartialPerm \u03b1} [(j : \u03b1) \u2192 Decidable (j \u2208 \u03c0.domain)] {h : Disjoint \u03c0.domain \u03c0'.domain} {x : \u03b1} (hx : x \u2208 \u03c0'.domain) :(PartialPerm.piecewise \u03c0 \u03c0' h).toFun x = \u03c0'.toFun x := by sorry", "full_tactic_state": "\u03b1 : Type u_1\n\u03c0 \u03c0' : PartialPerm \u03b1\ninst\u271d : (j : \u03b1) \u2192 Decidable (j \u2208 \u03c0.domain)\nh : Disjoint \u03c0.domain \u03c0'.domain\nx : \u03b1\nhx : x \u2208 \u03c0'.domain\n\u22a2 (PartialPerm.piecewise \u03c0 \u03c0' h).toFun x = \u03c0'.toFun x", "dependency": [645, 645, 14, 757, 759]}, "PartialPerm.le_piecewise_left": {"natural_language_statement": "The theorem `le_piecewise_left` states that for any two partial permutations `\u03c0` and `\u03c0'` with disjoint domains, `\u03c0` is less than or equal to the piecewise composition of `\u03c0` and `\u03c0'`.", "formal_statement": "example {\u03b1 : Type u_1} {\u03c0 : PartialPerm \u03b1} {\u03c0' : PartialPerm \u03b1} [(j : \u03b1) \u2192 Decidable (j \u2208 \u03c0.domain)] {h : Disjoint \u03c0.domain \u03c0'.domain} :\u03c0 \u2264 PartialPerm.piecewise \u03c0 \u03c0' h := by sorry", "full_tactic_state": "\u03b1 : Type u_1\n\u03c0 \u03c0' : PartialPerm \u03b1\ninst\u271d : (j : \u03b1) \u2192 Decidable (j \u2208 \u03c0.domain)\nh : Disjoint \u03c0.domain \u03c0'.domain\n\u22a2 \u03c0 \u2264 PartialPerm.piecewise \u03c0 \u03c0' h", "dependency": [645, 645, 14, 757, 759]}, "PartialPerm.le_piecewise_right": {"natural_language_statement": "Function `le_piecewise_right` states that for two partial permutations `\u03c0` and `\u03c0'` with disjoint domains, `\u03c0'` is less than or equal to the piecewise composition of `\u03c0` and `\u03c0'`.", "formal_statement": "example {\u03b1 : Type u_1} {\u03c0 : PartialPerm \u03b1} {\u03c0' : PartialPerm \u03b1} [(j : \u03b1) \u2192 Decidable (j \u2208 \u03c0.domain)] {h : Disjoint \u03c0.domain \u03c0'.domain} :\u03c0' \u2264 PartialPerm.piecewise \u03c0 \u03c0' h := by sorry", "full_tactic_state": "\u03b1 : Type u_1\n\u03c0 \u03c0' : PartialPerm \u03b1\ninst\u271d : (j : \u03b1) \u2192 Decidable (j \u2208 \u03c0.domain)\nh : Disjoint \u03c0.domain \u03c0'.domain\n\u22a2 \u03c0' \u2264 PartialPerm.piecewise \u03c0 \u03c0' h", "dependency": [645, 645, 14, 757, 759]}, "Set.BijOn.toPartialPerm_toFun": {"natural_language_statement": "Function `Set.BijOn.toPartialPerm` converts a bijective function `f` between two sets `s` and `t` into a partial permutation on the type `\u03b1`. The resulting partial permutation has `f` as its forward function, the inverse function of `f` restricted to `s` as its inverse function, and `s` as its domain. The theorem `Set.BijOn.toPartialPerm_toFun` states that the forward function of the resulting partial permutation is indeed `f`.", "formal_statement": "@[simp]example {\u03b1 : Type u_1} [Nonempty \u03b1] (f : \u03b1 \u2192 \u03b1) (s : Set \u03b1) (hf : Set.BijOn f s s) :(Set.BijOn.toPartialPerm f s hf).toFun = f := by sorry", "full_tactic_state": "\u03b1 : Type u_1\ninst\u271d : Nonempty \u03b1\nf : \u03b1 \u2192 \u03b1\ns : Set \u03b1\nhf : Set.BijOn f s s\n\u22a2 (Set.BijOn.toPartialPerm f s hf).toFun = f", "dependency": [212, 69, 665, 767]}, "Set.BijOn.toPartialPerm_invFun": {"natural_language_statement": "The theorem `Set.BijOn.toPartialPerm_invFun` states that for a bijective function `f` on a set `s`, the inverse function of the partial permutation `Set.BijOn.toPartialPerm f s hf` is equal to the inverse function of `f` restricted to `s`.", "formal_statement": "@[simp]example {\u03b1 : Type u_1} [Nonempty \u03b1] (f : \u03b1 \u2192 \u03b1) (s : Set \u03b1) (hf : Set.BijOn f s s) :(Set.BijOn.toPartialPerm f s hf).invFun = Function.invFunOn f s := by sorry", "full_tactic_state": "\u03b1 : Type u_1\ninst\u271d : Nonempty \u03b1\nf : \u03b1 \u2192 \u03b1\ns : Set \u03b1\nhf : Set.BijOn f s s\n\u22a2 (Set.BijOn.toPartialPerm f s hf).invFun = Function.invFunOn f s", "dependency": [212, 69, 665, 767, 769]}, "Set.BijOn.toPartialPerm_domain": {"natural_language_statement": "The theorem `Set.BijOn.toPartialPerm_domain` states that the domain of the partial permutation `Set.BijOn.toPartialPerm f s hf` is equal to the set `s`.", "formal_statement": "@[simp]example {\u03b1 : Type u_1} [Nonempty \u03b1] (f : \u03b1 \u2192 \u03b1) (s : Set \u03b1) (hf : Set.BijOn f s s) :(Set.BijOn.toPartialPerm f s hf).domain = s := by sorry", "full_tactic_state": "\u03b1 : Type u_1\ninst\u271d : Nonempty \u03b1\nf : \u03b1 \u2192 \u03b1\ns : Set \u03b1\nhf : Set.BijOn f s s\n\u22a2 (Set.BijOn.toPartialPerm f s hf).domain = s", "dependency": [212, 69, 665, 767]}, "Equiv.Perm.toPartialPerm_one": {"natural_language_statement": "The theorem `Equiv.Perm.toPartialPerm_one` states that converting the identity permutation on a type `\u03b1` to a partial permutation results in the identity partial permutation on `\u03b1`.", "formal_statement": "@[simp]example {\u03b1 : Type u_1} :Equiv.Perm.toPartialPerm (Equiv.refl \u03b1) = PartialPerm.refl \u03b1 := by sorry", "full_tactic_state": "\u03b1 : Type u_1\n\u22a2 Equiv.Perm.toPartialPerm (Equiv.refl \u03b1) = PartialPerm.refl \u03b1", "dependency": [772, 774, 720]}, "Equiv.Perm.toPartialPerm_inv": {"natural_language_statement": "Function `Equiv.Perm.toPartialPerm_inv` states that the inverse of a permutation, when converted to a partial permutation, is equal to the inverse of the partial permutation obtained from the original permutation.", "formal_statement": "@[simp]example {\u03b1 : Type u_1} (\u03c0 : Equiv.Perm \u03b1) :Equiv.Perm.toPartialPerm \u03c0\u207b\u00b9 = PartialPerm.symm (Equiv.Perm.toPartialPerm \u03c0) := by sorry", "full_tactic_state": "\u03b1 : Type u_1\n\u03c0 : Equiv.Perm \u03b1\n\u22a2 Equiv.Perm.toPartialPerm \u03c0\u207b\u00b9 = PartialPerm.symm (Equiv.Perm.toPartialPerm \u03c0)", "dependency": [773, 772, 644, 772]}, "Equiv.Perm.toPartialEquiv_toPartialPerm": {"natural_language_statement": "The theorem `Equiv.Perm.toPartialEquiv_toPartialPerm` states that converting a permutation to a partial permutation and then back to a partial equivalence yields the same result as converting the permutation directly to a partial equivalence.", "formal_statement": "@[simp]example {\u03b1 : Type u_1} (\u03c0 : Equiv.Perm \u03b1) :PartialPerm.toPartialEquiv (Equiv.Perm.toPartialPerm \u03c0) = Equiv.toPartialEquiv \u03c0 := by sorry", "full_tactic_state": "\u03b1 : Type u_1\n\u03c0 : Equiv.Perm \u03b1\n\u22a2 PartialPerm.toPartialEquiv (Equiv.Perm.toPartialPerm \u03c0) = Equiv.toPartialEquiv \u03c0", "dependency": [773, 733, 772, 777]}, "ConNF.StructApprox.completeAtomPerm_apply": {"natural_language_statement": "Function `ConNF.StructApprox.completeAtomPerm` defines a permutation on the set of atoms in the context of Constructive Ordinal Notation (ConNF), given a free `\u03b2`-structural approximation `\u03c0` and a `\u03b2`-extended index `A`. This permutation is constructed by applying the `\u03b2`-structural approximation to `A`, which results in a near-litter approximation, and then using this near-litter approximation to define a permutation on the set of atoms.", "formal_statement": "example [ConNF.Params ] [ConNF.Level] [ConNF.FOAAssumptions] {\u03b2 : ConNF.\u039b} [ConNF.LeLevel \u2191\u03b2] [ConNF.StructApprox.FreedomOfActionHypothesis \u03b2] {\u03c0 : ConNF.StructApprox \u2191\u03b2} (h\u03c0f : ConNF.StructApprox.Free \u03c0) (A : ConNF.ExtendedIndex \u2191\u03b2) (a : ConNF.Atom) :(ConNF.StructApprox.completeAtomPerm h\u03c0f A) a = ConNF.StructApprox.completeAtomMap \u03c0 A a := by sorry", "full_tactic_state": "inst\u271d\u2074 : ConNF.Params\ninst\u271d\u00b3 : ConNF.Level\ninst\u271d\u00b2 : ConNF.FOAAssumptions\n\u03b2 : ConNF.\u039b\ninst\u271d\u00b9 : ConNF.LeLevel \u2191\u03b2\ninst\u271d : ConNF.StructApprox.FreedomOfActionHypothesis \u03b2\n\u03c0 : ConNF.StructApprox \u2191\u03b2\nh\u03c0f : ConNF.StructApprox.Free \u03c0\nA : ConNF.ExtendedIndex \u2191\u03b2\na : ConNF.Atom\n\u22a2 (ConNF.StructApprox.completeAtomPerm h\u03c0f A) a = ConNF.StructApprox.completeAtomMap \u03c0 A a", "dependency": [1, 402, 779, 781, 782, 61, 783, 784]}, "ConNF.StructApprox.completeLitterPerm_apply": {"natural_language_statement": "The theorem `ConNF.StructApprox.completeLitterPerm_apply` is a part of the construction of the natural numbers in the context of Constructive Ordinal Notation (ConNF). It defines a permutation on the litter type `ConNF.Litter` from a free `\u03b2`-structural approximation `\u03c0` and a `\u03b2`-extended index `A`. This permutation is derived from the `ConNF.StructApprox.completeLitterMap` function, which maps elements of `ConNF.Litter` to other elements of `ConNF.Litter` based on the approximation `\u03c0` and the index `A`.", "formal_statement": "example [ConNF.Params ] [ConNF.Level] [ConNF.FOAAssumptions] {\u03b2 : ConNF.\u039b} [ConNF.LeLevel \u2191\u03b2] [ConNF.StructApprox.FreedomOfActionHypothesis \u03b2] {\u03c0 : ConNF.StructApprox \u2191\u03b2} (h\u03c0f : ConNF.StructApprox.Free \u03c0) (A : ConNF.ExtendedIndex \u2191\u03b2) (L : ConNF.Litter) :(ConNF.StructApprox.completeLitterPerm h\u03c0f A) L = ConNF.StructApprox.completeLitterMap \u03c0 A L := by sorry", "full_tactic_state": "inst\u271d\u2074 : ConNF.Params\ninst\u271d\u00b3 : ConNF.Level\ninst\u271d\u00b2 : ConNF.FOAAssumptions\n\u03b2 : ConNF.\u039b\ninst\u271d\u00b9 : ConNF.LeLevel \u2191\u03b2\ninst\u271d : ConNF.StructApprox.FreedomOfActionHypothesis \u03b2\n\u03c0 : ConNF.StructApprox \u2191\u03b2\nh\u03c0f : ConNF.StructApprox.Free \u03c0\nA : ConNF.ExtendedIndex \u2191\u03b2\nL : ConNF.Litter\n\u22a2 (ConNF.StructApprox.completeLitterPerm h\u03c0f A) L = ConNF.StructApprox.completeLitterMap \u03c0 A L", "dependency": [1, 402, 779, 781, 782, 61, 786, 787]}, "ConNF.StructApprox.completeNearLitterPerm_smul_atom": {"natural_language_statement": "In the context of Constructive Ordinal Notation (ConNF), given a free \u03b2-structural approximation \u03c0, the `ConNF.StructApprox.completeNearLitterPerm` function provides a near-litter permutation for each \u03b2-extended index A, and the `ConNF.StructApprox.completeAtomMap` function completes each atom. The theorem `ConNF.StructApprox.completeNearLitterPerm_smul_atom` proves that the action of the near-litter permutation on an atom is equal to the atom's completion by the \u03b2-structural approximation \u03c0.", "formal_statement": "example [ConNF.Params ] [ConNF.Level] [ConNF.FOAAssumptions] {\u03b2 : ConNF.\u039b} [ConNF.LeLevel \u2191\u03b2] [ConNF.StructApprox.FreedomOfActionHypothesis \u03b2] {\u03c0 : ConNF.StructApprox \u2191\u03b2} (h\u03c0f : ConNF.StructApprox.Free \u03c0) (A : ConNF.ExtendedIndex \u2191\u03b2) (a : ConNF.Atom) :ConNF.StructApprox.completeNearLitterPerm h\u03c0f A \u2022 a = ConNF.StructApprox.completeAtomMap \u03c0 A a := by sorry", "full_tactic_state": "inst\u271d\u2074 : ConNF.Params\ninst\u271d\u00b3 : ConNF.Level\ninst\u271d\u00b2 : ConNF.FOAAssumptions\n\u03b2 : ConNF.\u039b\ninst\u271d\u00b9 : ConNF.LeLevel \u2191\u03b2\ninst\u271d : ConNF.StructApprox.FreedomOfActionHypothesis \u03b2\n\u03c0 : ConNF.StructApprox \u2191\u03b2\nh\u03c0f : ConNF.StructApprox.Free \u03c0\nA : ConNF.ExtendedIndex \u2191\u03b2\na : ConNF.Atom\n\u22a2 ConNF.StructApprox.completeNearLitterPerm h\u03c0f A \u2022 a = ConNF.StructApprox.completeAtomMap \u03c0 A a", "dependency": [1, 402, 779, 781, 782, 61, 789, 784]}, "ConNF.StructApprox.completeNearLitterPerm_smul_litter": {"natural_language_statement": "In Constructive Ordinal Notation (ConNF), the theorem `ConNF.StructApprox.completeNearLitterPerm_smul_litter` asserts that the action of a `\u03b2`-structural approximation `\u03c0` on a litter `L`, when lifted to the `NearLitterPerm` level, is equivalent to the completion of the litter map for `\u03c0`, `A`, and `L`. This theorem demonstrates the consistency and commutativity of the `\u03b2`-structural approximation and its completion, ensuring that the construction of the natural numbers in ConNF is mathematically sound.", "formal_statement": "example [ConNF.Params ] [ConNF.Level] [ConNF.FOAAssumptions] {\u03b2 : ConNF.\u039b} [ConNF.LeLevel \u2191\u03b2] [ConNF.StructApprox.FreedomOfActionHypothesis \u03b2] {\u03c0 : ConNF.StructApprox \u2191\u03b2} (h\u03c0f : ConNF.StructApprox.Free \u03c0) (A : ConNF.ExtendedIndex \u2191\u03b2) (L : ConNF.Litter) :ConNF.StructApprox.completeNearLitterPerm h\u03c0f A \u2022 L = ConNF.StructApprox.completeLitterMap \u03c0 A L := by sorry", "full_tactic_state": "inst\u271d\u2074 : ConNF.Params\ninst\u271d\u00b3 : ConNF.Level\ninst\u271d\u00b2 : ConNF.FOAAssumptions\n\u03b2 : ConNF.\u039b\ninst\u271d\u00b9 : ConNF.LeLevel \u2191\u03b2\ninst\u271d : ConNF.StructApprox.FreedomOfActionHypothesis \u03b2\n\u03c0 : ConNF.StructApprox \u2191\u03b2\nh\u03c0f : ConNF.StructApprox.Free \u03c0\nA : ConNF.ExtendedIndex \u2191\u03b2\nL : ConNF.Litter\n\u22a2 ConNF.StructApprox.completeNearLitterPerm h\u03c0f A \u2022 L = ConNF.StructApprox.completeLitterMap \u03c0 A L", "dependency": [1, 402, 779, 781, 782, 61, 789, 787]}, "ConNF.StructApprox.completeNearLitterPerm_smul_nearLitter": {"natural_language_statement": "In the context of Constructive Ordinal Notation (ConNF), the theorem `ConNF.StructApprox.completeNearLitterPerm_smul_nearLitter` states that for any free `\u03b2`-structural approximation `\u03c0`, any `\u03b2`-extended index `A`, and any near-litter `N`, the action of the near-litter permutation `ConNF.StructApprox.completeNearLitterPerm h\u03c0f A` on `N` is equal to the near-litter map `ConNF.StructApprox.completeNearLitterMap \u03c0 A N`.", "formal_statement": "example [ConNF.Params ] [ConNF.Level] [ConNF.FOAAssumptions] {\u03b2 : ConNF.\u039b} [ConNF.LeLevel \u2191\u03b2] [ConNF.StructApprox.FreedomOfActionHypothesis \u03b2] {\u03c0 : ConNF.StructApprox \u2191\u03b2} (h\u03c0f : ConNF.StructApprox.Free \u03c0) (A : ConNF.ExtendedIndex \u2191\u03b2) (N : ConNF.NearLitter) :ConNF.StructApprox.completeNearLitterPerm h\u03c0f A \u2022 N = ConNF.StructApprox.completeNearLitterMap \u03c0 A N := by sorry", "full_tactic_state": "inst\u271d\u2074 : ConNF.Params\ninst\u271d\u00b3 : ConNF.Level\ninst\u271d\u00b2 : ConNF.FOAAssumptions\n\u03b2 : ConNF.\u039b\ninst\u271d\u00b9 : ConNF.LeLevel \u2191\u03b2\ninst\u271d : ConNF.StructApprox.FreedomOfActionHypothesis \u03b2\n\u03c0 : ConNF.StructApprox \u2191\u03b2\nh\u03c0f : ConNF.StructApprox.Free \u03c0\nA : ConNF.ExtendedIndex \u2191\u03b2\nN : ConNF.NearLitter\n\u22a2 ConNF.StructApprox.completeNearLitterPerm h\u03c0f A \u2022 N = ConNF.StructApprox.completeNearLitterMap \u03c0 A N", "dependency": [1, 402, 779, 781, 782, 61, 789, 792]}, "ConNF.StructApprox.ofBot_toStructPerm": {"natural_language_statement": "In the context of Constructive Ordinal Notation (ConNF), the theorem `ConNF.StructApprox.ofBot_toStructPerm` states that the `ConNF.Tree.ofBot` function, when applied to the result of the `ConNF.Allowable.toStructPerm` function, returns the original `ConNF.Allowable` object.", "formal_statement": "@[simp]example [ConNF.Params ] (\u03c0 : ConNF.Allowable \u22a5 ) :ConNF.Tree.ofBot (ConNF.Allowable.toStructPerm \u03c0) = \u03c0 := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03c0 : ConNF.Allowable \u22a5\n\u22a2 ConNF.Tree.ofBot (ConNF.Allowable.toStructPerm \u03c0) = \u03c0", "dependency": [1]}, "ConNF.StructApprox.allowableBelow_bot": {"natural_language_statement": "In the context of Constructive Ordinal Notation (ConNF), the theorem `ConNF.StructApprox.allowableBelow_bot` states that for any free `\u03b2`-structural approximation `\u03c0` and any `\u03b2`-extended index `A`, there exists an allowable permutation `\u03c1` such that for every `\u03b2`-extended index `B`, the complete near-litter permutation of `\u03c0` applied to `B` is equal to the composition of `B` with `\u03c1`.", "formal_statement": "example [ConNF.Params ] [ConNF.Level] [ConNF.FOAAssumptions] {\u03b2 : ConNF.\u039b} [ConNF.LeLevel \u2191\u03b2] [ConNF.StructApprox.FreedomOfActionHypothesis \u03b2] {\u03c0 : ConNF.StructApprox \u2191\u03b2} (h\u03c0f : ConNF.StructApprox.Free \u03c0) (A : ConNF.ExtendedIndex \u2191\u03b2) :ConNF.StructApprox.AllowableBelow h\u03c0f \u22a5 A := by sorry", "full_tactic_state": "inst\u271d\u2074 : ConNF.Params\ninst\u271d\u00b3 : ConNF.Level\ninst\u271d\u00b2 : ConNF.FOAAssumptions\n\u03b2 : ConNF.\u039b\ninst\u271d\u00b9 : ConNF.LeLevel \u2191\u03b2\ninst\u271d : ConNF.StructApprox.FreedomOfActionHypothesis \u03b2\n\u03c0 : ConNF.StructApprox \u2191\u03b2\nh\u03c0f : ConNF.StructApprox.Free \u03c0\nA : ConNF.ExtendedIndex \u2191\u03b2\n\u22a2 ConNF.StructApprox.AllowableBelow h\u03c0f \u22a5 A", "dependency": [1, 402, 779, 781, 782, 61, 795]}, "ConNF.StructApprox.exists_nil_cons_of_path'": {"natural_language_statement": "The theorem `ConNF.StructApprox.exists_nil_cons_of_path'` states that for any non-trivial path `A` from vertex `\u03b2` to vertex `\u03b3` in a quiver, there exists a vertex `\u03b4` less than `\u03b2` and a path `B` from `\u03b4` to `\u03b3` such that `A` is the composition of a trivial path from `\u03b2` to `\u03b4` and `B`.", "formal_statement": "example [ConNF.Params ] {\u03b2 : ConNF.TypeIndex} {\u03b3 : ConNF.TypeIndex} (A : Quiver.Path \u03b2 \u03b3) (hA : Quiver.Path.length A \u2260 0) :\u2203 (\u03b4 : ConNF.TypeIndex) (h : \u03b4 < \u03b2) (B : Quiver.Path \u03b4 \u03b3), A = Quiver.Path.comp (Quiver.Path.cons Quiver.Path.nil h) B := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03b2 \u03b3 : ConNF.TypeIndex\nA : Quiver.Path \u03b2 \u03b3\nhA : Quiver.Path.length A \u2260 0\n\u22a2 \u2203 \u03b4, \u2203 (h : \u03b4 < \u03b2), \u2203 B, A = Quiver.Path.comp (Quiver.Path.cons Quiver.Path.nil h) B", "dependency": [1, 76, 137, 76, 135, 301]}, "ConNF.StructApprox.exists_nil_cons_of_path": {"natural_language_statement": "Given the `ConNF.Params` class and the `ConNF.Level` instance in the context of Constructive Ordinal Notation (ConNF), for any `\u03b2` which is less than or equal to the level `\u03b1`, and given a finite path `A` from `\u03b2` to the base type `\u22a5`, there exists a type index `\u03b3` which is strictly less than `\u03b2`, and a finite path `B` from `\u03b3` to `\u22a5` such that `A` can be decomposed into a single step from `\u03b2` to `\u03b3` followed by the path `B`. This theorem is central to understanding the construction of natural numbers in the context of ConNF, as it shows how paths can be broken down into individual steps and combined to form larger paths.", "formal_statement": "example [ConNF.Params ] [ConNF.Level] {\u03b2 : ConNF.\u039b} [ConNF.LeLevel \u2191\u03b2] (A : ConNF.ExtendedIndex \u2191\u03b2) :\u2203 (\u03b3 : ConNF.TypeIndex) (_ : ConNF.LtLevel \u03b3) (h : \u03b3 < \u2191\u03b2) (B : ConNF.ExtendedIndex \u03b3), A = Quiver.Path.comp (Quiver.Path.cons Quiver.Path.nil h) B := by sorry", "full_tactic_state": "inst\u271d\u00b2 : ConNF.Params\ninst\u271d\u00b9 : ConNF.Level\n\u03b2 : ConNF.\u039b\ninst\u271d : ConNF.LeLevel \u2191\u03b2\nA : ConNF.ExtendedIndex \u2191\u03b2\n\u22a2 \u2203 \u03b3, \u2203 (_ : ConNF.LtLevel \u03b3) (h : \u03b3 < \u2191\u03b2), \u2203 B, A = Quiver.Path.comp (Quiver.Path.cons Quiver.Path.nil h) B", "dependency": [1, 402, 61, 98, 61, 135, 301]}, "ConNF.StructApprox.completeAllowable_comp": {"natural_language_statement": "In the context of Constructive Ordinal Notation (ConNF), the theorem `ConNF.StructApprox.completeAllowable_comp` states that for any free `\u03b2`-structural approximation `\u03c0`, the `\u03b2`-allowable permutation `ConNF.Allowable.toStructPerm (ConNF.StructApprox.completeAllowable h\u03c0f)` is equal to the `\u03b2`-near-litter permutation `ConNF.StructApprox.completeNearLitterPerm h\u03c0f`.", "formal_statement": "example [ConNF.Params ] [ConNF.Level] [ConNF.FOAAssumptions] {\u03b2 : ConNF.\u039b} [ConNF.LeLevel \u2191\u03b2] [ConNF.StructApprox.FreedomOfActionHypothesis \u03b2] {\u03c0 : ConNF.StructApprox \u2191\u03b2} (h\u03c0f : ConNF.StructApprox.Free \u03c0) :ConNF.Allowable.toStructPerm (ConNF.StructApprox.completeAllowable h\u03c0f) = ConNF.StructApprox.completeNearLitterPerm h\u03c0f := by sorry", "full_tactic_state": "inst\u271d\u2074 : ConNF.Params\ninst\u271d\u00b3 : ConNF.Level\ninst\u271d\u00b2 : ConNF.FOAAssumptions\n\u03b2 : ConNF.\u039b\ninst\u271d\u00b9 : ConNF.LeLevel \u2191\u03b2\ninst\u271d : ConNF.StructApprox.FreedomOfActionHypothesis \u03b2\n\u03c0 : ConNF.StructApprox \u2191\u03b2\nh\u03c0f : ConNF.StructApprox.Free \u03c0\n\u22a2 ConNF.Allowable.toStructPerm (ConNF.StructApprox.completeAllowable h\u03c0f) =\n    ConNF.StructApprox.completeNearLitterPerm h\u03c0f", "dependency": [1, 402, 779, 781, 782, 799, 789]}, "ConNF.StructApprox.complete_exception_mem": {"natural_language_statement": "The theorem `ConNF.StructApprox.complete_exception_mem` states that if `\u03c0` is a free `\u03b2`-structural approximation, `A` is a `\u03b2`-extended index, and `a` is an atom such that the near litter permutation `ConNF.StructApprox.completeNearLitterPerm h\u03c0f A` is an exception with respect to `a`, then `a` is a member of the domain of the atom permutation of `\u03c0 A`.", "formal_statement": "example [ConNF.Params ] [ConNF.Level] [ConNF.FOAAssumptions] {\u03b2 : ConNF.\u039b} [ConNF.LeLevel \u2191\u03b2] [ConNF.StructApprox.FreedomOfActionHypothesis \u03b2] {\u03c0 : ConNF.StructApprox \u2191\u03b2} (h\u03c0f : ConNF.StructApprox.Free \u03c0) (A : ConNF.ExtendedIndex \u2191\u03b2) (a : ConNF.Atom) (ha : ConNF.NearLitterPerm.IsException (ConNF.StructApprox.completeNearLitterPerm h\u03c0f A) a) :a \u2208 (\u03c0 A).atomPerm.domain := by sorry", "full_tactic_state": "inst\u271d\u2074 : ConNF.Params\ninst\u271d\u00b3 : ConNF.Level\ninst\u271d\u00b2 : ConNF.FOAAssumptions\n\u03b2 : ConNF.\u039b\ninst\u271d\u00b9 : ConNF.LeLevel \u2191\u03b2\ninst\u271d : ConNF.StructApprox.FreedomOfActionHypothesis \u03b2\n\u03c0 : ConNF.StructApprox \u2191\u03b2\nh\u03c0f : ConNF.StructApprox.Free \u03c0\nA : ConNF.ExtendedIndex \u2191\u03b2\na : ConNF.Atom\nha : ConNF.NearLitterPerm.IsException (ConNF.StructApprox.completeNearLitterPerm h\u03c0f A) a\n\u22a2 a \u2208 (\u03c0 A).atomPerm.domain", "dependency": [1, 402, 779, 781, 782, 61, 801, 789]}, "ConNF.StructApprox.completeAllowable_exactlyApproximates": {"natural_language_statement": "The theorem `ConNF.StructApprox.completeAllowable_exactlyApproximates` states that for any free `\u03b2`-structural approximation `\u03c0`, the `\u03b2`-allowable permutation `ConNF.Allowable.toStructPerm (ConNF.StructApprox.completeAllowable h\u03c0f)` exactly approximates `\u03c0`.", "formal_statement": "example [ConNF.Params ] [ConNF.Level] [ConNF.FOAAssumptions] {\u03b2 : ConNF.\u039b} [ConNF.LeLevel \u2191\u03b2] [ConNF.StructApprox.FreedomOfActionHypothesis \u03b2] {\u03c0 : ConNF.StructApprox \u2191\u03b2} (h\u03c0f : ConNF.StructApprox.Free \u03c0) :ConNF.StructApprox.ExactlyApproximates \u03c0 (ConNF.Allowable.toStructPerm (ConNF.StructApprox.completeAllowable h\u03c0f)) := by sorry", "full_tactic_state": "inst\u271d\u2074 : ConNF.Params\ninst\u271d\u00b3 : ConNF.Level\ninst\u271d\u00b2 : ConNF.FOAAssumptions\n\u03b2 : ConNF.\u039b\ninst\u271d\u00b9 : ConNF.LeLevel \u2191\u03b2\ninst\u271d : ConNF.StructApprox.FreedomOfActionHypothesis \u03b2\n\u03c0 : ConNF.StructApprox \u2191\u03b2\nh\u03c0f : ConNF.StructApprox.Free \u03c0\n\u22a2 ConNF.StructApprox.ExactlyApproximates \u03c0 (ConNF.Allowable.toStructPerm (ConNF.StructApprox.completeAllowable h\u03c0f))", "dependency": [1, 402, 779, 781, 782, 803, 799]}, "ConNF.StructApprox.freedom_of_action": {"natural_language_statement": "Given a `\u03b2`-structural approximation `\u03c0\u2080` that is free, there exists a `\u03b2`-structural permutation `\u03c0` such that `\u03c0\u2080` exactly approximates `\u03c0`.", "formal_statement": "example [ConNF.Params ] [ConNF.Level] [ConNF.FOAAssumptions] {\u03b2 : ConNF.\u039b} [i : ConNF.LeLevel \u2191\u03b2] (\u03c0\u2080 : ConNF.StructApprox \u2191\u03b2) (h : ConNF.StructApprox.Free \u03c0\u2080) :\u2203 (\u03c0 : ConNF.Allowable \u2191\u03b2), ConNF.StructApprox.ExactlyApproximates \u03c0\u2080 (ConNF.Allowable.toStructPerm \u03c0) := by sorry", "full_tactic_state": "inst\u271d\u00b2 : ConNF.Params\ninst\u271d\u00b9 : ConNF.Level\ninst\u271d : ConNF.FOAAssumptions\n\u03b2 : ConNF.\u039b\ni : ConNF.LeLevel \u2191\u03b2\n\u03c0\u2080 : ConNF.StructApprox \u2191\u03b2\nh : ConNF.StructApprox.Free \u03c0\u2080\n\u22a2 \u2203 \u03c0, ConNF.StructApprox.ExactlyApproximates \u03c0\u2080 (ConNF.Allowable.toStructPerm \u03c0)", "dependency": [1, 402, 781, 782, 803]}, "ConNF.NearLitterAction.approximates_iff": {"natural_language_statement": "The theorem `ConNF.NearLitterAction.approximates_iff` states that a near-litter action `\u03c8` approximates a near-litter permutation `\u03c0` if and only if the action of `\u03c0` on atoms and litters is consistent with the mapping provided by `\u03c8`.", "formal_statement": "example [ConNF.Params ] (\u03c8 : ConNF.NearLitterAction) (\u03c0 : ConNF.NearLitterPerm) :ConNF.NearLitterAction.Approximates \u03c8 \u03c0 \u2194 (\u2200 (a : ConNF.Atom) (h : (\u03c8.atomMap a).Dom), \u03c0 \u2022 a = (\u03c8.atomMap a).get h) \u2227 \u2200 (L : ConNF.Litter) (h : (\u03c8.litterMap L).Dom), \u03c0 \u2022 ConNF.Litter.toNearLitter L = (\u03c8.litterMap L).get h := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03c8 : ConNF.NearLitterAction\n\u03c0 : ConNF.NearLitterPerm\n\u22a2 ConNF.NearLitterAction.Approximates \u03c8 \u03c0 \u2194\n    (\u2200 (a : ConNF.Atom) (h : (\u03c8.atomMap a).Dom), \u03c0 \u2022 a = (\u03c8.atomMap a).get h) \u2227\n      \u2200 (L : ConNF.Litter) (h : (\u03c8.litterMap L).Dom), \u03c0 \u2022 ConNF.Litter.toNearLitter L = (\u03c8.litterMap L).get h", "dependency": [1, 806, 483]}, "ConNF.StructAction.foaMotive_atom": {"natural_language_statement": "This theorem is a part of the Constructive Ordinal Notation (ConNF) project. It is used to prove that for any \u03b2-structural action \u03c8 that is lawful, a \u03b2-structural approximation derived from \u03c8 exactly approximates a \u03b2-structural permutation \u03c1 if and only if for every \u03b2-extended index A, the near-litter approximation derived from \u03c8 exactly approximates the near-litter permutation derived from \u03c1. A key step in this proof involves showing that for any atom a that is in the domain of the atom map of \u03c8 at A, the application of \u03c1 at A to a is equal to the value of the atom map of \u03c8 at A at a.", "formal_statement": "example [ConNF.Params ] [ConNF.Level] [ConNF.FOAAssumptions] {\u03b2 : ConNF.\u039b} [ConNF.LeLevel \u2191\u03b2] (\u03c8 : ConNF.StructAction \u2191\u03b2) (h\u2081 : ConNF.StructAction.Lawful \u03c8) (\u03c1 : ConNF.Allowable \u2191\u03b2) (h\u03c1 : ConNF.StructApprox.ExactlyApproximates (ConNF.StructAction.rc \u03c8 h\u2081) (ConNF.Allowable.toStructPerm \u03c1)) (A : ConNF.ExtendedIndex \u2191\u03b2) (a : ConNF.Atom) (ha : ((\u03c8 A).atomMap a).Dom) :ConNF.Allowable.toStructPerm \u03c1 A \u2022 a = ((\u03c8 A).atomMap a).get ha := by sorry", "full_tactic_state": "inst\u271d\u00b3 : ConNF.Params\ninst\u271d\u00b2 : ConNF.Level\ninst\u271d\u00b9 : ConNF.FOAAssumptions\n\u03b2 : ConNF.\u039b\ninst\u271d : ConNF.LeLevel \u2191\u03b2\n\u03c8 : ConNF.StructAction \u2191\u03b2\nh\u2081 : ConNF.StructAction.Lawful \u03c8\n\u03c1 : ConNF.Allowable \u2191\u03b2\nh\u03c1 : ConNF.StructApprox.ExactlyApproximates (ConNF.StructAction.rc \u03c8 h\u2081) (ConNF.Allowable.toStructPerm \u03c1)\nA : ConNF.ExtendedIndex \u2191\u03b2\na : ConNF.Atom\nha : ((\u03c8 A).atomMap a).Dom\n\u22a2 ConNF.Allowable.toStructPerm \u03c1 A \u2022 a = ((\u03c8 A).atomMap a).get ha", "dependency": [1, 402, 808, 809, 803, 810, 61]}, "ConNF.StructAction.foaMotive_litter": {"natural_language_statement": "In the context of Constructive Ordinal Notation (ConNF), given a `\u03b2`-structural action `\u03c8` that is lawful and coherent, an allowable `\u03c1`, and a `\u03b2`-extended index `A`, a litter `L`, and a proof `hL` that `L` is in the domain of the litter map of `\u03c8` applied to `A`, if `L` is a flexible litter, then `((\u03c8 A).litterMap L).get hL` is also a flexible litter. Additionally, it provides conditions for the domains of the `atomMap` and `litterMap` functions of `\u03c8`, ensuring that these functions are defined for all necessary inputs.", "formal_statement": "example [ConNF.Params ] [ConNF.Level] [ConNF.FOAAssumptions] {\u03b2 : ConNF.\u039b} [ConNF.LeLevel \u2191\u03b2] (\u03c8 : ConNF.StructAction \u2191\u03b2) (h\u2081 : ConNF.StructAction.Lawful \u03c8) (h\u2082 : ConNF.StructAction.Coherent \u03c8) (\u03c1 : ConNF.Allowable \u2191\u03b2) (h\u03c1 : ConNF.StructApprox.ExactlyApproximates (ConNF.StructAction.rc \u03c8 h\u2081) (ConNF.Allowable.toStructPerm \u03c1)) (A : ConNF.ExtendedIndex \u2191\u03b2) (L : ConNF.Litter) (ih : \u2200 c < { path := A, value := Sum.inr (ConNF.Litter.toNearLitter L) }, ConNF.StructAction.FOAMotive \u03c8 \u03c1 c) (hL : ((\u03c8 A).litterMap L).Dom) :ConNF.Allowable.toStructPerm \u03c1 A \u2022 L = (((\u03c8 A).litterMap L).get hL).fst := by sorry", "full_tactic_state": "inst\u271d\u00b3 : ConNF.Params\ninst\u271d\u00b2 : ConNF.Level\ninst\u271d\u00b9 : ConNF.FOAAssumptions\n\u03b2 : ConNF.\u039b\ninst\u271d : ConNF.LeLevel \u2191\u03b2\n\u03c8 : ConNF.StructAction \u2191\u03b2\nh\u2081 : ConNF.StructAction.Lawful \u03c8\nh\u2082 : ConNF.StructAction.Coherent \u03c8\n\u03c1 : ConNF.Allowable \u2191\u03b2\nh\u03c1 : ConNF.StructApprox.ExactlyApproximates (ConNF.StructAction.rc \u03c8 h\u2081) (ConNF.Allowable.toStructPerm \u03c1)\nA : ConNF.ExtendedIndex \u2191\u03b2\nL : ConNF.Litter\nih : \u2200 c < { path := A, value := Sum.inr (ConNF.Litter.toNearLitter L) }, ConNF.StructAction.FOAMotive \u03c8 \u03c1 c\nhL : ((\u03c8 A).litterMap L).Dom\n\u22a2 ConNF.Allowable.toStructPerm \u03c1 A \u2022 L = (((\u03c8 A).litterMap L).get hL).fst", "dependency": [1, 402, 808, 809, 812, 803, 810, 61, 65, 483, 816]}, "ConNF.StructAction.foaMotive_nearLitter": {"natural_language_statement": "The theorem `ConNF.StructAction.foaMotive_nearLitter` is a part of the formalization of Constructive Ordinal Notation (ConNF) in Lean 4. It states that for any `\u03b2`-structural action `\u03c8` that is lawful and coherent, any allowable `\u03c1`, any `\u03b2`-extended index `A`, any litter `L`, and any proof `hL` that `L` is in the domain of the litter map of `\u03c8` applied to `A`, if `L` is a flexible litter, then `((\u03c8 A).litterMap L).get hL` is also a flexible litter. Additionally, it provides conditions for the domains of the `atomMap` and `litterMap` functions of `\u03c8`, ensuring that these functions are defined for all necessary inputs.", "formal_statement": "example [ConNF.Params ] [ConNF.Level] [ConNF.FOAAssumptions] {\u03b2 : ConNF.\u039b} [ConNF.LeLevel \u2191\u03b2] (\u03c8 : ConNF.StructAction \u2191\u03b2) (h\u2081 : ConNF.StructAction.Lawful \u03c8) (h\u2082 : ConNF.StructAction.Coherent \u03c8) (\u03c1 : ConNF.Allowable \u2191\u03b2) (h\u03c1 : ConNF.StructApprox.ExactlyApproximates (ConNF.StructAction.rc \u03c8 h\u2081) (ConNF.Allowable.toStructPerm \u03c1)) (A : ConNF.ExtendedIndex \u2191\u03b2) (L : ConNF.Litter) (ih : \u2200 c < { path := A, value := Sum.inr (ConNF.Litter.toNearLitter L) }, ConNF.StructAction.FOAMotive \u03c8 \u03c1 c) (hL : ((\u03c8 A).litterMap L).Dom) :ConNF.Allowable.toStructPerm \u03c1 A \u2022 ConNF.Litter.toNearLitter L = ((\u03c8 A).litterMap L).get hL := by sorry", "full_tactic_state": "inst\u271d\u00b3 : ConNF.Params\ninst\u271d\u00b2 : ConNF.Level\ninst\u271d\u00b9 : ConNF.FOAAssumptions\n\u03b2 : ConNF.\u039b\ninst\u271d : ConNF.LeLevel \u2191\u03b2\n\u03c8 : ConNF.StructAction \u2191\u03b2\nh\u2081 : ConNF.StructAction.Lawful \u03c8\nh\u2082 : ConNF.StructAction.Coherent \u03c8\n\u03c1 : ConNF.Allowable \u2191\u03b2\nh\u03c1 : ConNF.StructApprox.ExactlyApproximates (ConNF.StructAction.rc \u03c8 h\u2081) (ConNF.Allowable.toStructPerm \u03c1)\nA : ConNF.ExtendedIndex \u2191\u03b2\nL : ConNF.Litter\nih : \u2200 c < { path := A, value := Sum.inr (ConNF.Litter.toNearLitter L) }, ConNF.StructAction.FOAMotive \u03c8 \u03c1 c\nhL : ((\u03c8 A).litterMap L).Dom\n\u22a2 ConNF.Allowable.toStructPerm \u03c1 A \u2022 ConNF.Litter.toNearLitter L = ((\u03c8 A).litterMap L).get hL", "dependency": [1, 402, 808, 809, 812, 803, 810, 61, 65, 483, 816, 483]}, "ConNF.StructAction.freedom_of_action": {"natural_language_statement": "The theorem `ConNF.StructAction.freedom_of_action` asserts that, under the Constructive Ordinal Notation (ConNF) framework, given a `\u03b2`-structural action `\u03c8` and certain conditions such as lawfulness and coherence, there exists a `\u03b2`-allowable permutation `\u03c1` that approximates `\u03c8`. This theorem is a key step in proving the 'Freedom of Action' property, which is crucial for ConNF's construction of the natural numbers.", "formal_statement": "example [ConNF.Params ] [ConNF.Level] [ConNF.FOAAssumptions] {\u03b2 : ConNF.\u039b} [ConNF.LeLevel \u2191\u03b2] (\u03c8 : ConNF.StructAction \u2191\u03b2) (h\u2081 : ConNF.StructAction.Lawful \u03c8) (h\u2082 : ConNF.StructAction.Coherent \u03c8) :\u2203 (\u03c1 : ConNF.Allowable \u2191\u03b2), ConNF.StructAction.Approximates \u03c8 (ConNF.Allowable.toStructPerm \u03c1) := by sorry", "full_tactic_state": "inst\u271d\u00b3 : ConNF.Params\ninst\u271d\u00b2 : ConNF.Level\ninst\u271d\u00b9 : ConNF.FOAAssumptions\n\u03b2 : ConNF.\u039b\ninst\u271d : ConNF.LeLevel \u2191\u03b2\n\u03c8 : ConNF.StructAction \u2191\u03b2\nh\u2081 : ConNF.StructAction.Lawful \u03c8\nh\u2082 : ConNF.StructAction.Coherent \u03c8\n\u22a2 \u2203 \u03c1, ConNF.StructAction.Approximates \u03c8 (ConNF.Allowable.toStructPerm \u03c1)", "dependency": [1, 402, 808, 809, 812, 819]}, "ConNF.NearLitterBehaviour.approximates_iff": {"natural_language_statement": "The theorem `ConNF.NearLitterBehaviour.approximates_iff` states that a `ConNF.NearLitterBehaviour` object `\u03be` approximates a `ConNF.NearLitterPerm` object `\u03c0` if and only if for any `ConNF.Atom` `a` such that `\u03be.atomMap a` is defined, the action of `\u03c0` on `a` is equal to the value of `\u03be.atomMap a`, and for any `ConNF.NearLitter` `N` such that `\u03be.nearLitterMap N` is defined, the action of `\u03c0` on `N` is equal to the value of `\u03be.nearLitterMap N`.", "formal_statement": "example [ConNF.Params ] (\u03be : ConNF.NearLitterBehaviour) (\u03c0 : ConNF.NearLitterPerm) :ConNF.NearLitterBehaviour.Approximates \u03be \u03c0 \u2194 (\u2200 (a : ConNF.Atom) (h : (\u03be.atomMap a).Dom), \u03c0 \u2022 a = (\u03be.atomMap a).get h) \u2227 \u2200 (N : ConNF.NearLitter) (h : (\u03be.nearLitterMap N).Dom), \u03c0 \u2022 N = (\u03be.nearLitterMap N).get h := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03be : ConNF.NearLitterBehaviour\n\u03c0 : ConNF.NearLitterPerm\n\u22a2 ConNF.NearLitterBehaviour.Approximates \u03be \u03c0 \u2194\n    (\u2200 (a : ConNF.Atom) (h : (\u03be.atomMap a).Dom), \u03c0 \u2022 a = (\u03be.atomMap a).get h) \u2227\n      \u2200 (N : ConNF.NearLitter) (h : (\u03be.nearLitterMap N).Dom), \u03c0 \u2022 N = (\u03be.nearLitterMap N).get h", "dependency": [1, 821]}, "ConNF.NearLitterBehaviour.action_lawful": {"natural_language_statement": "Given a lawful near-litter-behaviour in the context of Constructive Ordinal Notation (ConNF), the function `ConNF.NearLitterBehaviour.action` constructs a lawful near-litter-action, ensuring that the atom and litter maps are injective and that the images of atoms in litters are mapped to atoms inside the corresponding near-litters.", "formal_statement": "example [ConNF.Params ] (\u03be : ConNF.NearLitterBehaviour) (h\u03be : ConNF.NearLitterBehaviour.Lawful \u03be) :ConNF.NearLitterAction.Lawful (ConNF.NearLitterBehaviour.action \u03be h\u03be) := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03be : ConNF.NearLitterBehaviour\nh\u03be : ConNF.NearLitterBehaviour.Lawful \u03be\n\u22a2 ConNF.NearLitterAction.Lawful (ConNF.NearLitterBehaviour.action \u03be h\u03be)", "dependency": [1, 823, 825, 826]}, "ConNF.StructBehaviour.action_lawful": {"natural_language_statement": "The theorem `ConNF.StructBehaviour.action_lawful` states that if `\u03be` is a lawful `\u03b2`-structural action, then the `\u03b2`-structural action `ConNF.StructBehaviour.action \u03be h\u03be` is also lawful. A `\u03b2`-structural action is a product that assigns a near-litter action to each `\u03b2`-extended index. For `\u03be` to be lawful, it must satisfy the condition that for every `\u03b2`-extended index `A`, the near-litter action assigned by `\u03be` to `A` is lawful. A near-litter action is lawful if it satisfies certain properties, such as being order-preserving and respecting the structure of the near-litter.", "formal_statement": "example [ConNF.Params ] {\u03b2 : ConNF.\u039b} (\u03be : ConNF.StructBehaviour \u2191\u03b2) (h\u03be : ConNF.StructBehaviour.Lawful \u03be) :ConNF.StructAction.Lawful (ConNF.StructBehaviour.action \u03be h\u03be) := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03b2 : ConNF.\u039b\n\u03be : ConNF.StructBehaviour \u2191\u03b2\nh\u03be : ConNF.StructBehaviour.Lawful \u03be\n\u22a2 ConNF.StructAction.Lawful (ConNF.StructBehaviour.action \u03be h\u03be)", "dependency": [1, 828, 829, 809, 830]}, "ConNF.NearLitterBehaviour.action_atomMap": {"natural_language_statement": "The theorem `ConNF.NearLitterBehaviour.action_atomMap` states that the atom map of the lawful near-litter-action `ConNF.NearLitterBehaviour.action \u03be h\u03be` is equal to the atom map of the modified near-litter-behaviour `ConNF.NearLitterBehaviour.withLitters \u03be h\u03be`.", "formal_statement": "@[simp]example [ConNF.Params ] (\u03be : ConNF.NearLitterBehaviour) (h\u03be : ConNF.NearLitterBehaviour.Lawful \u03be) :(ConNF.NearLitterBehaviour.action \u03be h\u03be).atomMap = (ConNF.NearLitterBehaviour.withLitters \u03be h\u03be).atomMap := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03be : ConNF.NearLitterBehaviour\nh\u03be : ConNF.NearLitterBehaviour.Lawful \u03be\n\u22a2 (ConNF.NearLitterBehaviour.action \u03be h\u03be).atomMap = (ConNF.NearLitterBehaviour.withLitters \u03be h\u03be).atomMap", "dependency": [1, 823, 826, 832]}, "ConNF.NearLitterBehaviour.action_litterMap": {"natural_language_statement": "The `ConNF.NearLitterBehaviour.action_litterMap` theorem states that the litter map of the lawful near-litter-action constructed from a lawful near-litter-behaviour `\u03be` is equal to the near-litter map of the modified near-litter-behaviour `ConNF.NearLitterBehaviour.withLitters \u03be h\u03be` applied to the near-litter formed by wrapping a litter `L` with its own litter set.", "formal_statement": "@[simp]example [ConNF.Params ] (\u03be : ConNF.NearLitterBehaviour) (h\u03be : ConNF.NearLitterBehaviour.Lawful \u03be) :(ConNF.NearLitterBehaviour.action \u03be h\u03be).litterMap = fun (L : ConNF.Litter) => (ConNF.NearLitterBehaviour.withLitters \u03be h\u03be).nearLitterMap (ConNF.Litter.toNearLitter L) := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03be : ConNF.NearLitterBehaviour\nh\u03be : ConNF.NearLitterBehaviour.Lawful \u03be\n\u22a2 (ConNF.NearLitterBehaviour.action \u03be h\u03be).litterMap = fun L =>\n    (ConNF.NearLitterBehaviour.withLitters \u03be h\u03be).nearLitterMap (ConNF.Litter.toNearLitter L)", "dependency": [1, 823, 826, 832, 483]}, "ConNF.NearLitterBehaviour.action_approximates": {"natural_language_statement": "The theorem `ConNF.NearLitterBehaviour.action_approximates` states that if `\u03be` is a lawful near-litter-behaviour and `\u03c0` is a near-litter-permutation that approximates the near-litter-action derived from `\u03be`, then `\u03be` approximates `\u03c0` in the sense that the action of `\u03c0` on atoms and litters is consistent with the mapping provided by `\u03be`.", "formal_statement": "example [ConNF.Params ] (\u03be : ConNF.NearLitterBehaviour) (h\u03be : ConNF.NearLitterBehaviour.Lawful \u03be) (\u03c0 : ConNF.NearLitterPerm) (h : ConNF.NearLitterAction.Approximates (ConNF.NearLitterBehaviour.action \u03be h\u03be) \u03c0) :ConNF.NearLitterBehaviour.Approximates \u03be \u03c0 := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03be : ConNF.NearLitterBehaviour\nh\u03be : ConNF.NearLitterBehaviour.Lawful \u03be\n\u03c0 : ConNF.NearLitterPerm\nh : ConNF.NearLitterAction.Approximates (ConNF.NearLitterBehaviour.action \u03be h\u03be) \u03c0\n\u22a2 ConNF.NearLitterBehaviour.Approximates \u03be \u03c0", "dependency": [1, 823, 806, 826, 821]}, "ConNF.StructBehaviour.action_approximates": {"natural_language_statement": "In the context of Constructive Ordinal Notation (ConNF), a `\u03b2`-structural action `\u03be` *approximates* a `\u03b2`-structural permutation `\u03c0` if, for every `\u03b2`-extended index `A`, the `\u03b2`-extended near-litter action `\u03be A` approximates the `\u03b2`-extended near-litter permutation `\u03c0 A`. This approximation is defined by the `ConNF.NearLitterBehaviour.Approximates` relation between near-litter actions and permutations.", "formal_statement": "example [ConNF.Params ] {\u03b2 : ConNF.\u039b} (\u03be : ConNF.StructBehaviour \u2191\u03b2) (h\u03be : ConNF.StructBehaviour.Lawful \u03be) (\u03c0 : ConNF.StructPerm \u2191\u03b2) (h : ConNF.StructAction.Approximates (ConNF.StructBehaviour.action \u03be h\u03be) \u03c0) :ConNF.StructBehaviour.Approximates \u03be \u03c0 := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03b2 : ConNF.\u039b\n\u03be : ConNF.StructBehaviour \u2191\u03b2\nh\u03be : ConNF.StructBehaviour.Lawful \u03be\n\u03c0 : ConNF.StructPerm \u2191\u03b2\nh : ConNF.StructAction.Approximates (ConNF.StructBehaviour.action \u03be h\u03be) \u03c0\n\u22a2 ConNF.StructBehaviour.Approximates \u03be \u03c0", "dependency": [1, 828, 829, 55, 819, 830, 836]}, "ConNF.NearLitterBehaviour.litterPresent_of_dom": {"natural_language_statement": "The theorem `ConNF.NearLitterBehaviour.litterPresent_of_dom` states that if there exists a near-litter `N` such that the near-litter map `\u03be.nearLitterMap N` is defined and the first component of `N` is equal to the given litter `L`, then there exists a near-litter `N` such that the near-litter map `\u03be.nearLitterMap N` is defined and the first component of `N` is equal to the given litter `L`.", "formal_statement": "example [ConNF.Params ] {\u03be : ConNF.NearLitterBehaviour} (h\u03be : ConNF.NearLitterBehaviour.Lawful \u03be) {L : ConNF.Litter} (h : ((ConNF.NearLitterBehaviour.withLitters \u03be h\u03be).nearLitterMap (ConNF.Litter.toNearLitter L)).Dom) :ConNF.NearLitterBehaviour.LitterPresent \u03be L := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03be : ConNF.NearLitterBehaviour\nh\u03be : ConNF.NearLitterBehaviour.Lawful \u03be\nL : ConNF.Litter\nh : ((ConNF.NearLitterBehaviour.withLitters \u03be h\u03be).nearLitterMap (ConNF.Litter.toNearLitter L)).Dom\n\u22a2 ConNF.NearLitterBehaviour.LitterPresent \u03be L", "dependency": [1, 823, 832, 483, 838]}, "ConNF.StructBehaviour.action_coherentDom": {"natural_language_statement": "In the context of Constructive Ordinal Notation (ConNF), a `\u03b2`-structural action is a product that assigns a near-litter action to each `\u03b2`-extended index. For a `\u03b2`-structural action `\u03be` to be lawful, it must satisfy the condition that for every `\u03b2`-extended index `A`, the near-litter action assigned by `\u03be` to `A` is lawful. A near-litter action is lawful if it satisfies certain properties, such as being order-preserving and respecting the structure of the near-litter. Additionally, a `\u03b2`-structural action is coherent if it satisfies certain conditions that ensure the construction of the natural numbers in ConNF is well-defined and consistent. The theorem `ConNF.StructBehaviour.action_coherentDom` states that if `\u03be` is a lawful and coherent `\u03b2`-structural action, then the `\u03b2`-structural action `ConNF.StructBehaviour.action \u03be h\u2081` is also coherent.", "formal_statement": "example [ConNF.Params ] [ConNF.Level] [ConNF.FOAAssumptions] {\u03b2 : ConNF.\u039b} (\u03be : ConNF.StructBehaviour \u2191\u03b2) (h\u2081 : ConNF.StructBehaviour.Lawful \u03be) (h\u2082 : ConNF.StructBehaviour.Coherent \u03be) :ConNF.StructAction.CoherentDom (ConNF.StructBehaviour.action \u03be h\u2081) := by sorry", "full_tactic_state": "inst\u271d\u00b2 : ConNF.Params\ninst\u271d\u00b9 : ConNF.Level\ninst\u271d : ConNF.FOAAssumptions\n\u03b2 : ConNF.\u039b\n\u03be : ConNF.StructBehaviour \u2191\u03b2\nh\u2081 : ConNF.StructBehaviour.Lawful \u03be\nh\u2082 : ConNF.StructBehaviour.Coherent \u03be\n\u22a2 ConNF.StructAction.CoherentDom (ConNF.StructBehaviour.action \u03be h\u2081)", "dependency": [1, 828, 829, 840, 813, 830]}, "ConNF.StructBehaviour.action_coherent": {"natural_language_statement": "The theorem `ConNF.StructBehaviour.action_coherent` states that if `\u03be` is a `\u03b2`-structural action that is lawful and coherent, then the `\u03b2`-structural action `ConNF.StructBehaviour.action \u03be h\u2081` is also coherent.", "formal_statement": "example [ConNF.Params ] [ConNF.Level] [ConNF.FOAAssumptions] {\u03b2 : ConNF.\u039b} (\u03be : ConNF.StructBehaviour \u2191\u03b2) (h\u2081 : ConNF.StructBehaviour.Lawful \u03be) (h\u2082 : ConNF.StructBehaviour.Coherent \u03be) :ConNF.StructAction.Coherent (ConNF.StructBehaviour.action \u03be h\u2081) := by sorry", "full_tactic_state": "inst\u271d\u00b2 : ConNF.Params\ninst\u271d\u00b9 : ConNF.Level\ninst\u271d : ConNF.FOAAssumptions\n\u03b2 : ConNF.\u039b\n\u03be : ConNF.StructBehaviour \u2191\u03b2\nh\u2081 : ConNF.StructBehaviour.Lawful \u03be\nh\u2082 : ConNF.StructBehaviour.Coherent \u03be\n\u22a2 ConNF.StructAction.Coherent (ConNF.StructBehaviour.action \u03be h\u2081)", "dependency": [1, 828, 829, 840, 812, 830]}, "ConNF.StructBehaviour.freedom_of_action": {"natural_language_statement": "This is the theorem that establishes the \"Freedom of Action\" in the context of Constructive Ordinal Notation (ConNF). It states that for any lawful $\\beta$-structural action $\\xi$, there exists a $\\beta$-allowable $\\beta$-structural permutation $\\rho$ such that $\\xi$ approximates $\\rho$. This theorem is crucial in ensuring the consistency and well-definedness of the construction of natural numbers in ConNF.", "formal_statement": "example [ConNF.Params ] [ConNF.Level] [ConNF.FOAAssumptions] {\u03b2 : ConNF.\u039b} [ConNF.LeLevel \u2191\u03b2] (\u03be : ConNF.StructBehaviour \u2191\u03b2) (h\u2081 : ConNF.StructBehaviour.Lawful \u03be) (h\u2082 : ConNF.StructBehaviour.Coherent \u03be) :\u2203 (\u03c1 : ConNF.Allowable \u2191\u03b2), ConNF.StructBehaviour.Approximates \u03be (ConNF.Allowable.toStructPerm \u03c1) := by sorry", "full_tactic_state": "inst\u271d\u00b3 : ConNF.Params\ninst\u271d\u00b2 : ConNF.Level\ninst\u271d\u00b9 : ConNF.FOAAssumptions\n\u03b2 : ConNF.\u039b\ninst\u271d : ConNF.LeLevel \u2191\u03b2\n\u03be : ConNF.StructBehaviour \u2191\u03b2\nh\u2081 : ConNF.StructBehaviour.Lawful \u03be\nh\u2082 : ConNF.StructBehaviour.Coherent \u03be\n\u22a2 \u2203 \u03c1, ConNF.StructBehaviour.Approximates \u03be (ConNF.Allowable.toStructPerm \u03c1)", "dependency": [1, 402, 828, 829, 840, 836]}, "ConNF.Allowable.comp_nil": {"natural_language_statement": "Function `ConNF.Allowable.comp` defines a monoid homomorphism from the set of allowable permutations at level `\u03b2` to the set of allowable permutations at level `\u03b3`, where `\u03b2` and `\u03b3` are type indices in the context of Constructive Ordinal Notation (ConNF), and `\u03b2` is less than or equal to `\u03b3`. The function is defined recursively along a path `A` from `\u03b2` to `\u03b3`. When the path `A` is empty (i.e., `Quiver.Path.nil`), the function `ConNF.Allowable.comp` simplifies to the identity monoid homomorphism `MonoidHom.id`, which maps each element to itself.", "formal_statement": "@[simp]example [ConNF.Params ] [ConNF.Level] [ConNF.FOAAssumptions] {\u03b2 : ConNF.TypeIndex} [ConNF.LeLevel \u03b2] :ConNF.Allowable.comp Quiver.Path.nil = MonoidHom.id (ConNF.Allowable \u03b2) := by sorry", "full_tactic_state": "inst\u271d\u00b3 : ConNF.Params\ninst\u271d\u00b2 : ConNF.Level\ninst\u271d\u00b9 : ConNF.FOAAssumptions\n\u03b2 : ConNF.TypeIndex\ninst\u271d : ConNF.LeLevel \u03b2\n\u22a2 ConNF.Allowable.comp Quiver.Path.nil = MonoidHom.id (ConNF.Allowable \u03b2)", "dependency": [1, 402, 815, 846]}, "ConNF.Allowable.comp_eq": {"natural_language_statement": "Function `ConNF.Allowable.comp` defines a monoid homomorphism from the set of allowable permutations at level `\u03b2` to the set of allowable permutations at level `\u03b3`, where `\u03b2` and `\u03b3` are type indices in the context of Constructive Ordinal Notation (ConNF), and `\u03b2` is less than or equal to `\u03b3`. The function is defined recursively along a path `A` from `\u03b2` to `\u03b3`. The theorem `ConNF.Allowable.comp_eq` states that when `\u03b3 < \u03b2`, the function `ConNF.allowableCons` is equal to `ConNF.Allowable.comp` applied to the path consisting of a single arrow from `\u03b3` to `\u03b2`.", "formal_statement": "@[simp]example [ConNF.Params ] [ConNF.Level] [ConNF.FOAAssumptions] {\u03b2 : ConNF.TypeIndex} {\u03b3 : ConNF.TypeIndex} [ConNF.LeLevel \u03b2] [ConNF.LeLevel \u03b3] (h : \u03b3 < \u03b2) :ConNF.allowableCons h = ConNF.Allowable.comp (Quiver.Path.cons Quiver.Path.nil h) := by sorry", "full_tactic_state": "inst\u271d\u2074 : ConNF.Params\ninst\u271d\u00b3 : ConNF.Level\ninst\u271d\u00b2 : ConNF.FOAAssumptions\n\u03b2 \u03b3 : ConNF.TypeIndex\ninst\u271d\u00b9 : ConNF.LeLevel \u03b2\ninst\u271d : ConNF.LeLevel \u03b3\nh : \u03b3 < \u03b2\n\u22a2 ConNF.allowableCons h = ConNF.Allowable.comp (Quiver.Path.cons Quiver.Path.nil h)", "dependency": [1, 402, 402, 815, 301]}, "ConNF.Allowable.comp_cons": {"natural_language_statement": "In the context of Constructive Ordinal Notation (ConNF), the function `ConNF.Allowable.comp` defines a monoid homomorphism from the set of allowable permutations at level `\u03b2` to the set of allowable permutations at level `\u03b3`, where `\u03b2` and `\u03b3` are type indices in the context of ConNF, and `\u03b2` is less than or equal to `\u03b3`. This function is defined recursively along a path `A` from `\u03b2` to `\u03b3`. The theorem `ConNF.Allowable.comp_cons` states that the composition of the monoid homomorphism `ConNF.Allowable.comp` with the monoid homomorphism `ConNF.allowableCons` is equal to the monoid homomorphism `ConNF.Allowable.comp` applied to the path `A` extended by the arrow `h`.", "formal_statement": "@[simp]example [ConNF.Params ] [ConNF.Level] [ConNF.FOAAssumptions] {\u03b2 : ConNF.TypeIndex} {\u03b3 : ConNF.TypeIndex} {\u03b4 : ConNF.TypeIndex} [ConNF.LeLevel \u03b2] [ConNF.LeLevel \u03b3] [ConNF.LeLevel \u03b4] (A : Quiver.Path \u03b2 \u03b3) (h : \u03b4 < \u03b3) :MonoidHom.comp (ConNF.allowableCons h) (ConNF.Allowable.comp A) = ConNF.Allowable.comp (Quiver.Path.cons A h) := by sorry", "full_tactic_state": "inst\u271d\u2075 : ConNF.Params\ninst\u271d\u2074 : ConNF.Level\ninst\u271d\u00b3 : ConNF.FOAAssumptions\n\u03b2 \u03b3 \u03b4 : ConNF.TypeIndex\ninst\u271d\u00b2 : ConNF.LeLevel \u03b2\ninst\u271d\u00b9 : ConNF.LeLevel \u03b3\ninst\u271d : ConNF.LeLevel \u03b4\nA : Quiver.Path \u03b2 \u03b3\nh : \u03b4 < \u03b3\n\u22a2 MonoidHom.comp (ConNF.allowableCons h) (ConNF.Allowable.comp A) = ConNF.Allowable.comp (Quiver.Path.cons A h)", "dependency": [1, 402, 402, 402, 76, 850, 815, 815, 301]}, "ConNF.Allowable.comp_cons_apply": {"natural_language_statement": "The function `ConNF.Allowable.comp` defines a monoid homomorphism from the set of allowable permutations at level `\u03b2` to the set of allowable permutations at level `\u03b3`, where `\u03b2` and `\u03b3` are type indices in the context of Constructive Ordinal Notation (ConNF), and `\u03b2` is less than or equal to `\u03b3`. The function is defined recursively along a path `A` from `\u03b2` to `\u03b3`. The theorem `ConNF.Allowable.comp_cons_apply` states that for a path `A` from `\u03b2` to `\u03b3` and an arrow `h` from `\u03b3` to `\u03b4`, the composition of `ConNF.Allowable.comp A` with `ConNF.Allowable.cons h` is equal to `ConNF.Allowable.comp (Quiver.Path.cons A h)`.", "formal_statement": "@[simp]example [ConNF.Params ] [ConNF.Level] [ConNF.FOAAssumptions] {\u03b2 : ConNF.TypeIndex} {\u03b3 : ConNF.TypeIndex} {\u03b4 : ConNF.TypeIndex} [ConNF.LeLevel \u03b2] [ConNF.LeLevel \u03b3] [ConNF.LeLevel \u03b4] (A : Quiver.Path \u03b2 \u03b3) (h : \u03b4 < \u03b3) (\u03c0 : ConNF.Allowable \u03b2) :(ConNF.allowableCons h) ((ConNF.Allowable.comp A) \u03c0) = (ConNF.Allowable.comp (Quiver.Path.cons A h)) \u03c0 := by sorry", "full_tactic_state": "inst\u271d\u2075 : ConNF.Params\ninst\u271d\u2074 : ConNF.Level\ninst\u271d\u00b3 : ConNF.FOAAssumptions\n\u03b2 \u03b3 \u03b4 : ConNF.TypeIndex\ninst\u271d\u00b2 : ConNF.LeLevel \u03b2\ninst\u271d\u00b9 : ConNF.LeLevel \u03b3\ninst\u271d : ConNF.LeLevel \u03b4\nA : Quiver.Path \u03b2 \u03b3\nh : \u03b4 < \u03b3\n\u03c0 : ConNF.Allowable \u03b2\n\u22a2 (ConNF.allowableCons h) ((ConNF.Allowable.comp A) \u03c0) = (ConNF.Allowable.comp (Quiver.Path.cons A h)) \u03c0", "dependency": [1, 402, 402, 402, 76, 815, 815, 301]}, "ConNF.Allowable.comp_comp_apply": {"natural_language_statement": "Function `ConNF.Allowable.comp` defines a monoid homomorphism from the set of allowable permutations at level `\u03b2` to the set of allowable permutations at level `\u03b3`, where `\u03b2` and `\u03b3` are type indices in the context of Constructive Ordinal Notation (ConNF), and `\u03b2` is less than or equal to `\u03b3`. The function is defined recursively along a path `A` from `\u03b2` to `\u03b3`. The theorem `ConNF.Allowable.comp_comp_apply` states that the composition of two such homomorphisms, corresponding to paths `A` and `B` respectively, is equal to the homomorphism corresponding to the composition of the paths `A` and `B`.", "formal_statement": "@[simp]example [ConNF.Params ] [ConNF.Level] [ConNF.FOAAssumptions] {\u03b2 : ConNF.TypeIndex} {\u03b3 : ConNF.TypeIndex} {\u03b4 : ConNF.TypeIndex} [ConNF.LeLevel \u03b2] [ConNF.LeLevel \u03b3] [i : ConNF.LeLevel \u03b4] (A : Quiver.Path \u03b2 \u03b3) (B : Quiver.Path \u03b3 \u03b4) (\u03c0 : ConNF.Allowable \u03b2) :(ConNF.Allowable.comp B) ((ConNF.Allowable.comp A) \u03c0) = (ConNF.Allowable.comp (Quiver.Path.comp A B)) \u03c0 := by sorry", "full_tactic_state": "inst\u271d\u2074 : ConNF.Params\ninst\u271d\u00b3 : ConNF.Level\ninst\u271d\u00b2 : ConNF.FOAAssumptions\n\u03b2 \u03b3 \u03b4 : ConNF.TypeIndex\ninst\u271d\u00b9 : ConNF.LeLevel \u03b2\ninst\u271d : ConNF.LeLevel \u03b3\ni : ConNF.LeLevel \u03b4\nA : Quiver.Path \u03b2 \u03b3\nB : Quiver.Path \u03b3 \u03b4\n\u03c0 : ConNF.Allowable \u03b2\n\u22a2 (ConNF.Allowable.comp B) ((ConNF.Allowable.comp A) \u03c0) = (ConNF.Allowable.comp (Quiver.Path.comp A B)) \u03c0", "dependency": [1, 402, 402, 402, 76, 76, 815, 815, 815, 135]}, "ConNF.Allowable.toStructPerm_comp": {"natural_language_statement": "Function `ConNF.Allowable.comp` defines a monoid homomorphism from the set of allowable permutations at level `\u03b2` to the set of allowable permutations at level `\u03b3`, where `\u03b2` and `\u03b3` are type indices in the context of Constructive Ordinal Notation (ConNF), and `\u03b2` is less than or equal to `\u03b3`. The function is defined recursively along a path `A` from `\u03b2` to `\u03b3`. Given a path `A` from type index `\u03b2` to type index `\u03b3` and an `\u03b1`-tree `a` of type `\u03c4`, it returns a `\u03b2`-tree of type `\u03c4` by applying `a` to the composition of `A` with any `\u03b2`-extended type index `B`.", "formal_statement": "@[simp]example [ConNF.Params ] [ConNF.Level] [ConNF.FOAAssumptions] {\u03b2 : ConNF.TypeIndex} {\u03b3 : ConNF.TypeIndex} [ConNF.LeLevel \u03b2] [i : ConNF.LeLevel \u03b3] (A : Quiver.Path \u03b2 \u03b3) (\u03c0 : ConNF.Allowable \u03b2) :ConNF.Allowable.toStructPerm ((ConNF.Allowable.comp A) \u03c0) = ConNF.Tree.comp A (ConNF.Allowable.toStructPerm \u03c0) := by sorry", "full_tactic_state": "inst\u271d\u00b3 : ConNF.Params\ninst\u271d\u00b2 : ConNF.Level\ninst\u271d\u00b9 : ConNF.FOAAssumptions\n\u03b2 \u03b3 : ConNF.TypeIndex\ninst\u271d : ConNF.LeLevel \u03b2\ni : ConNF.LeLevel \u03b3\nA : Quiver.Path \u03b2 \u03b3\n\u03c0 : ConNF.Allowable \u03b2\n\u22a2 ConNF.Allowable.toStructPerm ((ConNF.Allowable.comp A) \u03c0) = ConNF.Tree.comp A (ConNF.Allowable.toStructPerm \u03c0)", "dependency": [1, 402, 402, 76, 815, 304]}, "ConNF.Allowable.toStructPerm_apply": {"natural_language_statement": "The function `ConNF.Allowable.comp` defines a monoid homomorphism from the set of allowable permutations at level `\u03b2` to the set of allowable permutations at level `\u03b3`, where `\u03b2` and `\u03b3` are type indices in the context of Constructive Ordinal Notation (ConNF), and `\u03b2` is less than or equal to `\u03b3`. The function is defined recursively along a path `A` from `\u03b2` to `\u03b3`. The theorem `ConNF.Allowable.toStructPerm_apply` states that the application of the function `ConNF.Allowable.comp` to an allowable permutation `\u03c0` at level `\u03b2` and a path `A` from `\u03b2` to `\u03b3` is equal to the application of the function `ConNF.Allowable.toStructPerm` to `\u03c0` and `A`.", "formal_statement": "@[simp]example [ConNF.Params ] [ConNF.Level] [ConNF.FOAAssumptions] {\u03b2 : ConNF.TypeIndex} [ConNF.LeLevel \u03b2] (A : Quiver.Path \u03b2 \u22a5 ) (\u03c0 : ConNF.Allowable \u03b2) :NearLitterPerm.ofBot ((ConNF.Allowable.comp A) \u03c0) = ConNF.Allowable.toStructPerm \u03c0 A := by sorry", "full_tactic_state": "inst\u271d\u00b3 : ConNF.Params\ninst\u271d\u00b2 : ConNF.Level\ninst\u271d\u00b9 : ConNF.FOAAssumptions\n\u03b2 : ConNF.TypeIndex\ninst\u271d : ConNF.LeLevel \u03b2\nA : Quiver.Path \u03b2 \u22a5\n\u03c0 : ConNF.Allowable \u03b2\n\u22a2 NearLitterPerm.ofBot ((ConNF.Allowable.comp A) \u03c0) = ConNF.Allowable.toStructPerm \u03c0 A", "dependency": [1, 402, 76, 815]}, "ConNF.Allowable.comp_bot": {"natural_language_statement": "Function `ConNF.Allowable.comp` defines a monoid homomorphism from the set of allowable permutations at level `\u03b2` to the set of allowable permutations at level `\u03b3`, where `\u03b2` and `\u03b3` are type indices in the context of Constructive Ordinal Notation (ConNF), and `\u03b2` is less than or equal to `\u03b3`. The function is defined recursively along a path `A` from `\u03b2` to `\u03b3`. The theorem `ConNF.Allowable.comp_bot` states that for a path `A` from `\u03b2` to the bottom level `\u22a5`, the function `ConNF.Allowable.comp A` applied to an allowable permutation `\u03c1` at level `\u03b2` is equal to the structure permutation of `\u03c1` along the path `A`.", "formal_statement": "example [ConNF.Params ] [ConNF.Level] [ConNF.FOAAssumptions] {\u03b2 : ConNF.TypeIndex} [ConNF.LeLevel \u03b2] (A : Quiver.Path \u03b2 \u22a5 ) (\u03c1 : ConNF.Allowable \u03b2) :(ConNF.Allowable.comp A) \u03c1 = ConNF.Allowable.toStructPerm \u03c1 A := by sorry", "full_tactic_state": "inst\u271d\u00b3 : ConNF.Params\ninst\u271d\u00b2 : ConNF.Level\ninst\u271d\u00b9 : ConNF.FOAAssumptions\n\u03b2 : ConNF.TypeIndex\ninst\u271d : ConNF.LeLevel \u03b2\nA : Quiver.Path \u03b2 \u22a5\n\u03c1 : ConNF.Allowable \u03b2\n\u22a2 (ConNF.Allowable.comp A) \u03c1 = ConNF.Allowable.toStructPerm \u03c1 A", "dependency": [1, 402, 76, 815]}, "ConNF.smul_mem_support": {"natural_language_statement": "The theorem `ConNF.smul_mem_support` is a result in the context of Constructive Ordinal Notation (ConNF), which represents a specific type of ordinal notation. It states that if an element `c` is in the support of a tangle `t`, then applying a permutation `\u03c0` to both `c` and `t` results in the permuted element being in the support of the permuted tangle. This theorem is crucial for ensuring that the set of addresses being enumerated by each tangle is closed under permutations, which is a key property for proving the correctness of the ConNF system.", "formal_statement": "example [ConNF.Params ] [ConNF.Level] [ConNF.FOAAssumptions] {\u03b2 : ConNF.\u039b} [ConNF.LtLevel \u2191\u03b2] {c : ConNF.Address \u2191\u03b2} {t : ConNF.Tangle \u2191\u03b2} (h : c \u2208 ConNF.TangleData.Tangle.support t) (\u03c0 : ConNF.Allowable \u2191\u03b2) :\u03c0 \u2022 c \u2208 ConNF.TangleData.Tangle.support (\u03c0 \u2022 t) := by sorry", "full_tactic_state": "inst\u271d\u00b3 : ConNF.Params\ninst\u271d\u00b2 : ConNF.Level\ninst\u271d\u00b9 : ConNF.FOAAssumptions\n\u03b2 : ConNF.\u039b\ninst\u271d : ConNF.LtLevel \u2191\u03b2\nc : ConNF.Address \u2191\u03b2\nt : ConNF.Tangle \u2191\u03b2\nh : c \u2208 ConNF.TangleData.Tangle.support t\n\u03c0 : ConNF.Allowable \u2191\u03b2\n\u22a2 \u03c0 \u2022 c \u2208 ConNF.TangleData.Tangle.support (\u03c0 \u2022 t)", "dependency": [1, 98, 60, 395, 395]}, "ConNF.NearLitterPerm.ofBot_comp'": {"natural_language_statement": "Function `ConNF.NearLitterPerm.ofBot_comp'` simplifies the composition of `ConNF.NearLitterPerm.ofBot` with `ConNF.Allowable.toStructPerm` and `Quiver.Hom.toPath` in the context of Constructive Ordinal Notation (ConNF).", "formal_statement": "@[simp]example [ConNF.Params ] [ConNF.Level] [ConNF.FOAAssumptions] {\u03b2 : ConNF.TypeIndex} [ConNF.LeLevel \u03b2] {h\u03b2 : \u22a5 < \u03b2} {\u03c1 : ConNF.Allowable \u03b2} :NearLitterPerm.ofBot ((ConNF.allowableCons h\u03b2) \u03c1) = ConNF.Allowable.toStructPerm \u03c1 (Quiver.Hom.toPath h\u03b2) := by sorry", "full_tactic_state": "inst\u271d\u00b3 : ConNF.Params\ninst\u271d\u00b2 : ConNF.Level\ninst\u271d\u00b9 : ConNF.FOAAssumptions\n\u03b2 : ConNF.TypeIndex\ninst\u271d : ConNF.LeLevel \u03b2\nh\u03b2 : \u22a5 < \u03b2\n\u03c1 : ConNF.Allowable \u03b2\n\u22a2 NearLitterPerm.ofBot ((ConNF.allowableCons h\u03b2) \u03c1) = ConNF.Allowable.toStructPerm \u03c1 (Quiver.Hom.toPath h\u03b2)", "dependency": [1, 402, 74]}, "ConNF.exists_cons_of_length_ne_zero": {"natural_language_statement": "Given a path `p` from `x` to `y` in a quiver `V`, if the length of `p` is not zero, then there exists a vertex `t`, a path `q` from `x` to `t`, and an arrow `e` from `t` to `y` such that `p` is the concatenation of `q` and `e`.", "formal_statement": "example {V : Type u_1} [Quiver V] {x : V} {y : V} (p : Quiver.Path x y) (h : Quiver.Path.length p \u2260 0) :\u2203 (t : V) (q : Quiver.Path x t) (e : t \u27f6 y), p = Quiver.Path.cons q e := by sorry", "full_tactic_state": "V : Type u_1\ninst\u271d : Quiver V\nx y : V\np : Quiver.Path x y\nh : Quiver.Path.length p \u2260 0\n\u22a2 \u2203 t q e, p = Quiver.Path.cons q e", "dependency": [75, 76, 137, 76, 301]}, "ConNF.ofBot_smul": {"natural_language_statement": "The theorem `ConNF.ofBot_smul` states that in the context of Constructive Ordinal Notation (ConNF), the action of a `ConNF.Allowable` element `\u03c0` on an element `x` of a type `X` that is a `MulAction` of `ConNF.NearLitterPerm` is equivalent to the action of `NearLitterPerm.ofBot \u03c0` on `x`.", "formal_statement": "@[simp]example [ConNF.Params ] {X : Type u_1} [MulAction ConNF.NearLitterPerm X] (\u03c0 : ConNF.Allowable \u22a5 ) (x : X) :\u03c0 \u2022 x = NearLitterPerm.ofBot \u03c0 \u2022 x := by sorry", "full_tactic_state": "inst\u271d\u00b9 : ConNF.Params\nX : Type u_1\ninst\u271d : MulAction ConNF.NearLitterPerm X\n\u03c0 : ConNF.Allowable \u22a5\nx : X\n\u22a2 \u03c0 \u2022 x = NearLitterPerm.ofBot \u03c0 \u2022 x", "dependency": [1, 56]}, "ConNF.Sublitter.mk_S_eq_\u03ba": {"natural_language_statement": "The theorem `ConNF.Sublitter.mk_S_eq_\u03ba` states that for any sublitter `S` in the context of Constructive Ordinal Notation (ConNF), the cardinality of the set `S.carrier` is equal to the cardinality of the type `ConNF.\u03ba`.", "formal_statement": "example [ConNF.Params ] (S : ConNF.Sublitter) :Cardinal.mk \u2191S.carrier = Cardinal.mk ConNF.\u03ba := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\nS : ConNF.Sublitter\n\u22a2 Cardinal.mk \u2191S.carrier = Cardinal.mk ConNF.\u03ba", "dependency": [1, 29, 29]}, "ConNF.Sublitter.mk_eq_\u03ba": {"natural_language_statement": "In the context of Constructive Ordinal Notation (ConNF), given a sublitter `S`, the cardinality of `S` is equal to the cardinality of `\u03ba`.", "formal_statement": "@[simp]example [ConNF.Params ] (S : ConNF.Sublitter) :Cardinal.mk \u21a5S = Cardinal.mk ConNF.\u03ba := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\nS : ConNF.Sublitter\n\u22a2 Cardinal.mk \u21a5S = Cardinal.mk ConNF.\u03ba", "dependency": [1, 29, 29]}, "ConNF.Sublitter.mk_eq_\u03ba'": {"natural_language_statement": "The theorem `ConNF.Sublitter.mk_eq_\u03ba'` states that the cardinality of any sublitter `S` in the context of Constructive Ordinal Notation (ConNF) is equal to the cardinality of the type `ConNF.\u03ba`.", "formal_statement": "@[simp]example [ConNF.Params ] (S : ConNF.Sublitter) :Cardinal.mk \u2191\u2191S = Cardinal.mk ConNF.\u03ba := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\nS : ConNF.Sublitter\n\u22a2 Cardinal.mk \u21a5S = Cardinal.mk ConNF.\u03ba", "dependency": [1, 29, 29]}, "ConNF.Sublitter.carrier_eq_coe": {"natural_language_statement": "The `ConNF.Params` class in Lean 4 defines a set of parameters that are used in the construction of the natural numbers in the context of Constructive Ordinal Notation (ConNF). These parameters include the types `\u039b`, `\u03ba`, and `\u03bc`, along with various properties and relationships between these types, such as linear orders, well-orders, zero elements, successor orders, and subtraction operations. Additionally, there are conditions on the cardinalities of these types and their cofinalities. The theorem `ConNF.Sublitter.carrier_eq_coe` states that the carrier of a sublitter `S` is equal to the coercion of `S`.", "formal_statement": "@[simp]example [ConNF.Params ] {S : ConNF.Sublitter} :S.carrier = \u2191S := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\nS : ConNF.Sublitter\n\u22a2 S.carrier = \u2191S", "dependency": [1]}, "ConNF.Sublitter.ext": {"natural_language_statement": "Function `ConNF.Sublitter.ext` is an extensionality theorem for the `ConNF.Sublitter` structure in Lean 4. It states that two `ConNF.Sublitter` objects are equal if their underlying sets are equal.", "formal_statement": "example [ConNF.Params ] {S\u2081 : ConNF.Sublitter} {S\u2082 : ConNF.Sublitter} (h : \u2191S\u2081 = \u2191S\u2082) :S\u2081 = S\u2082 := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\nS\u2081 S\u2082 : ConNF.Sublitter\nh : S\u2081 = S\u2082\n\u22a2 S\u2081 = S\u2082", "dependency": [1]}, "ConNF.Sublitter.fst_eq_of_mem": {"natural_language_statement": "In the context of Constructive Ordinal Notation (ConNF), given a sublitter `S` and an atom `a` that belongs to `S`, the first component of `a` is equal to the litter of `S`.", "formal_statement": "example [ConNF.Params ] {S : ConNF.Sublitter} {a : ConNF.Atom} (h : a \u2208 S) :a.1 = S.litter := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\nS : ConNF.Sublitter\na : ConNF.Atom\nh : a \u2208 S\n\u22a2 a.1 = S.litter", "dependency": [1]}, "ConNF.Sublitter.mem_litterSet_of_mem": {"natural_language_statement": "The theorem `ConNF.Sublitter.mem_litterSet_of_mem` states that if an atom `a` belongs to a sublitter `S`, then `a` also belongs to the litter set of `S`.", "formal_statement": "example [ConNF.Params ] {S : ConNF.Sublitter} {a : ConNF.Atom} (h : a \u2208 S) :a \u2208 ConNF.litterSet S.litter := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\nS : ConNF.Sublitter\na : ConNF.Atom\nh : a \u2208 S\n\u22a2 a \u2208 ConNF.litterSet S.litter", "dependency": [1, 467]}, "ConNF.Sublitter.litter_diff_eq": {"natural_language_statement": "The theorem `ConNF.Sublitter.litter_diff_eq` states that for any sublitter `S` in the context of Constructive Ordinal Notation (ConNF), the set difference between `S` and the litter set corresponding to `S`'s litter is the empty set.", "formal_statement": "@[simp]example [ConNF.Params ] (S : ConNF.Sublitter) :\u2191S \\ ConNF.litterSet S.litter = \u2205 := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\nS : ConNF.Sublitter\n\u22a2 \u2191S \\ ConNF.litterSet S.litter = \u2205", "dependency": [1, 467]}, "ConNF.Sublitter.isNearLitter": {"natural_language_statement": "The theorem `ConNF.Sublitter.isNearLitter` states that for any sublitter `S` in the context of Constructive Ordinal Notation (ConNF), the set `S` is near the litter `S.litter`. This means that the set `S` has a small symmetric difference with the litter set of `S.litter`.", "formal_statement": "example [ConNF.Params ] (S : ConNF.Sublitter) :ConNF.IsNearLitter S.litter \u2191S := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\nS : ConNF.Sublitter\n\u22a2 ConNF.IsNearLitter S.litter \u2191S", "dependency": [1, 466]}, "ConNF.Sublitter.toNearLitter_litter": {"natural_language_statement": "The function `ConNF.Sublitter.toNearLitter` converts a `ConNF.Sublitter` to a `ConNF.NearLitter`. A `ConNF.Sublitter` represents a subset of a `ConNF.Litter`, and a `ConNF.NearLitter` is a pair consisting of a `ConNF.Litter` and a `ConNF.Sublitter` such that the `ConNF.Sublitter` is near the `ConNF.Litter`. The theorem `ConNF.Sublitter.toNearLitter_litter` states that the `ConNF.Litter` component of the resulting `ConNF.NearLitter` is equal to the `ConNF.Litter` component of the original `ConNF.Sublitter`.", "formal_statement": "@[simp]example [ConNF.Params ] (S : ConNF.Sublitter) :(ConNF.Sublitter.toNearLitter S).fst = S.litter := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\nS : ConNF.Sublitter\n\u22a2 (ConNF.Sublitter.toNearLitter S).fst = S.litter", "dependency": [1, 870]}, "ConNF.Sublitter.mem_toNearLitter": {"natural_language_statement": "Function `ConNF.Sublitter.toNearLitter` converts a `ConNF.Sublitter` to a `ConNF.NearLitter`. A `ConNF.Sublitter` represents a subset of a `ConNF.Litter`, and a `ConNF.NearLitter` is a pair consisting of a `ConNF.Litter` and a `ConNF.Sublitter` such that the `ConNF.Sublitter` is near the `ConNF.Litter`. The theorem `ConNF.Sublitter.mem_toNearLitter` states that for any `ConNF.Atom` `a`, `a` is an element of `ConNF.Sublitter.toNearLitter S` if and only if `a` is an element of `S`.", "formal_statement": "@[simp]example [ConNF.Params ] {S : ConNF.Sublitter} (a : ConNF.Atom) :a \u2208 ConNF.Sublitter.toNearLitter S \u2194 a \u2208 S := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\nS : ConNF.Sublitter\na : ConNF.Atom\n\u22a2 a \u2208 ConNF.Sublitter.toNearLitter S \u2194 a \u2208 S", "dependency": [1, 870]}, "ConNF.Litter.litter_toSublitter": {"natural_language_statement": "Function `ConNF.Litter.toSublitter` converts a `ConNF.Litter` object `L` into a `ConNF.Sublitter` object, which represents a subset of a `ConNF.Litter`. The resulting `ConNF.Sublitter` has `L` as its `litter` field.", "formal_statement": "@[simp]example [ConNF.Params ] (L : ConNF.Litter) :(ConNF.Litter.toSublitter L).litter = L := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\nL : ConNF.Litter\n\u22a2 (ConNF.Litter.toSublitter L).litter = L", "dependency": [1, 873]}, "ConNF.Litter.coe_toSublitter": {"natural_language_statement": "Function `ConNF.Litter.coe_toSublitter` converts a `ConNF.Litter` object `L` into a `ConNF.Sublitter` object, which represents a subset of a `ConNF.Litter`. The resulting `ConNF.Sublitter` has `L` as its `litter` field, `ConNF.litterSet L` as its `carrier` field, and proofs that the `carrier` is a subset of the `litter` and that the difference between the `litter` and the `carrier` is a small set. The function `ConNF.litterSet` defines a set corresponding to a given litter `L` in the context of Constructive Ordinal Notation (ConNF). This set contains all atoms `a` such that the first projection of `a` is equal to `L`.", "formal_statement": "@[simp]example [ConNF.Params ] (L : ConNF.Litter) :\u2191(ConNF.Litter.toSublitter L) = ConNF.litterSet L := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\nL : ConNF.Litter\n\u22a2 \u2191(ConNF.Litter.toSublitter L) = ConNF.litterSet L", "dependency": [1, 873, 467]}, "ConNF.Sublitter.equiv_apply_mem": {"natural_language_statement": "Function `ConNF.Sublitter.equiv` establishes an equivalence between any two sublitters in the context of Constructive Ordinal Notation. The theorem `ConNF.Sublitter.equiv_apply_mem` states that if `a` is an element of sublitter `S`, then the image of `a` under the equivalence `ConNF.Sublitter.equiv S T` is indeed an element of sublitter `T`.", "formal_statement": "@[simp]example [ConNF.Params ] {S : ConNF.Sublitter} {T : ConNF.Sublitter} (a : \u21a5S) :\u2191((ConNF.Sublitter.equiv S T) a) \u2208 T := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\nS T : ConNF.Sublitter\na : \u21a5S\n\u22a2 \u2191((ConNF.Sublitter.equiv S T) a) \u2208 T", "dependency": [1, 876]}, "ConNF.Sublitter.equiv_symm_apply_mem": {"natural_language_statement": "The theorem `ConNF.Sublitter.equiv_symm_apply_mem` states that for any two sublitters `S` and `T` in the context of Constructive Ordinal Notation, the inverse of the equivalence `ConNF.Sublitter.equiv S T` maps any element of `T` to an element of `S`.", "formal_statement": "@[simp]example [ConNF.Params ] {S : ConNF.Sublitter} {T : ConNF.Sublitter} (a : \u21a5T) :\u2191((ConNF.Sublitter.equiv S T).symm a) \u2208 S := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\nS T : ConNF.Sublitter\na : \u21a5T\n\u22a2 \u2191((ConNF.Sublitter.equiv S T).symm a) \u2208 S", "dependency": [1, 876]}, "ConNF.flexible_cases": {"natural_language_statement": "In the context of Constructive Ordinal Notation (ConNF), given a finite path `A` from a type `\u03b2` to the base type `\u22a5`, and a litter `L`, the theorem `ConNF.flexible_cases` states that `L` is either inflexible (the image of an f-map) or flexible (not the image of any f-map).", "formal_statement": "example [ConNF.Params ] [ConNF.Level] [ConNF.FOAAssumptions] {\u03b2 : ConNF.TypeIndex} (A : ConNF.ExtendedIndex \u03b2) (L : ConNF.Litter) :ConNF.Inflexible A L \u2228 ConNF.Flexible A L := by sorry", "full_tactic_state": "inst\u271d\u00b2 : ConNF.Params\ninst\u271d\u00b9 : ConNF.Level\ninst\u271d : ConNF.FOAAssumptions\n\u03b2 : ConNF.TypeIndex\nA : ConNF.ExtendedIndex \u03b2\nL : ConNF.Litter\n\u22a2 ConNF.Inflexible A L \u2228 ConNF.Flexible A L", "dependency": [1, 61, 879, 842]}, "ConNF.not_constrains_flexible": {"natural_language_statement": "In Constructive Ordinal Notation (ConNF), `ConNF.not_constrains_flexible` is a theorem that states that a ConNF address `c` does not constrain a flexible litter `L` to be in its near-litter. This theorem is crucial for ensuring the consistency of the ConNF construction of natural numbers, where flexibility ensures that no two elements of a given litter are considered equal.", "formal_statement": "example [ConNF.Params ] [ConNF.Level] [ConNF.FOAAssumptions] {\u03b2 : ConNF.\u039b} (c : ConNF.Address \u2191\u03b2) {A : ConNF.ExtendedIndex \u2191\u03b2} {L : ConNF.Litter} (hL : ConNF.Flexible A L) :\u00ac c \u227a { path := A, value := Sum.inr (ConNF.Litter.toNearLitter L) } := by sorry", "full_tactic_state": "inst\u271d\u00b2 : ConNF.Params\ninst\u271d\u00b9 : ConNF.Level\ninst\u271d : ConNF.FOAAssumptions\n\u03b2 : ConNF.\u039b\nc : ConNF.Address \u2191\u03b2\nA : ConNF.ExtendedIndex \u2191\u03b2\nL : ConNF.Litter\nhL : ConNF.Flexible A L\n\u22a2 \u00acc \u227a { path := A, value := Sum.inr (ConNF.Litter.toNearLitter L) }", "dependency": [1, 60, 61, 842, 65, 483]}, "ConNF.not_transConstrains_flexible": {"natural_language_statement": "The theorem `ConNF.not_transConstrains_flexible` states that in the context of Constructive Ordinal Notation (ConNF), for a given address `c` and an extended index `A`, if `L` is a *flexible* litter, then `c` does not transitively constrain the near-litter formed by wrapping `L` with its litter set. This property is crucial in ensuring that the construction of the natural numbers in ConNF is well-defined and consistent.", "formal_statement": "example [ConNF.Params ] [ConNF.Level] [ConNF.FOAAssumptions] {\u03b2 : ConNF.\u039b} (c : ConNF.Address \u2191\u03b2) {A : ConNF.ExtendedIndex \u2191\u03b2} {L : ConNF.Litter} (hL : ConNF.Flexible A L) :\u00ac c < { path := A, value := Sum.inr (ConNF.Litter.toNearLitter L) } := by sorry", "full_tactic_state": "inst\u271d\u00b2 : ConNF.Params\ninst\u271d\u00b9 : ConNF.Level\ninst\u271d : ConNF.FOAAssumptions\n\u03b2 : ConNF.\u039b\nc : ConNF.Address \u2191\u03b2\nA : ConNF.ExtendedIndex \u2191\u03b2\nL : ConNF.Litter\nhL : ConNF.Flexible A L\n\u22a2 \u00acc < { path := A, value := Sum.inr (ConNF.Litter.toNearLitter L) }", "dependency": [1, 60, 61, 842, 65, 483]}, "ConNF.mk_flexible": {"natural_language_statement": "The theorem `ConNF.mk_flexible` states that in the context of Constructive Ordinal Notation (ConNF), the cardinality of the set of all *flexible* litters (litters that are not the image of any f-map) is equal to the cardinality of the base type `\u03bc`. This result is crucial in ensuring that the construction of the natural numbers in ConNF is well-defined and consistent.", "formal_statement": "example [ConNF.Params ] [ConNF.Level] [ConNF.FOAAssumptions] {\u03b2 : ConNF.TypeIndex} (A : ConNF.ExtendedIndex \u03b2) :Cardinal.mk \u2191{L : ConNF.Litter | ConNF.Flexible A L} = Cardinal.mk ConNF.\u03bc := by sorry", "full_tactic_state": "inst\u271d\u00b2 : ConNF.Params\ninst\u271d\u00b9 : ConNF.Level\ninst\u271d : ConNF.FOAAssumptions\n\u03b2 : ConNF.TypeIndex\nA : ConNF.ExtendedIndex \u03b2\n\u22a2 Cardinal.mk \u2191{L | ConNF.Flexible A L} = Cardinal.mk ConNF.\u03bc", "dependency": [1, 61, 29, 842, 29]}, "ConNF.Inflexible.comp": {"natural_language_statement": "The `ConNF.Inflexible.comp` theorem in the context of Constructive Ordinal Notation (ConNF) states that if a litter `L` is inflexible with respect to an extended index `A`, and `B` is a path from a type `\u03b2` to a type `\u03b3`, then `L` is also inflexible with respect to the composition of `B` and `A`.", "formal_statement": "example [ConNF.Params ] [ConNF.Level] [ConNF.FOAAssumptions] {\u03b2 : ConNF.TypeIndex} {\u03b3 : ConNF.TypeIndex} {L : ConNF.Litter} {A : ConNF.ExtendedIndex \u03b3} (h : ConNF.Inflexible A L) (B : Quiver.Path \u03b2 \u03b3) :ConNF.Inflexible (Quiver.Path.comp B A) L := by sorry", "full_tactic_state": "inst\u271d\u00b2 : ConNF.Params\ninst\u271d\u00b9 : ConNF.Level\ninst\u271d : ConNF.FOAAssumptions\n\u03b2 \u03b3 : ConNF.TypeIndex\nL : ConNF.Litter\nA : ConNF.ExtendedIndex \u03b3\nh : ConNF.Inflexible A L\nB : Quiver.Path \u03b2 \u03b3\n\u22a2 ConNF.Inflexible (Quiver.Path.comp B A) L", "dependency": [1, 61, 879, 76, 879, 135]}, "ConNF.not_flexible_iff": {"natural_language_statement": "The theorem `ConNF.not_flexible_iff` states that in the context of Constructive Ordinal Notation (ConNF), a litter `L` is not *flexible* (i.e., not the image of any f-map) if and only if it is *inflexible* (i.e., an image of an f-map).", "formal_statement": "@[simp]example [ConNF.Params ] [ConNF.Level] [ConNF.FOAAssumptions] {\u03b2 : ConNF.TypeIndex} {L : ConNF.Litter} {A : ConNF.ExtendedIndex \u03b2} :\u00ac ConNF.Flexible A L \u2194 ConNF.Inflexible A L := by sorry", "full_tactic_state": "inst\u271d\u00b2 : ConNF.Params\ninst\u271d\u00b9 : ConNF.Level\ninst\u271d : ConNF.FOAAssumptions\n\u03b2 : ConNF.TypeIndex\nL : ConNF.Litter\nA : ConNF.ExtendedIndex \u03b2\n\u22a2 \u00acConNF.Flexible A L \u2194 ConNF.Inflexible A L", "dependency": [1, 61, 842, 879]}, "ConNF.flexible_of_comp_flexible": {"natural_language_statement": "To prove that if a litter `L` is *flexible* with respect to a composition of paths `B.comp A`, then `L` is also *flexible* with respect to `A`, we can use the `ConNF.flexible_of_comp_flexible` theorem in the context of Constructive Ordinal Notation (ConNF). This theorem is a key result in the ConNF project that ensures the well-definedness and consistency of the construction of the natural numbers, crucial for establishing the power of ConNF as a system of ordinal notation.", "formal_statement": "example [ConNF.Params ] [ConNF.Level] [ConNF.FOAAssumptions] {\u03b2 : ConNF.TypeIndex} {\u03b3 : ConNF.TypeIndex} {L : ConNF.Litter} {A : ConNF.ExtendedIndex \u03b3} {B : Quiver.Path \u03b2 \u03b3} (h : ConNF.Flexible (Quiver.Path.comp B A) L) :ConNF.Flexible A L := by sorry", "full_tactic_state": "inst\u271d\u00b2 : ConNF.Params\ninst\u271d\u00b9 : ConNF.Level\ninst\u271d : ConNF.FOAAssumptions\n\u03b2 \u03b3 : ConNF.TypeIndex\nL : ConNF.Litter\nA : ConNF.ExtendedIndex \u03b3\nB : Quiver.Path \u03b2 \u03b3\nh : ConNF.Flexible (Quiver.Path.comp B A) L\n\u22a2 ConNF.Flexible A L", "dependency": [1, 61, 76, 842, 135, 842]}, "ConNF.inflexibleBot_inflexibleCoe": {"natural_language_statement": "In the context of Constructive Ordinal Notation (ConNF), the theorem `ConNF.inflexibleBot_inflexibleCoe` states that if `L` is `A`-inflexible when `\u03b4 = \u22a5` (denoted as `ConNF.InflexibleBot A L`), and `L` is also `A`-inflexible when `\u03b5 \u2260 \u22a5` (denoted as `ConNF.InflexibleCoe A L`), then there is a contradiction, represented by the type `False`. This theorem is used to handle the case where a type index is equal to another type index due to extensionality, ensuring that the path retains its inflexibility and validity.", "formal_statement": "example [ConNF.Params ] [ConNF.Level] [ConNF.FOAAssumptions] {\u03b2 : ConNF.\u039b} {A : ConNF.ExtendedIndex \u2191\u03b2} {L : ConNF.Litter} :ConNF.InflexibleBot A L \u2192 ConNF.InflexibleCoe A L \u2192 False := by sorry", "full_tactic_state": "inst\u271d\u00b2 : ConNF.Params\ninst\u271d\u00b9 : ConNF.Level\ninst\u271d : ConNF.FOAAssumptions\n\u03b2 : ConNF.\u039b\nA : ConNF.ExtendedIndex \u2191\u03b2\nL : ConNF.Litter\n\u22a2 ConNF.InflexibleBot A L \u2192 ConNF.InflexibleCoe A L \u2192 False", "dependency": [1, 61, 887, 889, 891]}, "ConNF.InflexibleCoePath.\u03b4_lt_\u03b2": {"natural_language_statement": "The theorem `ConNF.InflexibleCoePath.\u03b4_lt_\u03b2` states that in the context of Constructive Ordinal Notation (ConNF), if `A` is an `InflexibleCoePath` from a type index `\u03b2` to the base type index `\u22a5`, then the type index `\u03b4` in the path is strictly less than `\u03b2`.", "formal_statement": "example [ConNF.Params ] [ConNF.Level] {\u03b2 : ConNF.\u039b} {A : ConNF.ExtendedIndex \u2191\u03b2} (h : ConNF.InflexibleCoePath A) :\u2191h.\u03b4 < \u2191\u03b2 := by sorry", "full_tactic_state": "inst\u271d\u00b9 : ConNF.Params\ninst\u271d : ConNF.Level\n\u03b2 : ConNF.\u039b\nA : ConNF.ExtendedIndex \u2191\u03b2\nh : ConNF.InflexibleCoePath A\n\u22a2 h.\u03b4 < \u03b2", "dependency": [1, 61, 890]}, "ConNF.InflexibleCoe.\u03b4_lt_\u03b2": {"natural_language_statement": "The theorem `ConNF.InflexibleCoe.\u03b4_lt_\u03b2` states that in the context of Constructive Ordinal Notation (ConNF), if `L` is `A`-inflexible (excluding `\u03b5 = \u22a5`), then the `\u03b4` of the path `h.path` is strictly less than `\u03b2`.", "formal_statement": "example [ConNF.Params ] [ConNF.Level] [ConNF.FOAAssumptions] {\u03b2 : ConNF.\u039b} {A : ConNF.ExtendedIndex \u2191\u03b2} {L : ConNF.Litter} (h : ConNF.InflexibleCoe A L) :\u2191h.path.\u03b4 < \u2191\u03b2 := by sorry", "full_tactic_state": "inst\u271d\u00b2 : ConNF.Params\ninst\u271d\u00b9 : ConNF.Level\ninst\u271d : ConNF.FOAAssumptions\n\u03b2 : ConNF.\u039b\nA : ConNF.ExtendedIndex \u2191\u03b2\nL : ConNF.Litter\nh : ConNF.InflexibleCoe A L\n\u22a2 h.path.\u03b4 < \u03b2", "dependency": [1, 61, 889]}, "ConNF.inflexible_of_inflexibleBot": {"natural_language_statement": "The theorem states that if L is A-inflexible at the bottom, then L is A-inflexible. This is a result of the fact that A-inflexibility at the bottom implies A-inflexibility at all levels, due to the well-founded nature of the ConNF hierarchy and the properties of the f-maps.", "formal_statement": "example [ConNF.Params ] [ConNF.Level] [ConNF.FOAAssumptions] {\u03b2 : ConNF.\u039b} {A : ConNF.ExtendedIndex \u2191\u03b2} {L : ConNF.Litter} (h : ConNF.InflexibleBot A L) :ConNF.Inflexible A L := by sorry", "full_tactic_state": "inst\u271d\u00b2 : ConNF.Params\ninst\u271d\u00b9 : ConNF.Level\ninst\u271d : ConNF.FOAAssumptions\n\u03b2 : ConNF.\u039b\nA : ConNF.ExtendedIndex \u2191\u03b2\nL : ConNF.Litter\nh : ConNF.InflexibleBot A L\n\u22a2 ConNF.Inflexible A L", "dependency": [1, 61, 887, 879]}, "ConNF.inflexible_of_inflexibleCoe": {"natural_language_statement": "The theorem `ConNF.inflexible_of_inflexibleCoe` states that if `L` is `A`-inflexible (excluding `\u03b5 = \u22a5`), then `L` is inflexible. This theorem is used in the context of Constructive Ordinal Notation (ConNF) to handle cases where a type index is equal to another type index due to extensionality, ensuring that the path retains its inflexibility and validity.", "formal_statement": "example [ConNF.Params ] [ConNF.Level] [ConNF.FOAAssumptions] {\u03b2 : ConNF.\u039b} {A : ConNF.ExtendedIndex \u2191\u03b2} {L : ConNF.Litter} (h : ConNF.InflexibleCoe A L) :ConNF.Inflexible A L := by sorry", "full_tactic_state": "inst\u271d\u00b2 : ConNF.Params\ninst\u271d\u00b9 : ConNF.Level\ninst\u271d : ConNF.FOAAssumptions\n\u03b2 : ConNF.\u039b\nA : ConNF.ExtendedIndex \u2191\u03b2\nL : ConNF.Litter\nh : ConNF.InflexibleCoe A L\n\u22a2 ConNF.Inflexible A L", "dependency": [1, 61, 889, 879]}, "ConNF.inflexibleBot_or_inflexibleCoe_of_inflexible": {"natural_language_statement": "Given a litter `L` and an extended index `A` in the context of Constructive Ordinal Notation (ConNF), if `L` is `A`-inflexible, then either `L` is `A`-inflexible at the bottom (i.e., when `\u03b4 = \u22a5`) or `L` is `A`-inflexible through coe (i.e., excluding `\u03b5 = \u22a5`).", "formal_statement": "example [ConNF.Params ] [ConNF.Level] [ConNF.FOAAssumptions] {\u03b2 : ConNF.\u039b} {A : ConNF.ExtendedIndex \u2191\u03b2} {L : ConNF.Litter} (h : ConNF.Inflexible A L) :Nonempty (ConNF.InflexibleBot A L) \u2228 Nonempty (ConNF.InflexibleCoe A L) := by sorry", "full_tactic_state": "inst\u271d\u00b2 : ConNF.Params\ninst\u271d\u00b9 : ConNF.Level\ninst\u271d : ConNF.FOAAssumptions\n\u03b2 : ConNF.\u039b\nA : ConNF.ExtendedIndex \u2191\u03b2\nL : ConNF.Litter\nh : ConNF.Inflexible A L\n\u22a2 Nonempty (ConNF.InflexibleBot A L) \u2228 Nonempty (ConNF.InflexibleCoe A L)", "dependency": [1, 61, 879, 212, 887, 212, 889]}, "ConNF.inflexible_iff_inflexibleBot_or_inflexibleCoe": {"natural_language_statement": "The theorem `ConNF.inflexible_iff_inflexibleBot_or_inflexibleCoe` in Lean 4 states that a litter `L` is `A`-inflexible if and only if there exists a proof that `L` is `A`-inflexible at the bottom of the hierarchy (`ConNF.InflexibleBot A L`) or there exists a proof that `L` is `A`-inflexible at the coe level (`ConNF.InflexibleCoe A L`). This theorem is crucial in the context of Constructive Ordinal Notation (ConNF) to ensure that the path from a type `\u03b1` to the base type `\u22a5` retains its inflexibility throughout the construction.", "formal_statement": "example [ConNF.Params ] [ConNF.Level] [ConNF.FOAAssumptions] {\u03b2 : ConNF.\u039b} {A : ConNF.ExtendedIndex \u2191\u03b2} {L : ConNF.Litter} :ConNF.Inflexible A L \u2194 Nonempty (ConNF.InflexibleBot A L) \u2228 Nonempty (ConNF.InflexibleCoe A L) := by sorry", "full_tactic_state": "inst\u271d\u00b2 : ConNF.Params\ninst\u271d\u00b9 : ConNF.Level\ninst\u271d : ConNF.FOAAssumptions\n\u03b2 : ConNF.\u039b\nA : ConNF.ExtendedIndex \u2191\u03b2\nL : ConNF.Litter\n\u22a2 ConNF.Inflexible A L \u2194 Nonempty (ConNF.InflexibleBot A L) \u2228 Nonempty (ConNF.InflexibleCoe A L)", "dependency": [1, 61, 879, 212, 887, 212, 889]}, "ConNF.flexible_iff_not_inflexibleBot_inflexibleCoe": {"natural_language_statement": "In the context of Constructive Ordinal Notation (ConNF), a litter `L` is considered *flexible* if it is not the image of any f-map. This property is crucial in ensuring that the construction of the natural numbers in ConNF is well-defined and consistent. The theorem `ConNF.flexible_iff_not_inflexibleBot_inflexibleCoe` states that a litter `L` is *flexible* if and only if it is not `A`-inflexible at the base type (`ConNF.InflexibleBot A L`) and it is not `A`-inflexible at any other type (`ConNF.InflexibleCoe A L`).", "formal_statement": "example [ConNF.Params ] [ConNF.Level] [ConNF.FOAAssumptions] {\u03b2 : ConNF.\u039b} {A : ConNF.ExtendedIndex \u2191\u03b2} {L : ConNF.Litter} :ConNF.Flexible A L \u2194 IsEmpty (ConNF.InflexibleBot A L) \u2227 IsEmpty (ConNF.InflexibleCoe A L) := by sorry", "full_tactic_state": "inst\u271d\u00b2 : ConNF.Params\ninst\u271d\u00b9 : ConNF.Level\ninst\u271d : ConNF.FOAAssumptions\n\u03b2 : ConNF.\u039b\nA : ConNF.ExtendedIndex \u2191\u03b2\nL : ConNF.Litter\n\u22a2 ConNF.Flexible A L \u2194 IsEmpty (ConNF.InflexibleBot A L) \u2227 IsEmpty (ConNF.InflexibleCoe A L)", "dependency": [1, 61, 842, 899, 887, 899, 889]}, "ConNF.flexible_cases'": {"natural_language_statement": "For a given type index `\u03b2` in the context of Constructive Ordinal Notation (ConNF), and a litter `L`, there are three cases to consider when determining the flexibility of `L` relative to `A`, an extended index of `\u03b2`: either `L` is flexible, `L` is inflexible due to `\u03b4 = \u22a5`, or `L` is inflexible due to `\u03b4` being equal to another type index due to extensionality. This theorem establishes that one of these cases must be true, indicating the overall flexibility of `L` in the context provided by `A`.", "formal_statement": "example [ConNF.Params ] [ConNF.Level] [ConNF.FOAAssumptions] {\u03b2 : ConNF.\u039b} (A : ConNF.ExtendedIndex \u2191\u03b2) (L : ConNF.Litter) :ConNF.Flexible A L \u2228 Nonempty (ConNF.InflexibleBot A L) \u2228 Nonempty (ConNF.InflexibleCoe A L) := by sorry", "full_tactic_state": "inst\u271d\u00b2 : ConNF.Params\ninst\u271d\u00b9 : ConNF.Level\ninst\u271d : ConNF.FOAAssumptions\n\u03b2 : ConNF.\u039b\nA : ConNF.ExtendedIndex \u2191\u03b2\nL : ConNF.Litter\n\u22a2 ConNF.Flexible A L \u2228 Nonempty (ConNF.InflexibleBot A L) \u2228 Nonempty (ConNF.InflexibleCoe A L)", "dependency": [1, 61, 842, 212, 887, 212, 889]}, "ConNF.inflexibleCoe_smul": {"natural_language_statement": "In the context of Constructive Ordinal Notation (ConNF), the theorem `ConNF.inflexibleCoe_smul` states that if `L` is `A`-inflexible (excluding `\u03b5 = \u22a5`), then `ConNF.Allowable.toStructPerm \u03c1 A \u2022 L` is also `A`-inflexible, where `ConNF.Allowable.toStructPerm \u03c1 A \u2022 L` represents the action of the permutation `ConNF.Allowable.toStructPerm \u03c1 A` on `L`.", "formal_statement": "@[simp]example [ConNF.Params ] [ConNF.Level] [ConNF.FOAAssumptions] {\u03b2 : ConNF.\u039b} [ConNF.LeLevel \u2191\u03b2] {A : ConNF.ExtendedIndex \u2191\u03b2} {L : ConNF.Litter} {\u03c1 : ConNF.Allowable \u2191\u03b2} :Nonempty (ConNF.InflexibleCoe A (ConNF.Allowable.toStructPerm \u03c1 A \u2022 L)) \u2194 Nonempty (ConNF.InflexibleCoe A L) := by sorry", "full_tactic_state": "inst\u271d\u00b3 : ConNF.Params\ninst\u271d\u00b2 : ConNF.Level\ninst\u271d\u00b9 : ConNF.FOAAssumptions\n\u03b2 : ConNF.\u039b\ninst\u271d : ConNF.LeLevel \u2191\u03b2\nA : ConNF.ExtendedIndex \u2191\u03b2\nL : ConNF.Litter\n\u03c1 : ConNF.Allowable \u2191\u03b2\n\u22a2 Nonempty (ConNF.InflexibleCoe A (ConNF.Allowable.toStructPerm \u03c1 A \u2022 L)) \u2194 Nonempty (ConNF.InflexibleCoe A L)", "dependency": [1, 402, 61, 212, 889, 212, 889]}, "ConNF.inflexibleBot_smul": {"natural_language_statement": "The theorem `ConNF.inflexibleBot_smul` is a result in the context of Constructive Ordinal Notation (ConNF), which is a formalization of an extension of the Constructive Ordinals by allowing for 'literals' and 'structures' that can be manipulated under a carefully defined set of rules. The theorem states that if `L` is inflexible with respect to `A` and `\u03c1` is a permutation of `L` that respects the `A`-inflexibility of `L`, then the permutation `\u03c1` applied to `L` results in another inflexible structure with respect to `A`. This result is crucial in establishing the recursive properties of the ConNF system.", "formal_statement": "@[simp]example [ConNF.Params ] [ConNF.Level] [ConNF.FOAAssumptions] {\u03b2 : ConNF.\u039b} [ConNF.LeLevel \u2191\u03b2] {A : ConNF.ExtendedIndex \u2191\u03b2} {L : ConNF.Litter} {\u03c1 : ConNF.Allowable \u2191\u03b2} :Nonempty (ConNF.InflexibleBot A (ConNF.Allowable.toStructPerm \u03c1 A \u2022 L)) \u2194 Nonempty (ConNF.InflexibleBot A L) := by sorry", "full_tactic_state": "inst\u271d\u00b3 : ConNF.Params\ninst\u271d\u00b2 : ConNF.Level\ninst\u271d\u00b9 : ConNF.FOAAssumptions\n\u03b2 : ConNF.\u039b\ninst\u271d : ConNF.LeLevel \u2191\u03b2\nA : ConNF.ExtendedIndex \u2191\u03b2\nL : ConNF.Litter\n\u03c1 : ConNF.Allowable \u2191\u03b2\n\u22a2 Nonempty (ConNF.InflexibleBot A (ConNF.Allowable.toStructPerm \u03c1 A \u2022 L)) \u2194 Nonempty (ConNF.InflexibleBot A L)", "dependency": [1, 402, 61, 212, 887, 212, 887]}, "ConNF.Flexible.smul": {"natural_language_statement": "In the context of Constructive Ordinal Notation (ConNF), a litter `L` is considered *flexible* if it is not the image of any f-map. This property is crucial in ensuring that the construction of the natural numbers in ConNF is well-defined and consistent. The theorem `ConNF.Flexible.smul` states that if `L` is a *flexible* litter and `\u03c1` is an allowable permutation, then the action of `\u03c1` on `L` results in another *flexible* litter.", "formal_statement": "example [ConNF.Params ] [ConNF.Level] [ConNF.FOAAssumptions] {\u03b2 : ConNF.\u039b} [ConNF.LeLevel \u2191\u03b2] {A : ConNF.ExtendedIndex \u2191\u03b2} {L : ConNF.Litter} (h : ConNF.Flexible A L) (\u03c1 : ConNF.Allowable \u2191\u03b2) :ConNF.Flexible A (ConNF.Allowable.toStructPerm \u03c1 A \u2022 L) := by sorry", "full_tactic_state": "inst\u271d\u00b3 : ConNF.Params\ninst\u271d\u00b2 : ConNF.Level\ninst\u271d\u00b9 : ConNF.FOAAssumptions\n\u03b2 : ConNF.\u039b\ninst\u271d : ConNF.LeLevel \u2191\u03b2\nA : ConNF.ExtendedIndex \u2191\u03b2\nL : ConNF.Litter\nh : ConNF.Flexible A L\n\u03c1 : ConNF.Allowable \u2191\u03b2\n\u22a2 ConNF.Flexible A (ConNF.Allowable.toStructPerm \u03c1 A \u2022 L)", "dependency": [1, 402, 61, 842, 842]}, "ConNF.flexible_smul": {"natural_language_statement": "The theorem `ConNF.flexible_smul` states that in the context of Constructive Ordinal Notation (ConNF), a litter `L` is *flexible* if and only if its image under the action of any allowable permutation is also *flexible*. This property is crucial in ensuring that the construction of the natural numbers in ConNF is well-defined and consistent.", "formal_statement": "@[simp]example [ConNF.Params ] [ConNF.Level] [ConNF.FOAAssumptions] {\u03b2 : ConNF.\u039b} [ConNF.LeLevel \u2191\u03b2] {A : ConNF.ExtendedIndex \u2191\u03b2} {L : ConNF.Litter} {\u03c1 : ConNF.Allowable \u2191\u03b2} :ConNF.Flexible A (ConNF.Allowable.toStructPerm \u03c1 A \u2022 L) \u2194 ConNF.Flexible A L := by sorry", "full_tactic_state": "inst\u271d\u00b3 : ConNF.Params\ninst\u271d\u00b2 : ConNF.Level\ninst\u271d\u00b9 : ConNF.FOAAssumptions\n\u03b2 : ConNF.\u039b\ninst\u271d : ConNF.LeLevel \u2191\u03b2\nA : ConNF.ExtendedIndex \u2191\u03b2\nL : ConNF.Litter\n\u03c1 : ConNF.Allowable \u2191\u03b2\n\u22a2 ConNF.Flexible A (ConNF.Allowable.toStructPerm \u03c1 A \u2022 L) \u2194 ConNF.Flexible A L", "dependency": [1, 402, 61, 842, 842]}, "ConNF.inflexibleCoe_smul_path": {"natural_language_statement": "In the context of Constructive Ordinal Notation (ConNF), the theorem `ConNF.inflexibleCoe_smul_path` states that the path of a proof-relevant statement that `L` is `A`-inflexible (excluding `\u03b5 = \u22a5`) remains unchanged after applying the `ConNF.InflexibleCoe.smul` method. This method is used to handle cases where a type index is equal to another type index due to extensionality, ensuring that the path retains its inflexibility and validity.", "formal_statement": "@[simp]example [ConNF.Params ] [ConNF.Level] [ConNF.FOAAssumptions] {\u03b2 : ConNF.\u039b} [ConNF.LeLevel \u2191\u03b2] {A : ConNF.ExtendedIndex \u2191\u03b2} {L : ConNF.Litter} {\u03c1 : ConNF.Allowable \u2191\u03b2} (h : ConNF.InflexibleCoe A L) :(ConNF.InflexibleCoe.smul h \u03c1).path = h.path := by sorry", "full_tactic_state": "inst\u271d\u00b3 : ConNF.Params\ninst\u271d\u00b2 : ConNF.Level\ninst\u271d\u00b9 : ConNF.FOAAssumptions\n\u03b2 : ConNF.\u039b\ninst\u271d : ConNF.LeLevel \u2191\u03b2\nA : ConNF.ExtendedIndex \u2191\u03b2\nL : ConNF.Litter\n\u03c1 : ConNF.Allowable \u2191\u03b2\nh : ConNF.InflexibleCoe A L\n\u22a2 (ConNF.InflexibleCoe.smul h \u03c1).path = h.path", "dependency": [1, 402, 61, 889, 906]}, "ConNF.inflexibleBot_smul_path": {"natural_language_statement": "The theorem `ConNF.inflexibleBot_smul_path` states that if `L` is `A`-inflexible and `\u03c1` is an allowable permutation, then the path of `\u03c1 \u2022 L` is the same as the path of `L`.", "formal_statement": "@[simp]example [ConNF.Params ] [ConNF.Level] [ConNF.FOAAssumptions] {\u03b2 : ConNF.\u039b} [ConNF.LeLevel \u2191\u03b2] {A : ConNF.ExtendedIndex \u2191\u03b2} {L : ConNF.Litter} {\u03c1 : ConNF.Allowable \u2191\u03b2} (h : ConNF.InflexibleBot A L) :(ConNF.InflexibleBot.smul h \u03c1).path = h.path := by sorry", "full_tactic_state": "inst\u271d\u00b3 : ConNF.Params\ninst\u271d\u00b2 : ConNF.Level\ninst\u271d\u00b9 : ConNF.FOAAssumptions\n\u03b2 : ConNF.\u039b\ninst\u271d : ConNF.LeLevel \u2191\u03b2\nA : ConNF.ExtendedIndex \u2191\u03b2\nL : ConNF.Litter\n\u03c1 : ConNF.Allowable \u2191\u03b2\nh : ConNF.InflexibleBot A L\n\u22a2 (ConNF.InflexibleBot.smul h \u03c1).path = h.path", "dependency": [1, 402, 61, 887, 908]}, "ConNF.hasPosition_subsingleton": {"natural_language_statement": "In the context of Constructive Ordinal Notation (ConNF), given a `ConNF.Litter` `L` and two `ConNF.\u03bc` elements `\u03bd\u2081` and `\u03bd\u2082`, if both `\u03bd\u2081` and `\u03bd\u2082` are related to `L` by the `ConNF.HasPosition` relation, then `\u03bd\u2081` and `\u03bd\u2082` must be equal. This means that for a given `ConNF.Litter`, there is at most one `ConNF.\u03bc` element that can be related to it by the `ConNF.HasPosition` relation.", "formal_statement": "example [ConNF.Params ] [ConNF.Level] [ConNF.FOAAssumptions] {L : ConNF.Litter} {\u03bd\u2081 : ConNF.\u03bc} {\u03bd\u2082 : ConNF.\u03bc} (h\u2081 : ConNF.HasPosition L \u03bd\u2081) (h\u2082 : ConNF.HasPosition L \u03bd\u2082) :\u03bd\u2081 = \u03bd\u2082 := by sorry", "full_tactic_state": "inst\u271d\u00b2 : ConNF.Params\ninst\u271d\u00b9 : ConNF.Level\ninst\u271d : ConNF.FOAAssumptions\nL : ConNF.Litter\n\u03bd\u2081 \u03bd\u2082 : ConNF.\u03bc\nh\u2081 : ConNF.HasPosition L \u03bd\u2081\nh\u2082 : ConNF.HasPosition L \u03bd\u2082\n\u22a2 \u03bd\u2081 = \u03bd\u2082", "dependency": [1, 910, 910]}, "ConNF.hasPosition_of_litterConstrains": {"natural_language_statement": "The theorem `ConNF.hasPosition_of_litterConstrains` states that for any two `ConNF.Litter` objects `L\u2081` and `L\u2082`, if `L\u2081` constrains `L\u2082`, then there exists a `ConNF.\u03bc` element `\u03bd` such that `L\u2082` has position `\u03bd`.", "formal_statement": "example [ConNF.Params ] [ConNF.Level] [ConNF.FOAAssumptions] {L\u2081 : ConNF.Litter} {L\u2082 : ConNF.Litter} (h : ConNF.LitterConstrains L\u2081 L\u2082) :\u2203 (\u03bd : ConNF.\u03bc), ConNF.HasPosition L\u2082 \u03bd := by sorry", "full_tactic_state": "inst\u271d\u00b2 : ConNF.Params\ninst\u271d\u00b9 : ConNF.Level\ninst\u271d : ConNF.FOAAssumptions\nL\u2081 L\u2082 : ConNF.Litter\nh : ConNF.LitterConstrains L\u2081 L\u2082\n\u22a2 \u2203 \u03bd, ConNF.HasPosition L\u2082 \u03bd", "dependency": [1, 912, 910]}, "ConNF.hasPosition_lt_of_litterConstrains": {"natural_language_statement": "In Constructive Ordinal Notation (ConNF), the `ConNF.LitterConstrains` relation is used to express the constraints that one `Litter` object imposes on another. The `ConNF.HasPosition` relation describes the position of a `Litter` object within the `ConNF.\u03bc` type. The theorem `ConNF.hasPosition_lt_of_litterConstrains` states that if `L\u2081` is constrained by `L\u2082` and both have positions in `ConNF.\u03bc`, then the position of `L\u2081` is less than the position of `L\u2082` in `ConNF.\u03bc`.", "formal_statement": "example [ConNF.Params ] [ConNF.Level] [ConNF.FOAAssumptions] {L\u2081 : ConNF.Litter} {L\u2082 : ConNF.Litter} (h : ConNF.LitterConstrains L\u2081 L\u2082) {\u03bd\u2081 : ConNF.\u03bc} {\u03bd\u2082 : ConNF.\u03bc} (h\u2081 : ConNF.HasPosition L\u2081 \u03bd\u2081) (h\u2082 : ConNF.HasPosition L\u2082 \u03bd\u2082) :\u03bd\u2081 < \u03bd\u2082 := by sorry", "full_tactic_state": "inst\u271d\u00b2 : ConNF.Params\ninst\u271d\u00b9 : ConNF.Level\ninst\u271d : ConNF.FOAAssumptions\nL\u2081 L\u2082 : ConNF.Litter\nh : ConNF.LitterConstrains L\u2081 L\u2082\n\u03bd\u2081 \u03bd\u2082 : ConNF.\u03bc\nh\u2081 : ConNF.HasPosition L\u2081 \u03bd\u2081\nh\u2082 : ConNF.HasPosition L\u2082 \u03bd\u2082\n\u22a2 \u03bd\u2081 < \u03bd\u2082", "dependency": [1, 912, 910, 910]}, "ConNF.litterConstrains_subrelation": {"natural_language_statement": "The theorem `ConNF.litterConstrains_subrelation` states that the relation `ConNF.LitterConstrains` is a subrelation of the relation `InvImage (fun (x x_1 : WithBot ConNF.\u03bc) => x < x_1) ConNF.positionOrBot`. This means that if `ConNF.LitterConstrains` holds between two elements, then so does `InvImage (fun (x x_1 : WithBot ConNF.\u03bc) => x < x_1) ConNF.positionOrBot`.", "formal_statement": "example [ConNF.Params ] [ConNF.Level] [ConNF.FOAAssumptions] :Subrelation ConNF.LitterConstrains (InvImage (fun (x x_1 : WithBot ConNF.\u03bc) => x < x_1) ConNF.positionOrBot) := by sorry", "full_tactic_state": "inst\u271d\u00b2 : ConNF.Params\ninst\u271d\u00b9 : ConNF.Level\ninst\u271d : ConNF.FOAAssumptions\n\u22a2 Subrelation ConNF.LitterConstrains (InvImage (fun x x_1 => x < x_1) ConNF.positionOrBot)", "dependency": [1, 122, 96, 915]}, "ConNF.litterConstrains_wf": {"natural_language_statement": "The theorem `ConNF.litterConstrains_wf` states that the relation `ConNF.LitterConstrains` is well-founded. This means that every non-empty set of `ConNF.Litter`s has a minimal element with respect to the relation `ConNF.LitterConstrains`.", "formal_statement": "example [ConNF.Params ] [ConNF.Level] [ConNF.FOAAssumptions] :WellFounded ConNF.LitterConstrains := by sorry", "full_tactic_state": "inst\u271d\u00b2 : ConNF.Params\ninst\u271d\u00b9 : ConNF.Level\ninst\u271d : ConNF.FOAAssumptions\n\u22a2 WellFounded ConNF.LitterConstrains", "dependency": [1, 19]}, "ConNF.constrains_atom": {"natural_language_statement": "The theorem `ConNF.constrains_atom` states that in the context of Constructive Ordinal Notation (ConNF), for a given address `c` and an extended index `A`, the condition `c \u227a { path := A, value := Sum.inl a }` holds if and only if `c` is equal to `{ path := A, value := Sum.inr (ConNF.Litter.toNearLitter a.1) }`, where `a` is an atom and `ConNF.Litter.toNearLitter` converts a litter to its corresponding near-litter.", "formal_statement": "@[simp]example [ConNF.Params ] [ConNF.Level] [ConNF.FOAAssumptions] {\u03b2 : ConNF.\u039b} {c : ConNF.Address \u2191\u03b2} {A : ConNF.ExtendedIndex \u2191\u03b2} {a : ConNF.Atom} :c \u227a { path := A, value := Sum.inl a } \u2194 c = { path := A, value := Sum.inr (ConNF.Litter.toNearLitter a.1) } := by sorry", "full_tactic_state": "inst\u271d\u00b2 : ConNF.Params\ninst\u271d\u00b9 : ConNF.Level\ninst\u271d : ConNF.FOAAssumptions\n\u03b2 : ConNF.\u039b\nc : ConNF.Address \u2191\u03b2\nA : ConNF.ExtendedIndex \u2191\u03b2\na : ConNF.Atom\n\u22a2 c \u227a { path := A, value := Sum.inl a } \u2194 c = { path := A, value := Sum.inr (ConNF.Litter.toNearLitter a.1) }", "dependency": [1, 60, 61, 67, 65, 483]}, "ConNF.constrains_nearLitter": {"natural_language_statement": "The theorem `ConNF.constrains_nearLitter` in Constructive Ordinal Notation (ConNF) formalism, specifically defined for proving the consistency of `AD^+` using the determinacy of games on the ordinals, provides a condition for a constraint imposed by a near-litter that is not a litter. It states that for a constraint `c` to be less than a near-litter `N` that is not a litter, either `c` must be equal to the near-litter formed from the litter part of `N`, or `c` must be an atom that is an element of the symmetric difference between the litter set of `N` and the subset of the litter set that forms `N`. This theorem is crucial for understanding the relationship between constraints and near-litters in the context of ConNF.", "formal_statement": "example [ConNF.Params ] [ConNF.Level] [ConNF.FOAAssumptions] {\u03b2 : ConNF.\u039b} {c : ConNF.Address \u2191\u03b2} {A : ConNF.ExtendedIndex \u2191\u03b2} {N : ConNF.NearLitter} (hN : \u00ac ConNF.NearLitter.IsLitter N) :c \u227a { path := A, value := Sum.inr N } \u2194 c = { path := A, value := Sum.inr (ConNF.Litter.toNearLitter N.fst) } \u2228 \u2203 a \u2208 symmDiff (ConNF.litterSet N.fst) \u2191N.snd, c = { path := A, value := Sum.inl a } := by sorry", "full_tactic_state": "inst\u271d\u00b2 : ConNF.Params\ninst\u271d\u00b9 : ConNF.Level\ninst\u271d : ConNF.FOAAssumptions\n\u03b2 : ConNF.\u039b\nc : ConNF.Address \u2191\u03b2\nA : ConNF.ExtendedIndex \u2191\u03b2\nN : ConNF.NearLitter\nhN : \u00acConNF.NearLitter.IsLitter N\n\u22a2 c \u227a { path := A, value := Sum.inr N } \u2194\n    c = { path := A, value := Sum.inr (ConNF.Litter.toNearLitter N.fst) } \u2228\n      \u2203 a \u2208 symmDiff (ConNF.litterSet N.fst) \u2191N.snd, c = { path := A, value := Sum.inl a }", "dependency": [1, 60, 61, 495, 65, 65, 483, 62, 467, 67]}, "ConNF.acc_atom": {"natural_language_statement": "The theorem `ConNF.acc_atom` is a part of the Constructive Ordinal Notation (ConNF) formalization in Lean 4. It states that if a certain relation `\u227a` (which represents a well-founded relation in the context of ConNF) is accessible for a specific element of type `ConNF.Address \u2191\u03b2` that has a `Sum.inr` constructor (which means it represents a near-litter), then the relation `\u227a` is also accessible for a similar element but with a `Sum.inl` constructor (which represents an atom). This result is crucial for proving the well-foundedness of the relation `\u227a` in the context of ConNF, which is essential for the correctness of the model of ordinals and cardinals in the formalization.", "formal_statement": "example [ConNF.Params ] [ConNF.Level] [ConNF.FOAAssumptions] {\u03b2 : ConNF.\u039b} {a : ConNF.Atom} {A : ConNF.ExtendedIndex \u2191\u03b2} (h : Acc (fun (x x_1 : ConNF.Address \u2191\u03b2) => x \u227a x_1) { path := A, value := Sum.inr (ConNF.Litter.toNearLitter a.1) }) :Acc (fun (x x_1 : ConNF.Address \u2191\u03b2) => x \u227a x_1) { path := A, value := Sum.inl a } := by sorry", "full_tactic_state": "inst\u271d\u00b2 : ConNF.Params\ninst\u271d\u00b9 : ConNF.Level\ninst\u271d : ConNF.FOAAssumptions\n\u03b2 : ConNF.\u039b\na : ConNF.Atom\nA : ConNF.ExtendedIndex \u2191\u03b2\nh : Acc (fun x x_1 => x \u227a x_1) { path := A, value := Sum.inr (ConNF.Litter.toNearLitter a.1) }\n\u22a2 Acc (fun x x_1 => x \u227a x_1) { path := A, value := Sum.inl a }", "dependency": [1, 61, 920, 60, 65, 483, 920, 60, 67]}, "ConNF.acc_nearLitter": {"natural_language_statement": "In the context of Constructive Ordinal Notation (ConNF), the theorem `ConNF.acc_nearLitter` states that if for every element `a` in a near-litter `N`, the address `{ path := A, value := Sum.inr (ConNF.Litter.toNearLitter a.1) }` is accessible under the relation `\u227a`, then the address `{ path := A, value := Sum.inr N }` is also accessible under the same relation.", "formal_statement": "example [ConNF.Params ] [ConNF.Level] [ConNF.FOAAssumptions] {\u03b2 : ConNF.\u039b} {N : ConNF.NearLitter} {A : ConNF.ExtendedIndex \u2191\u03b2} (h : \u2200 a \u2208 N, Acc (fun (x x_1 : ConNF.Address \u2191\u03b2) => x \u227a x_1) { path := A, value := Sum.inr (ConNF.Litter.toNearLitter a.1) }) :Acc (fun (x x_1 : ConNF.Address \u2191\u03b2) => x \u227a x_1) { path := A, value := Sum.inr N } := by sorry", "full_tactic_state": "inst\u271d\u00b2 : ConNF.Params\ninst\u271d\u00b9 : ConNF.Level\ninst\u271d : ConNF.FOAAssumptions\n\u03b2 : ConNF.\u039b\nN : ConNF.NearLitter\nA : ConNF.ExtendedIndex \u2191\u03b2\nh : \u2200 a \u2208 N, Acc (fun x x_1 => x \u227a x_1) { path := A, value := Sum.inr (ConNF.Litter.toNearLitter a.1) }\n\u22a2 Acc (fun x x_1 => x \u227a x_1) { path := A, value := Sum.inr N }", "dependency": [1, 61, 920, 60, 65, 483, 920, 60, 65]}, "ConNF.constrains_wf": {"natural_language_statement": "Function `ConNF.constrains_wf` proves that the `\u227a` relation on `ConNF.Address` is well-founded. This means that every non-empty subset of `ConNF.Address` has a minimal element with respect to the relation `\u227a`.", "formal_statement": "example [ConNF.Params ] [ConNF.Level] [ConNF.FOAAssumptions] (\u03b2 : ConNF.\u039b) :WellFounded fun (x x_1 : ConNF.Address \u2191\u03b2) => x \u227a x_1 := by sorry", "full_tactic_state": "inst\u271d\u00b2 : ConNF.Params\ninst\u271d\u00b9 : ConNF.Level\ninst\u271d : ConNF.FOAAssumptions\n\u03b2 : ConNF.\u039b\n\u22a2 WellFounded fun x x_1 => x \u227a x_1", "dependency": [1, 19, 60]}, "ConNF.Address.le_iff": {"natural_language_statement": "The theorem `ConNF.Address.le_iff` in Lean 4 states that for two addresses `c` and `d` in the same level `\u03b2`, `c` is less than or equal to `d` if and only if `c` is related to `d` by the reflexive transitive closure of the relation `\u227a`.", "formal_statement": "example [ConNF.Params ] [ConNF.Level] [ConNF.FOAAssumptions] {\u03b2 : ConNF.\u039b} {c : ConNF.Address \u2191\u03b2} {d : ConNF.Address \u2191\u03b2} :c \u2264 d \u2194 Relation.ReflTransGen (fun (x x_1 : ConNF.Address \u2191\u03b2) => x \u227a x_1) c d := by sorry", "full_tactic_state": "inst\u271d\u00b2 : ConNF.Params\ninst\u271d\u00b9 : ConNF.Level\ninst\u271d : ConNF.FOAAssumptions\n\u03b2 : ConNF.\u039b\nc d : ConNF.Address \u2191\u03b2\n\u22a2 c \u2264 d \u2194 Relation.ReflTransGen (fun x x_1 => x \u227a x_1) c d", "dependency": [1, 60, 60, 924, 60]}, "ConNF.Address.lt_iff": {"natural_language_statement": "The theorem `ConNF.Address.lt_iff` in Lean 4 states that for two addresses `c` and `d` in the context of Constructive Ordinal Notation (ConNF), `c` is less than `d` if and only if `c` is related to `d` by the transitive closure of the relation `\u227a`.", "formal_statement": "example [ConNF.Params ] [ConNF.Level] [ConNF.FOAAssumptions] {\u03b2 : ConNF.\u039b} {c : ConNF.Address \u2191\u03b2} {d : ConNF.Address \u2191\u03b2} :c < d \u2194 Relation.TransGen (fun (x x_1 : ConNF.Address \u2191\u03b2) => x \u227a x_1) c d := by sorry", "full_tactic_state": "inst\u271d\u00b2 : ConNF.Params\ninst\u271d\u00b9 : ConNF.Level\ninst\u271d : ConNF.FOAAssumptions\n\u03b2 : ConNF.\u039b\nc d : ConNF.Address \u2191\u03b2\n\u22a2 c < d \u2194 Relation.TransGen (fun x x_1 => x \u227a x_1) c d", "dependency": [1, 60, 60, 926, 60]}, "ConNF.le_nearLitter": {"natural_language_statement": "`ConNF.le_nearLitter` is a theorem in Constructive Ordinal Notation (ConNF) that states that if a near-litter `N` (a pair consisting of a litter and a subset of that litter) is less than or equal to an address `c` in the context of a parameter `\u03b2` of the ConNF hierarchy, then the near-litter formed by wrapping the litter of `N` with its litter set is also less than or equal to `c`. This theorem is crucial to establishing the well-foundedness of the ConNF hierarchy and proving the consistency of the natural numbers with the ZFC axioms.", "formal_statement": "example [ConNF.Params ] [ConNF.Level] [ConNF.FOAAssumptions] {\u03b2 : ConNF.\u039b} {N : ConNF.NearLitter} {B : ConNF.ExtendedIndex \u2191\u03b2} {c : ConNF.Address \u2191\u03b2} (h : { path := B, value := Sum.inr N } \u2264 c) :{ path := B, value := Sum.inr (ConNF.Litter.toNearLitter N.fst) } \u2264 c := by sorry", "full_tactic_state": "inst\u271d\u00b2 : ConNF.Params\ninst\u271d\u00b9 : ConNF.Level\ninst\u271d : ConNF.FOAAssumptions\n\u03b2 : ConNF.\u039b\nN : ConNF.NearLitter\nB : ConNF.ExtendedIndex \u2191\u03b2\nc : ConNF.Address \u2191\u03b2\nh : { path := B, value := Sum.inr N } \u2264 c\n\u22a2 { path := B, value := Sum.inr (ConNF.Litter.toNearLitter N.fst) } \u2264 c", "dependency": [1, 61, 60, 65, 65, 483]}, "ConNF.lt_nearLitter": {"natural_language_statement": "The theorem `ConNF.lt_nearLitter` states that if `c` is an address in the near-litter of `N`, and `c` is less than an address that points to the near-litter of `N`, then `c` is also less than the near-litter of `N` itself. This makes sense because the near-litter of `N` is a more specific address than the near-litter of `N`, and thus any address less than the near-litter of `N` will also be less than the near-litter of `N`.", "formal_statement": "example [ConNF.Params ] [ConNF.Level] [ConNF.FOAAssumptions] {\u03b2 : ConNF.\u039b} {N : ConNF.NearLitter} {B : ConNF.ExtendedIndex \u2191\u03b2} {c : ConNF.Address \u2191\u03b2} (h : c < { path := B, value := Sum.inr (ConNF.Litter.toNearLitter N.fst) }) :c < { path := B, value := Sum.inr N } := by sorry", "full_tactic_state": "inst\u271d\u00b2 : ConNF.Params\ninst\u271d\u00b9 : ConNF.Level\ninst\u271d : ConNF.FOAAssumptions\n\u03b2 : ConNF.\u039b\nN : ConNF.NearLitter\nB : ConNF.ExtendedIndex \u2191\u03b2\nc : ConNF.Address \u2191\u03b2\nh : c < { path := B, value := Sum.inr (ConNF.Litter.toNearLitter N.fst) }\n\u22a2 c < { path := B, value := Sum.inr N }", "dependency": [1, 61, 60, 65, 483, 65]}, "ConNF.lt_nearLitter'": {"natural_language_statement": "`ConNF.lt_nearLitter'` is a theorem that helps one prove that if a certain element is less than another element in the context of Constructive Ordinal Notation (ConNF), then another related element is also less than the second element. This theorem is used in the proof of `ConNF.lt_base` to establish the fact that the base type is well-ordered, which is a crucial property for constructing the natural numbers in the ConNF context.", "formal_statement": "example [ConNF.Params ] [ConNF.Level] [ConNF.FOAAssumptions] {\u03b2 : ConNF.\u039b} {N : ConNF.NearLitter} {B : ConNF.ExtendedIndex \u2191\u03b2} {c : ConNF.Address \u2191\u03b2} (h : { path := B, value := Sum.inr N } < c) :{ path := B, value := Sum.inr (ConNF.Litter.toNearLitter N.fst) } < c := by sorry", "full_tactic_state": "inst\u271d\u00b2 : ConNF.Params\ninst\u271d\u00b9 : ConNF.Level\ninst\u271d : ConNF.FOAAssumptions\n\u03b2 : ConNF.\u039b\nN : ConNF.NearLitter\nB : ConNF.ExtendedIndex \u2191\u03b2\nc : ConNF.Address \u2191\u03b2\nh : { path := B, value := Sum.inr N } < c\n\u22a2 { path := B, value := Sum.inr (ConNF.Litter.toNearLitter N.fst) } < c", "dependency": [1, 61, 60, 65, 65, 483]}, "ConNF.small_constrains": {"natural_language_statement": "In the context of Constructive Ordinal Notation (ConNF), the theorem `ConNF.small_constrains` asserts that for any address `c` in the base type `\u03b2`, the set of addresses `d` that are constrained by `c` (denoted as `d \u227a c`) has a cardinality that is strictly less than the cardinality of the type `ConNF.\u03ba`. This theorem is crucial for establishing the well-foundedness of the `\u227a` relation on addresses within the ConNF framework.", "formal_statement": "example [ConNF.Params ] [ConNF.Level] [ConNF.FOAAssumptions] {\u03b2 : ConNF.\u039b} (c : ConNF.Address \u2191\u03b2) :ConNF.Small {d : ConNF.Address \u2191\u03b2 | d \u227a c} := by sorry", "full_tactic_state": "inst\u271d\u00b2 : ConNF.Params\ninst\u271d\u00b9 : ConNF.Level\ninst\u271d : ConNF.FOAAssumptions\n\u03b2 : ConNF.\u039b\nc : ConNF.Address \u2191\u03b2\n\u22a2 ConNF.Small {d | d \u227a c}", "dependency": [1, 60, 233, 60]}, "ConNF.reduced_iff": {"natural_language_statement": "The theorem `ConNF.reduced_iff` states that an address in Constructive Ordinal Notation (ConNF) is reduced (either an atom or a litter) if and only if it is either the left injection of an atom or the right injection of a litter.", "formal_statement": "example [ConNF.Params ] :\u2200 (a : ConNF.Atom \u2295 ConNF.NearLitter), ConNF.Reduced a \u2194 (\u2203 (a_1 : ConNF.Atom), a = Sum.inl a_1) \u2228 \u2203 (L : ConNF.Litter), a = Sum.inr (ConNF.Litter.toNearLitter L) := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u22a2 \u2200 (a : ConNF.Atom \u2295 ConNF.NearLitter),\n    ConNF.Reduced a \u2194 (\u2203 a_1, a = Sum.inl a_1) \u2228 \u2203 L, a = Sum.inr (ConNF.Litter.toNearLitter L)", "dependency": [1, 932, 67, 65, 483]}, "ConNF.isLitter_of_reduced": {"natural_language_statement": "The theorem `ConNF.isLitter_of_reduced` states that if a near-litter `N` is reduced in the context of Constructive Ordinal Notation (ConNF), then `N` is of the form `L.toNearLitter` for some litter `L`.", "formal_statement": "example [ConNF.Params ] {N : ConNF.NearLitter} (h : ConNF.Reduced (Sum.inr N)) :ConNF.NearLitter.IsLitter N := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\nN : ConNF.NearLitter\nh : ConNF.Reduced (Sum.inr N)\n\u22a2 ConNF.NearLitter.IsLitter N", "dependency": [1, 932, 65, 495]}, "ConNF.mem_reflTransClosure_of_mem": {"natural_language_statement": "The theorem `ConNF.mem_reflTransClosure_of_mem` states that if `c` is an element of a set `S` of addresses in the context of Constructive Ordinal Notation (ConNF), then `c` is also an element of the reflexive transitive closure of `S`. This means that `c` can be reached from the addresses in `S` through a finite series of descents.", "formal_statement": "example [ConNF.Params ] [ConNF.Level] [ConNF.FOAAssumptions] {\u03b2 : ConNF.\u039b} (S : Set (ConNF.Address \u2191\u03b2)) (c : ConNF.Address \u2191\u03b2) (hc : c \u2208 S) :c \u2208 ConNF.reflTransClosure S := by sorry", "full_tactic_state": "inst\u271d\u00b2 : ConNF.Params\ninst\u271d\u00b9 : ConNF.Level\ninst\u271d : ConNF.FOAAssumptions\n\u03b2 : ConNF.\u039b\nS : Set (ConNF.Address \u2191\u03b2)\nc : ConNF.Address \u2191\u03b2\nhc : c \u2208 S\n\u22a2 c \u2208 ConNF.reflTransClosure S", "dependency": [1, 69, 60, 60, 935]}, "ConNF.mem_reduction_of_reduced": {"natural_language_statement": "The theorem `mem_reduction_of_reduced` in Constructive Ordinal Notation (ConNF) states that if an address `c` is reduced and belongs to a set of addresses `S`, then `c` also belongs to the reduction of `S`. The reduction of a set of addresses is the intersection of the reflexive transitive closure of the set under the constraints relation and the set of reduced conditions.", "formal_statement": "example [ConNF.Params ] [ConNF.Level] [ConNF.FOAAssumptions] {\u03b2 : ConNF.\u039b} (S : Set (ConNF.Address \u2191\u03b2)) (c : ConNF.Address \u2191\u03b2) (hc\u2081 : ConNF.Reduced c.value) (hc\u2082 : c \u2208 S) :c \u2208 ConNF.reduction S := by sorry", "full_tactic_state": "inst\u271d\u00b2 : ConNF.Params\ninst\u271d\u00b9 : ConNF.Level\ninst\u271d : ConNF.FOAAssumptions\n\u03b2 : ConNF.\u039b\nS : Set (ConNF.Address \u2191\u03b2)\nc : ConNF.Address \u2191\u03b2\nhc\u2081 : ConNF.Reduced c.value\nhc\u2082 : c \u2208 S\n\u22a2 c \u2208 ConNF.reduction S", "dependency": [1, 69, 60, 60, 932, 937]}, "ConNF.mem_reduction_of_reduced_constrains": {"natural_language_statement": "The theorem `mem_reduction_of_reduced_constrains` in Constructive Ordinal Notation (ConNF) states that if `c` is a reduced condition, `c` is constrained by `d`, and `d` is in the set `S`, then `c` is in the reduction of `S`.", "formal_statement": "example [ConNF.Params ] [ConNF.Level] [ConNF.FOAAssumptions] {\u03b2 : ConNF.\u039b} (S : Set (ConNF.Address \u2191\u03b2)) (c : ConNF.Address \u2191\u03b2) (d : ConNF.Address \u2191\u03b2) (hc : ConNF.Reduced c.value) (hcd : c \u227a d) (hd : d \u2208 S) :c \u2208 ConNF.reduction S := by sorry", "full_tactic_state": "inst\u271d\u00b2 : ConNF.Params\ninst\u271d\u00b9 : ConNF.Level\ninst\u271d : ConNF.FOAAssumptions\n\u03b2 : ConNF.\u039b\nS : Set (ConNF.Address \u2191\u03b2)\nc d : ConNF.Address \u2191\u03b2\nhc : ConNF.Reduced c.value\nhcd : c \u227a d\nhd : d \u2208 S\n\u22a2 c \u2208 ConNF.reduction S", "dependency": [1, 69, 60, 60, 60, 932, 937]}, "ConNF.small_nthReduction": {"natural_language_statement": "The `nthClosure` of a small set is small.", "formal_statement": "example [ConNF.Params ] [ConNF.Level] [ConNF.FOAAssumptions] {\u03b2 : ConNF.\u039b} {S : Set (ConNF.Address \u2191\u03b2)} {n : \u2115 } (h : ConNF.Small S) :ConNF.Small (ConNF.nthClosure S n) := by sorry", "full_tactic_state": "inst\u271d\u00b2 : ConNF.Params\ninst\u271d\u00b9 : ConNF.Level\ninst\u271d : ConNF.FOAAssumptions\n\u03b2 : ConNF.\u039b\nS : Set (ConNF.Address \u2191\u03b2)\nn : \u2115\nh : ConNF.Small S\n\u22a2 ConNF.Small (ConNF.nthClosure S n)", "dependency": [1, 69, 60, 233, 233, 940]}, "ConNF.reflTransClosure_eq_iUnion_nthClosure": {"natural_language_statement": "Function `ConNF.reflTransClosure` computes the reflexive transitive closure of a set of addresses in the context of Constructive Ordinal Notation (ConNF). The reflexive transitive closure of a set `S` of addresses is the set of all addresses `c` such that there exists an address `d` in `S` for which `c` is less than or equal to `d`. This function is crucial in the context of ConNF because it allows us to determine the set of all addresses that can be reached from the addresses in `S` through a finite series of descents. The theorem `ConNF.reflTransClosure_eq_iUnion_nthClosure` states that the reflexive transitive closure of a set `S` is equal to the `\u2115`-indexed union of the `n`th closures of `S`.", "formal_statement": "example [ConNF.Params ] [ConNF.Level] [ConNF.FOAAssumptions] {\u03b2 : ConNF.\u039b} {S : Set (ConNF.Address \u2191\u03b2)} :ConNF.reflTransClosure S = \u22c3 (n : \u2115 ), ConNF.nthClosure S n := by sorry", "full_tactic_state": "inst\u271d\u00b2 : ConNF.Params\ninst\u271d\u00b9 : ConNF.Level\ninst\u271d : ConNF.FOAAssumptions\n\u03b2 : ConNF.\u039b\nS : Set (ConNF.Address \u2191\u03b2)\n\u22a2 ConNF.reflTransClosure S = \u22c3 n, ConNF.nthClosure S n", "dependency": [1, 69, 60, 935, 940]}, "ConNF.reflTransClosure_small": {"natural_language_statement": "The theorem `ConNF.reflTransClosure_small` states that the reflexive transitive closure of a small set of addresses in the context of Constructive Ordinal Notation (ConNF) is also small. This result is crucial because it ensures that the set of all addresses that can be reached from a small set of addresses through a finite series of descents remains small.", "formal_statement": "example [ConNF.Params ] [ConNF.Level] [ConNF.FOAAssumptions] {\u03b2 : ConNF.\u039b} {S : Set (ConNF.Address \u2191\u03b2)} (h : ConNF.Small S) :ConNF.Small (ConNF.reflTransClosure S) := by sorry", "full_tactic_state": "inst\u271d\u00b2 : ConNF.Params\ninst\u271d\u00b9 : ConNF.Level\ninst\u271d : ConNF.FOAAssumptions\n\u03b2 : ConNF.\u039b\nS : Set (ConNF.Address \u2191\u03b2)\nh : ConNF.Small S\n\u22a2 ConNF.Small (ConNF.reflTransClosure S)", "dependency": [1, 69, 60, 233, 233, 935]}, "ConNF.transClosure_small": {"natural_language_statement": "In the context of Constructive Ordinal Notation (ConNF), the transitive closure of a small set is also small.", "formal_statement": "example [ConNF.Params ] [ConNF.Level] [ConNF.FOAAssumptions] {\u03b2 : ConNF.\u039b} {S : Set (ConNF.Address \u2191\u03b2)} (h : ConNF.Small S) :ConNF.Small (ConNF.transClosure S) := by sorry", "full_tactic_state": "inst\u271d\u00b2 : ConNF.Params\ninst\u271d\u00b9 : ConNF.Level\ninst\u271d : ConNF.FOAAssumptions\n\u03b2 : ConNF.\u039b\nS : Set (ConNF.Address \u2191\u03b2)\nh : ConNF.Small S\n\u22a2 ConNF.Small (ConNF.transClosure S)", "dependency": [1, 69, 60, 233, 233, 944]}, "ConNF.reduction_small": {"natural_language_statement": "Function `ConNF.reduction_small` proves that the reduction of a small set is also small in the context of Constructive Ordinal Notation (ConNF).", "formal_statement": "example [ConNF.Params ] [ConNF.Level] [ConNF.FOAAssumptions] {\u03b2 : ConNF.\u039b} {S : Set (ConNF.Address \u2191\u03b2)} (h : ConNF.Small S) :ConNF.Small (ConNF.reduction S) := by sorry", "full_tactic_state": "inst\u271d\u00b2 : ConNF.Params\ninst\u271d\u00b9 : ConNF.Level\ninst\u271d : ConNF.FOAAssumptions\n\u03b2 : ConNF.\u039b\nS : Set (ConNF.Address \u2191\u03b2)\nh : ConNF.Small S\n\u22a2 ConNF.Small (ConNF.reduction S)", "dependency": [1, 69, 60, 233, 233, 937]}, "ConNF.reduction_supports": {"natural_language_statement": "Given the Lean 4 object `ConNF.reduction_supports`, which is a theorem in the context of Constructive Ordinal Notation (ConNF) in Lean 4, it states that the reduction of a set of addresses supports every element in its domain under the action of structural permutations. This theorem is useful in proving the existence of a permutation that normalizes the addresses within the set.", "formal_statement": "example [ConNF.Params ] [ConNF.Level] [ConNF.FOAAssumptions] {\u03b2 : ConNF.\u039b} (S : Set (ConNF.Address \u2191\u03b2)) (c : ConNF.Address \u2191\u03b2) (hc : c \u2208 S) :MulAction.Supports (ConNF.StructPerm \u2191\u03b2) (ConNF.reduction S) c := by sorry", "full_tactic_state": "inst\u271d\u00b2 : ConNF.Params\ninst\u271d\u00b9 : ConNF.Level\ninst\u271d : ConNF.FOAAssumptions\n\u03b2 : ConNF.\u039b\nS : Set (ConNF.Address \u2191\u03b2)\nc : ConNF.Address \u2191\u03b2\nhc : c \u2208 S\n\u22a2 MulAction.Supports (ConNF.StructPerm \u2191\u03b2) (ConNF.reduction S) c", "dependency": [1, 69, 60, 60, 68, 55, 937]}, "ConNF.reduction_support_supports": {"natural_language_statement": "In the context of Constructive Ordinal Notation (ConNF), the theorem `ConNF.reduction_support_supports` asserts that for any tangle `t` at level `\u03b2`, the reduction of the carrier set of the small support of `t` supports `t` under the action of the allowable permutations at level `\u03b2`. This means that if an allowable permutation acts trivially on every element in the reduction of the small support of `t`, then it also acts trivially on `t`.", "formal_statement": "example [ConNF.Params ] [ConNF.Level] [ConNF.FOAAssumptions] {\u03b2 : ConNF.\u039b} [ConNF.TangleData \u2191\u03b2] (t : ConNF.Tangle \u2191\u03b2) :MulAction.Supports (ConNF.Allowable \u2191\u03b2) (ConNF.reduction (ConNF.Enumeration.carrier (ConNF.TangleData.Tangle.support t).enum)) t := by sorry", "full_tactic_state": "inst\u271d\u00b3 : ConNF.Params\ninst\u271d\u00b2 : ConNF.Level\ninst\u271d\u00b9 : ConNF.FOAAssumptions\n\u03b2 : ConNF.\u039b\ninst\u271d : ConNF.TangleData \u2191\u03b2\nt : ConNF.Tangle \u2191\u03b2\n\u22a2 MulAction.Supports (ConNF.Allowable \u2191\u03b2)\n    (ConNF.reduction (ConNF.Enumeration.carrier (ConNF.TangleData.Tangle.support t).enum)) t", "dependency": [1, 39, 68, 937, 70, 395]}, "PartialPerm.exists_sandbox_subset": {"natural_language_statement": "Given a type \u03b1 and a function f : \u03b1 \u2192 \u03b1, the symmetric difference of two sets s and f '' s is defined as the union of the relative complements s \\ f '' s and f '' s \\ s. This theorem states that if the cardinality of this symmetric difference is at most the cardinality of a set t (hypothesis hs), and the set t has at least the cardinality of the natural numbers (hypothesis ht), then the cardinality of the disjoint union of the natural numbers and the relative complements s \\ f '' s and f '' s \\ s is also at most the cardinality of the set t.", "formal_statement": "example {\u03b1 : Type u_1} {f : \u03b1 \u2192 \u03b1} {s : Set \u03b1} {t : Set \u03b1} (hs : Cardinal.mk \u2191(symmDiff s (f '' s)) \u2264 Cardinal.mk \u2191t) (ht : Cardinal.aleph0 \u2264 Cardinal.mk \u2191t) :Cardinal.mk (\u2115 \u00d7 \u2191(s \\ f '' s) \u2295 \u2115 \u00d7 \u2191(f '' s \\ s)) \u2264 Cardinal.mk \u2191t := by sorry", "full_tactic_state": "\u03b1 : Type u_1\nf : \u03b1 \u2192 \u03b1\ns t : Set \u03b1\nhs : Cardinal.mk \u2191(symmDiff s (f '' s)) \u2264 Cardinal.mk \u2191t\nht : Cardinal.aleph0 \u2264 Cardinal.mk \u2191t\n\u22a2 Cardinal.mk (\u2115 \u00d7 \u2191(s \\ f '' s) \u2295 \u2115 \u00d7 \u2191(f '' s \\ s)) \u2264 Cardinal.mk \u2191t", "dependency": [69, 69, 29, 62, 29, 510, 29, 29, 29]}, "PartialPerm.sandboxSubset_subset": {"natural_language_statement": "`PartialPerm.sandboxSubset_subset` is a theorem stating that if the symmetric difference of a set `s` and its image under a function `f` is at most as large as a set `t`, and `t` has at least the cardinality of the natural numbers (denoted as `\u2135\u2080`), then the sandbox subset of `t` created by `PartialPerm.sandboxSubset` is a subset of `t`.", "formal_statement": "example {\u03b1 : Type u_1} {f : \u03b1 \u2192 \u03b1} {s : Set \u03b1} {t : Set \u03b1} (hs : Cardinal.mk \u2191(symmDiff s (f '' s)) \u2264 Cardinal.mk \u2191t) (ht : Cardinal.aleph0 \u2264 Cardinal.mk \u2191t) :PartialPerm.sandboxSubset hs ht \u2286 t := by sorry", "full_tactic_state": "\u03b1 : Type u_1\nf : \u03b1 \u2192 \u03b1\ns t : Set \u03b1\nhs : Cardinal.mk \u2191(symmDiff s (f '' s)) \u2264 Cardinal.mk \u2191t\nht : Cardinal.aleph0 \u2264 Cardinal.mk \u2191t\n\u22a2 PartialPerm.sandboxSubset hs ht \u2286 t", "dependency": [69, 69, 29, 62, 29, 510, 29, 950]}, "PartialPerm.completeToFun_domain": {"natural_language_statement": "Function `CompleteToFun` is an internal implementation detail used in the `Equiv` construction to complete a permutation. It is used only as a stepping stone to complete the permutation by placing the remaining elements in their correct positions. The final result of this function is a permutation that extends the given partial permutation to a full permutation, and hence is not relevant for a high-level understanding of the mathematical concepts involved. Instead, one should focus on the lemmas and theorems surrounding `Complete`, which are the actual mathematical components of the `PartialPerm` theory.", "formal_statement": "example {\u03b1 : Type u_1} {f : \u03b1 \u2192 \u03b1} {s : Set \u03b1} {t : Set \u03b1} (hs : Cardinal.mk \u2191(symmDiff s (f '' s)) \u2264 Cardinal.mk \u2191t) (ht : Cardinal.aleph0 \u2264 Cardinal.mk \u2191t) (x : \u03b1) (h : x \u2208 PartialPerm.completeDomain hs ht) :PartialPerm.completeToFun hs ht x \u2208 PartialPerm.completeDomain hs ht := by sorry", "full_tactic_state": "\u03b1 : Type u_1\nf : \u03b1 \u2192 \u03b1\ns t : Set \u03b1\nhs : Cardinal.mk \u2191(symmDiff s (f '' s)) \u2264 Cardinal.mk \u2191t\nht : Cardinal.aleph0 \u2264 Cardinal.mk \u2191t\nx : \u03b1\nh : x \u2208 PartialPerm.completeDomain hs ht\n\u22a2 PartialPerm.completeToFun hs ht x \u2208 PartialPerm.completeDomain hs ht", "dependency": [69, 69, 29, 62, 29, 510, 29, 952, 953, 952]}, "PartialPerm.completeInvFun_domain": {"natural_language_statement": "Function `PartialPerm.completeInvFun` is a noncomputable function that completes the inverse of a partial permutation `f` defined on a subset `s` of a type `\u03b1`, where `s` and `t` are subsets of `\u03b1` such that the symmetric difference of `s` and the image of `s` under `f` has a cardinality less than or equal to the cardinality of `t`, and `t` has a cardinality greater than or equal to the smallest infinite cardinal number `\u2135\u2080`. The function returns an element of `\u03b1` based on the conditions provided.", "formal_statement": "example {\u03b1 : Type u_1} {f : \u03b1 \u2192 \u03b1} {s : Set \u03b1} {t : Set \u03b1} (hs : Cardinal.mk \u2191(symmDiff s (f '' s)) \u2264 Cardinal.mk \u2191t) (ht : Cardinal.aleph0 \u2264 Cardinal.mk \u2191t) [Nonempty \u03b1] (x : \u03b1) (h : x \u2208 PartialPerm.completeDomain hs ht) :PartialPerm.completeInvFun hs ht x \u2208 PartialPerm.completeDomain hs ht := by sorry", "full_tactic_state": "\u03b1 : Type u_1\nf : \u03b1 \u2192 \u03b1\ns t : Set \u03b1\nhs : Cardinal.mk \u2191(symmDiff s (f '' s)) \u2264 Cardinal.mk \u2191t\nht : Cardinal.aleph0 \u2264 Cardinal.mk \u2191t\ninst\u271d : Nonempty \u03b1\nx : \u03b1\nh : x \u2208 PartialPerm.completeDomain hs ht\n\u22a2 PartialPerm.completeInvFun hs ht x \u2208 PartialPerm.completeDomain hs ht", "dependency": [69, 69, 29, 62, 29, 510, 29, 212, 952, 955, 952]}, "PartialPerm.complete_left_inv": {"natural_language_statement": "Given a partial permutation `f` defined on a subset `s` of a type `\u03b1`, where `s` and `t` are subsets of `\u03b1` such that the symmetric difference of `s` and the image of `s` under `f` has a cardinality less than or equal to the cardinality of `t`, and `t` has a cardinality greater than or equal to the smallest infinite cardinal number `\u2135\u2080`, and the union of `s` and the image of `s` under `f` is disjoint from `t`, and `f` is injective on `s`, then the completion of `f` to a local permutation is a left inverse.", "formal_statement": "example {\u03b1 : Type u_1} {f : \u03b1 \u2192 \u03b1} {s : Set \u03b1} {t : Set \u03b1} (hs : Cardinal.mk \u2191(symmDiff s (f '' s)) \u2264 Cardinal.mk \u2191t) (ht : Cardinal.aleph0 \u2264 Cardinal.mk \u2191t) [Nonempty \u03b1] (hst : Disjoint (s \u222a f '' s) t) (hf : Set.InjOn f s) (x : \u03b1) (h : x \u2208 PartialPerm.completeDomain hs ht) :PartialPerm.completeInvFun hs ht (PartialPerm.completeToFun hs ht x) = x := by sorry", "full_tactic_state": "\u03b1 : Type u_1\nf : \u03b1 \u2192 \u03b1\ns t : Set \u03b1\nhs : Cardinal.mk \u2191(symmDiff s (f '' s)) \u2264 Cardinal.mk \u2191t\nht : Cardinal.aleph0 \u2264 Cardinal.mk \u2191t\ninst\u271d : Nonempty \u03b1\nhst : Disjoint (s \u222a f '' s) t\nhf : Set.InjOn f s\nx : \u03b1\nh : x \u2208 PartialPerm.completeDomain hs ht\n\u22a2 PartialPerm.completeInvFun hs ht (PartialPerm.completeToFun hs ht x) = x", "dependency": [69, 69, 29, 62, 29, 510, 29, 212, 757, 111, 952, 955, 953]}, "PartialPerm.complete_right_inv": {"natural_language_statement": "The `PartialPerm.complete_right_inv` theorem in Lean 4 states that for a partial permutation `f` defined on a subset `s` of a type `\u03b1`, with `s` and `t` being subsets of `\u03b1` such that the symmetric difference of `s` and the image of `s` under `f` has a cardinality less than or equal to the cardinality of `t`, and `t` having a cardinality greater than or equal to the smallest infinite cardinal number `\u2135\u2080`, if `s \u222a f '' s` and `t` are disjoint, and `f` is injective on `s`, then the completion of `f` to a local permutation, when applied to the completion of its inverse, returns the original element.", "formal_statement": "example {\u03b1 : Type u_1} {f : \u03b1 \u2192 \u03b1} {s : Set \u03b1} {t : Set \u03b1} (hs : Cardinal.mk \u2191(symmDiff s (f '' s)) \u2264 Cardinal.mk \u2191t) (ht : Cardinal.aleph0 \u2264 Cardinal.mk \u2191t) [Nonempty \u03b1] (hst : Disjoint (s \u222a f '' s) t) (hf : Set.InjOn f s) (x : \u03b1) (h : x \u2208 PartialPerm.completeDomain hs ht) :PartialPerm.completeToFun hs ht (PartialPerm.completeInvFun hs ht x) = x := by sorry", "full_tactic_state": "\u03b1 : Type u_1\nf : \u03b1 \u2192 \u03b1\ns t : Set \u03b1\nhs : Cardinal.mk \u2191(symmDiff s (f '' s)) \u2264 Cardinal.mk \u2191t\nht : Cardinal.aleph0 \u2264 Cardinal.mk \u2191t\ninst\u271d : Nonempty \u03b1\nhst : Disjoint (s \u222a f '' s) t\nhf : Set.InjOn f s\nx : \u03b1\nh : x \u2208 PartialPerm.completeDomain hs ht\n\u22a2 PartialPerm.completeToFun hs ht (PartialPerm.completeInvFun hs ht x) = x", "dependency": [69, 69, 29, 62, 29, 510, 29, 212, 757, 111, 952, 953, 955]}, "PartialPerm.completeDomain_eq": {"natural_language_statement": "Function `PartialPerm.complete` completes a function `f` on a domain `s` into a local permutation that agrees with `f` on `s`, with domain contained in `s \u222a (f '' s) \u222a t`, where `t` is a set that is disjoint from `s \u222a (f '' s)` and has at least the cardinality of the natural numbers `\u2135\u2080`. The function `f` must be injective on `s`. Function `PartialPerm.completeDomain` defines the domain on which we will define the completion of a function to a local permutation. This domain is the union of three sets: the original set `s`, the image of `s` under the function `f`, and an additional set `sandboxSubset hs ht` which depends on the given conditions `hs` and `ht`.", "formal_statement": "@[simp]example {\u03b1 : Type u_1} {f : \u03b1 \u2192 \u03b1} {s : Set \u03b1} {t : Set \u03b1} (hs : Cardinal.mk \u2191(symmDiff s (f '' s)) \u2264 Cardinal.mk \u2191t) (ht : Cardinal.aleph0 \u2264 Cardinal.mk \u2191t) [Nonempty \u03b1] {hst : Disjoint (s \u222a f '' s) t} {hf : Set.InjOn f s} :(PartialPerm.complete f s t hs ht hst hf).domain = PartialPerm.completeDomain hs ht := by sorry", "full_tactic_state": "\u03b1 : Type u_1\nf : \u03b1 \u2192 \u03b1\ns t : Set \u03b1\nhs : Cardinal.mk \u2191(symmDiff s (f '' s)) \u2264 Cardinal.mk \u2191t\nht : Cardinal.aleph0 \u2264 Cardinal.mk \u2191t\ninst\u271d : Nonempty \u03b1\nhst : Disjoint (s \u222a f '' s) t\nhf : Set.InjOn f s\n\u22a2 (PartialPerm.complete f s t hs ht hst hf).domain = PartialPerm.completeDomain hs ht", "dependency": [69, 69, 29, 62, 29, 510, 29, 212, 757, 111, 959, 952]}, "PartialPerm.mem_completeDomain_of_mem": {"natural_language_statement": "Function `mem_completeDomain_of_mem` proves that if `x` is an element of `s`, then `x` is also an element of `PartialPerm.completeDomain hs ht`.", "formal_statement": "example {\u03b1 : Type u_1} {f : \u03b1 \u2192 \u03b1} {s : Set \u03b1} {t : Set \u03b1} (hs : Cardinal.mk \u2191(symmDiff s (f '' s)) \u2264 Cardinal.mk \u2191t) (ht : Cardinal.aleph0 \u2264 Cardinal.mk \u2191t) (x : \u03b1) (hx : x \u2208 s) :x \u2208 PartialPerm.completeDomain hs ht := by sorry", "full_tactic_state": "\u03b1 : Type u_1\nf : \u03b1 \u2192 \u03b1\ns t : Set \u03b1\nhs : Cardinal.mk \u2191(symmDiff s (f '' s)) \u2264 Cardinal.mk \u2191t\nht : Cardinal.aleph0 \u2264 Cardinal.mk \u2191t\nx : \u03b1\nhx : x \u2208 s\n\u22a2 x \u2208 PartialPerm.completeDomain hs ht", "dependency": [69, 69, 29, 62, 29, 510, 29, 952]}, "PartialPerm.mem_completeDomain_of_mem_image": {"natural_language_statement": "The theorem `mem_completeDomain_of_mem_image` states that if the cardinality of the symmetric difference between a set `s` and its image under a function `f` is less than or equal to the cardinality of a set `t`, and the cardinality of `t` is greater than or equal to the cardinality of the natural numbers, then for any element `x` in the image of `s` under `f`, `x` also belongs to the complete domain of the partial permutation.", "formal_statement": "example {\u03b1 : Type u_1} {f : \u03b1 \u2192 \u03b1} {s : Set \u03b1} {t : Set \u03b1} (hs : Cardinal.mk \u2191(symmDiff s (f '' s)) \u2264 Cardinal.mk \u2191t) (ht : Cardinal.aleph0 \u2264 Cardinal.mk \u2191t) (x : \u03b1) (hx : x \u2208 f '' s) :x \u2208 PartialPerm.completeDomain hs ht := by sorry", "full_tactic_state": "\u03b1 : Type u_1\nf : \u03b1 \u2192 \u03b1\ns t : Set \u03b1\nhs : Cardinal.mk \u2191(symmDiff s (f '' s)) \u2264 Cardinal.mk \u2191t\nht : Cardinal.aleph0 \u2264 Cardinal.mk \u2191t\nx : \u03b1\nhx : x \u2208 f '' s\n\u22a2 x \u2208 PartialPerm.completeDomain hs ht", "dependency": [69, 69, 29, 62, 29, 510, 29, 952]}, "PartialPerm.not_mem_sandbox_of_mem": {"natural_language_statement": "`PartialPerm.not_mem_sandbox_of_mem` is a theorem in Lean 4 that states that if the cardinality of the symmetric difference between a set `s` and the image of `s` under a function `f` is less than or equal to the cardinality of a set `t`, and if the cardinality of `t` is infinite, and if the union of `s` and the image of `s` under `f` is disjoint from `t`, then for any element `x` in `s`, `x` is not in the sandbox subset of `t`.", "formal_statement": "example {\u03b1 : Type u_1} {f : \u03b1 \u2192 \u03b1} {s : Set \u03b1} {t : Set \u03b1} (hs : Cardinal.mk \u2191(symmDiff s (f '' s)) \u2264 Cardinal.mk \u2191t) (ht : Cardinal.aleph0 \u2264 Cardinal.mk \u2191t) (hst : Disjoint (s \u222a f '' s) t) (x : \u03b1) (hx : x \u2208 s) :x \u2209 PartialPerm.sandboxSubset hs ht := by sorry", "full_tactic_state": "\u03b1 : Type u_1\nf : \u03b1 \u2192 \u03b1\ns t : Set \u03b1\nhs : Cardinal.mk \u2191(symmDiff s (f '' s)) \u2264 Cardinal.mk \u2191t\nht : Cardinal.aleph0 \u2264 Cardinal.mk \u2191t\nhst : Disjoint (s \u222a f '' s) t\nx : \u03b1\nhx : x \u2208 s\n\u22a2 x \u2209 PartialPerm.sandboxSubset hs ht", "dependency": [69, 69, 29, 62, 29, 510, 29, 757, 950]}, "PartialPerm.not_mem_sandbox_of_mem_image": {"natural_language_statement": "The theorem `not_mem_sandbox_of_mem_image` states that if the symmetric difference between a set `s` and its image under a function `f` has a cardinality less than or equal to the cardinality of a set `t`, and `t` is disjoint from the union of `s` and its image under `f`, then any element in the image of `s` under `f` does not belong to the sandbox subset of `t`.", "formal_statement": "example {\u03b1 : Type u_1} {f : \u03b1 \u2192 \u03b1} {s : Set \u03b1} {t : Set \u03b1} (hs : Cardinal.mk \u2191(symmDiff s (f '' s)) \u2264 Cardinal.mk \u2191t) (ht : Cardinal.aleph0 \u2264 Cardinal.mk \u2191t) (hst : Disjoint (s \u222a f '' s) t) (x : \u03b1) (hx : x \u2208 f '' s) :x \u2209 PartialPerm.sandboxSubset hs ht := by sorry", "full_tactic_state": "\u03b1 : Type u_1\nf : \u03b1 \u2192 \u03b1\ns t : Set \u03b1\nhs : Cardinal.mk \u2191(symmDiff s (f '' s)) \u2264 Cardinal.mk \u2191t\nht : Cardinal.aleph0 \u2264 Cardinal.mk \u2191t\nhst : Disjoint (s \u222a f '' s) t\nx : \u03b1\nhx : x \u2208 f '' s\n\u22a2 x \u2209 PartialPerm.sandboxSubset hs ht", "dependency": [69, 69, 29, 62, 29, 510, 29, 757, 950]}, "PartialPerm.complete_apply_eq": {"natural_language_statement": "The `partialPerm.complete_apply_eq` theorem in Lean 4 shows that, given a function `f` that is injective on a set `s`, and a set `t` such that the symmetric difference between `s` and `f '' s` (the image of `s` under `f`) is smaller than or equal to `t` and `t` has at least the cardinality of the natural numbers, the function `f` itself is equal to the complete function `partialPerm.complete f s t hs ht hst hf` when restricted to `s`.", "formal_statement": "@[simp]example {\u03b1 : Type u_1} {f : \u03b1 \u2192 \u03b1} {s : Set \u03b1} {t : Set \u03b1} (hs : Cardinal.mk \u2191(symmDiff s (f '' s)) \u2264 Cardinal.mk \u2191t) (ht : Cardinal.aleph0 \u2264 Cardinal.mk \u2191t) [Nonempty \u03b1] {hst : Disjoint (s \u222a f '' s) t} {hf : Set.InjOn f s} (x : \u03b1) (hx : x \u2208 s) :(PartialPerm.complete f s t hs ht hst hf).toFun x = f x := by sorry", "full_tactic_state": "\u03b1 : Type u_1\nf : \u03b1 \u2192 \u03b1\ns t : Set \u03b1\nhs : Cardinal.mk \u2191(symmDiff s (f '' s)) \u2264 Cardinal.mk \u2191t\nht : Cardinal.aleph0 \u2264 Cardinal.mk \u2191t\ninst\u271d : Nonempty \u03b1\nhst : Disjoint (s \u222a f '' s) t\nhf : Set.InjOn f s\nx : \u03b1\nhx : x \u2208 s\n\u22a2 (PartialPerm.complete f s t hs ht hst hf).toFun x = f x", "dependency": [69, 69, 29, 62, 29, 510, 29, 212, 757, 111, 959]}, "ConNF.StructApprox.atom_injective_extends": {"natural_language_statement": "In the context of Constructive Ordinal Notation (ConNF), the theorem `ConNF.StructApprox.atom_injective_extends` states that, given a `\u03b2`-structural approximation `\u03c0` and two addresses `c` and `d` such that the `\u03b2`-structural action `ConNF.StructApprox.ihsAction \u03c0 c d` is lawful, if two atoms `a` and `b` are mapped to the same atom by the function `ConNF.StructApprox.completeAtomMap \u03c0 A` for some `\u03b2`-extended index `A`, then `a` must be equal to `b`.", "formal_statement": "example [ConNF.Params ] [ConNF.Level] [ConNF.FOAAssumptions] {\u03b2 : ConNF.\u039b} [ConNF.LeLevel \u2191\u03b2] [ConNF.StructApprox.FreedomOfActionHypothesis \u03b2] {\u03c0 : ConNF.StructApprox \u2191\u03b2} {c : ConNF.Address \u2191\u03b2} {d : ConNF.Address \u2191\u03b2} (hcd : ConNF.StructAction.Lawful (ConNF.StructApprox.ihsAction \u03c0 c d)) {a : ConNF.Atom} {b : ConNF.Atom} {A : ConNF.ExtendedIndex \u2191\u03b2} (hac : { path := A, value := Sum.inl a } \u2208 ConNF.StructApprox.reflTransConstrained c d) (hbc : { path := A, value := Sum.inl b } \u2208 ConNF.StructApprox.reflTransConstrained c d) (h : ConNF.StructApprox.completeAtomMap \u03c0 A a = ConNF.StructApprox.completeAtomMap \u03c0 A b) :a = b := by sorry", "full_tactic_state": "inst\u271d\u2074 : ConNF.Params\ninst\u271d\u00b3 : ConNF.Level\ninst\u271d\u00b2 : ConNF.FOAAssumptions\n\u03b2 : ConNF.\u039b\ninst\u271d\u00b9 : ConNF.LeLevel \u2191\u03b2\ninst\u271d : ConNF.StructApprox.FreedomOfActionHypothesis \u03b2\n\u03c0 : ConNF.StructApprox \u2191\u03b2\nc d : ConNF.Address \u2191\u03b2\nhcd : ConNF.StructAction.Lawful (ConNF.StructApprox.ihsAction \u03c0 c d)\na b : ConNF.Atom\nA : ConNF.ExtendedIndex \u2191\u03b2\nhac : { path := A, value := Sum.inl a } \u2208 ConNF.StructApprox.reflTransConstrained c d\nhbc : { path := A, value := Sum.inl b } \u2208 ConNF.StructApprox.reflTransConstrained c d\nh : ConNF.StructApprox.completeAtomMap \u03c0 A a = ConNF.StructApprox.completeAtomMap \u03c0 A b\n\u22a2 a = b", "dependency": [1, 402, 779, 781, 60, 60, 809, 966, 61, 67, 967, 67, 967, 784, 784]}, "ConNF.StructApprox.inOut_def": {"natural_language_statement": "The theorem `ConNF.StructApprox.inOut_def` states that for a near litter permutation `\u03c0`, an atom `a`, and a litter `L`, the predicate `ConNF.StructApprox.InOut \u03c0 a L` holds if and only if either `a` is equal to `L` or `\u03c0 \u2022 a` is equal to `\u03c0 \u2022 L`, but not both.", "formal_statement": "example [ConNF.Params ] {\u03c0 : ConNF.NearLitterPerm} {a : ConNF.Atom} {L : ConNF.Litter} :ConNF.StructApprox.InOut \u03c0 a L \u2194 Xor' (a.1 = L) ((\u03c0 \u2022 a).1 = \u03c0 \u2022 L) := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03c0 : ConNF.NearLitterPerm\na : ConNF.Atom\nL : ConNF.Litter\n\u22a2 ConNF.StructApprox.InOut \u03c0 a L \u2194 Xor' (a.1 = L) ((\u03c0 \u2022 a).1 = \u03c0 \u2022 L)", "dependency": [1, 969, 970]}, "ConNF.StructApprox.isException_of_inOut": {"natural_language_statement": "In the context of Constructive Ordinal Notation (ConNF), given a near litter permutation `\u03c0`, an atom `a`, and a litter `L`, if either `a` is equal to `L` or `\u03c0 \u2022 a` is equal to `\u03c0 \u2022 L`, but not both, then either `\u03c0` is an exception with respect to `a` or `\u03c0` is an exception with respect to `\u03c0 \u2022 a`.", "formal_statement": "example [ConNF.Params ] {\u03c0 : ConNF.NearLitterPerm} {a : ConNF.Atom} {L : ConNF.Litter} :ConNF.StructApprox.InOut \u03c0 a L \u2192 ConNF.NearLitterPerm.IsException \u03c0 a \u2228 ConNF.NearLitterPerm.IsException \u03c0 (\u03c0 \u2022 a) := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03c0 : ConNF.NearLitterPerm\na : ConNF.Atom\nL : ConNF.Litter\n\u22a2 ConNF.StructApprox.InOut \u03c0 a L \u2192 ConNF.NearLitterPerm.IsException \u03c0 a \u2228 ConNF.NearLitterPerm.IsException \u03c0 (\u03c0 \u2022 a)", "dependency": [1, 969, 801, 801]}, "ConNF.StructApprox.Biexact.constrains": {"natural_language_statement": "The theorem `ConNF.StructApprox.Biexact.constrains` states that if two structural permutations `\u03c0` and `\u03c0'` are biexact with respect to an address `c`, and `d` is an address that is less than or equal to `c`, then `\u03c0` and `\u03c0'` are also biexact with respect to `d`.", "formal_statement": "example [ConNF.Params ] [ConNF.Level] [ConNF.FOAAssumptions] {\u03b2 : ConNF.\u039b} {\u03c0 : ConNF.StructPerm \u2191\u03b2} {\u03c0' : ConNF.StructPerm \u2191\u03b2} {c : ConNF.Address \u2191\u03b2} {d : ConNF.Address \u2191\u03b2} (h : ConNF.StructApprox.Biexact \u03c0 \u03c0' c) (h' : d \u2264 c) :ConNF.StructApprox.Biexact \u03c0 \u03c0' d := by sorry", "full_tactic_state": "inst\u271d\u00b2 : ConNF.Params\ninst\u271d\u00b9 : ConNF.Level\ninst\u271d : ConNF.FOAAssumptions\n\u03b2 : ConNF.\u039b\n\u03c0 \u03c0' : ConNF.StructPerm \u2191\u03b2\nc d : ConNF.Address \u2191\u03b2\nh : ConNF.StructApprox.Biexact \u03c0 \u03c0' c\nh' : d \u2264 c\n\u22a2 ConNF.StructApprox.Biexact \u03c0 \u03c0' d", "dependency": [1, 55, 55, 60, 60, 973, 973]}, "ConNF.StructApprox.Biexact.smul_eq_smul": {"natural_language_statement": "In the context of Constructive Ordinal Notation (ConNF), the theorem `ConNF.StructApprox.Biexact.smul_eq_smul` states that if two structural permutations `\u03c0` and `\u03c0'` are biexact with respect to a given address `c`, then `\u03c0 \u2022 c = \u03c0' \u2022 c`. This property is crucial in ensuring that the construction of the natural numbers in ConNF is well-defined and consistent. Specifically, it requires that for any extended index `A` and any atom `a`, if `\u27e8A, inl a\u27e9 \u2264 c`, then `\u03c0 A \u2022 a = \u03c0' A \u2022 a`. Additionally, for any extended index `A` and any litter `L`, if `\u27e8A, inr L.toNearLitter\u27e9 \u2264 c` and `L` is flexible, then `\u03c0 A \u2022 L = \u03c0' A \u2022 L`. Lastly, for any extended index `A` and any litter `L`, if `\u27e8A, inr L.toNearLitter\u27e9 \u2264 c` and `\u03c0 A \u2022 L = \u03c0' A \u2022 L`, then `\u03c0 A \u2022 L.toNearLitter = \u03c0' A \u2022 L.toNearLitter`.", "formal_statement": "example [ConNF.Params ] [ConNF.Level] [ConNF.FOAAssumptions] {\u03b2 : ConNF.\u039b} [ConNF.LeLevel \u2191\u03b2] {\u03c0 : ConNF.Allowable \u2191\u03b2} {\u03c0' : ConNF.Allowable \u2191\u03b2} {c : ConNF.Address \u2191\u03b2} (h : ConNF.StructApprox.Biexact (ConNF.Allowable.toStructPerm \u03c0) (ConNF.Allowable.toStructPerm \u03c0') c) :\u03c0 \u2022 c = \u03c0' \u2022 c := by sorry", "full_tactic_state": "inst\u271d\u00b3 : ConNF.Params\ninst\u271d\u00b2 : ConNF.Level\ninst\u271d\u00b9 : ConNF.FOAAssumptions\n\u03b2 : ConNF.\u039b\ninst\u271d : ConNF.LeLevel \u2191\u03b2\n\u03c0 \u03c0' : ConNF.Allowable \u2191\u03b2\nc : ConNF.Address \u2191\u03b2\nh : ConNF.StructApprox.Biexact (ConNF.Allowable.toStructPerm \u03c0) (ConNF.Allowable.toStructPerm \u03c0') c\n\u22a2 \u03c0 \u2022 c = \u03c0' \u2022 c", "dependency": [1, 402, 60, 973]}, "ConNF.StructApprox.Biexact.smul_eq_smul_nearLitter": {"natural_language_statement": "The theorem `ConNF.StructApprox.Biexact.smul_eq_smul_nearLitter` states that, within the context of Constructive Ordinal Notation (ConNF), for two structural permutations `\u03c0` and `\u03c0'` that are *biexact* with respect to a given address `c`, and for any extended index `A` and any near litter `N` such that `\u27e8A, inr N\u27e9 \u2264 c`, the result of applying `\u03c0 A` to `N` is equal to the result of applying `\u03c0' A` to `N`. This is a key property in ensuring the consistency of the construction of the natural numbers in ConNF.", "formal_statement": "example [ConNF.Params ] [ConNF.Level] [ConNF.FOAAssumptions] {\u03b2 : ConNF.\u039b} [ConNF.LeLevel \u2191\u03b2] {\u03c0 : ConNF.Allowable \u2191\u03b2} {\u03c0' : ConNF.Allowable \u2191\u03b2} {A : ConNF.ExtendedIndex \u2191\u03b2} {N : ConNF.NearLitter} (h : ConNF.StructApprox.Biexact (ConNF.Allowable.toStructPerm \u03c0) (ConNF.Allowable.toStructPerm \u03c0') { path := A, value := Sum.inr N }) :ConNF.Allowable.toStructPerm \u03c0 A \u2022 N = ConNF.Allowable.toStructPerm \u03c0' A \u2022 N := by sorry", "full_tactic_state": "inst\u271d\u00b3 : ConNF.Params\ninst\u271d\u00b2 : ConNF.Level\ninst\u271d\u00b9 : ConNF.FOAAssumptions\n\u03b2 : ConNF.\u039b\ninst\u271d : ConNF.LeLevel \u2191\u03b2\n\u03c0 \u03c0' : ConNF.Allowable \u2191\u03b2\nA : ConNF.ExtendedIndex \u2191\u03b2\nN : ConNF.NearLitter\nh :\n  ConNF.StructApprox.Biexact (ConNF.Allowable.toStructPerm \u03c0) (ConNF.Allowable.toStructPerm \u03c0')\n    { path := A, value := Sum.inr N }\n\u22a2 ConNF.Allowable.toStructPerm \u03c0 A \u2022 N = ConNF.Allowable.toStructPerm \u03c0' A \u2022 N", "dependency": [1, 402, 61, 973, 65]}, "ConNF.StructApprox.mem_dom_of_exactlyApproximates": {"natural_language_statement": "In the context of Constructive Ordinal Notation (ConNF), the theorem establishes that if a `\u03b2`-structural approximation exactly approximates a `\u03b2`-structural permutation, then for any given `\u03b2`-extended index `A` and elements `a`, `L` such that `a` is not equal to `L` and the permutation of `a` is not equal to the permutation of `L`, `a` must be in the domain of the near-litter permutation assigned to `A` by the `\u03b2`-structural approximation.", "formal_statement": "example [ConNF.Params ] [ConNF.Level] {\u03b2 : ConNF.\u039b} [ConNF.LeLevel \u2191\u03b2] {\u03c0\u2080 : ConNF.StructApprox \u2191\u03b2} {\u03c0 : ConNF.StructPerm \u2191\u03b2} (h\u03c0 : ConNF.StructApprox.ExactlyApproximates \u03c0\u2080 \u03c0) {A : ConNF.ExtendedIndex \u2191\u03b2} {a : ConNF.Atom} {L : ConNF.Litter} (h : ConNF.StructApprox.InOut (\u03c0 A) a L) :a \u2208 (\u03c0\u2080 A).atomPerm.domain := by sorry", "full_tactic_state": "inst\u271d\u00b2 : ConNF.Params\ninst\u271d\u00b9 : ConNF.Level\n\u03b2 : ConNF.\u039b\ninst\u271d : ConNF.LeLevel \u2191\u03b2\n\u03c0\u2080 : ConNF.StructApprox \u2191\u03b2\n\u03c0 : ConNF.StructPerm \u2191\u03b2\nh\u03c0 : ConNF.StructApprox.ExactlyApproximates \u03c0\u2080 \u03c0\nA : ConNF.ExtendedIndex \u2191\u03b2\na : ConNF.Atom\nL : ConNF.Litter\nh : ConNF.StructApprox.InOut (\u03c0 A) a L\n\u22a2 a \u2208 (\u03c0\u2080 A).atomPerm.domain", "dependency": [1, 402, 781, 55, 803, 61, 969]}, "ConNF.StructApprox.constrainedAction_comp_mapFlexible": {"natural_language_statement": "In the context of Constructive Ordinal Notation (ConNF), the theorem `ConNF.StructApprox.constrainedAction_comp_mapFlexible` states that for any `\u03b2`-structural action `\u03c0` that is free, any path `A` from type index `\u03b2` to type index `\u03b3`, and any set `s` with small cardinality, the `\u03b2`-structural action `ConNF.Tree.comp A (ConNF.StructApprox.constrainedAction \u03c0 s hs)` satisfies the `map_flexible` property. The `free` hypothesis implies that for every `\u03b2`-extended index `B`, the near-litter approximation `(\u03c0 B)` is free with respect to `B`. The `small` hypothesis ensures that the cardinality of `s` is strictly less than the cardinality of `ConNF.\u03ba`. This theorem is crucial in the proof of Freedom of Action in ConNF, which states that every free approximation exactly approximates some allowable permutation.", "formal_statement": "example [ConNF.Params ] [ConNF.Level] [ConNF.FOAAssumptions] {\u03b2 : ConNF.\u039b} [ConNF.LeLevel \u2191\u03b2] [ConNF.StructApprox.FreedomOfActionHypothesis \u03b2] {\u03c0 : ConNF.StructApprox \u2191\u03b2} (h\u03c0f : ConNF.StructApprox.Free \u03c0) {\u03b3 : ConNF.\u039b} {s : Set (ConNF.Address \u2191\u03b2)} {hs : ConNF.Small s} (A : Quiver.Path \u2191\u03b2 \u2191\u03b3) :ConNF.StructAction.MapFlexible (ConNF.Tree.comp A (ConNF.StructApprox.constrainedAction \u03c0 s hs)) := by sorry", "full_tactic_state": "inst\u271d\u2074 : ConNF.Params\ninst\u271d\u00b3 : ConNF.Level\ninst\u271d\u00b2 : ConNF.FOAAssumptions\n\u03b2 : ConNF.\u039b\ninst\u271d\u00b9 : ConNF.LeLevel \u2191\u03b2\ninst\u271d : ConNF.StructApprox.FreedomOfActionHypothesis \u03b2\n\u03c0 : ConNF.StructApprox \u2191\u03b2\nh\u03c0f : ConNF.StructApprox.Free \u03c0\n\u03b3 : ConNF.\u039b\ns : Set (ConNF.Address \u2191\u03b2)\nhs : ConNF.Small s\nA : Quiver.Path \u2191\u03b2 \u2191\u03b3\n\u22a2 ConNF.StructAction.MapFlexible (ConNF.Tree.comp A (ConNF.StructApprox.constrainedAction \u03c0 s hs))", "dependency": [1, 402, 779, 781, 782, 69, 60, 233, 76, 814, 304, 978]}, "ConNF.StructApprox.ihsAction_comp_mapFlexible": {"natural_language_statement": "The theorem `ConNF.StructApprox.ihsAction_comp_mapFlexible` is a property of a `\u03b2`-structural action `\u03c6` in the context of Constructive Ordinal Notation (ConNF). It states that for any `\u03b2`-extended index `B`, any litter `L`, and any proof `hL` that `L` is in the domain of the litter map of `\u03c6` applied to `B`, if `L` is a flexible litter, then `((\u03c6 B).litterMap L).get hL` is also a flexible litter.", "formal_statement": "example [ConNF.Params ] [ConNF.Level] [ConNF.FOAAssumptions] {\u03b2 : ConNF.\u039b} [ConNF.LeLevel \u2191\u03b2] [ConNF.StructApprox.FreedomOfActionHypothesis \u03b2] {\u03c0 : ConNF.StructApprox \u2191\u03b2} (h\u03c0f : ConNF.StructApprox.Free \u03c0) {\u03b3 : ConNF.\u039b} (c : ConNF.Address \u2191\u03b2) (d : ConNF.Address \u2191\u03b2) (A : Quiver.Path \u2191\u03b2 \u2191\u03b3) :ConNF.StructAction.MapFlexible (ConNF.Tree.comp A (ConNF.StructApprox.ihsAction \u03c0 c d)) := by sorry", "full_tactic_state": "inst\u271d\u2074 : ConNF.Params\ninst\u271d\u00b3 : ConNF.Level\ninst\u271d\u00b2 : ConNF.FOAAssumptions\n\u03b2 : ConNF.\u039b\ninst\u271d\u00b9 : ConNF.LeLevel \u2191\u03b2\ninst\u271d : ConNF.StructApprox.FreedomOfActionHypothesis \u03b2\n\u03c0 : ConNF.StructApprox \u2191\u03b2\nh\u03c0f : ConNF.StructApprox.Free \u03c0\n\u03b3 : ConNF.\u039b\nc d : ConNF.Address \u2191\u03b2\nA : Quiver.Path \u2191\u03b2 \u2191\u03b3\n\u22a2 ConNF.StructAction.MapFlexible (ConNF.Tree.comp A (ConNF.StructApprox.ihsAction \u03c0 c d))", "dependency": [1, 402, 779, 781, 782, 60, 60, 76, 814, 304, 966]}, "ConNF.StructApprox.completeLitterMap_flexible": {"natural_language_statement": "In the context of Constructive Ordinal Notation (ConNF), the theorem `ConNF.StructApprox.completeLitterMap_flexible` states that for any free `\u03b2`-structural approximation `\u03c0`, any `\u03b2`-extended index `A`, and any flexible litter `L`, the litter `ConNF.StructApprox.completeLitterMap \u03c0 A L` is also flexible. This property ensures that the construction of the natural numbers in ConNF is well-defined and consistent.", "formal_statement": "example [ConNF.Params ] [ConNF.Level] [ConNF.FOAAssumptions] {\u03b2 : ConNF.\u039b} [ConNF.LeLevel \u2191\u03b2] [ConNF.StructApprox.FreedomOfActionHypothesis \u03b2] {\u03c0 : ConNF.StructApprox \u2191\u03b2} (h\u03c0f : ConNF.StructApprox.Free \u03c0) {A : ConNF.ExtendedIndex \u2191\u03b2} {L : ConNF.Litter} (h : ConNF.Flexible A L) :ConNF.Flexible A (ConNF.StructApprox.completeLitterMap \u03c0 A L) := by sorry", "full_tactic_state": "inst\u271d\u2074 : ConNF.Params\ninst\u271d\u00b3 : ConNF.Level\ninst\u271d\u00b2 : ConNF.FOAAssumptions\n\u03b2 : ConNF.\u039b\ninst\u271d\u00b9 : ConNF.LeLevel \u2191\u03b2\ninst\u271d : ConNF.StructApprox.FreedomOfActionHypothesis \u03b2\n\u03c0 : ConNF.StructApprox \u2191\u03b2\nh\u03c0f : ConNF.StructApprox.Free \u03c0\nA : ConNF.ExtendedIndex \u2191\u03b2\nL : ConNF.Litter\nh : ConNF.Flexible A L\n\u22a2 ConNF.Flexible A (ConNF.StructApprox.completeLitterMap \u03c0 A L)", "dependency": [1, 402, 779, 781, 782, 61, 842, 842, 787]}, "ConNF.StructApprox.completeLitterMap_inflexibleBot": {"natural_language_statement": "The theorem `ConNF.StructApprox.completeLitterMap_inflexibleBot` states that if `L` is `A`-inflexible, then the litter `ConNF.StructApprox.completeLitterMap \u03c0 A L` is also `A`-inflexible. This theorem is part of the construction of the natural numbers in the context of Constructive Ordinal Notation (ConNF).", "formal_statement": "example [ConNF.Params ] [ConNF.Level] [ConNF.FOAAssumptions] {\u03b2 : ConNF.\u039b} [ConNF.LeLevel \u2191\u03b2] [ConNF.StructApprox.FreedomOfActionHypothesis \u03b2] {\u03c0 : ConNF.StructApprox \u2191\u03b2} {A : ConNF.ExtendedIndex \u2191\u03b2} {L : ConNF.Litter} (h : ConNF.InflexibleBot A L) :ConNF.InflexibleBot A (ConNF.StructApprox.completeLitterMap \u03c0 A L) := by sorry", "full_tactic_state": "inst\u271d\u2074 : ConNF.Params\ninst\u271d\u00b3 : ConNF.Level\ninst\u271d\u00b2 : ConNF.FOAAssumptions\n\u03b2 : ConNF.\u039b\ninst\u271d\u00b9 : ConNF.LeLevel \u2191\u03b2\ninst\u271d : ConNF.StructApprox.FreedomOfActionHypothesis \u03b2\n\u03c0 : ConNF.StructApprox \u2191\u03b2\nA : ConNF.ExtendedIndex \u2191\u03b2\nL : ConNF.Litter\nh : ConNF.InflexibleBot A L\n\u22a2 ConNF.InflexibleBot A (ConNF.StructApprox.completeLitterMap \u03c0 A L)", "dependency": [1, 402, 779, 781, 61, 887, 887, 787]}, "ConNF.StructApprox.completeLitterMap_inflexibleCoe": {"natural_language_statement": "The theorem `ConNF.StructApprox.completeLitterMap_inflexibleCoe` states that if `\u03c0` is a free `\u03b2`-structural approximation, `c` and `d` are lawful `\u03b2`-structural actions, `A` is a `\u03b2`-extended index, `L` is a litter, and `L` is `A`-inflexible, then `ConNF.StructApprox.completeLitterMap \u03c0 A L` is also `A`-inflexible.", "formal_statement": "example [ConNF.Params ] [ConNF.Level] [ConNF.FOAAssumptions] {\u03b2 : ConNF.\u039b} [ConNF.LeLevel \u2191\u03b2] [ConNF.StructApprox.FreedomOfActionHypothesis \u03b2] {\u03c0 : ConNF.StructApprox \u2191\u03b2} (h\u03c0f : ConNF.StructApprox.Free \u03c0) {c : ConNF.Address \u2191\u03b2} {d : ConNF.Address \u2191\u03b2} (hcd : ConNF.StructAction.Lawful (ConNF.StructApprox.ihsAction \u03c0 c d)) {A : ConNF.ExtendedIndex \u2191\u03b2} {L : ConNF.Litter} (h : ConNF.InflexibleCoe A L) (hL : { path := A, value := Sum.inr (ConNF.Litter.toNearLitter L) } \u2208 ConNF.StructApprox.reflTransConstrained c d) :ConNF.InflexibleCoe A (ConNF.StructApprox.completeLitterMap \u03c0 A L) := by sorry", "full_tactic_state": "inst\u271d\u2074 : ConNF.Params\ninst\u271d\u00b3 : ConNF.Level\ninst\u271d\u00b2 : ConNF.FOAAssumptions\n\u03b2 : ConNF.\u039b\ninst\u271d\u00b9 : ConNF.LeLevel \u2191\u03b2\ninst\u271d : ConNF.StructApprox.FreedomOfActionHypothesis \u03b2\n\u03c0 : ConNF.StructApprox \u2191\u03b2\nh\u03c0f : ConNF.StructApprox.Free \u03c0\nc d : ConNF.Address \u2191\u03b2\nhcd : ConNF.StructAction.Lawful (ConNF.StructApprox.ihsAction \u03c0 c d)\nA : ConNF.ExtendedIndex \u2191\u03b2\nL : ConNF.Litter\nh : ConNF.InflexibleCoe A L\nhL : { path := A, value := Sum.inr (ConNF.Litter.toNearLitter L) } \u2208 ConNF.StructApprox.reflTransConstrained c d\n\u22a2 ConNF.InflexibleCoe A (ConNF.StructApprox.completeLitterMap \u03c0 A L)", "dependency": [1, 402, 779, 781, 782, 60, 60, 809, 966, 61, 889, 65, 483, 967, 889, 787]}, "ConNF.StructApprox.completeLitterMap_flexible'": {"natural_language_statement": "The theorem `ConNF.StructApprox.completeLitterMap_flexible'` is a part of the proof of freedom of action in Constructive Ordinal Notation (ConNF). It states that if a `\u03b2`-structural approximation `\u03c0` is free, and the `\u03b2`-extended index `A` and the litter `L` satisfy certain conditions, then the litter `L` is also flexible. This property is crucial in ensuring that the construction of the natural numbers in ConNF is well-defined and consistent.", "formal_statement": "example [ConNF.Params ] [ConNF.Level] [ConNF.FOAAssumptions] {\u03b2 : ConNF.\u039b} [ConNF.LeLevel \u2191\u03b2] [ConNF.StructApprox.FreedomOfActionHypothesis \u03b2] {\u03c0 : ConNF.StructApprox \u2191\u03b2} (h\u03c0f : ConNF.StructApprox.Free \u03c0) {c : ConNF.Address \u2191\u03b2} {d : ConNF.Address \u2191\u03b2} (hcd : ConNF.StructAction.Lawful (ConNF.StructApprox.ihsAction \u03c0 c d)) {A : ConNF.ExtendedIndex \u2191\u03b2} {L : ConNF.Litter} (hL : { path := A, value := Sum.inr (ConNF.Litter.toNearLitter L) } \u2208 ConNF.StructApprox.reflTransConstrained c d) (h : ConNF.Flexible A (ConNF.StructApprox.completeLitterMap \u03c0 A L)) :ConNF.Flexible A L := by sorry", "full_tactic_state": "inst\u271d\u2074 : ConNF.Params\ninst\u271d\u00b3 : ConNF.Level\ninst\u271d\u00b2 : ConNF.FOAAssumptions\n\u03b2 : ConNF.\u039b\ninst\u271d\u00b9 : ConNF.LeLevel \u2191\u03b2\ninst\u271d : ConNF.StructApprox.FreedomOfActionHypothesis \u03b2\n\u03c0 : ConNF.StructApprox \u2191\u03b2\nh\u03c0f : ConNF.StructApprox.Free \u03c0\nc d : ConNF.Address \u2191\u03b2\nhcd : ConNF.StructAction.Lawful (ConNF.StructApprox.ihsAction \u03c0 c d)\nA : ConNF.ExtendedIndex \u2191\u03b2\nL : ConNF.Litter\nhL : { path := A, value := Sum.inr (ConNF.Litter.toNearLitter L) } \u2208 ConNF.StructApprox.reflTransConstrained c d\nh : ConNF.Flexible A (ConNF.StructApprox.completeLitterMap \u03c0 A L)\n\u22a2 ConNF.Flexible A L", "dependency": [1, 402, 779, 781, 782, 60, 60, 809, 966, 61, 65, 483, 967, 842, 787, 842]}, "ConNF.StructApprox.completeLitterMap_flexible_iff": {"natural_language_statement": "The theorem `ConNF.StructApprox.completeLitterMap_flexible_iff` states that for any `\u03b2`-structural approximation `\u03c0` that is free, any `\u03b2`-extended index `A`, and any litter `L`, the litter `ConNF.StructApprox.completeLitterMap \u03c0 A L` is flexible if and only if `L` itself is flexible. This property is crucial in ensuring that the construction of the natural numbers in Constructive Ordinal Notation (ConNF) is well-defined and consistent.", "formal_statement": "example [ConNF.Params ] [ConNF.Level] [ConNF.FOAAssumptions] {\u03b2 : ConNF.\u039b} [ConNF.LeLevel \u2191\u03b2] [ConNF.StructApprox.FreedomOfActionHypothesis \u03b2] {\u03c0 : ConNF.StructApprox \u2191\u03b2} (h\u03c0f : ConNF.StructApprox.Free \u03c0) {c : ConNF.Address \u2191\u03b2} {d : ConNF.Address \u2191\u03b2} (hcd : ConNF.StructAction.Lawful (ConNF.StructApprox.ihsAction \u03c0 c d)) {A : ConNF.ExtendedIndex \u2191\u03b2} {L : ConNF.Litter} (hL : { path := A, value := Sum.inr (ConNF.Litter.toNearLitter L) } \u2208 ConNF.StructApprox.reflTransConstrained c d) :ConNF.Flexible A (ConNF.StructApprox.completeLitterMap \u03c0 A L) \u2194 ConNF.Flexible A L := by sorry", "full_tactic_state": "inst\u271d\u2074 : ConNF.Params\ninst\u271d\u00b3 : ConNF.Level\ninst\u271d\u00b2 : ConNF.FOAAssumptions\n\u03b2 : ConNF.\u039b\ninst\u271d\u00b9 : ConNF.LeLevel \u2191\u03b2\ninst\u271d : ConNF.StructApprox.FreedomOfActionHypothesis \u03b2\n\u03c0 : ConNF.StructApprox \u2191\u03b2\nh\u03c0f : ConNF.StructApprox.Free \u03c0\nc d : ConNF.Address \u2191\u03b2\nhcd : ConNF.StructAction.Lawful (ConNF.StructApprox.ihsAction \u03c0 c d)\nA : ConNF.ExtendedIndex \u2191\u03b2\nL : ConNF.Litter\nhL : { path := A, value := Sum.inr (ConNF.Litter.toNearLitter L) } \u2208 ConNF.StructApprox.reflTransConstrained c d\n\u22a2 ConNF.Flexible A (ConNF.StructApprox.completeLitterMap \u03c0 A L) \u2194 ConNF.Flexible A L", "dependency": [1, 402, 779, 781, 782, 60, 60, 809, 966, 61, 65, 483, 967, 842, 787, 842]}, "ConNF.StructApprox.completeLitterMap_inflexibleBot'": {"natural_language_statement": "The theorem `ConNF.StructApprox.completeLitterMap_inflexibleBot'` is a part of the construction of the natural numbers in the context of Constructive Ordinal Notation (ConNF). It states that if a `\u03b2`-structural approximation `\u03c0` is free, a `\u03b2`-extended index `A`, and a litter `L` satisfy certain conditions, then `L` is `A`-inflexible.", "formal_statement": "example [ConNF.Params ] [ConNF.Level] [ConNF.FOAAssumptions] {\u03b2 : ConNF.\u039b} [ConNF.LeLevel \u2191\u03b2] [ConNF.StructApprox.FreedomOfActionHypothesis \u03b2] {\u03c0 : ConNF.StructApprox \u2191\u03b2} (h\u03c0f : ConNF.StructApprox.Free \u03c0) {c : ConNF.Address \u2191\u03b2} {d : ConNF.Address \u2191\u03b2} (hcd : ConNF.StructAction.Lawful (ConNF.StructApprox.ihsAction \u03c0 c d)) {A : ConNF.ExtendedIndex \u2191\u03b2} {L : ConNF.Litter} (hL : { path := A, value := Sum.inr (ConNF.Litter.toNearLitter L) } \u2208 ConNF.StructApprox.reflTransConstrained c d) (h : ConNF.InflexibleBot A (ConNF.StructApprox.completeLitterMap \u03c0 A L)) :ConNF.InflexibleBot A L := by sorry", "full_tactic_state": "inst\u271d\u2074 : ConNF.Params\ninst\u271d\u00b3 : ConNF.Level\ninst\u271d\u00b2 : ConNF.FOAAssumptions\n\u03b2 : ConNF.\u039b\ninst\u271d\u00b9 : ConNF.LeLevel \u2191\u03b2\ninst\u271d : ConNF.StructApprox.FreedomOfActionHypothesis \u03b2\n\u03c0 : ConNF.StructApprox \u2191\u03b2\nh\u03c0f : ConNF.StructApprox.Free \u03c0\nc d : ConNF.Address \u2191\u03b2\nhcd : ConNF.StructAction.Lawful (ConNF.StructApprox.ihsAction \u03c0 c d)\nA : ConNF.ExtendedIndex \u2191\u03b2\nL : ConNF.Litter\nhL : { path := A, value := Sum.inr (ConNF.Litter.toNearLitter L) } \u2208 ConNF.StructApprox.reflTransConstrained c d\nh : ConNF.InflexibleBot A (ConNF.StructApprox.completeLitterMap \u03c0 A L)\n\u22a2 ConNF.InflexibleBot A L", "dependency": [1, 402, 779, 781, 782, 60, 60, 809, 966, 61, 65, 483, 967, 887, 787, 887]}, "ConNF.StructApprox.completeLitterMap_inflexibleBot_iff": {"natural_language_statement": "The theorem `ConNF.StructApprox.completeLitterMap_inflexibleBot_iff` states that for any `\u03b2`-structural approximation `\u03c0` that is free, any `\u03b2`-extended index `A`, and any litter `L`, the litter `ConNF.StructApprox.completeLitterMap \u03c0 A L` is `A`-inflexible if and only if `L` is `A`-inflexible.", "formal_statement": "example [ConNF.Params ] [ConNF.Level] [ConNF.FOAAssumptions] {\u03b2 : ConNF.\u039b} [ConNF.LeLevel \u2191\u03b2] [ConNF.StructApprox.FreedomOfActionHypothesis \u03b2] {\u03c0 : ConNF.StructApprox \u2191\u03b2} (h\u03c0f : ConNF.StructApprox.Free \u03c0) {c : ConNF.Address \u2191\u03b2} {d : ConNF.Address \u2191\u03b2} (hcd : ConNF.StructAction.Lawful (ConNF.StructApprox.ihsAction \u03c0 c d)) {A : ConNF.ExtendedIndex \u2191\u03b2} {L : ConNF.Litter} (hL : { path := A, value := Sum.inr (ConNF.Litter.toNearLitter L) } \u2208 ConNF.StructApprox.reflTransConstrained c d) :Nonempty (ConNF.InflexibleBot A (ConNF.StructApprox.completeLitterMap \u03c0 A L)) \u2194 Nonempty (ConNF.InflexibleBot A L) := by sorry", "full_tactic_state": "inst\u271d\u2074 : ConNF.Params\ninst\u271d\u00b3 : ConNF.Level\ninst\u271d\u00b2 : ConNF.FOAAssumptions\n\u03b2 : ConNF.\u039b\ninst\u271d\u00b9 : ConNF.LeLevel \u2191\u03b2\ninst\u271d : ConNF.StructApprox.FreedomOfActionHypothesis \u03b2\n\u03c0 : ConNF.StructApprox \u2191\u03b2\nh\u03c0f : ConNF.StructApprox.Free \u03c0\nc d : ConNF.Address \u2191\u03b2\nhcd : ConNF.StructAction.Lawful (ConNF.StructApprox.ihsAction \u03c0 c d)\nA : ConNF.ExtendedIndex \u2191\u03b2\nL : ConNF.Litter\nhL : { path := A, value := Sum.inr (ConNF.Litter.toNearLitter L) } \u2208 ConNF.StructApprox.reflTransConstrained c d\n\u22a2 Nonempty (ConNF.InflexibleBot A (ConNF.StructApprox.completeLitterMap \u03c0 A L)) \u2194 Nonempty (ConNF.InflexibleBot A L)", "dependency": [1, 402, 779, 781, 782, 60, 60, 809, 966, 61, 65, 483, 967, 212, 887, 787, 212, 887]}, "ConNF.StructApprox.completeLitterMap_inflexibleCoe'": {"natural_language_statement": "The theorem `ConNF.StructApprox.completeLitterMap_inflexibleCoe'` is a part of the construction of the natural numbers in the context of Constructive Ordinal Notation (ConNF). It states that if a `\u03b2`-structural approximation `\u03c0` is free and `L` is `A`-inflexible (excluding `\u03b5 = \u22a5`), then `L` itself is `A`-inflexible.", "formal_statement": "example [ConNF.Params ] [ConNF.Level] [ConNF.FOAAssumptions] {\u03b2 : ConNF.\u039b} [ConNF.LeLevel \u2191\u03b2] [ConNF.StructApprox.FreedomOfActionHypothesis \u03b2] {\u03c0 : ConNF.StructApprox \u2191\u03b2} (h\u03c0f : ConNF.StructApprox.Free \u03c0) {A : ConNF.ExtendedIndex \u2191\u03b2} {L : ConNF.Litter} (h : ConNF.InflexibleCoe A (ConNF.StructApprox.completeLitterMap \u03c0 A L)) :ConNF.InflexibleCoe A L := by sorry", "full_tactic_state": "inst\u271d\u2074 : ConNF.Params\ninst\u271d\u00b3 : ConNF.Level\ninst\u271d\u00b2 : ConNF.FOAAssumptions\n\u03b2 : ConNF.\u039b\ninst\u271d\u00b9 : ConNF.LeLevel \u2191\u03b2\ninst\u271d : ConNF.StructApprox.FreedomOfActionHypothesis \u03b2\n\u03c0 : ConNF.StructApprox \u2191\u03b2\nh\u03c0f : ConNF.StructApprox.Free \u03c0\nA : ConNF.ExtendedIndex \u2191\u03b2\nL : ConNF.Litter\nh : ConNF.InflexibleCoe A (ConNF.StructApprox.completeLitterMap \u03c0 A L)\n\u22a2 ConNF.InflexibleCoe A L", "dependency": [1, 402, 779, 781, 782, 61, 889, 787, 889]}, "ConNF.StructApprox.completeLitterMap_inflexibleCoe_iff": {"natural_language_statement": "`ConNF.StructApprox.completeLitterMap_inflexibleCoe_iff` is a theorem in the context of Constructive Ordinal Notation (ConNF) that relates the inflexibility of a litter `L` to the inflexibility of the litter `ConNF.StructApprox.completeLitterMap \u03c0 A L`, where `\u03c0` is a `\u03b2`-structural approximation, `A` is a `\u03b2`-extended index, and `L` is a litter. The theorem states that the existence of a proof that `L` is `A`-inflexible (excluding `\u03b5 = \u22a5`) is equivalent to the existence of a proof that `ConNF.StructApprox.completeLitterMap \u03c0 A L` is `A`-inflexible (excluding `\u03b5 = \u22a5`).", "formal_statement": "example [ConNF.Params ] [ConNF.Level] [ConNF.FOAAssumptions] {\u03b2 : ConNF.\u039b} [ConNF.LeLevel \u2191\u03b2] [ConNF.StructApprox.FreedomOfActionHypothesis \u03b2] {\u03c0 : ConNF.StructApprox \u2191\u03b2} (h\u03c0f : ConNF.StructApprox.Free \u03c0) {c : ConNF.Address \u2191\u03b2} {d : ConNF.Address \u2191\u03b2} (hcd : ConNF.StructAction.Lawful (ConNF.StructApprox.ihsAction \u03c0 c d)) {A : ConNF.ExtendedIndex \u2191\u03b2} {L : ConNF.Litter} (hL : { path := A, value := Sum.inr (ConNF.Litter.toNearLitter L) } \u2208 ConNF.StructApprox.reflTransConstrained c d) :Nonempty (ConNF.InflexibleCoe A (ConNF.StructApprox.completeLitterMap \u03c0 A L)) \u2194 Nonempty (ConNF.InflexibleCoe A L) := by sorry", "full_tactic_state": "inst\u271d\u2074 : ConNF.Params\ninst\u271d\u00b3 : ConNF.Level\ninst\u271d\u00b2 : ConNF.FOAAssumptions\n\u03b2 : ConNF.\u039b\ninst\u271d\u00b9 : ConNF.LeLevel \u2191\u03b2\ninst\u271d : ConNF.StructApprox.FreedomOfActionHypothesis \u03b2\n\u03c0 : ConNF.StructApprox \u2191\u03b2\nh\u03c0f : ConNF.StructApprox.Free \u03c0\nc d : ConNF.Address \u2191\u03b2\nhcd : ConNF.StructAction.Lawful (ConNF.StructApprox.ihsAction \u03c0 c d)\nA : ConNF.ExtendedIndex \u2191\u03b2\nL : ConNF.Litter\nhL : { path := A, value := Sum.inr (ConNF.Litter.toNearLitter L) } \u2208 ConNF.StructApprox.reflTransConstrained c d\n\u22a2 Nonempty (ConNF.InflexibleCoe A (ConNF.StructApprox.completeLitterMap \u03c0 A L)) \u2194 Nonempty (ConNF.InflexibleCoe A L)", "dependency": [1, 402, 779, 781, 782, 60, 60, 809, 966, 61, 65, 483, 967, 212, 889, 787, 212, 889]}, "ConNF.StructApprox.supports": {"natural_language_statement": "The `ConNF.StructApprox.supports` theorem in Lean 4 is a part of the system designed to construct natural numbers using Constructive Ordinal Notation (ConNF), which includes a specific construction of the natural numbers utilizing a combination of finite and infinite paths through a transfinite hierarchy of types. The theorem asserts that for any two allowable permutations of the same type `\u03b2` within the context of ConNF, if these permutations leave each element (either an atom or a near-litter) unchanged when applied to the respective elements within the support of a given tangle at type `\u03b2`, then these permutations must in fact be identical when applied to the tangle itself. This property is crucial for ensuring that the construction of the natural numbers is well-defined and consistent.", "formal_statement": "example [ConNF.Params ] [ConNF.Level] [ConNF.FOAAssumptions] {\u03b2 : ConNF.\u039b} [ConNF.LeLevel \u2191\u03b2] {\u03c0 : ConNF.Allowable \u2191\u03b2} {\u03c0' : ConNF.Allowable \u2191\u03b2} {t : ConNF.Tangle \u2191\u03b2} (ha : \u2200 (A : ConNF.ExtendedIndex \u2191\u03b2) (a : ConNF.Atom), { path := A, value := Sum.inl a } \u2208 ConNF.TangleData.Tangle.support t \u2192 ConNF.Allowable.toStructPerm \u03c0 A \u2022 a = ConNF.Allowable.toStructPerm \u03c0' A \u2022 a) (hN : \u2200 (A : ConNF.ExtendedIndex \u2191\u03b2) (N : ConNF.NearLitter), { path := A, value := Sum.inr N } \u2208 ConNF.TangleData.Tangle.support t \u2192 ConNF.Allowable.toStructPerm \u03c0 A \u2022 N = ConNF.Allowable.toStructPerm \u03c0' A \u2022 N) :\u03c0 \u2022 t = \u03c0' \u2022 t := by sorry", "full_tactic_state": "inst\u271d\u00b3 : ConNF.Params\ninst\u271d\u00b2 : ConNF.Level\ninst\u271d\u00b9 : ConNF.FOAAssumptions\n\u03b2 : ConNF.\u039b\ninst\u271d : ConNF.LeLevel \u2191\u03b2\n\u03c0 \u03c0' : ConNF.Allowable \u2191\u03b2\nt : ConNF.Tangle \u2191\u03b2\nha :\n  \u2200 (A : ConNF.ExtendedIndex \u2191\u03b2) (a : ConNF.Atom),\n    { path := A, value := Sum.inl a } \u2208 ConNF.TangleData.Tangle.support t \u2192\n      ConNF.Allowable.toStructPerm \u03c0 A \u2022 a = ConNF.Allowable.toStructPerm \u03c0' A \u2022 a\nhN :\n  \u2200 (A : ConNF.ExtendedIndex \u2191\u03b2) (N : ConNF.NearLitter),\n    { path := A, value := Sum.inr N } \u2208 ConNF.TangleData.Tangle.support t \u2192\n      ConNF.Allowable.toStructPerm \u03c0 A \u2022 N = ConNF.Allowable.toStructPerm \u03c0' A \u2022 N\n\u22a2 \u03c0 \u2022 t = \u03c0' \u2022 t", "dependency": [1, 402, 61, 67, 395, 61, 65, 395]}, "ConNF.StructApprox.ConNF.StructApprox.extracted_1": {"natural_language_statement": "The object `ConNF.StructApprox.ConNF.StructApprox.extracted_1` is a theorem in the Lean 4 library that is used in the context of Constructive Ordinal Notation (ConNF). The theorem is a key step in the proof of Freedom of Action, which is a statement about the action of a structured permutation on a litter. The theorem states that if a structured action exactly approximates a structured permutation, then a certain construction involving the structured action and the permutation results in the same litter. The theorem is a crucial part of the proof of Freedom of Action in the context of Constructive Ordinal Notation.", "formal_statement": "example [ConNF.Params ] [ConNF.Level] [ConNF.FOAAssumptions] {\u03b2 : ConNF.\u039b} [ConNF.LeLevel \u2191\u03b2] [ConNF.StructApprox.FreedomOfActionHypothesis \u03b2] {\u03c0 : ConNF.StructApprox \u2191\u03b2} {\u03b3 : ConNF.\u039b} [ConNF.LeLevel \u2191\u03b3] (A : Quiver.Path \u2191\u03b2 \u2191\u03b3) (s : Set (ConNF.Address \u2191\u03b2)) (hs : ConNF.Small s) (h\u03c0 : ConNF.StructAction.Lawful (ConNF.Tree.comp A (ConNF.StructApprox.constrainedAction \u03c0 s hs))) (\u03c1 : ConNF.Allowable \u2191\u03b3) (h : ConNF.StructApprox.ExactlyApproximates (ConNF.StructAction.rc (ConNF.Tree.comp A (ConNF.StructApprox.constrainedAction \u03c0 s hs)) h\u03c0) (ConNF.Allowable.toStructPerm \u03c1)) (B : ConNF.ExtendedIndex \u2191\u03b3) (N : ConNF.NearLitter) (c : ConNF.Address \u2191\u03b2) (hc\u2081 : c \u2208 s) (hc\u2082 : { path := Quiver.Path.comp A B, value := Sum.inr N } \u2264 c) (L : ConNF.Litter) (hc\u2082' : { path := Quiver.Path.comp A B, value := Sum.inr (ConNF.Litter.toNearLitter L) } \u2264 c) (hNL : N.fst = L) (hL : ConNF.InflexibleBot B L) :ConNF.StructApprox.completeLitterMap \u03c0 (Quiver.Path.comp A B) L = ConNF.Allowable.toStructPerm \u03c1 B \u2022 L := by sorry", "full_tactic_state": "inst\u271d\u2075 : ConNF.Params\ninst\u271d\u2074 : ConNF.Level\ninst\u271d\u00b3 : ConNF.FOAAssumptions\n\u03b2 : ConNF.\u039b\ninst\u271d\u00b2 : ConNF.LeLevel \u2191\u03b2\ninst\u271d\u00b9 : ConNF.StructApprox.FreedomOfActionHypothesis \u03b2\n\u03c0 : ConNF.StructApprox \u2191\u03b2\n\u03b3 : ConNF.\u039b\ninst\u271d : ConNF.LeLevel \u2191\u03b3\nA : Quiver.Path \u2191\u03b2 \u2191\u03b3\ns : Set (ConNF.Address \u2191\u03b2)\nhs : ConNF.Small s\nh\u03c0 : ConNF.StructAction.Lawful (ConNF.Tree.comp A (ConNF.StructApprox.constrainedAction \u03c0 s hs))\n\u03c1 : ConNF.Allowable \u2191\u03b3\nh :\n  ConNF.StructApprox.ExactlyApproximates\n    (ConNF.StructAction.rc (ConNF.Tree.comp A (ConNF.StructApprox.constrainedAction \u03c0 s hs)) h\u03c0)\n    (ConNF.Allowable.toStructPerm \u03c1)\nB : ConNF.ExtendedIndex \u2191\u03b3\nN : ConNF.NearLitter\nc : ConNF.Address \u2191\u03b2\nhc\u2081 : c \u2208 s\nhc\u2082 : { path := Quiver.Path.comp A B, value := Sum.inr N } \u2264 c\nL : ConNF.Litter\nhc\u2082' : { path := Quiver.Path.comp A B, value := Sum.inr (ConNF.Litter.toNearLitter L) } \u2264 c\nhNL : N.fst = L\nhL : ConNF.InflexibleBot B L\n\u22a2 ConNF.StructApprox.completeLitterMap \u03c0 (Quiver.Path.comp A B) L = ConNF.Allowable.toStructPerm \u03c1 B \u2022 L", "dependency": [1, 402, 779, 781, 402, 76, 69, 60, 233, 809, 304, 978, 803, 810, 304, 978, 61, 60, 135, 65, 135, 65, 483, 887, 787, 135]}, "ConNF.StructApprox.constrainedAction_coherent'": {"natural_language_statement": "The theorem `ConNF.StructApprox.constrainedAction_coherent'` is a key step in the proof of freedom of action in Constructive Ordinal Notation (ConNF). It states that for any `\u03b2`-structural approximation `\u03c0` that is free, any `\u03b2`-extended index `A`, and any near-litter `N`, the function `ConNF.StructApprox.completeNearLitterMap \u03c0 A N` is equal to the action of the allowable permutation `\u03c1` on `N`.", "formal_statement": "example [ConNF.Params ] [ConNF.Level] [ConNF.FOAAssumptions] {\u03b2 : ConNF.\u039b} [ConNF.LeLevel \u2191\u03b2] [ConNF.StructApprox.FreedomOfActionHypothesis \u03b2] {\u03c0 : ConNF.StructApprox \u2191\u03b2} (h\u03c0f : ConNF.StructApprox.Free \u03c0) {\u03b3 : ConNF.\u039b} [ConNF.LeLevel \u2191\u03b3] (A : Quiver.Path \u2191\u03b2 \u2191\u03b3) (N : ConNF.ExtendedIndex \u2191\u03b3 \u00d7 ConNF.NearLitter) (s : Set (ConNF.Address \u2191\u03b2)) (hs : ConNF.Small s) (hc : \u2203 c \u2208 s, { path := Quiver.Path.comp A N.1, value := Sum.inr N.2 } \u2264 c) (h\u03c0 : ConNF.StructAction.Lawful (ConNF.Tree.comp A (ConNF.StructApprox.constrainedAction \u03c0 s hs))) (\u03c1 : ConNF.Allowable \u2191\u03b3) (h : ConNF.StructApprox.ExactlyApproximates (ConNF.StructAction.rc (ConNF.Tree.comp A (ConNF.StructApprox.constrainedAction \u03c0 s hs)) h\u03c0) (ConNF.Allowable.toStructPerm \u03c1)) :ConNF.StructApprox.completeNearLitterMap \u03c0 (Quiver.Path.comp A N.1) N.2 = ConNF.Allowable.toStructPerm \u03c1 N.1 \u2022 N.2 := by sorry", "full_tactic_state": "inst\u271d\u2075 : ConNF.Params\ninst\u271d\u2074 : ConNF.Level\ninst\u271d\u00b3 : ConNF.FOAAssumptions\n\u03b2 : ConNF.\u039b\ninst\u271d\u00b2 : ConNF.LeLevel \u2191\u03b2\ninst\u271d\u00b9 : ConNF.StructApprox.FreedomOfActionHypothesis \u03b2\n\u03c0 : ConNF.StructApprox \u2191\u03b2\nh\u03c0f : ConNF.StructApprox.Free \u03c0\n\u03b3 : ConNF.\u039b\ninst\u271d : ConNF.LeLevel \u2191\u03b3\nA : Quiver.Path \u2191\u03b2 \u2191\u03b3\nN : ConNF.ExtendedIndex \u2191\u03b3 \u00d7 ConNF.NearLitter\ns : Set (ConNF.Address \u2191\u03b2)\nhs : ConNF.Small s\nhc : \u2203 c \u2208 s, { path := Quiver.Path.comp A N.1, value := Sum.inr N.2 } \u2264 c\nh\u03c0 : ConNF.StructAction.Lawful (ConNF.Tree.comp A (ConNF.StructApprox.constrainedAction \u03c0 s hs))\n\u03c1 : ConNF.Allowable \u2191\u03b3\nh :\n  ConNF.StructApprox.ExactlyApproximates\n    (ConNF.StructAction.rc (ConNF.Tree.comp A (ConNF.StructApprox.constrainedAction \u03c0 s hs)) h\u03c0)\n    (ConNF.Allowable.toStructPerm \u03c1)\n\u22a2 ConNF.StructApprox.completeNearLitterMap \u03c0 (Quiver.Path.comp A N.1) N.2 = ConNF.Allowable.toStructPerm \u03c1 N.1 \u2022 N.2", "dependency": [1, 402, 779, 781, 782, 402, 76, 61, 69, 60, 233, 135, 65, 809, 304, 978, 803, 810, 304, 978, 792, 135]}, "ConNF.StructApprox.constrainedAction_coherent": {"natural_language_statement": "The theorem `ConNF.StructApprox.constrainedAction_coherent` is a coherence lemma in the context of Constructive Ordinal Notation (ConNF). It states that the action of the complete litter map, below a given address `c`, is equal to the action of any allowable permutation that exactly approximates it. This condition can only be applied for `\u03b3 < \u03b1` as we're dealing with lower allowable permutations.", "formal_statement": "example [ConNF.Params ] [ConNF.Level] [ConNF.FOAAssumptions] {\u03b2 : ConNF.\u039b} [ConNF.LeLevel \u2191\u03b2] [ConNF.StructApprox.FreedomOfActionHypothesis \u03b2] {\u03c0 : ConNF.StructApprox \u2191\u03b2} (h\u03c0f : ConNF.StructApprox.Free \u03c0) {\u03b3 : ConNF.\u039b} [ConNF.LeLevel \u2191\u03b3] (A : Quiver.Path \u2191\u03b2 \u2191\u03b3) (B : ConNF.ExtendedIndex \u2191\u03b3) (N : ConNF.NearLitter) (s : Set (ConNF.Address \u2191\u03b2)) (hs : ConNF.Small s) (hc : \u2203 c \u2208 s, { path := Quiver.Path.comp A B, value := Sum.inr N } \u2264 c) (h\u03c0 : ConNF.StructAction.Lawful (ConNF.Tree.comp A (ConNF.StructApprox.constrainedAction \u03c0 s hs))) (\u03c1 : ConNF.Allowable \u2191\u03b3) (h : ConNF.StructApprox.ExactlyApproximates (ConNF.StructAction.rc (ConNF.Tree.comp A (ConNF.StructApprox.constrainedAction \u03c0 s hs)) h\u03c0) (ConNF.Allowable.toStructPerm \u03c1)) :ConNF.StructApprox.completeNearLitterMap \u03c0 (Quiver.Path.comp A B) N = ConNF.Tree.comp B (ConNF.Allowable.toStructPerm \u03c1) \u2022 N := by sorry", "full_tactic_state": "inst\u271d\u2075 : ConNF.Params\ninst\u271d\u2074 : ConNF.Level\ninst\u271d\u00b3 : ConNF.FOAAssumptions\n\u03b2 : ConNF.\u039b\ninst\u271d\u00b2 : ConNF.LeLevel \u2191\u03b2\ninst\u271d\u00b9 : ConNF.StructApprox.FreedomOfActionHypothesis \u03b2\n\u03c0 : ConNF.StructApprox \u2191\u03b2\nh\u03c0f : ConNF.StructApprox.Free \u03c0\n\u03b3 : ConNF.\u039b\ninst\u271d : ConNF.LeLevel \u2191\u03b3\nA : Quiver.Path \u2191\u03b2 \u2191\u03b3\nB : ConNF.ExtendedIndex \u2191\u03b3\nN : ConNF.NearLitter\ns : Set (ConNF.Address \u2191\u03b2)\nhs : ConNF.Small s\nhc : \u2203 c \u2208 s, { path := Quiver.Path.comp A B, value := Sum.inr N } \u2264 c\nh\u03c0 : ConNF.StructAction.Lawful (ConNF.Tree.comp A (ConNF.StructApprox.constrainedAction \u03c0 s hs))\n\u03c1 : ConNF.Allowable \u2191\u03b3\nh :\n  ConNF.StructApprox.ExactlyApproximates\n    (ConNF.StructAction.rc (ConNF.Tree.comp A (ConNF.StructApprox.constrainedAction \u03c0 s hs)) h\u03c0)\n    (ConNF.Allowable.toStructPerm \u03c1)\n\u22a2 ConNF.StructApprox.completeNearLitterMap \u03c0 (Quiver.Path.comp A B) N =\n    ConNF.Tree.comp B (ConNF.Allowable.toStructPerm \u03c1) \u2022 N", "dependency": [1, 402, 779, 781, 782, 402, 76, 61, 69, 60, 233, 135, 65, 809, 304, 978, 803, 810, 304, 978, 792, 135, 304]}, "ConNF.StructApprox.constrainedAction_coherent_atom": {"natural_language_statement": "The coherence lemma for atoms, which is much easier to prove. The statement is here for symmetry.", "formal_statement": "example [ConNF.Params ] [ConNF.Level] [ConNF.FOAAssumptions] {\u03b2 : ConNF.\u039b} [ConNF.LeLevel \u2191\u03b2] [ConNF.StructApprox.FreedomOfActionHypothesis \u03b2] {\u03c0 : ConNF.StructApprox \u2191\u03b2} {\u03b3 : ConNF.\u039b} [ConNF.LeLevel \u2191\u03b3] (A : Quiver.Path \u2191\u03b2 \u2191\u03b3) (B : ConNF.ExtendedIndex \u2191\u03b3) (a : ConNF.Atom) (s : Set (ConNF.Address \u2191\u03b2)) (hs : ConNF.Small s) (hc : \u2203 c \u2208 s, { path := Quiver.Path.comp A B, value := Sum.inl a } \u2264 c) (h\u03c0 : ConNF.StructAction.Lawful (ConNF.Tree.comp A (ConNF.StructApprox.constrainedAction \u03c0 s hs))) (\u03c1 : ConNF.Allowable \u2191\u03b3) (h : ConNF.StructApprox.ExactlyApproximates (ConNF.StructAction.rc (ConNF.Tree.comp A (ConNF.StructApprox.constrainedAction \u03c0 s hs)) h\u03c0) (ConNF.Allowable.toStructPerm \u03c1)) :ConNF.StructApprox.completeAtomMap \u03c0 (Quiver.Path.comp A B) a = ConNF.Tree.comp B (ConNF.Allowable.toStructPerm \u03c1) \u2022 a := by sorry", "full_tactic_state": "inst\u271d\u2075 : ConNF.Params\ninst\u271d\u2074 : ConNF.Level\ninst\u271d\u00b3 : ConNF.FOAAssumptions\n\u03b2 : ConNF.\u039b\ninst\u271d\u00b2 : ConNF.LeLevel \u2191\u03b2\ninst\u271d\u00b9 : ConNF.StructApprox.FreedomOfActionHypothesis \u03b2\n\u03c0 : ConNF.StructApprox \u2191\u03b2\n\u03b3 : ConNF.\u039b\ninst\u271d : ConNF.LeLevel \u2191\u03b3\nA : Quiver.Path \u2191\u03b2 \u2191\u03b3\nB : ConNF.ExtendedIndex \u2191\u03b3\na : ConNF.Atom\ns : Set (ConNF.Address \u2191\u03b2)\nhs : ConNF.Small s\nhc : \u2203 c \u2208 s, { path := Quiver.Path.comp A B, value := Sum.inl a } \u2264 c\nh\u03c0 : ConNF.StructAction.Lawful (ConNF.Tree.comp A (ConNF.StructApprox.constrainedAction \u03c0 s hs))\n\u03c1 : ConNF.Allowable \u2191\u03b3\nh :\n  ConNF.StructApprox.ExactlyApproximates\n    (ConNF.StructAction.rc (ConNF.Tree.comp A (ConNF.StructApprox.constrainedAction \u03c0 s hs)) h\u03c0)\n    (ConNF.Allowable.toStructPerm \u03c1)\n\u22a2 ConNF.StructApprox.completeAtomMap \u03c0 (Quiver.Path.comp A B) a = ConNF.Tree.comp B (ConNF.Allowable.toStructPerm \u03c1) \u2022 a", "dependency": [1, 402, 779, 781, 402, 76, 61, 69, 60, 233, 135, 67, 809, 304, 978, 803, 810, 304, 978, 784, 135, 304]}, "ConNF.StructApprox.ihsAction_coherent": {"natural_language_statement": "The theorem `ConNF.StructApprox.ihsAction_coherent` states that in the context of Constructive Ordinal Notation (ConNF), given a `\u03b2`-structural approximation `\u03c0` that is free, a path `A` from `\u03b2` to `\u03b3`, a `\u03b3`-extended index `B`, a near-litter `N`, addresses `c` and `d` such that the composition of `A` and `B` is in the transitive closure of `c` and `d`, and a lawful `\u03b2`-structural action that exactly approximates a `\u03b3`-allowable permutation `\u03c1`, the `\u03b2`-structural approximation `\u03c0` applied to the composition of `A` and `B` and `N` is equal to the `\u03b3`-allowable permutation `\u03c1` applied to `N`.", "formal_statement": "example [ConNF.Params ] [ConNF.Level] [ConNF.FOAAssumptions] {\u03b2 : ConNF.\u039b} [ConNF.LeLevel \u2191\u03b2] [ConNF.StructApprox.FreedomOfActionHypothesis \u03b2] {\u03c0 : ConNF.StructApprox \u2191\u03b2} (h\u03c0f : ConNF.StructApprox.Free \u03c0) {\u03b3 : ConNF.\u039b} [ConNF.LeLevel \u2191\u03b3] (A : Quiver.Path \u2191\u03b2 \u2191\u03b3) (B : ConNF.ExtendedIndex \u2191\u03b3) (N : ConNF.NearLitter) (c : ConNF.Address \u2191\u03b2) (d : ConNF.Address \u2191\u03b2) (hc : { path := Quiver.Path.comp A B, value := Sum.inr N } \u2208 ConNF.StructApprox.transConstrained c d) (h\u03c0 : ConNF.StructAction.Lawful (ConNF.Tree.comp A (ConNF.StructApprox.ihsAction \u03c0 c d))) (\u03c1 : ConNF.Allowable \u2191\u03b3) (h : ConNF.StructApprox.ExactlyApproximates (ConNF.StructAction.rc (ConNF.Tree.comp A (ConNF.StructApprox.ihsAction \u03c0 c d)) h\u03c0) (ConNF.Allowable.toStructPerm \u03c1)) :ConNF.StructApprox.completeNearLitterMap \u03c0 (Quiver.Path.comp A B) N = ConNF.Tree.comp B (ConNF.Allowable.toStructPerm \u03c1) \u2022 N := by sorry", "full_tactic_state": "inst\u271d\u2075 : ConNF.Params\ninst\u271d\u2074 : ConNF.Level\ninst\u271d\u00b3 : ConNF.FOAAssumptions\n\u03b2 : ConNF.\u039b\ninst\u271d\u00b2 : ConNF.LeLevel \u2191\u03b2\ninst\u271d\u00b9 : ConNF.StructApprox.FreedomOfActionHypothesis \u03b2\n\u03c0 : ConNF.StructApprox \u2191\u03b2\nh\u03c0f : ConNF.StructApprox.Free \u03c0\n\u03b3 : ConNF.\u039b\ninst\u271d : ConNF.LeLevel \u2191\u03b3\nA : Quiver.Path \u2191\u03b2 \u2191\u03b3\nB : ConNF.ExtendedIndex \u2191\u03b3\nN : ConNF.NearLitter\nc d : ConNF.Address \u2191\u03b2\nhc : { path := Quiver.Path.comp A B, value := Sum.inr N } \u2208 ConNF.StructApprox.transConstrained c d\nh\u03c0 : ConNF.StructAction.Lawful (ConNF.Tree.comp A (ConNF.StructApprox.ihsAction \u03c0 c d))\n\u03c1 : ConNF.Allowable \u2191\u03b3\nh :\n  ConNF.StructApprox.ExactlyApproximates\n    (ConNF.StructAction.rc (ConNF.Tree.comp A (ConNF.StructApprox.ihsAction \u03c0 c d)) h\u03c0) (ConNF.Allowable.toStructPerm \u03c1)\n\u22a2 ConNF.StructApprox.completeNearLitterMap \u03c0 (Quiver.Path.comp A B) N =\n    ConNF.Tree.comp B (ConNF.Allowable.toStructPerm \u03c1) \u2022 N", "dependency": [1, 402, 779, 781, 782, 402, 76, 61, 60, 60, 135, 65, 995, 809, 304, 966, 803, 810, 304, 966, 792, 135, 304]}, "ConNF.StructApprox.ihsAction_coherent_atom": {"natural_language_statement": "The theorem `ConNF.StructApprox.ihsAction_coherent_atom` states that in the context of Constructive Ordinal Notation (ConNF), given a `\u03b2`-structural approximation `\u03c0`, a `\u03b2`-extended index `A`, a `\u03b3`-extended index `B`, an atom `a`, a `\u03b2`-address `c`, and a `\u03b2`-address `d`, if `A` composed with `B` is less than `c`, the `\u03b2`-structural action `ConNF.StructApprox.ihsAction \u03c0 c d` is lawful, and the `\u03b2`-structural approximation `ConNF.StructAction.rc (ConNF.Tree.comp A (ConNF.StructApprox.ihsAction \u03c0 c d)) h\u03c0` exactly approximates the `\u03b2`-structural permutation `ConNF.Allowable.toStructPerm \u03c1`, then the function `ConNF.StructApprox.completeAtomMap \u03c0 (Quiver.Path.comp A B) a` is equal to `ConNF.Tree.comp B (ConNF.Allowable.toStructPerm \u03c1) \u2022 a`.", "formal_statement": "example [ConNF.Params ] [ConNF.Level] [ConNF.FOAAssumptions] {\u03b2 : ConNF.\u039b} [ConNF.LeLevel \u2191\u03b2] [ConNF.StructApprox.FreedomOfActionHypothesis \u03b2] {\u03c0 : ConNF.StructApprox \u2191\u03b2} {\u03b3 : ConNF.\u039b} [ConNF.LeLevel \u2191\u03b3] (A : Quiver.Path \u2191\u03b2 \u2191\u03b3) (B : ConNF.ExtendedIndex \u2191\u03b3) (a : ConNF.Atom) (c : ConNF.Address \u2191\u03b2) (d : ConNF.Address \u2191\u03b2) (hc : { path := Quiver.Path.comp A B, value := Sum.inl a } < c) (h\u03c0 : ConNF.StructAction.Lawful (ConNF.Tree.comp A (ConNF.StructApprox.ihsAction \u03c0 c d))) (\u03c1 : ConNF.Allowable \u2191\u03b3) (h : ConNF.StructApprox.ExactlyApproximates (ConNF.StructAction.rc (ConNF.Tree.comp A (ConNF.StructApprox.ihsAction \u03c0 c d)) h\u03c0) (ConNF.Allowable.toStructPerm \u03c1)) :ConNF.StructApprox.completeAtomMap \u03c0 (Quiver.Path.comp A B) a = ConNF.Tree.comp B (ConNF.Allowable.toStructPerm \u03c1) \u2022 a := by sorry", "full_tactic_state": "inst\u271d\u2075 : ConNF.Params\ninst\u271d\u2074 : ConNF.Level\ninst\u271d\u00b3 : ConNF.FOAAssumptions\n\u03b2 : ConNF.\u039b\ninst\u271d\u00b2 : ConNF.LeLevel \u2191\u03b2\ninst\u271d\u00b9 : ConNF.StructApprox.FreedomOfActionHypothesis \u03b2\n\u03c0 : ConNF.StructApprox \u2191\u03b2\n\u03b3 : ConNF.\u039b\ninst\u271d : ConNF.LeLevel \u2191\u03b3\nA : Quiver.Path \u2191\u03b2 \u2191\u03b3\nB : ConNF.ExtendedIndex \u2191\u03b3\na : ConNF.Atom\nc d : ConNF.Address \u2191\u03b2\nhc : { path := Quiver.Path.comp A B, value := Sum.inl a } < c\nh\u03c0 : ConNF.StructAction.Lawful (ConNF.Tree.comp A (ConNF.StructApprox.ihsAction \u03c0 c d))\n\u03c1 : ConNF.Allowable \u2191\u03b3\nh :\n  ConNF.StructApprox.ExactlyApproximates\n    (ConNF.StructAction.rc (ConNF.Tree.comp A (ConNF.StructApprox.ihsAction \u03c0 c d)) h\u03c0) (ConNF.Allowable.toStructPerm \u03c1)\n\u22a2 ConNF.StructApprox.completeAtomMap \u03c0 (Quiver.Path.comp A B) a = ConNF.Tree.comp B (ConNF.Allowable.toStructPerm \u03c1) \u2022 a", "dependency": [1, 402, 779, 781, 402, 76, 61, 60, 60, 135, 67, 809, 304, 966, 803, 810, 304, 966, 784, 135, 304]}, "ConNF.StructApprox.litter_injective_extends": {"natural_language_statement": "In the context of Constructive Ordinal Notation (ConNF), the theorem `ConNF.StructApprox.litter_injective_extends` states that for a free `\u03b2`-structural approximation `\u03c0`, a `\u03b2`-extended index `A`, and two litters `L\u2081` and `L\u2082`, if both `L\u2081` and `L\u2082` are within the set of addresses that are either less than or equal to the address `c` or less than or equal to the address `d`, and if the complete litter map of `\u03c0` applied to `A` and `L\u2081` equals the complete litter map of `\u03c0` applied to `A` and `L\u2082`, then `L\u2081` must equal `L\u2082`.", "formal_statement": "example [ConNF.Params ] [ConNF.Level] [ConNF.FOAAssumptions] {\u03b2 : ConNF.\u039b} [ConNF.LeLevel \u2191\u03b2] [ConNF.StructApprox.FreedomOfActionHypothesis \u03b2] {\u03c0 : ConNF.StructApprox \u2191\u03b2} (h\u03c0f : ConNF.StructApprox.Free \u03c0) {c : ConNF.Address \u2191\u03b2} {d : ConNF.Address \u2191\u03b2} (hcd : ConNF.StructAction.Lawful (ConNF.StructApprox.ihsAction \u03c0 c d)) {A : ConNF.ExtendedIndex \u2191\u03b2} {L\u2081 : ConNF.Litter} {L\u2082 : ConNF.Litter} (h\u2081 : { path := A, value := Sum.inr (ConNF.Litter.toNearLitter L\u2081) } \u2208 ConNF.StructApprox.reflTransConstrained c d) (h\u2082 : { path := A, value := Sum.inr (ConNF.Litter.toNearLitter L\u2082) } \u2208 ConNF.StructApprox.reflTransConstrained c d) (h : ConNF.StructApprox.completeLitterMap \u03c0 A L\u2081 = ConNF.StructApprox.completeLitterMap \u03c0 A L\u2082) :L\u2081 = L\u2082 := by sorry", "full_tactic_state": "inst\u271d\u2074 : ConNF.Params\ninst\u271d\u00b3 : ConNF.Level\ninst\u271d\u00b2 : ConNF.FOAAssumptions\n\u03b2 : ConNF.\u039b\ninst\u271d\u00b9 : ConNF.LeLevel \u2191\u03b2\ninst\u271d : ConNF.StructApprox.FreedomOfActionHypothesis \u03b2\n\u03c0 : ConNF.StructApprox \u2191\u03b2\nh\u03c0f : ConNF.StructApprox.Free \u03c0\nc d : ConNF.Address \u2191\u03b2\nhcd : ConNF.StructAction.Lawful (ConNF.StructApprox.ihsAction \u03c0 c d)\nA : ConNF.ExtendedIndex \u2191\u03b2\nL\u2081 L\u2082 : ConNF.Litter\nh\u2081 : { path := A, value := Sum.inr (ConNF.Litter.toNearLitter L\u2081) } \u2208 ConNF.StructApprox.reflTransConstrained c d\nh\u2082 : { path := A, value := Sum.inr (ConNF.Litter.toNearLitter L\u2082) } \u2208 ConNF.StructApprox.reflTransConstrained c d\nh : ConNF.StructApprox.completeLitterMap \u03c0 A L\u2081 = ConNF.StructApprox.completeLitterMap \u03c0 A L\u2082\n\u22a2 L\u2081 = L\u2082", "dependency": [1, 402, 779, 781, 782, 60, 60, 809, 966, 61, 65, 483, 967, 65, 483, 967, 787, 787]}, "ConNF.StructApprox.splitLt_wellFounded": {"natural_language_statement": "Given a well-founded relation `r` on a type `\u03b1`, the split relation `ConNF.StructApprox.SplitLt r` on `\u03b1 \u00d7 \u03b1` is also well-founded.", "formal_statement": "example {\u03b1 : Type u_1} {r : \u03b1 \u2192 \u03b1 \u2192 Prop } (hr : WellFounded r) :WellFounded (ConNF.StructApprox.SplitLt r) := by sorry", "full_tactic_state": "\u03b1 : Type u_1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\nhr : WellFounded r\n\u22a2 WellFounded (ConNF.StructApprox.SplitLt r)", "dependency": [19, 19, 999]}, "ConNF.StructApprox.completeAtomMap_mem_completeNearLitterMap_toNearLitter'": {"natural_language_statement": "The Lean 4 object `ConNF.StructApprox.completeAtomMap_mem_completeNearLitterMap_toNearLitter'` is a theorem in the context of Constructive Ordinal Notation (ConNF). It states that for any `\u03b2`-structural approximation `\u03c0` that is free, and any `\u03b2`-extended indices `c` and `d` such that the `\u03b2`-structural action `ConNF.StructApprox.ihsAction \u03c0 c d` is lawful, and any `\u03b2`-extended index `A` and atom `a` such that `a.1 = L` and the address `{ path := A, value := Sum.inr (ConNF.Litter.toNearLitter L) }` is in the set `ConNF.StructApprox.reflTransConstrained c d`, then `ConNF.StructApprox.completeAtomMap \u03c0 A a` is in `ConNF.StructApprox.completeNearLitterMap \u03c0 A (ConNF.Litter.toNearLitter L)`.", "formal_statement": "example [ConNF.Params ] [ConNF.Level] [ConNF.FOAAssumptions] {\u03b2 : ConNF.\u039b} [ConNF.LeLevel \u2191\u03b2] [ConNF.StructApprox.FreedomOfActionHypothesis \u03b2] {\u03c0 : ConNF.StructApprox \u2191\u03b2} (h\u03c0f : ConNF.StructApprox.Free \u03c0) {c : ConNF.Address \u2191\u03b2} {d : ConNF.Address \u2191\u03b2} (hcd : ConNF.StructAction.Lawful (ConNF.StructApprox.ihsAction \u03c0 c d)) {A : ConNF.ExtendedIndex \u2191\u03b2} {a : ConNF.Atom} {L : ConNF.Litter} (ha : a.1 = L) (hL : { path := A, value := Sum.inr (ConNF.Litter.toNearLitter L) } \u2208 ConNF.StructApprox.reflTransConstrained c d) :ConNF.StructApprox.completeAtomMap \u03c0 A a \u2208 ConNF.StructApprox.completeNearLitterMap \u03c0 A (ConNF.Litter.toNearLitter L) := by sorry", "full_tactic_state": "inst\u271d\u2074 : ConNF.Params\ninst\u271d\u00b3 : ConNF.Level\ninst\u271d\u00b2 : ConNF.FOAAssumptions\n\u03b2 : ConNF.\u039b\ninst\u271d\u00b9 : ConNF.LeLevel \u2191\u03b2\ninst\u271d : ConNF.StructApprox.FreedomOfActionHypothesis \u03b2\n\u03c0 : ConNF.StructApprox \u2191\u03b2\nh\u03c0f : ConNF.StructApprox.Free \u03c0\nc d : ConNF.Address \u2191\u03b2\nhcd : ConNF.StructAction.Lawful (ConNF.StructApprox.ihsAction \u03c0 c d)\nA : ConNF.ExtendedIndex \u2191\u03b2\na : ConNF.Atom\nL : ConNF.Litter\nha : a.1 = L\nhL : { path := A, value := Sum.inr (ConNF.Litter.toNearLitter L) } \u2208 ConNF.StructApprox.reflTransConstrained c d\n\u22a2 ConNF.StructApprox.completeAtomMap \u03c0 A a \u2208 ConNF.StructApprox.completeNearLitterMap \u03c0 A (ConNF.Litter.toNearLitter L)", "dependency": [1, 402, 779, 781, 782, 60, 60, 809, 966, 61, 65, 483, 967, 784, 792, 483]}, "ConNF.StructApprox.ihsAction_lawful_extends": {"natural_language_statement": "In the context of Constructive Ordinal Notation (ConNF), the theorem `ConNF.StructApprox.ihsAction_lawful_extends` states that if a `\u03b2`-structural approximation `\u03c0` is free and satisfies the lawfulness condition for all pairs of addresses `e` and `f` that split `c` and `d` under the split relation, then the `\u03b2`-structural action defined by `\u03c0` is lawful for the pair `c` and `d`.", "formal_statement": "example [ConNF.Params ] [ConNF.Level] [ConNF.FOAAssumptions] {\u03b2 : ConNF.\u039b} [ConNF.LeLevel \u2191\u03b2] [ConNF.StructApprox.FreedomOfActionHypothesis \u03b2] {\u03c0 : ConNF.StructApprox \u2191\u03b2} (h\u03c0f : ConNF.StructApprox.Free \u03c0) (c : ConNF.Address \u2191\u03b2) (d : ConNF.Address \u2191\u03b2) (h\u03c0 : \u2200 (e f : ConNF.Address \u2191\u03b2), ConNF.StructApprox.SplitLt (fun (c d : ConNF.Address \u2191\u03b2) => c < d) (e, f) (c, d) \u2192 ConNF.StructAction.Lawful (ConNF.StructApprox.ihsAction \u03c0 e f)) :ConNF.StructAction.Lawful (ConNF.StructApprox.ihsAction \u03c0 c d) := by sorry", "full_tactic_state": "inst\u271d\u2074 : ConNF.Params\ninst\u271d\u00b3 : ConNF.Level\ninst\u271d\u00b2 : ConNF.FOAAssumptions\n\u03b2 : ConNF.\u039b\ninst\u271d\u00b9 : ConNF.LeLevel \u2191\u03b2\ninst\u271d : ConNF.StructApprox.FreedomOfActionHypothesis \u03b2\n\u03c0 : ConNF.StructApprox \u2191\u03b2\nh\u03c0f : ConNF.StructApprox.Free \u03c0\nc d : ConNF.Address \u2191\u03b2\nh\u03c0 :\n  \u2200 (e f : ConNF.Address \u2191\u03b2),\n    ConNF.StructApprox.SplitLt (fun c d => c < d) (e, f) (c, d) \u2192\n      ConNF.StructAction.Lawful (ConNF.StructApprox.ihsAction \u03c0 e f)\n\u22a2 ConNF.StructAction.Lawful (ConNF.StructApprox.ihsAction \u03c0 c d)", "dependency": [1, 402, 779, 781, 782, 60, 60, 60, 999, 60, 809, 966, 809, 966]}, "ConNF.StructApprox.ihsAction_lawful": {"natural_language_statement": "The theorem `ConNF.StructApprox.ihsAction_lawful` states that every `ihs_action` defined in the context of Constructive Ordinal Notation (ConNF) satisfies the lawfulness condition for each `\u03b2`-extended index.", "formal_statement": "example [ConNF.Params ] [ConNF.Level] [ConNF.FOAAssumptions] {\u03b2 : ConNF.\u039b} [ConNF.LeLevel \u2191\u03b2] [ConNF.StructApprox.FreedomOfActionHypothesis \u03b2] {\u03c0 : ConNF.StructApprox \u2191\u03b2} (h\u03c0f : ConNF.StructApprox.Free \u03c0) (c : ConNF.Address \u2191\u03b2) (d : ConNF.Address \u2191\u03b2) :ConNF.StructAction.Lawful (ConNF.StructApprox.ihsAction \u03c0 c d) := by sorry", "full_tactic_state": "inst\u271d\u2074 : ConNF.Params\ninst\u271d\u00b3 : ConNF.Level\ninst\u271d\u00b2 : ConNF.FOAAssumptions\n\u03b2 : ConNF.\u039b\ninst\u271d\u00b9 : ConNF.LeLevel \u2191\u03b2\ninst\u271d : ConNF.StructApprox.FreedomOfActionHypothesis \u03b2\n\u03c0 : ConNF.StructApprox \u2191\u03b2\nh\u03c0f : ConNF.StructApprox.Free \u03c0\nc d : ConNF.Address \u2191\u03b2\n\u22a2 ConNF.StructAction.Lawful (ConNF.StructApprox.ihsAction \u03c0 c d)", "dependency": [1, 402, 779, 781, 782, 60, 60, 809, 966]}, "ConNF.StructApprox.completeAtomMap_injective": {"natural_language_statement": "In Constructive Ordinal Notation (ConNF), given a free \u03b2-structural approximation \u03c0, the function that maps each \u03b2-extended index to an atom, known as the complete atom map, is injective. This means that for any two \u03b2-extended indices A and B, if the complete atom maps of A and B are equal, then A and B are equal as well.", "formal_statement": "example [ConNF.Params ] [ConNF.Level] [ConNF.FOAAssumptions] {\u03b2 : ConNF.\u039b} [ConNF.LeLevel \u2191\u03b2] [ConNF.StructApprox.FreedomOfActionHypothesis \u03b2] {\u03c0 : ConNF.StructApprox \u2191\u03b2} (h\u03c0f : ConNF.StructApprox.Free \u03c0) (A : ConNF.ExtendedIndex \u2191\u03b2) :Function.Injective (ConNF.StructApprox.completeAtomMap \u03c0 A) := by sorry", "full_tactic_state": "inst\u271d\u2074 : ConNF.Params\ninst\u271d\u00b3 : ConNF.Level\ninst\u271d\u00b2 : ConNF.FOAAssumptions\n\u03b2 : ConNF.\u039b\ninst\u271d\u00b9 : ConNF.LeLevel \u2191\u03b2\ninst\u271d : ConNF.StructApprox.FreedomOfActionHypothesis \u03b2\n\u03c0 : ConNF.StructApprox \u2191\u03b2\nh\u03c0f : ConNF.StructApprox.Free \u03c0\nA : ConNF.ExtendedIndex \u2191\u03b2\n\u22a2 Function.Injective (ConNF.StructApprox.completeAtomMap \u03c0 A)", "dependency": [1, 402, 779, 781, 782, 61, 89, 784]}, "ConNF.StructApprox.completeLitterMap_injective": {"natural_language_statement": "The theorem `ConNF.StructApprox.completeLitterMap_injective` states that the function `ConNF.StructApprox.completeLitterMap`, which takes a `\u03b2`-structural approximation `\u03c0`, a `\u03b2`-extended index `A`, and a litter `L`, and returns a litter, is injective. This means that for any two litters `L\u2081` and `L\u2082`, if `ConNF.StructApprox.completeLitterMap \u03c0 A L\u2081 = ConNF.StructApprox.completeLitterMap \u03c0 A L\u2082`, then `L\u2081 = L\u2082`.", "formal_statement": "example [ConNF.Params ] [ConNF.Level] [ConNF.FOAAssumptions] {\u03b2 : ConNF.\u039b} [ConNF.LeLevel \u2191\u03b2] [ConNF.StructApprox.FreedomOfActionHypothesis \u03b2] {\u03c0 : ConNF.StructApprox \u2191\u03b2} (h\u03c0f : ConNF.StructApprox.Free \u03c0) (A : ConNF.ExtendedIndex \u2191\u03b2) :Function.Injective (ConNF.StructApprox.completeLitterMap \u03c0 A) := by sorry", "full_tactic_state": "inst\u271d\u2074 : ConNF.Params\ninst\u271d\u00b3 : ConNF.Level\ninst\u271d\u00b2 : ConNF.FOAAssumptions\n\u03b2 : ConNF.\u039b\ninst\u271d\u00b9 : ConNF.LeLevel \u2191\u03b2\ninst\u271d : ConNF.StructApprox.FreedomOfActionHypothesis \u03b2\n\u03c0 : ConNF.StructApprox \u2191\u03b2\nh\u03c0f : ConNF.StructApprox.Free \u03c0\nA : ConNF.ExtendedIndex \u2191\u03b2\n\u22a2 Function.Injective (ConNF.StructApprox.completeLitterMap \u03c0 A)", "dependency": [1, 402, 779, 781, 782, 61, 89, 787]}, "ConNF.StructApprox.completeAtomMap_mem_completeNearLitterMap_toNearLitter": {"natural_language_statement": "The theorem `ConNF.StructApprox.completeAtomMap_mem_completeNearLitterMap_toNearLitter` states that in the context of Constructive Ordinal Notation (ConNF), if a `\u03b2`-structural approximation `\u03c0` is free (meaning that for every `\u03b2`-extended index `A`, the near-litter approximation `(\u03c0 A)` is free with respect to `A`), and `A` is a `\u03b2`-extended index, `a` is an atom, and `L` is a litter, then the condition `ConNF.StructApprox.completeAtomMap \u03c0 A a \u2208 ConNF.StructApprox.completeNearLitterMap \u03c0 A (ConNF.Litter.toNearLitter L)` holds if and only if `a.1 = L`. This means that atoms inside litters are mapped inside the corresponding image near-litter.", "formal_statement": "example [ConNF.Params ] [ConNF.Level] [ConNF.FOAAssumptions] {\u03b2 : ConNF.\u039b} [ConNF.LeLevel \u2191\u03b2] [ConNF.StructApprox.FreedomOfActionHypothesis \u03b2] {\u03c0 : ConNF.StructApprox \u2191\u03b2} (h\u03c0f : ConNF.StructApprox.Free \u03c0) {A : ConNF.ExtendedIndex \u2191\u03b2} {a : ConNF.Atom} {L : ConNF.Litter} :ConNF.StructApprox.completeAtomMap \u03c0 A a \u2208 ConNF.StructApprox.completeNearLitterMap \u03c0 A (ConNF.Litter.toNearLitter L) \u2194 a.1 = L := by sorry", "full_tactic_state": "inst\u271d\u2074 : ConNF.Params\ninst\u271d\u00b3 : ConNF.Level\ninst\u271d\u00b2 : ConNF.FOAAssumptions\n\u03b2 : ConNF.\u039b\ninst\u271d\u00b9 : ConNF.LeLevel \u2191\u03b2\ninst\u271d : ConNF.StructApprox.FreedomOfActionHypothesis \u03b2\n\u03c0 : ConNF.StructApprox \u2191\u03b2\nh\u03c0f : ConNF.StructApprox.Free \u03c0\nA : ConNF.ExtendedIndex \u2191\u03b2\na : ConNF.Atom\nL : ConNF.Litter\n\u22a2 ConNF.StructApprox.completeAtomMap \u03c0 A a \u2208\n      ConNF.StructApprox.completeNearLitterMap \u03c0 A (ConNF.Litter.toNearLitter L) \u2194\n    a.1 = L", "dependency": [1, 402, 779, 781, 782, 61, 784, 792, 483]}, "ConNF.StructApprox.mem_image_iff": {"natural_language_statement": "The theorem `ConNF.StructApprox.mem_image_iff` states that for an injective function `f` and a set `s`, an element `f x` is in the image of `s` under `f` if and only if `x` is in `s`.", "formal_statement": "example {\u03b1 : Type u_1} {\u03b2 : Type u_2} {f : \u03b1 \u2192 \u03b2} (hf : Function.Injective f) (x : \u03b1) (s : Set \u03b1) :f x \u2208 f '' s \u2194 x \u2208 s := by sorry", "full_tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : \u03b1 \u2192 \u03b2\nhf : Function.Injective f\nx : \u03b1\ns : Set \u03b1\n\u22a2 f x \u2208 f '' s \u2194 x \u2208 s", "dependency": [89, 69]}, "ConNF.StructApprox.completeAtomMap_mem_completeNearLitterMap": {"natural_language_statement": "In the context of Constructive Ordinal Notation (ConNF), the theorem `ConNF.StructApprox.completeAtomMap_mem_completeNearLitterMap` states that if a `\u03b2`-structural approximation `\u03c0` is free, meaning that for every `\u03b2`-extended index `A`, the near-litter approximation `(\u03c0 A)` is free with respect to `A`, then an atom `a` is inside a near-litter `N` if and only if the image of `a` under the function `ConNF.StructApprox.completeAtomMap \u03c0 A` is inside the image near-litter `ConNF.StructApprox.completeNearLitterMap \u03c0 A N`.", "formal_statement": "example [ConNF.Params ] [ConNF.Level] [ConNF.FOAAssumptions] {\u03b2 : ConNF.\u039b} [ConNF.LeLevel \u2191\u03b2] [ConNF.StructApprox.FreedomOfActionHypothesis \u03b2] {\u03c0 : ConNF.StructApprox \u2191\u03b2} (h\u03c0f : ConNF.StructApprox.Free \u03c0) {A : ConNF.ExtendedIndex \u2191\u03b2} {a : ConNF.Atom} {N : ConNF.NearLitter} :ConNF.StructApprox.completeAtomMap \u03c0 A a \u2208 ConNF.StructApprox.completeNearLitterMap \u03c0 A N \u2194 a \u2208 N := by sorry", "full_tactic_state": "inst\u271d\u2074 : ConNF.Params\ninst\u271d\u00b3 : ConNF.Level\ninst\u271d\u00b2 : ConNF.FOAAssumptions\n\u03b2 : ConNF.\u039b\ninst\u271d\u00b9 : ConNF.LeLevel \u2191\u03b2\ninst\u271d : ConNF.StructApprox.FreedomOfActionHypothesis \u03b2\n\u03c0 : ConNF.StructApprox \u2191\u03b2\nh\u03c0f : ConNF.StructApprox.Free \u03c0\nA : ConNF.ExtendedIndex \u2191\u03b2\na : ConNF.Atom\nN : ConNF.NearLitter\n\u22a2 ConNF.StructApprox.completeAtomMap \u03c0 A a \u2208 ConNF.StructApprox.completeNearLitterMap \u03c0 A N \u2194 a \u2208 N", "dependency": [1, 402, 779, 781, 782, 61, 784, 792]}, "ConNF.StructApprox.completeNearLitterMap_injective": {"natural_language_statement": "The theorem `ConNF.StructApprox.completeNearLitterMap_injective` states that the function `ConNF.StructApprox.completeNearLitterMap` is injective. This function is used in the proof of freedom of action in Constructive Ordinal Notation (ConNF).", "formal_statement": "example [ConNF.Params ] [ConNF.Level] [ConNF.FOAAssumptions] {\u03b2 : ConNF.\u039b} [ConNF.LeLevel \u2191\u03b2] [ConNF.StructApprox.FreedomOfActionHypothesis \u03b2] {\u03c0 : ConNF.StructApprox \u2191\u03b2} (h\u03c0f : ConNF.StructApprox.Free \u03c0) (A : ConNF.ExtendedIndex \u2191\u03b2) :Function.Injective (ConNF.StructApprox.completeNearLitterMap \u03c0 A) := by sorry", "full_tactic_state": "inst\u271d\u2074 : ConNF.Params\ninst\u271d\u00b3 : ConNF.Level\ninst\u271d\u00b2 : ConNF.FOAAssumptions\n\u03b2 : ConNF.\u039b\ninst\u271d\u00b9 : ConNF.LeLevel \u2191\u03b2\ninst\u271d : ConNF.StructApprox.FreedomOfActionHypothesis \u03b2\n\u03c0 : ConNF.StructApprox \u2191\u03b2\nh\u03c0f : ConNF.StructApprox.Free \u03c0\nA : ConNF.ExtendedIndex \u2191\u03b2\n\u22a2 Function.Injective (ConNF.StructApprox.completeNearLitterMap \u03c0 A)", "dependency": [1, 402, 779, 781, 782, 61, 89, 792]}, "ConNF.StructApprox.completeAtomMap_bijective": {"natural_language_statement": "The theorem `ConNF.StructApprox.completeAtomMap_bijective` states that the function `ConNF.StructApprox.completeAtomMap`, which maps each `\u03b2`-extended index to an atom, is bijective. This means that the function is both injective (one-to-one) and surjective (onto).", "formal_statement": "example [ConNF.Params ] [ConNF.Level] [ConNF.FOAAssumptions] {\u03b2 : ConNF.\u039b} [ConNF.LeLevel \u2191\u03b2] [ConNF.StructApprox.FreedomOfActionHypothesis \u03b2] {\u03c0 : ConNF.StructApprox \u2191\u03b2} (h\u03c0f : ConNF.StructApprox.Free \u03c0) (A : ConNF.ExtendedIndex \u2191\u03b2) :Function.Bijective (ConNF.StructApprox.completeAtomMap \u03c0 A) := by sorry", "full_tactic_state": "inst\u271d\u2074 : ConNF.Params\ninst\u271d\u00b3 : ConNF.Level\ninst\u271d\u00b2 : ConNF.FOAAssumptions\n\u03b2 : ConNF.\u039b\ninst\u271d\u00b9 : ConNF.LeLevel \u2191\u03b2\ninst\u271d : ConNF.StructApprox.FreedomOfActionHypothesis \u03b2\n\u03c0 : ConNF.StructApprox \u2191\u03b2\nh\u03c0f : ConNF.StructApprox.Free \u03c0\nA : ConNF.ExtendedIndex \u2191\u03b2\n\u22a2 Function.Bijective (ConNF.StructApprox.completeAtomMap \u03c0 A)", "dependency": [1, 402, 779, 781, 782, 61, 1010, 784]}, "ConNF.StructApprox.completeLitterMap_bijective": {"natural_language_statement": "The theorem `ConNF.StructApprox.completeLitterMap_bijective` states that the function `ConNF.StructApprox.completeLitterMap` is bijective, meaning it is both injective (one-to-one) and surjective (onto). This function is part of the construction of the natural numbers in the context of Constructive Ordinal Notation (ConNF).", "formal_statement": "example [ConNF.Params ] [ConNF.Level] [ConNF.FOAAssumptions] {\u03b2 : ConNF.\u039b} [ConNF.LeLevel \u2191\u03b2] [ConNF.StructApprox.FreedomOfActionHypothesis \u03b2] {\u03c0 : ConNF.StructApprox \u2191\u03b2} (h\u03c0f : ConNF.StructApprox.Free \u03c0) (A : ConNF.ExtendedIndex \u2191\u03b2) :Function.Bijective (ConNF.StructApprox.completeLitterMap \u03c0 A) := by sorry", "full_tactic_state": "inst\u271d\u2074 : ConNF.Params\ninst\u271d\u00b3 : ConNF.Level\ninst\u271d\u00b2 : ConNF.FOAAssumptions\n\u03b2 : ConNF.\u039b\ninst\u271d\u00b9 : ConNF.LeLevel \u2191\u03b2\ninst\u271d : ConNF.StructApprox.FreedomOfActionHypothesis \u03b2\n\u03c0 : ConNF.StructApprox \u2191\u03b2\nh\u03c0f : ConNF.StructApprox.Free \u03c0\nA : ConNF.ExtendedIndex \u2191\u03b2\n\u22a2 Function.Bijective (ConNF.StructApprox.completeLitterMap \u03c0 A)", "dependency": [1, 402, 779, 781, 782, 61, 1010, 787]}, "ConNF.StructApprox.completeNearLitterMap_bijective": {"natural_language_statement": "The theorem `ConNF.StructApprox.completeNearLitterMap_bijective` states that the function `ConNF.StructApprox.completeNearLitterMap \u03c0 A` is bijective, meaning it is both injective (one-to-one) and surjective (onto), for any free `\u03b2`-structural approximation `\u03c0` and any `\u03b2`-extended index `A`.", "formal_statement": "example [ConNF.Params ] [ConNF.Level] [ConNF.FOAAssumptions] {\u03b2 : ConNF.\u039b} [ConNF.LeLevel \u2191\u03b2] [ConNF.StructApprox.FreedomOfActionHypothesis \u03b2] {\u03c0 : ConNF.StructApprox \u2191\u03b2} (h\u03c0f : ConNF.StructApprox.Free \u03c0) (A : ConNF.ExtendedIndex \u2191\u03b2) :Function.Bijective (ConNF.StructApprox.completeNearLitterMap \u03c0 A) := by sorry", "full_tactic_state": "inst\u271d\u2074 : ConNF.Params\ninst\u271d\u00b3 : ConNF.Level\ninst\u271d\u00b2 : ConNF.FOAAssumptions\n\u03b2 : ConNF.\u039b\ninst\u271d\u00b9 : ConNF.LeLevel \u2191\u03b2\ninst\u271d : ConNF.StructApprox.FreedomOfActionHypothesis \u03b2\n\u03c0 : ConNF.StructApprox \u2191\u03b2\nh\u03c0f : ConNF.StructApprox.Free \u03c0\nA : ConNF.ExtendedIndex \u2191\u03b2\n\u22a2 Function.Bijective (ConNF.StructApprox.completeNearLitterMap \u03c0 A)", "dependency": [1, 402, 779, 781, 782, 61, 1010, 792]}, "ConNF.StructApprox.completeNearLitterMap_subset_range": {"natural_language_statement": "In the context of Constructive Ordinal Notation (ConNF), the theorem `ConNF.StructApprox.completeNearLitterMap_subset_range` states that for any `\u03b2`-extended index `A` and litter `L`, the near-litter `ConNF.StructApprox.completeNearLitterMap \u03c0 A (ConNF.Litter.toNearLitter L)` is a subset of the range of the function `ConNF.StructApprox.completeAtomMap \u03c0 A`, which maps each `\u03b2`-extended index to an atom.", "formal_statement": "example [ConNF.Params ] [ConNF.Level] [ConNF.FOAAssumptions] {\u03b2 : ConNF.\u039b} [ConNF.LeLevel \u2191\u03b2] [ConNF.StructApprox.FreedomOfActionHypothesis \u03b2] {\u03c0 : ConNF.StructApprox \u2191\u03b2} (A : ConNF.ExtendedIndex \u2191\u03b2) (L : ConNF.Litter) :\u2191(ConNF.StructApprox.completeNearLitterMap \u03c0 A (ConNF.Litter.toNearLitter L)) \u2286 Set.range (ConNF.StructApprox.completeAtomMap \u03c0 A) := by sorry", "full_tactic_state": "inst\u271d\u2074 : ConNF.Params\ninst\u271d\u00b3 : ConNF.Level\ninst\u271d\u00b2 : ConNF.FOAAssumptions\n\u03b2 : ConNF.\u039b\ninst\u271d\u00b9 : ConNF.LeLevel \u2191\u03b2\ninst\u271d : ConNF.StructApprox.FreedomOfActionHypothesis \u03b2\n\u03c0 : ConNF.StructApprox \u2191\u03b2\nA : ConNF.ExtendedIndex \u2191\u03b2\nL : ConNF.Litter\n\u22a2 \u2191(ConNF.StructApprox.completeNearLitterMap \u03c0 A (ConNF.Litter.toNearLitter L)) \u2286\n    Set.range (ConNF.StructApprox.completeAtomMap \u03c0 A)", "dependency": [1, 402, 779, 781, 61, 792, 483, 1014, 784]}, "ConNF.StructApprox.completeAtomMap_surjective_extends": {"natural_language_statement": "`ConNF.StructApprox.completeAtomMap_surjective_extends` is a theorem in the Lean proof assistant that is used in the context of Constructive Ordinal Notation (ConNF). It states that if a given atom is a member of the range of the litter map generated by a \u03b2-structural approximation, then it must also be a member of the range of the atom map generated by the same \u03b2-structural approximation. This theorem is crucial in establishing the \"Freedom of Action\" principle in ConNF, ensuring that every free approximation exactly approximates some allowable permutation.", "formal_statement": "example [ConNF.Params ] [ConNF.Level] [ConNF.FOAAssumptions] {\u03b2 : ConNF.\u039b} [ConNF.LeLevel \u2191\u03b2] [ConNF.StructApprox.FreedomOfActionHypothesis \u03b2] {\u03c0 : ConNF.StructApprox \u2191\u03b2} (A : ConNF.ExtendedIndex \u2191\u03b2) (a : ConNF.Atom) (h : a.1 \u2208 Set.range (ConNF.StructApprox.completeLitterMap \u03c0 A)) :a \u2208 Set.range (ConNF.StructApprox.completeAtomMap \u03c0 A) := by sorry", "full_tactic_state": "inst\u271d\u2074 : ConNF.Params\ninst\u271d\u00b3 : ConNF.Level\ninst\u271d\u00b2 : ConNF.FOAAssumptions\n\u03b2 : ConNF.\u039b\ninst\u271d\u00b9 : ConNF.LeLevel \u2191\u03b2\ninst\u271d : ConNF.StructApprox.FreedomOfActionHypothesis \u03b2\n\u03c0 : ConNF.StructApprox \u2191\u03b2\nA : ConNF.ExtendedIndex \u2191\u03b2\na : ConNF.Atom\nh : a.1 \u2208 Set.range (ConNF.StructApprox.completeLitterMap \u03c0 A)\n\u22a2 a \u2208 Set.range (ConNF.StructApprox.completeAtomMap \u03c0 A)", "dependency": [1, 402, 779, 781, 61, 1014, 787, 1014, 784]}, "ConNF.StructApprox.completeAddressMap_atom_eq": {"natural_language_statement": "In the context of Constructive Ordinal Notation (ConNF), the function `ConNF.StructApprox.completeAddressMap` takes a `\u03b2`-structural approximation `\u03c0` and returns a function that maps each `\u03b2`-address to another `\u03b2`-address. This function is crucial in the proof of Freedom of Action in ConNF, which states that every free approximation exactly approximates some allowable permutation. The theorem `ConNF.StructApprox.completeAddressMap_atom_eq` states that for a `\u03b2`-extended index `B` and an atom `a`, the function `ConNF.StructApprox.completeAddressMap \u03c0` maps the `\u03b2`-address `{ path := B, value := Sum.inl a }` to the `\u03b2`-address `{ path := B, value := Sum.inl (ConNF.StructApprox.completeAtomMap \u03c0 B a) }`.", "formal_statement": "@[simp]example [ConNF.Params ] [ConNF.Level] [ConNF.FOAAssumptions] {\u03b2 : ConNF.\u039b} [ConNF.LeLevel \u2191\u03b2] [ConNF.StructApprox.FreedomOfActionHypothesis \u03b2] {\u03c0 : ConNF.StructApprox \u2191\u03b2} {a : ConNF.Atom} {B : ConNF.ExtendedIndex \u2191\u03b2} :ConNF.StructApprox.completeAddressMap \u03c0 { path := B, value := Sum.inl a } = { path := B, value := Sum.inl (ConNF.StructApprox.completeAtomMap \u03c0 B a) } := by sorry", "full_tactic_state": "inst\u271d\u2074 : ConNF.Params\ninst\u271d\u00b3 : ConNF.Level\ninst\u271d\u00b2 : ConNF.FOAAssumptions\n\u03b2 : ConNF.\u039b\ninst\u271d\u00b9 : ConNF.LeLevel \u2191\u03b2\ninst\u271d : ConNF.StructApprox.FreedomOfActionHypothesis \u03b2\n\u03c0 : ConNF.StructApprox \u2191\u03b2\na : ConNF.Atom\nB : ConNF.ExtendedIndex \u2191\u03b2\n\u22a2 ConNF.StructApprox.completeAddressMap \u03c0 { path := B, value := Sum.inl a } =\n    { path := B, value := Sum.inl (ConNF.StructApprox.completeAtomMap \u03c0 B a) }", "dependency": [1, 402, 779, 781, 61, 1017, 67, 67, 784]}, "ConNF.StructApprox.completeAddressMap_nearLitter_eq": {"natural_language_statement": "The theorem `ConNF.StructApprox.completeAddressMap_nearLitter_eq` is a part of the proof of Freedom of Action in Constructive Ordinal Notation (ConNF). It states that for a `\u03b2`-structural approximation `\u03c0`, the function `ConNF.StructApprox.completeAddressMap \u03c0` applied to a `\u03b2`-address of the form `{ path := B, value := Sum.inr N }` (where `B` is a `\u03b2`-extended index and `N` is a `\u03b2`-near-litter) returns a `\u03b2`-address of the form `{ path := B, value := Sum.inr (ConNF.StructApprox.completeNearLitterMap \u03c0 B N) }`.", "formal_statement": "@[simp]example [ConNF.Params ] [ConNF.Level] [ConNF.FOAAssumptions] {\u03b2 : ConNF.\u039b} [ConNF.LeLevel \u2191\u03b2] [ConNF.StructApprox.FreedomOfActionHypothesis \u03b2] {\u03c0 : ConNF.StructApprox \u2191\u03b2} {N : ConNF.NearLitter} {B : ConNF.ExtendedIndex \u2191\u03b2} :ConNF.StructApprox.completeAddressMap \u03c0 { path := B, value := Sum.inr N } = { path := B, value := Sum.inr (ConNF.StructApprox.completeNearLitterMap \u03c0 B N) } := by sorry", "full_tactic_state": "inst\u271d\u2074 : ConNF.Params\ninst\u271d\u00b3 : ConNF.Level\ninst\u271d\u00b2 : ConNF.FOAAssumptions\n\u03b2 : ConNF.\u039b\ninst\u271d\u00b9 : ConNF.LeLevel \u2191\u03b2\ninst\u271d : ConNF.StructApprox.FreedomOfActionHypothesis \u03b2\n\u03c0 : ConNF.StructApprox \u2191\u03b2\nN : ConNF.NearLitter\nB : ConNF.ExtendedIndex \u2191\u03b2\n\u22a2 ConNF.StructApprox.completeAddressMap \u03c0 { path := B, value := Sum.inr N } =\n    { path := B, value := Sum.inr (ConNF.StructApprox.completeNearLitterMap \u03c0 B N) }", "dependency": [1, 402, 779, 781, 61, 1017, 65, 65, 792]}, "ConNF.StructApprox.completeAddressMap_injective": {"natural_language_statement": "Function `ConNF.StructApprox.completeAddressMap` is a noncomputable function defined in the context of Constructive Ordinal Notation (ConNF). It takes as input a `\u03b2`-structural approximation `\u03c0` and returns a function that maps each `\u03b2`-address to another `\u03b2`-address. This function is crucial in the proof of Freedom of Action in ConNF, which states that every free approximation exactly approximates some allowable permutation.", "formal_statement": "example [ConNF.Params ] [ConNF.Level] [ConNF.FOAAssumptions] {\u03b2 : ConNF.\u039b} [ConNF.LeLevel \u2191\u03b2] [ConNF.StructApprox.FreedomOfActionHypothesis \u03b2] {\u03c0 : ConNF.StructApprox \u2191\u03b2} (h\u03c0f : ConNF.StructApprox.Free \u03c0) :Function.Injective (ConNF.StructApprox.completeAddressMap \u03c0) := by sorry", "full_tactic_state": "inst\u271d\u2074 : ConNF.Params\ninst\u271d\u00b3 : ConNF.Level\ninst\u271d\u00b2 : ConNF.FOAAssumptions\n\u03b2 : ConNF.\u039b\ninst\u271d\u00b9 : ConNF.LeLevel \u2191\u03b2\ninst\u271d : ConNF.StructApprox.FreedomOfActionHypothesis \u03b2\n\u03c0 : ConNF.StructApprox \u2191\u03b2\nh\u03c0f : ConNF.StructApprox.Free \u03c0\n\u22a2 Function.Injective (ConNF.StructApprox.completeAddressMap \u03c0)", "dependency": [1, 402, 779, 781, 782, 89, 1017]}, "ConNF.StructApprox.preimageConstrained_small": {"natural_language_statement": "The theorem `ConNF.StructApprox.preimageConstrained_small` states that the preimage of the set of `\u03b2`-addresses `d` such that `d \u227a c` under the map `ConNF.StructApprox.completeAddressMap \u03c0` is a small set, meaning its cardinality is strictly less than the cardinality of the type `ConNF.\u03ba` in the context of Constructive Ordinal Notation (ConNF).", "formal_statement": "example [ConNF.Params ] [ConNF.Level] [ConNF.FOAAssumptions] {\u03b2 : ConNF.\u039b} [ConNF.LeLevel \u2191\u03b2] [ConNF.StructApprox.FreedomOfActionHypothesis \u03b2] {\u03c0 : ConNF.StructApprox \u2191\u03b2} (h\u03c0f : ConNF.StructApprox.Free \u03c0) (c : ConNF.Address \u2191\u03b2) :ConNF.Small (ConNF.StructApprox.preimageConstrained \u03c0 c) := by sorry", "full_tactic_state": "inst\u271d\u2074 : ConNF.Params\ninst\u271d\u00b3 : ConNF.Level\ninst\u271d\u00b2 : ConNF.FOAAssumptions\n\u03b2 : ConNF.\u039b\ninst\u271d\u00b9 : ConNF.LeLevel \u2191\u03b2\ninst\u271d : ConNF.StructApprox.FreedomOfActionHypothesis \u03b2\n\u03c0 : ConNF.StructApprox \u2191\u03b2\nh\u03c0f : ConNF.StructApprox.Free \u03c0\nc : ConNF.Address \u2191\u03b2\n\u22a2 ConNF.Small (ConNF.StructApprox.preimageConstrained \u03c0 c)", "dependency": [1, 402, 779, 781, 782, 60, 233, 1021]}, "ConNF.StructApprox.preimageAction_lawful": {"natural_language_statement": "Function `ConNF.StructApprox.preimageAction` defines a `\u03b2`-structural action as a product that assigns a near-litter action to each `\u03b2`-extended index, under the condition that the `\u03b2`-structural approximation `\u03c0` is free, meaning that for every `\u03b2`-extended index `A`, the near-litter approximation `(\u03c0 A)` is free with respect to `A`. The theorem `ConNF.StructApprox.preimageAction_lawful` proves that this `\u03b2`-structural action satisfies the lawfulness condition for each `\u03b2`-extended index.", "formal_statement": "example [ConNF.Params ] [ConNF.Level] [ConNF.FOAAssumptions] {\u03b2 : ConNF.\u039b} [ConNF.LeLevel \u2191\u03b2] [ConNF.StructApprox.FreedomOfActionHypothesis \u03b2] {\u03c0 : ConNF.StructApprox \u2191\u03b2} (h\u03c0f : ConNF.StructApprox.Free \u03c0) {c : ConNF.Address \u2191\u03b2} :ConNF.StructAction.Lawful (ConNF.StructApprox.preimageAction h\u03c0f c) := by sorry", "full_tactic_state": "inst\u271d\u2074 : ConNF.Params\ninst\u271d\u00b3 : ConNF.Level\ninst\u271d\u00b2 : ConNF.FOAAssumptions\n\u03b2 : ConNF.\u039b\ninst\u271d\u00b9 : ConNF.LeLevel \u2191\u03b2\ninst\u271d : ConNF.StructApprox.FreedomOfActionHypothesis \u03b2\n\u03c0 : ConNF.StructApprox \u2191\u03b2\nh\u03c0f : ConNF.StructApprox.Free \u03c0\nc : ConNF.Address \u2191\u03b2\n\u22a2 ConNF.StructAction.Lawful (ConNF.StructApprox.preimageAction h\u03c0f c)", "dependency": [1, 402, 779, 781, 782, 60, 809, 1023]}, "ConNF.StructApprox.preimageAction_comp_mapFlexible": {"natural_language_statement": "The theorem `ConNF.StructApprox.preimageAction_comp_mapFlexible` in Constructive Ordinal Notation (ConNF) establishes a property of a `\u03b2`-structural action `\u03c6`, specifically that for any path `A` from type index `\u03b2` to type index `\u03b3`, if `\u03c6` is a free `\u03b2`-structural action (which ensures that for every `\u03b2`-extended index `A`, the near-litter approximation `(\u03c0 A)` is free with respect to `A`), then the `\u03b3`-structural action obtained by composing `A` with `\u03c6` is such that for any `\u03b3`-extended index `B`, if `L` is a flexible litter in the domain of the litter map of `\u03c6` applied to `B`, then `((\u03c6 B).litterMap L).get hL` is also a flexible litter. This property is crucial in the proof of Freedom of Action in ConNF, which states that every free approximation exactly approximates some allowable permutation.", "formal_statement": "example [ConNF.Params ] [ConNF.Level] [ConNF.FOAAssumptions] {\u03b2 : ConNF.\u039b} [ConNF.LeLevel \u2191\u03b2] [ConNF.StructApprox.FreedomOfActionHypothesis \u03b2] {\u03c0 : ConNF.StructApprox \u2191\u03b2} {h\u03c0f : ConNF.StructApprox.Free \u03c0} {\u03b3 : ConNF.\u039b} {c : ConNF.Address \u2191\u03b2} (A : Quiver.Path \u2191\u03b2 \u2191\u03b3) :ConNF.StructAction.MapFlexible (ConNF.Tree.comp A (ConNF.StructApprox.preimageAction h\u03c0f c)) := by sorry", "full_tactic_state": "inst\u271d\u2074 : ConNF.Params\ninst\u271d\u00b3 : ConNF.Level\ninst\u271d\u00b2 : ConNF.FOAAssumptions\n\u03b2 : ConNF.\u039b\ninst\u271d\u00b9 : ConNF.LeLevel \u2191\u03b2\ninst\u271d : ConNF.StructApprox.FreedomOfActionHypothesis \u03b2\n\u03c0 : ConNF.StructApprox \u2191\u03b2\nh\u03c0f : ConNF.StructApprox.Free \u03c0\n\u03b3 : ConNF.\u039b\nc : ConNF.Address \u2191\u03b2\nA : Quiver.Path \u2191\u03b2 \u2191\u03b3\n\u22a2 ConNF.StructAction.MapFlexible (ConNF.Tree.comp A (ConNF.StructApprox.preimageAction h\u03c0f c))", "dependency": [1, 402, 779, 781, 782, 60, 76, 814, 304, 1023]}, "ConNF.StructApprox.Relation.reflTransGen_of_eq": {"natural_language_statement": "The theorem `ConNF.StructApprox.Relation.reflTransGen_of_eq` states that for any relation `r` on a type `\u03b1`, if `x` and `y` are equal, then `x` is related to `y` by the reflexive transitive closure of `r`.", "formal_statement": "example {\u03b1 : Type u_1} {r : \u03b1 \u2192 \u03b1 \u2192 Prop } {x : \u03b1} {y : \u03b1} (h : x = y) :Relation.ReflTransGen r x y := by sorry", "full_tactic_state": "\u03b1 : Type u_1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\nx y : \u03b1\nh : x = y\n\u22a2 Relation.ReflTransGen r x y", "dependency": [924]}, "ConNF.StructApprox.completeLitterMap_surjective_extends": {"natural_language_statement": "The theorem `ConNF.StructApprox.completeLitterMap_surjective_extends` is a part of the proof of freedom of action in Constructive Ordinal Notation (ConNF). It states that for any `\u03b2`-structural approximation `\u03c0` that is free, any `\u03b2`-extended index `A`, and any litter `L`, if for every `\u03b2`-extended index `B` and every atom `a`, `a` is in the range of `ConNF.StructApprox.completeAtomMap \u03c0 B`, and for every `\u03b2`-extended index `B` and every near-litter `N`, `N` is in the range of `ConNF.StructApprox.completeNearLitterMap \u03c0 B`, then `L` is in the range of `ConNF.StructApprox.completeLitterMap \u03c0 A`.", "formal_statement": "example [ConNF.Params ] [ConNF.Level] [ConNF.FOAAssumptions] {\u03b2 : ConNF.\u039b} [ConNF.LeLevel \u2191\u03b2] [ConNF.StructApprox.FreedomOfActionHypothesis \u03b2] {\u03c0 : ConNF.StructApprox \u2191\u03b2} (h\u03c0f : ConNF.StructApprox.Free \u03c0) (A : ConNF.ExtendedIndex \u2191\u03b2) (L : ConNF.Litter) (ha : \u2200 (B : ConNF.ExtendedIndex \u2191\u03b2) (a : ConNF.Atom), { path := B, value := Sum.inl a } \u227a { path := A, value := Sum.inr (ConNF.Litter.toNearLitter L) } \u2192 a \u2208 Set.range (ConNF.StructApprox.completeAtomMap \u03c0 B)) (hN : \u2200 (B : ConNF.ExtendedIndex \u2191\u03b2) (N : ConNF.NearLitter), { path := B, value := Sum.inr N } \u227a { path := A, value := Sum.inr (ConNF.Litter.toNearLitter L) } \u2192 N \u2208 Set.range (ConNF.StructApprox.completeNearLitterMap \u03c0 B)) :L \u2208 Set.range (ConNF.StructApprox.completeLitterMap \u03c0 A) := by sorry", "full_tactic_state": "inst\u271d\u2074 : ConNF.Params\ninst\u271d\u00b3 : ConNF.Level\ninst\u271d\u00b2 : ConNF.FOAAssumptions\n\u03b2 : ConNF.\u039b\ninst\u271d\u00b9 : ConNF.LeLevel \u2191\u03b2\ninst\u271d : ConNF.StructApprox.FreedomOfActionHypothesis \u03b2\n\u03c0 : ConNF.StructApprox \u2191\u03b2\nh\u03c0f : ConNF.StructApprox.Free \u03c0\nA : ConNF.ExtendedIndex \u2191\u03b2\nL : ConNF.Litter\nha :\n  \u2200 (B : ConNF.ExtendedIndex \u2191\u03b2) (a : ConNF.Atom),\n    { path := B, value := Sum.inl a } \u227a { path := A, value := Sum.inr (ConNF.Litter.toNearLitter L) } \u2192\n      a \u2208 Set.range (ConNF.StructApprox.completeAtomMap \u03c0 B)\nhN :\n  \u2200 (B : ConNF.ExtendedIndex \u2191\u03b2) (N : ConNF.NearLitter),\n    { path := B, value := Sum.inr N } \u227a { path := A, value := Sum.inr (ConNF.Litter.toNearLitter L) } \u2192\n      N \u2208 Set.range (ConNF.StructApprox.completeNearLitterMap \u03c0 B)\n\u22a2 L \u2208 Set.range (ConNF.StructApprox.completeLitterMap \u03c0 A)", "dependency": [1, 402, 779, 781, 782, 61, 61, 67, 65, 483, 1014, 784, 61, 65, 65, 483, 1014, 792, 1014, 787]}, "ConNF.StructApprox.atom_mem_range_of_mem_completeNearLitterMap": {"natural_language_statement": "In the context of Constructive Ordinal Notation (ConNF), the theorem `ConNF.StructApprox.atom_mem_range_of_mem_completeNearLitterMap` states that if an atom `a` belongs to the range of the function `ConNF.StructApprox.completeNearLitterMap`, then `a` also belongs to the range of the function `ConNF.StructApprox.completeAtomMap`.", "formal_statement": "example [ConNF.Params ] [ConNF.Level] [ConNF.FOAAssumptions] {\u03b2 : ConNF.\u039b} [ConNF.LeLevel \u2191\u03b2] [ConNF.StructApprox.FreedomOfActionHypothesis \u03b2] {\u03c0 : ConNF.StructApprox \u2191\u03b2} (A : ConNF.ExtendedIndex \u2191\u03b2) (a : ConNF.Atom) {N : ConNF.NearLitter} (h : a \u2208 ConNF.StructApprox.completeNearLitterMap \u03c0 A N) :a \u2208 Set.range (ConNF.StructApprox.completeAtomMap \u03c0 A) := by sorry", "full_tactic_state": "inst\u271d\u2074 : ConNF.Params\ninst\u271d\u00b3 : ConNF.Level\ninst\u271d\u00b2 : ConNF.FOAAssumptions\n\u03b2 : ConNF.\u039b\ninst\u271d\u00b9 : ConNF.LeLevel \u2191\u03b2\ninst\u271d : ConNF.StructApprox.FreedomOfActionHypothesis \u03b2\n\u03c0 : ConNF.StructApprox \u2191\u03b2\nA : ConNF.ExtendedIndex \u2191\u03b2\na : ConNF.Atom\nN : ConNF.NearLitter\nh : a \u2208 ConNF.StructApprox.completeNearLitterMap \u03c0 A N\n\u22a2 a \u2208 Set.range (ConNF.StructApprox.completeAtomMap \u03c0 A)", "dependency": [1, 402, 779, 781, 61, 792, 1014, 784]}, "ConNF.StructApprox.completeNearLitterMap_coe": {"natural_language_statement": "`ConNF.StructApprox.completeNearLitterMap_coe` is a theorem in the context of Constructive Ordinal Notation (ConNF). It states that for any `\u03b2`-structural approximation `\u03c0` that is free, any `\u03b2`-extended index `A`, and any near-litter `N`, the image of `N` under the function `ConNF.StructApprox.completeNearLitterMap \u03c0 A` is equal to the image of `N` under the function `ConNF.StructApprox.completeAtomMap \u03c0 A`.", "formal_statement": "example [ConNF.Params ] [ConNF.Level] [ConNF.FOAAssumptions] {\u03b2 : ConNF.\u039b} [ConNF.LeLevel \u2191\u03b2] [ConNF.StructApprox.FreedomOfActionHypothesis \u03b2] {\u03c0 : ConNF.StructApprox \u2191\u03b2} (h\u03c0f : ConNF.StructApprox.Free \u03c0) (A : ConNF.ExtendedIndex \u2191\u03b2) (N : ConNF.NearLitter) :\u2191(ConNF.StructApprox.completeNearLitterMap \u03c0 A N) = ConNF.StructApprox.completeAtomMap \u03c0 A '' \u2191N := by sorry", "full_tactic_state": "inst\u271d\u2074 : ConNF.Params\ninst\u271d\u00b3 : ConNF.Level\ninst\u271d\u00b2 : ConNF.FOAAssumptions\n\u03b2 : ConNF.\u039b\ninst\u271d\u00b9 : ConNF.LeLevel \u2191\u03b2\ninst\u271d : ConNF.StructApprox.FreedomOfActionHypothesis \u03b2\n\u03c0 : ConNF.StructApprox \u2191\u03b2\nh\u03c0f : ConNF.StructApprox.Free \u03c0\nA : ConNF.ExtendedIndex \u2191\u03b2\nN : ConNF.NearLitter\n\u22a2 \u2191(ConNF.StructApprox.completeNearLitterMap \u03c0 A N) = ConNF.StructApprox.completeAtomMap \u03c0 A '' \u2191N", "dependency": [1, 402, 779, 781, 782, 61, 792, 784]}, "ConNF.StructApprox.preimage_symmDiff": {"natural_language_statement": "The preimage of the symmetric difference of two sets under a function is equal to the symmetric difference of the preimages of the two sets.", "formal_statement": "@[simp]example {\u03b1 : Type u_1} {\u03b2 : Type u_2} {s : Set \u03b2} {t : Set \u03b2} {f : \u03b1 \u2192 \u03b2} :f \u207b\u00b9' symmDiff s t = symmDiff (f \u207b\u00b9' s) (f \u207b\u00b9' t) := by sorry", "full_tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ns t : Set \u03b2\nf : \u03b1 \u2192 \u03b2\n\u22a2 f \u207b\u00b9' symmDiff s t = symmDiff (f \u207b\u00b9' s) (f \u207b\u00b9' t)", "dependency": [69, 69, 62, 62]}, "ConNF.StructApprox.completeNearLitterMap_surjective_extends": {"natural_language_statement": "The theorem `ConNF.StructApprox.completeNearLitterMap_surjective_extends` is a part of the proof of freedom of action in Constructive Ordinal Notation (ConNF). It states that for any free `\u03b2`-structural approximation `\u03c0`, any `\u03b2`-extended index `A`, and any near-litter `N` such that the first projection of `N` is in the range of `ConNF.StructApprox.completeLitterMap \u03c0 A` and the symmetric difference of the litter set of `N` and `N` itself is a subset of the range of `ConNF.StructApprox.completeAtomMap \u03c0 A`, then `N` is in the range of `ConNF.StructApprox.completeNearLitterMap \u03c0 A`.", "formal_statement": "example [ConNF.Params ] [ConNF.Level] [ConNF.FOAAssumptions] {\u03b2 : ConNF.\u039b} [ConNF.LeLevel \u2191\u03b2] [ConNF.StructApprox.FreedomOfActionHypothesis \u03b2] {\u03c0 : ConNF.StructApprox \u2191\u03b2} (h\u03c0f : ConNF.StructApprox.Free \u03c0) (A : ConNF.ExtendedIndex \u2191\u03b2) (N : ConNF.NearLitter) (hN : N.fst \u2208 Set.range (ConNF.StructApprox.completeLitterMap \u03c0 A)) (ha : symmDiff (ConNF.litterSet N.fst) \u2191N \u2286 Set.range (ConNF.StructApprox.completeAtomMap \u03c0 A)) :N \u2208 Set.range (ConNF.StructApprox.completeNearLitterMap \u03c0 A) := by sorry", "full_tactic_state": "inst\u271d\u2074 : ConNF.Params\ninst\u271d\u00b3 : ConNF.Level\ninst\u271d\u00b2 : ConNF.FOAAssumptions\n\u03b2 : ConNF.\u039b\ninst\u271d\u00b9 : ConNF.LeLevel \u2191\u03b2\ninst\u271d : ConNF.StructApprox.FreedomOfActionHypothesis \u03b2\n\u03c0 : ConNF.StructApprox \u2191\u03b2\nh\u03c0f : ConNF.StructApprox.Free \u03c0\nA : ConNF.ExtendedIndex \u2191\u03b2\nN : ConNF.NearLitter\nhN : N.fst \u2208 Set.range (ConNF.StructApprox.completeLitterMap \u03c0 A)\nha : symmDiff (ConNF.litterSet N.fst) \u2191N \u2286 Set.range (ConNF.StructApprox.completeAtomMap \u03c0 A)\n\u22a2 N \u2208 Set.range (ConNF.StructApprox.completeNearLitterMap \u03c0 A)", "dependency": [1, 402, 779, 781, 782, 61, 1014, 787, 62, 467, 1014, 784, 1014, 792]}, "ConNF.StructApprox.completeMap_surjective_extends": {"natural_language_statement": "The theorem `ConNF.StructApprox.completeMap_surjective_extends` is a part of the proof of the Freedom of Action in Constructive Ordinal Notation (ConNF). It asserts that for any `\u03b2`-structural approximation `\u03c0` which is free, if `\u03c0` is such that for all addresses `d` less than a given address `c`, the condition `ConNF.StructApprox.CompleteMapSurjectiveAt \u03c0 d` holds, then `ConNF.StructApprox.CompleteMapSurjectiveAt \u03c0 c` also holds. This theorem is used to prove that any free approximation `\u03c0` exactly approximates some allowable permutation.", "formal_statement": "example [ConNF.Params ] [ConNF.Level] [ConNF.FOAAssumptions] {\u03b2 : ConNF.\u039b} [ConNF.LeLevel \u2191\u03b2] [ConNF.StructApprox.FreedomOfActionHypothesis \u03b2] {\u03c0 : ConNF.StructApprox \u2191\u03b2} (h\u03c0f : ConNF.StructApprox.Free \u03c0) (c : ConNF.Address \u2191\u03b2) (hc : \u2200 d < c, ConNF.StructApprox.CompleteMapSurjectiveAt \u03c0 d) :ConNF.StructApprox.CompleteMapSurjectiveAt \u03c0 c := by sorry", "full_tactic_state": "inst\u271d\u2074 : ConNF.Params\ninst\u271d\u00b3 : ConNF.Level\ninst\u271d\u00b2 : ConNF.FOAAssumptions\n\u03b2 : ConNF.\u039b\ninst\u271d\u00b9 : ConNF.LeLevel \u2191\u03b2\ninst\u271d : ConNF.StructApprox.FreedomOfActionHypothesis \u03b2\n\u03c0 : ConNF.StructApprox \u2191\u03b2\nh\u03c0f : ConNF.StructApprox.Free \u03c0\nc : ConNF.Address \u2191\u03b2\nhc : \u2200 d < c, ConNF.StructApprox.CompleteMapSurjectiveAt \u03c0 d\n\u22a2 ConNF.StructApprox.CompleteMapSurjectiveAt \u03c0 c", "dependency": [1, 402, 779, 781, 782, 60, 1032, 1032]}, "ConNF.StructApprox.completeMapSurjectiveAtAll": {"natural_language_statement": "In the context of Constructive Ordinal Notation (ConNF), the theorem `ConNF.StructApprox.completeMapSurjectiveAtAll` states that for any `\u03b2`-structural approximation `\u03c0` that is free (i.e., every near-litter approximation in `\u03c0` is free with respect to the corresponding `\u03b2`-extended index), and any address `c` in the base type (the atom or near-litter) together with the path detailing how we descend from type `\u03b2` to type `\u22a5` by looking at elements of elements and so on in the model, the property `CompleteMapSurjectiveAt \u03c0 c` holds, meaning that the address `c` is in the range of `\u03c0`'s complete map.", "formal_statement": "example [ConNF.Params ] [ConNF.Level] [ConNF.FOAAssumptions] {\u03b2 : ConNF.\u039b} [ConNF.LeLevel \u2191\u03b2] [ConNF.StructApprox.FreedomOfActionHypothesis \u03b2] {\u03c0 : ConNF.StructApprox \u2191\u03b2} (h\u03c0f : ConNF.StructApprox.Free \u03c0) (c : ConNF.Address \u2191\u03b2) :ConNF.StructApprox.CompleteMapSurjectiveAt \u03c0 c := by sorry", "full_tactic_state": "inst\u271d\u2074 : ConNF.Params\ninst\u271d\u00b3 : ConNF.Level\ninst\u271d\u00b2 : ConNF.FOAAssumptions\n\u03b2 : ConNF.\u039b\ninst\u271d\u00b9 : ConNF.LeLevel \u2191\u03b2\ninst\u271d : ConNF.StructApprox.FreedomOfActionHypothesis \u03b2\n\u03c0 : ConNF.StructApprox \u2191\u03b2\nh\u03c0f : ConNF.StructApprox.Free \u03c0\nc : ConNF.Address \u2191\u03b2\n\u22a2 ConNF.StructApprox.CompleteMapSurjectiveAt \u03c0 c", "dependency": [1, 402, 779, 781, 782, 60, 1032]}, "ConNF.StructApprox.completeAtomMap_surjective": {"natural_language_statement": "In the context of Constructive Ordinal Notation (ConNF), the theorem `ConNF.StructApprox.completeAtomMap_surjective` asserts that for any free `\u03b2`-structural approximation `\u03c0` and any `\u03b2`-extended index `A`, the function `ConNF.StructApprox.completeAtomMap \u03c0 A`, which maps each `\u03b2`-extended index to an atom, is surjective. This means that every atom has at least one corresponding `\u03b2`-extended index through this function.", "formal_statement": "example [ConNF.Params ] [ConNF.Level] [ConNF.FOAAssumptions] {\u03b2 : ConNF.\u039b} [ConNF.LeLevel \u2191\u03b2] [ConNF.StructApprox.FreedomOfActionHypothesis \u03b2] {\u03c0 : ConNF.StructApprox \u2191\u03b2} (h\u03c0f : ConNF.StructApprox.Free \u03c0) (A : ConNF.ExtendedIndex \u2191\u03b2) :Function.Surjective (ConNF.StructApprox.completeAtomMap \u03c0 A) := by sorry", "full_tactic_state": "inst\u271d\u2074 : ConNF.Params\ninst\u271d\u00b3 : ConNF.Level\ninst\u271d\u00b2 : ConNF.FOAAssumptions\n\u03b2 : ConNF.\u039b\ninst\u271d\u00b9 : ConNF.LeLevel \u2191\u03b2\ninst\u271d : ConNF.StructApprox.FreedomOfActionHypothesis \u03b2\n\u03c0 : ConNF.StructApprox \u2191\u03b2\nh\u03c0f : ConNF.StructApprox.Free \u03c0\nA : ConNF.ExtendedIndex \u2191\u03b2\n\u22a2 Function.Surjective (ConNF.StructApprox.completeAtomMap \u03c0 A)", "dependency": [1, 402, 779, 781, 782, 61, 1035, 784]}, "ConNF.StructApprox.completeNearLitterMap_surjective": {"natural_language_statement": "The theorem `ConNF.StructApprox.completeNearLitterMap_surjective` is a part of the ConNF project and represents a key step in the proof of freedom of action within the Constructive Ordinal Notation (ConNF) system. It establishes that the function `ConNF.StructApprox.completeNearLitterMap` is surjective for a given `\u03b2`-structural approximation `\u03c0` that is free, meaning it satisfies the freedom of action hypothesis. The `\u03b2`-structural approximation `\u03c0` maps `\u03b2`-extended indices to near-litter approximations, and this surjectivity ensures that for every near-litter approximation, there exists a `\u03b2`-extended index that maps to it under the `\u03c0` function. This theorem is crucial for demonstrating the power of the ConNF system to constructively build up the natural numbers and other mathematical objects using a finite set of type indices and operations defined within the system.", "formal_statement": "example [ConNF.Params ] [ConNF.Level] [ConNF.FOAAssumptions] {\u03b2 : ConNF.\u039b} [ConNF.LeLevel \u2191\u03b2] [ConNF.StructApprox.FreedomOfActionHypothesis \u03b2] {\u03c0 : ConNF.StructApprox \u2191\u03b2} (h\u03c0f : ConNF.StructApprox.Free \u03c0) (A : ConNF.ExtendedIndex \u2191\u03b2) :Function.Surjective (ConNF.StructApprox.completeNearLitterMap \u03c0 A) := by sorry", "full_tactic_state": "inst\u271d\u2074 : ConNF.Params\ninst\u271d\u00b3 : ConNF.Level\ninst\u271d\u00b2 : ConNF.FOAAssumptions\n\u03b2 : ConNF.\u039b\ninst\u271d\u00b9 : ConNF.LeLevel \u2191\u03b2\ninst\u271d : ConNF.StructApprox.FreedomOfActionHypothesis \u03b2\n\u03c0 : ConNF.StructApprox \u2191\u03b2\nh\u03c0f : ConNF.StructApprox.Free \u03c0\nA : ConNF.ExtendedIndex \u2191\u03b2\n\u22a2 Function.Surjective (ConNF.StructApprox.completeNearLitterMap \u03c0 A)", "dependency": [1, 402, 779, 781, 782, 61, 1035, 792]}, "ConNF.StructApprox.completeLitterMap_surjective": {"natural_language_statement": "The theorem `ConNF.StructApprox.completeLitterMap_surjective` proves that the function `ConNF.StructApprox.completeLitterMap` is surjective. This function is part of the construction of the natural numbers in the context of Constructive Ordinal Notation (ConNF), and it takes a `\u03b2`-structural approximation `\u03c0`, a `\u03b2`-extended index `A`, and a litter `L`, and returns a litter. The theorem states that for any `\u03b2`-structural approximation `\u03c0` that is free, and any `\u03b2`-extended index `A`, the function `ConNF.StructApprox.completeLitterMap \u03c0 A` is surjective.", "formal_statement": "example [ConNF.Params ] [ConNF.Level] [ConNF.FOAAssumptions] {\u03b2 : ConNF.\u039b} [ConNF.LeLevel \u2191\u03b2] [ConNF.StructApprox.FreedomOfActionHypothesis \u03b2] {\u03c0 : ConNF.StructApprox \u2191\u03b2} (h\u03c0f : ConNF.StructApprox.Free \u03c0) (A : ConNF.ExtendedIndex \u2191\u03b2) :Function.Surjective (ConNF.StructApprox.completeLitterMap \u03c0 A) := by sorry", "full_tactic_state": "inst\u271d\u2074 : ConNF.Params\ninst\u271d\u00b3 : ConNF.Level\ninst\u271d\u00b2 : ConNF.FOAAssumptions\n\u03b2 : ConNF.\u039b\ninst\u271d\u00b9 : ConNF.LeLevel \u2191\u03b2\ninst\u271d : ConNF.StructApprox.FreedomOfActionHypothesis \u03b2\n\u03c0 : ConNF.StructApprox \u2191\u03b2\nh\u03c0f : ConNF.StructApprox.Free \u03c0\nA : ConNF.ExtendedIndex \u2191\u03b2\n\u22a2 Function.Surjective (ConNF.StructApprox.completeLitterMap \u03c0 A)", "dependency": [1, 402, 779, 781, 782, 61, 1035, 787]}, "ConNF.StructApprox.transConstrained_symm": {"natural_language_statement": "The theorem `ConNF.StructApprox.transConstrained_symm` states that the function `ConNF.StructApprox.transConstrained` is symmetric, meaning that for any two addresses `c` and `d` in the context of Constructive Ordinal Notation (ConNF), the set of addresses that are either strictly less than `c` or strictly less than `d` is the same as the set of addresses that are either strictly less than `d` or strictly less than `c`.", "formal_statement": "example [ConNF.Params ] [ConNF.Level] [ConNF.FOAAssumptions] {\u03b2 : ConNF.\u039b} (c : ConNF.Address \u2191\u03b2) (d : ConNF.Address \u2191\u03b2) :ConNF.StructApprox.transConstrained c d = ConNF.StructApprox.transConstrained d c := by sorry", "full_tactic_state": "inst\u271d\u00b2 : ConNF.Params\ninst\u271d\u00b9 : ConNF.Level\ninst\u271d : ConNF.FOAAssumptions\n\u03b2 : ConNF.\u039b\nc d : ConNF.Address \u2191\u03b2\n\u22a2 ConNF.StructApprox.transConstrained c d = ConNF.StructApprox.transConstrained d c", "dependency": [1, 60, 60, 995, 995]}, "ConNF.StructApprox.reflTransConstrained_symm": {"natural_language_statement": "The theorem `ConNF.StructApprox.reflTransConstrained_symm` states that the set of addresses that are either less than or equal to the address `c` or less than or equal to the address `d`, within the context of Constructive Ordinal Notation (ConNF), is symmetric with respect to `c` and `d`.", "formal_statement": "example [ConNF.Params ] [ConNF.Level] [ConNF.FOAAssumptions] {\u03b2 : ConNF.\u039b} (c : ConNF.Address \u2191\u03b2) (d : ConNF.Address \u2191\u03b2) :ConNF.StructApprox.reflTransConstrained c d = ConNF.StructApprox.reflTransConstrained d c := by sorry", "full_tactic_state": "inst\u271d\u00b2 : ConNF.Params\ninst\u271d\u00b9 : ConNF.Level\ninst\u271d : ConNF.FOAAssumptions\n\u03b2 : ConNF.\u039b\nc d : ConNF.Address \u2191\u03b2\n\u22a2 ConNF.StructApprox.reflTransConstrained c d = ConNF.StructApprox.reflTransConstrained d c", "dependency": [1, 60, 60, 967, 967]}, "ConNF.StructApprox.transConstrained_self": {"natural_language_statement": "The theorem `ConNF.StructApprox.transConstrained_self` states that for any address `c` in the context of Constructive Ordinal Notation (ConNF), the set of addresses that are either strictly less than `c` or strictly less than `c` itself is exactly the set of addresses that are strictly less than `c`.", "formal_statement": "@[simp]example [ConNF.Params ] [ConNF.Level] [ConNF.FOAAssumptions] {\u03b2 : ConNF.\u039b} (c : ConNF.Address \u2191\u03b2) :ConNF.StructApprox.transConstrained c c = {e : ConNF.Address \u2191\u03b2 | e < c} := by sorry", "full_tactic_state": "inst\u271d\u00b2 : ConNF.Params\ninst\u271d\u00b9 : ConNF.Level\ninst\u271d : ConNF.FOAAssumptions\n\u03b2 : ConNF.\u039b\nc : ConNF.Address \u2191\u03b2\n\u22a2 ConNF.StructApprox.transConstrained c c = {e | e < c}", "dependency": [1, 60, 995, 60]}, "ConNF.StructApprox.reflTransConstrained_self": {"natural_language_statement": "Function `ConNF.StructApprox.reflTransConstrained` defines a set of addresses that are either less than or equal to the address `c` or less than or equal to the address `d`, within the context of Constructive Ordinal Notation (ConNF). The theorem `ConNF.StructApprox.reflTransConstrained_self` states that for any address `c`, the set of addresses `ConNF.StructApprox.reflTransConstrained c c` is equal to the set of addresses that are less than or equal to `c`.", "formal_statement": "@[simp]example [ConNF.Params ] [ConNF.Level] [ConNF.FOAAssumptions] {\u03b2 : ConNF.\u039b} (c : ConNF.Address \u2191\u03b2) :ConNF.StructApprox.reflTransConstrained c c = {e : ConNF.Address \u2191\u03b2 | e \u2264 c} := by sorry", "full_tactic_state": "inst\u271d\u00b2 : ConNF.Params\ninst\u271d\u00b9 : ConNF.Level\ninst\u271d : ConNF.FOAAssumptions\n\u03b2 : ConNF.\u039b\nc : ConNF.Address \u2191\u03b2\n\u22a2 ConNF.StructApprox.reflTransConstrained c c = {e | e \u2264 c}", "dependency": [1, 60, 967, 60]}, "ConNF.StructApprox.mem_reflTransConstrained_of_mem_transConstrained": {"natural_language_statement": "In the context of Constructive Ordinal Notation (ConNF), given three addresses `c`, `d`, and `e`, if `e` is in the transitive closure of `c` and `d`, then `e` is also in the reflexive-transitive closure of `c` and `d`.", "formal_statement": "example [ConNF.Params ] [ConNF.Level] [ConNF.FOAAssumptions] {\u03b2 : ConNF.\u039b} {c : ConNF.Address \u2191\u03b2} {d : ConNF.Address \u2191\u03b2} {e : ConNF.Address \u2191\u03b2} (he : e \u2208 ConNF.StructApprox.transConstrained c d) :e \u2208 ConNF.StructApprox.reflTransConstrained c d := by sorry", "full_tactic_state": "inst\u271d\u00b2 : ConNF.Params\ninst\u271d\u00b9 : ConNF.Level\ninst\u271d : ConNF.FOAAssumptions\n\u03b2 : ConNF.\u039b\nc d e : ConNF.Address \u2191\u03b2\nhe : e \u2208 ConNF.StructApprox.transConstrained c d\n\u22a2 e \u2208 ConNF.StructApprox.reflTransConstrained c d", "dependency": [1, 60, 60, 60, 995, 967]}, "ConNF.StructApprox.transConstrained_trans": {"natural_language_statement": "Function `ConNF.StructApprox.transConstrained` takes two addresses `c` and `d` in the context of Constructive Ordinal Notation (ConNF) and returns a set of addresses that are either strictly less than `c` or strictly less than `d`. This set represents the transitive closure of the relation defined by `c` and `d`. The theorem `ConNF.StructApprox.transConstrained_trans` states that if `e` is in the transitive closure of `c` and `d`, and `f` is less than or equal to `e`, then `f` is also in the transitive closure of `c` and `d`.", "formal_statement": "example [ConNF.Params ] [ConNF.Level] [ConNF.FOAAssumptions] {\u03b2 : ConNF.\u039b} {c : ConNF.Address \u2191\u03b2} {d : ConNF.Address \u2191\u03b2} {e : ConNF.Address \u2191\u03b2} {f : ConNF.Address \u2191\u03b2} (he : e \u2208 ConNF.StructApprox.transConstrained c d) (hf : f \u2264 e) :f \u2208 ConNF.StructApprox.transConstrained c d := by sorry", "full_tactic_state": "inst\u271d\u00b2 : ConNF.Params\ninst\u271d\u00b9 : ConNF.Level\ninst\u271d : ConNF.FOAAssumptions\n\u03b2 : ConNF.\u039b\nc d e f : ConNF.Address \u2191\u03b2\nhe : e \u2208 ConNF.StructApprox.transConstrained c d\nhf : f \u2264 e\n\u22a2 f \u2208 ConNF.StructApprox.transConstrained c d", "dependency": [1, 60, 60, 60, 60, 995, 995]}, "ConNF.StructApprox.reflTransConstrained_trans": {"natural_language_statement": "Given a chain of addresses `e` and `f` where `e` is in the refl-trans closure of `c` and `d`, and `f` is less than or equal to `e`, then `f` is also in the refl-trans closure of `c` and `d`. This is a property of transitive closures in the context of constructing ordinals using Constructive Ordinal Notation (ConNF).", "formal_statement": "example [ConNF.Params ] [ConNF.Level] [ConNF.FOAAssumptions] {\u03b2 : ConNF.\u039b} {c : ConNF.Address \u2191\u03b2} {d : ConNF.Address \u2191\u03b2} {e : ConNF.Address \u2191\u03b2} {f : ConNF.Address \u2191\u03b2} (he : e \u2208 ConNF.StructApprox.reflTransConstrained c d) (hf : f \u2264 e) :f \u2208 ConNF.StructApprox.reflTransConstrained c d := by sorry", "full_tactic_state": "inst\u271d\u00b2 : ConNF.Params\ninst\u271d\u00b9 : ConNF.Level\ninst\u271d : ConNF.FOAAssumptions\n\u03b2 : ConNF.\u039b\nc d e f : ConNF.Address \u2191\u03b2\nhe : e \u2208 ConNF.StructApprox.reflTransConstrained c d\nhf : f \u2264 e\n\u22a2 f \u2208 ConNF.StructApprox.reflTransConstrained c d", "dependency": [1, 60, 60, 60, 60, 967, 967]}, "ConNF.StructApprox.transConstrained_of_reflTransConstrained_of_trans_constrains": {"natural_language_statement": "The theorem `ConNF.StructApprox.transConstrained_of_reflTransConstrained_of_trans_constrains` is a mathematical statement about Constructive Ordinal Notation (ConNF), which is a system used for representing ordinals in a computer proof assistant. The theorem states that if an address `f` is strictly less than another address `e`, and `e` is in the reflexive-transitive closure of the addresses `c` and `d`, then `f` is in the transitive closure of `c` and `d`. This theorem is used to prove properties about the structure of ConNFAddresses and helps to establish the correctness and soundness of the ConNF system in representing ordinals.", "formal_statement": "example [ConNF.Params ] [ConNF.Level] [ConNF.FOAAssumptions] {\u03b2 : ConNF.\u039b} {c : ConNF.Address \u2191\u03b2} {d : ConNF.Address \u2191\u03b2} {e : ConNF.Address \u2191\u03b2} {f : ConNF.Address \u2191\u03b2} (he : e \u2208 ConNF.StructApprox.reflTransConstrained c d) (hf : f < e) :f \u2208 ConNF.StructApprox.transConstrained c d := by sorry", "full_tactic_state": "inst\u271d\u00b2 : ConNF.Params\ninst\u271d\u00b9 : ConNF.Level\ninst\u271d : ConNF.FOAAssumptions\n\u03b2 : ConNF.\u039b\nc d e f : ConNF.Address \u2191\u03b2\nhe : e \u2208 ConNF.StructApprox.reflTransConstrained c d\nhf : f < e\n\u22a2 f \u2208 ConNF.StructApprox.transConstrained c d", "dependency": [1, 60, 60, 60, 60, 967, 995]}, "ConNF.StructApprox.transConstrained_of_constrains": {"natural_language_statement": "The theorem `ConNF.StructApprox.transConstrained_of_constrains` states that if `e` is in the transitive closure of `c` and `d`, and `f` is strictly less than `e`, then `f` is also in the transitive closure of `c` and `d`.", "formal_statement": "example [ConNF.Params ] [ConNF.Level] [ConNF.FOAAssumptions] {\u03b2 : ConNF.\u039b} {c : ConNF.Address \u2191\u03b2} {d : ConNF.Address \u2191\u03b2} {e : ConNF.Address \u2191\u03b2} {f : ConNF.Address \u2191\u03b2} (he : e \u2208 ConNF.StructApprox.transConstrained c d) (hf : f \u227a e) :f \u2208 ConNF.StructApprox.transConstrained c d := by sorry", "full_tactic_state": "inst\u271d\u00b2 : ConNF.Params\ninst\u271d\u00b9 : ConNF.Level\ninst\u271d : ConNF.FOAAssumptions\n\u03b2 : ConNF.\u039b\nc d e f : ConNF.Address \u2191\u03b2\nhe : e \u2208 ConNF.StructApprox.transConstrained c d\nhf : f \u227a e\n\u22a2 f \u2208 ConNF.StructApprox.transConstrained c d", "dependency": [1, 60, 60, 60, 60, 995, 995]}, "ConNF.StructApprox.reflTransConstrained_of_constrains": {"natural_language_statement": "The theorem `ConNF.StructApprox.reflTransConstrained_of_constrains` states that if `e` is in the set of addresses that are either less than or equal to `c` or less than or equal to `d`, and `f` is strictly less than `e`, then `f` is also in the set of addresses that are either less than or equal to `c` or less than or equal to `d`.", "formal_statement": "example [ConNF.Params ] [ConNF.Level] [ConNF.FOAAssumptions] {\u03b2 : ConNF.\u039b} {c : ConNF.Address \u2191\u03b2} {d : ConNF.Address \u2191\u03b2} {e : ConNF.Address \u2191\u03b2} {f : ConNF.Address \u2191\u03b2} (he : e \u2208 ConNF.StructApprox.reflTransConstrained c d) (hf : f \u227a e) :f \u2208 ConNF.StructApprox.reflTransConstrained c d := by sorry", "full_tactic_state": "inst\u271d\u00b2 : ConNF.Params\ninst\u271d\u00b9 : ConNF.Level\ninst\u271d : ConNF.FOAAssumptions\n\u03b2 : ConNF.\u039b\nc d e f : ConNF.Address \u2191\u03b2\nhe : e \u2208 ConNF.StructApprox.reflTransConstrained c d\nhf : f \u227a e\n\u22a2 f \u2208 ConNF.StructApprox.reflTransConstrained c d", "dependency": [1, 60, 60, 60, 60, 967, 967]}, "ConNF.StructApprox.transConstrained_of_reflTransConstrained_of_constrains": {"natural_language_statement": "The theorem `ConNF.StructApprox.transConstrained_of_reflTransConstrained_of_constrains` states that if `e` is in the reflexive-transitive closure of `c` and `d`, and `f` is strictly less than `e`, then `f` is in the transitive closure of `c` and `d`.", "formal_statement": "example [ConNF.Params ] [ConNF.Level] [ConNF.FOAAssumptions] {\u03b2 : ConNF.\u039b} {c : ConNF.Address \u2191\u03b2} {d : ConNF.Address \u2191\u03b2} {e : ConNF.Address \u2191\u03b2} {f : ConNF.Address \u2191\u03b2} (he : e \u2208 ConNF.StructApprox.reflTransConstrained c d) (hf : f \u227a e) :f \u2208 ConNF.StructApprox.transConstrained c d := by sorry", "full_tactic_state": "inst\u271d\u00b2 : ConNF.Params\ninst\u271d\u00b9 : ConNF.Level\ninst\u271d : ConNF.FOAAssumptions\n\u03b2 : ConNF.\u039b\nc d e f : ConNF.Address \u2191\u03b2\nhe : e \u2208 ConNF.StructApprox.reflTransConstrained c d\nhf : f \u227a e\n\u22a2 f \u2208 ConNF.StructApprox.transConstrained c d", "dependency": [1, 60, 60, 60, 60, 967, 995]}, "ConNF.StructApprox.fst_transConstrained": {"natural_language_statement": "The theorem `ConNF.StructApprox.fst_transConstrained` is a part of the Constructive Ordinal Notation (ConNF) project in Lean 4. It states that if an address `A` with a left injection of an atom `a` is in the reflexive-transitive closure of two addresses `c` and `d`, then the same address `A` with a right injection of the near-litter corresponding to `a` is in the transitive closure of `c` and `d`.", "formal_statement": "example [ConNF.Params ] [ConNF.Level] [ConNF.FOAAssumptions] {\u03b2 : ConNF.\u039b} {c : ConNF.Address \u2191\u03b2} {d : ConNF.Address \u2191\u03b2} {A : ConNF.ExtendedIndex \u2191\u03b2} {a : ConNF.Atom} (hac : { path := A, value := Sum.inl a } \u2208 ConNF.StructApprox.reflTransConstrained c d) :{ path := A, value := Sum.inr (ConNF.Litter.toNearLitter a.1) } \u2208 ConNF.StructApprox.transConstrained c d := by sorry", "full_tactic_state": "inst\u271d\u00b2 : ConNF.Params\ninst\u271d\u00b9 : ConNF.Level\ninst\u271d : ConNF.FOAAssumptions\n\u03b2 : ConNF.\u039b\nc d : ConNF.Address \u2191\u03b2\nA : ConNF.ExtendedIndex \u2191\u03b2\na : ConNF.Atom\nhac : { path := A, value := Sum.inl a } \u2208 ConNF.StructApprox.reflTransConstrained c d\n\u22a2 { path := A, value := Sum.inr (ConNF.Litter.toNearLitter a.1) } \u2208 ConNF.StructApprox.transConstrained c d", "dependency": [1, 60, 60, 61, 67, 967, 65, 483, 995]}, "ConNF.StructApprox.fst_mem_trans_constrained'": {"natural_language_statement": "In the context of Constructive Ordinal Notation (ConNF), the theorem `ConNF.StructApprox.fst_mem_trans_constrained'` asserts that if an address in the transitive closure of two addresses `c` and `d` is of the form `{ path := A, value := Sum.inl a }`, where `A` is an extended index and `a` is an atom, then the corresponding near-litter address `{ path := A, value := Sum.inr (ConNF.Litter.toNearLitter a.1) }` is also in the transitive closure of `c` and `d`.", "formal_statement": "example [ConNF.Params ] [ConNF.Level] [ConNF.FOAAssumptions] {\u03b2 : ConNF.\u039b} {c : ConNF.Address \u2191\u03b2} {d : ConNF.Address \u2191\u03b2} {A : ConNF.ExtendedIndex \u2191\u03b2} {a : ConNF.Atom} (h : { path := A, value := Sum.inl a } \u2208 ConNF.StructApprox.transConstrained c d) :{ path := A, value := Sum.inr (ConNF.Litter.toNearLitter a.1) } \u2208 ConNF.StructApprox.transConstrained c d := by sorry", "full_tactic_state": "inst\u271d\u00b2 : ConNF.Params\ninst\u271d\u00b9 : ConNF.Level\ninst\u271d : ConNF.FOAAssumptions\n\u03b2 : ConNF.\u039b\nc d : ConNF.Address \u2191\u03b2\nA : ConNF.ExtendedIndex \u2191\u03b2\na : ConNF.Atom\nh : { path := A, value := Sum.inl a } \u2208 ConNF.StructApprox.transConstrained c d\n\u22a2 { path := A, value := Sum.inr (ConNF.Litter.toNearLitter a.1) } \u2208 ConNF.StructApprox.transConstrained c d", "dependency": [1, 60, 60, 61, 67, 995, 65, 483, 995]}, "ConNF.StructApprox.fst_mem_transConstrained": {"natural_language_statement": "The theorem `ConNF.StructApprox.fst_mem_transConstrained` is a part of the Constructive Ordinal Notation (ConNF) project in Lean 4. It states that if a near-litter `N` is an element of the transitive closure of the relation defined by two addresses `c` and `d`, then the near-litter obtained by converting the litter of `N` to a near-litter is also an element of the transitive closure of the relation defined by `c` and `d`.", "formal_statement": "example [ConNF.Params ] [ConNF.Level] [ConNF.FOAAssumptions] {\u03b2 : ConNF.\u039b} {c : ConNF.Address \u2191\u03b2} {d : ConNF.Address \u2191\u03b2} {A : ConNF.ExtendedIndex \u2191\u03b2} {N : ConNF.NearLitter} (hN : { path := A, value := Sum.inr N } \u2208 ConNF.StructApprox.transConstrained c d) :{ path := A, value := Sum.inr (ConNF.Litter.toNearLitter N.fst) } \u2208 ConNF.StructApprox.transConstrained c d := by sorry", "full_tactic_state": "inst\u271d\u00b2 : ConNF.Params\ninst\u271d\u00b9 : ConNF.Level\ninst\u271d : ConNF.FOAAssumptions\n\u03b2 : ConNF.\u039b\nc d : ConNF.Address \u2191\u03b2\nA : ConNF.ExtendedIndex \u2191\u03b2\nN : ConNF.NearLitter\nhN : { path := A, value := Sum.inr N } \u2208 ConNF.StructApprox.transConstrained c d\n\u22a2 { path := A, value := Sum.inr (ConNF.Litter.toNearLitter N.fst) } \u2208 ConNF.StructApprox.transConstrained c d", "dependency": [1, 60, 60, 61, 65, 995, 65, 483, 995]}, "ConNF.StructApprox.fst_mem_refl_trans_constrained'": {"natural_language_statement": "The theorem `ConNF.StructApprox.fst_mem_refl_trans_constrained'` is a part of the Constructive Ordinal Notation (ConNF) project in Lean 4. It states that if a certain address is in the set of addresses that are either less than or equal to the address `c` or less than or equal to the address `d`, within the context of Constructive Ordinal Notation (ConNF), then another related address is also in the same set. This theorem is crucial for proving the correctness of the ConNF construction.", "formal_statement": "example [ConNF.Params ] [ConNF.Level] [ConNF.FOAAssumptions] {\u03b2 : ConNF.\u039b} {c : ConNF.Address \u2191\u03b2} {d : ConNF.Address \u2191\u03b2} {A : ConNF.ExtendedIndex \u2191\u03b2} {a : ConNF.Atom} (h : { path := A, value := Sum.inl a } \u2208 ConNF.StructApprox.reflTransConstrained c d) :{ path := A, value := Sum.inr (ConNF.Litter.toNearLitter a.1) } \u2208 ConNF.StructApprox.reflTransConstrained c d := by sorry", "full_tactic_state": "inst\u271d\u00b2 : ConNF.Params\ninst\u271d\u00b9 : ConNF.Level\ninst\u271d : ConNF.FOAAssumptions\n\u03b2 : ConNF.\u039b\nc d : ConNF.Address \u2191\u03b2\nA : ConNF.ExtendedIndex \u2191\u03b2\na : ConNF.Atom\nh : { path := A, value := Sum.inl a } \u2208 ConNF.StructApprox.reflTransConstrained c d\n\u22a2 { path := A, value := Sum.inr (ConNF.Litter.toNearLitter a.1) } \u2208 ConNF.StructApprox.reflTransConstrained c d", "dependency": [1, 60, 60, 61, 67, 967, 65, 483, 967]}, "ConNF.StructApprox.fst_mem_reflTransConstrained": {"natural_language_statement": "In the context of Constructive Ordinal Notation (ConNF), the theorem `ConNF.StructApprox.fst_mem_reflTransConstrained` states that if a near-litter `N` is an element of the set `ConNF.StructApprox.reflTransConstrained c d`, then the near-litter formed by wrapping the litter of `N` with its litter set is also an element of `ConNF.StructApprox.reflTransConstrained c d`.", "formal_statement": "example [ConNF.Params ] [ConNF.Level] [ConNF.FOAAssumptions] {\u03b2 : ConNF.\u039b} {c : ConNF.Address \u2191\u03b2} {d : ConNF.Address \u2191\u03b2} {A : ConNF.ExtendedIndex \u2191\u03b2} {N : ConNF.NearLitter} (hN : { path := A, value := Sum.inr N } \u2208 ConNF.StructApprox.reflTransConstrained c d) :{ path := A, value := Sum.inr (ConNF.Litter.toNearLitter N.fst) } \u2208 ConNF.StructApprox.reflTransConstrained c d := by sorry", "full_tactic_state": "inst\u271d\u00b2 : ConNF.Params\ninst\u271d\u00b9 : ConNF.Level\ninst\u271d : ConNF.FOAAssumptions\n\u03b2 : ConNF.\u039b\nc d : ConNF.Address \u2191\u03b2\nA : ConNF.ExtendedIndex \u2191\u03b2\nN : ConNF.NearLitter\nhN : { path := A, value := Sum.inr N } \u2208 ConNF.StructApprox.reflTransConstrained c d\n\u22a2 { path := A, value := Sum.inr (ConNF.Litter.toNearLitter N.fst) } \u2208 ConNF.StructApprox.reflTransConstrained c d", "dependency": [1, 60, 60, 61, 65, 967, 65, 483, 967]}, "ConNF.StructApprox.fst_mem_transConstrained_of_mem_symmDiff": {"natural_language_statement": "The theorem `ConNF.StructApprox.fst_mem_transConstrained_of_mem_symmDiff` states that if an atom `a` is in the symmetric difference of the litter set of a near-litter `N` and the near-litter `N` itself, and if `N` is in the transitive closure of two addresses `c` and `d`, then the near-litter formed by the litter of `a` is also in the transitive closure of `c` and `d`.", "formal_statement": "example [ConNF.Params ] [ConNF.Level] [ConNF.FOAAssumptions] {\u03b2 : ConNF.\u039b} {c : ConNF.Address \u2191\u03b2} {d : ConNF.Address \u2191\u03b2} {A : ConNF.ExtendedIndex \u2191\u03b2} {N : ConNF.NearLitter} {a : ConNF.Atom} (h : a \u2208 symmDiff (ConNF.litterSet N.fst) \u2191N) (hN : { path := A, value := Sum.inr N } \u2208 ConNF.StructApprox.transConstrained c d) :{ path := A, value := Sum.inr (ConNF.Litter.toNearLitter a.1) } \u2208 ConNF.StructApprox.transConstrained c d := by sorry", "full_tactic_state": "inst\u271d\u00b2 : ConNF.Params\ninst\u271d\u00b9 : ConNF.Level\ninst\u271d : ConNF.FOAAssumptions\n\u03b2 : ConNF.\u039b\nc d : ConNF.Address \u2191\u03b2\nA : ConNF.ExtendedIndex \u2191\u03b2\nN : ConNF.NearLitter\na : ConNF.Atom\nh : a \u2208 symmDiff (ConNF.litterSet N.fst) \u2191N\nhN : { path := A, value := Sum.inr N } \u2208 ConNF.StructApprox.transConstrained c d\n\u22a2 { path := A, value := Sum.inr (ConNF.Litter.toNearLitter a.1) } \u2208 ConNF.StructApprox.transConstrained c d", "dependency": [1, 60, 60, 61, 62, 467, 65, 995, 65, 483, 995]}, "ConNF.StructApprox.fst_mem_reflTransConstrained_of_mem_symmDiff": {"natural_language_statement": "In the context of Constructive Ordinal Notation (ConNF), the theorem `ConNF.StructApprox.fst_mem_reflTransConstrained_of_mem_symmDiff` states that if an atom `a` belongs to the symmetric difference of the litter set of a near-litter `N` and the near-litter `N` itself, and if the near-litter `N` is in the reflexive-transitive closure of two addresses `c` and `d`, then the near-litter formed by the litter of `a` and its litter set is also in the reflexive-transitive closure of `c` and `d`.", "formal_statement": "example [ConNF.Params ] [ConNF.Level] [ConNF.FOAAssumptions] {\u03b2 : ConNF.\u039b} {c : ConNF.Address \u2191\u03b2} {d : ConNF.Address \u2191\u03b2} {A : ConNF.ExtendedIndex \u2191\u03b2} {N : ConNF.NearLitter} {a : ConNF.Atom} (h : a \u2208 symmDiff (ConNF.litterSet N.fst) \u2191N) (hN : { path := A, value := Sum.inr N } \u2208 ConNF.StructApprox.reflTransConstrained c d) :{ path := A, value := Sum.inr (ConNF.Litter.toNearLitter a.1) } \u2208 ConNF.StructApprox.reflTransConstrained c d := by sorry", "full_tactic_state": "inst\u271d\u00b2 : ConNF.Params\ninst\u271d\u00b9 : ConNF.Level\ninst\u271d : ConNF.FOAAssumptions\n\u03b2 : ConNF.\u039b\nc d : ConNF.Address \u2191\u03b2\nA : ConNF.ExtendedIndex \u2191\u03b2\nN : ConNF.NearLitter\na : ConNF.Atom\nh : a \u2208 symmDiff (ConNF.litterSet N.fst) \u2191N\nhN : { path := A, value := Sum.inr N } \u2208 ConNF.StructApprox.reflTransConstrained c d\n\u22a2 { path := A, value := Sum.inr (ConNF.Litter.toNearLitter a.1) } \u2208 ConNF.StructApprox.reflTransConstrained c d", "dependency": [1, 60, 60, 61, 62, 467, 65, 967, 65, 483, 967]}, "ConNF.StructApprox.fst_mem_transConstrained_of_mem": {"natural_language_statement": "In the context of Constructive Ordinal Notation (ConNF), the theorem `ConNF.StructApprox.fst_mem_transConstrained_of_mem` asserts that if an atom `a` belongs to a near-litter `N`, and the near-litter `N` is an element of the transitive closure of the relation defined by two addresses `c` and `d`, then the near-litter formed by wrapping the litter of `a` is also an element of the transitive closure of the relation defined by `c` and `d`.", "formal_statement": "example [ConNF.Params ] [ConNF.Level] [ConNF.FOAAssumptions] {\u03b2 : ConNF.\u039b} {c : ConNF.Address \u2191\u03b2} {d : ConNF.Address \u2191\u03b2} {A : ConNF.ExtendedIndex \u2191\u03b2} {N : ConNF.NearLitter} {a : ConNF.Atom} (h : a \u2208 N) (hN : { path := A, value := Sum.inr N } \u2208 ConNF.StructApprox.transConstrained c d) :{ path := A, value := Sum.inr (ConNF.Litter.toNearLitter a.1) } \u2208 ConNF.StructApprox.transConstrained c d := by sorry", "full_tactic_state": "inst\u271d\u00b2 : ConNF.Params\ninst\u271d\u00b9 : ConNF.Level\ninst\u271d : ConNF.FOAAssumptions\n\u03b2 : ConNF.\u039b\nc d : ConNF.Address \u2191\u03b2\nA : ConNF.ExtendedIndex \u2191\u03b2\nN : ConNF.NearLitter\na : ConNF.Atom\nh : a \u2208 N\nhN : { path := A, value := Sum.inr N } \u2208 ConNF.StructApprox.transConstrained c d\n\u22a2 { path := A, value := Sum.inr (ConNF.Litter.toNearLitter a.1) } \u2208 ConNF.StructApprox.transConstrained c d", "dependency": [1, 60, 60, 61, 65, 995, 65, 483, 995]}, "ConNF.StructApprox.constrainedAction_atomMap": {"natural_language_statement": "In the context of Constructive Ordinal Notation (ConNF), the function `ConNF.StructApprox.constrainedAction_atomMap` defines a `\u03b2`-structural action as a product that assigns a near-litter action to each `\u03b2`-extended index, under the condition that the cardinality of a given set `s` is strictly less than the cardinality of the type `ConNF.\u03ba`.", "formal_statement": "@[simp]example [ConNF.Params ] [ConNF.Level] [ConNF.FOAAssumptions] {\u03b2 : ConNF.\u039b} [ConNF.LeLevel \u2191\u03b2] [ConNF.StructApprox.FreedomOfActionHypothesis \u03b2] {\u03c0 : ConNF.StructApprox \u2191\u03b2} {s : Set (ConNF.Address \u2191\u03b2)} {hs : ConNF.Small s} {B : ConNF.ExtendedIndex \u2191\u03b2} {a : ConNF.Atom} :(ConNF.StructApprox.constrainedAction \u03c0 s hs B).atomMap a = { Dom := \u2203 c \u2208 s, { path := B, value := Sum.inl a } \u2264 c, get := fun (x : \u2203 c \u2208 s, { path := B, value := Sum.inl a } \u2264 c) => ConNF.StructApprox.completeAtomMap \u03c0 B a } := by sorry", "full_tactic_state": "inst\u271d\u2074 : ConNF.Params\ninst\u271d\u00b3 : ConNF.Level\ninst\u271d\u00b2 : ConNF.FOAAssumptions\n\u03b2 : ConNF.\u039b\ninst\u271d\u00b9 : ConNF.LeLevel \u2191\u03b2\ninst\u271d : ConNF.StructApprox.FreedomOfActionHypothesis \u03b2\n\u03c0 : ConNF.StructApprox \u2191\u03b2\ns : Set (ConNF.Address \u2191\u03b2)\nhs : ConNF.Small s\nB : ConNF.ExtendedIndex \u2191\u03b2\na : ConNF.Atom\n\u22a2 (ConNF.StructApprox.constrainedAction \u03c0 s hs B).atomMap a =\n    { Dom := \u2203 c \u2208 s, { path := B, value := Sum.inl a } \u2264 c, get := fun x => ConNF.StructApprox.completeAtomMap \u03c0 B a }", "dependency": [1, 402, 779, 781, 69, 60, 233, 61, 978, 67, 67, 784]}, "ConNF.StructApprox.constrainedAction_litterMap": {"natural_language_statement": "The function `ConNF.StructApprox.constrainedAction_litterMap` is a part of the proof of freedom of action in Constructive Ordinal Notation (ConNF). It defines a `\u03b2`-structural action as a product that assigns a near-litter action to each `\u03b2`-extended index, under the condition that the cardinality of a given set `s` is strictly less than the cardinality of the type `ConNF.\u03ba`.", "formal_statement": "@[simp]example [ConNF.Params ] [ConNF.Level] [ConNF.FOAAssumptions] {\u03b2 : ConNF.\u039b} [ConNF.LeLevel \u2191\u03b2] [ConNF.StructApprox.FreedomOfActionHypothesis \u03b2] {\u03c0 : ConNF.StructApprox \u2191\u03b2} {s : Set (ConNF.Address \u2191\u03b2)} {hs : ConNF.Small s} {B : ConNF.ExtendedIndex \u2191\u03b2} {L : ConNF.Litter} :(ConNF.StructApprox.constrainedAction \u03c0 s hs B).litterMap L = { Dom := \u2203 c \u2208 s, { path := B, value := Sum.inr (ConNF.Litter.toNearLitter L) } \u2264 c, get := fun (x : \u2203 c \u2208 s, { path := B, value := Sum.inr (ConNF.Litter.toNearLitter L) } \u2264 c) => ConNF.StructApprox.completeNearLitterMap \u03c0 B (ConNF.Litter.toNearLitter L) } := by sorry", "full_tactic_state": "inst\u271d\u2074 : ConNF.Params\ninst\u271d\u00b3 : ConNF.Level\ninst\u271d\u00b2 : ConNF.FOAAssumptions\n\u03b2 : ConNF.\u039b\ninst\u271d\u00b9 : ConNF.LeLevel \u2191\u03b2\ninst\u271d : ConNF.StructApprox.FreedomOfActionHypothesis \u03b2\n\u03c0 : ConNF.StructApprox \u2191\u03b2\ns : Set (ConNF.Address \u2191\u03b2)\nhs : ConNF.Small s\nB : ConNF.ExtendedIndex \u2191\u03b2\nL : ConNF.Litter\n\u22a2 (ConNF.StructApprox.constrainedAction \u03c0 s hs B).litterMap L =\n    { Dom := \u2203 c \u2208 s, { path := B, value := Sum.inr (ConNF.Litter.toNearLitter L) } \u2264 c,\n      get := fun x => ConNF.StructApprox.completeNearLitterMap \u03c0 B (ConNF.Litter.toNearLitter L) }", "dependency": [1, 402, 779, 781, 69, 60, 233, 61, 978, 65, 483, 65, 483, 792, 483]}, "ConNF.StructApprox.ihsAction_atomMap": {"natural_language_statement": "In the context of Constructive Ordinal Notation (ConNF), the function `ConNF.StructApprox.ihsAction_atomMap` defines a `\u03b2`-structural action as a product that assigns a near-litter action to each `\u03b2`-extended index. It takes a `\u03b2`-structural approximation `\u03c0` and returns a function that maps each `\u03b2`-extended index to an atom. This function is defined using the `ConNF.HypAction.fixAtom` function, which is part of the `ConNF.HypAction` class. The `ConNF.HypAction.fixAtom` function uses the `ConNF.StructApprox.atomCompletion` and `ConNF.StructApprox.nearLitterCompletion` components of the `\u03b2`-structural approximation `\u03c0`.", "formal_statement": "@[simp]example [ConNF.Params ] [ConNF.Level] [ConNF.FOAAssumptions] {\u03b2 : ConNF.\u039b} [ConNF.LeLevel \u2191\u03b2] [ConNF.StructApprox.FreedomOfActionHypothesis \u03b2] {\u03c0 : ConNF.StructApprox \u2191\u03b2} {c : ConNF.Address \u2191\u03b2} {d : ConNF.Address \u2191\u03b2} {B : ConNF.ExtendedIndex \u2191\u03b2} {a : ConNF.Atom} :(ConNF.StructApprox.ihsAction \u03c0 c d B).atomMap a = { Dom := { path := B, value := Sum.inl a } \u2208 ConNF.StructApprox.transConstrained c d, get := fun (x : { path := B, value := Sum.inl a } \u2208 ConNF.StructApprox.transConstrained c d) => ConNF.StructApprox.completeAtomMap \u03c0 B a } := by sorry", "full_tactic_state": "inst\u271d\u2074 : ConNF.Params\ninst\u271d\u00b3 : ConNF.Level\ninst\u271d\u00b2 : ConNF.FOAAssumptions\n\u03b2 : ConNF.\u039b\ninst\u271d\u00b9 : ConNF.LeLevel \u2191\u03b2\ninst\u271d : ConNF.StructApprox.FreedomOfActionHypothesis \u03b2\n\u03c0 : ConNF.StructApprox \u2191\u03b2\nc d : ConNF.Address \u2191\u03b2\nB : ConNF.ExtendedIndex \u2191\u03b2\na : ConNF.Atom\n\u22a2 (ConNF.StructApprox.ihsAction \u03c0 c d B).atomMap a =\n    { Dom := { path := B, value := Sum.inl a } \u2208 ConNF.StructApprox.transConstrained c d,\n      get := fun x => ConNF.StructApprox.completeAtomMap \u03c0 B a }", "dependency": [1, 402, 779, 781, 60, 60, 61, 966, 67, 995, 67, 995, 784]}, "ConNF.StructApprox.ihsAction_litterMap": {"natural_language_statement": "The function `ConNF.StructApprox.ihsAction_litterMap` defines a `\u03b2`-structural action as a product that assigns a near-litter action to each `\u03b2`-extended index in the context of Constructive Ordinal Notation (ConNF). This function is used in the proof of freedom of action in Constructive Ordinal Notation (ConNF).", "formal_statement": "@[simp]example [ConNF.Params ] [ConNF.Level] [ConNF.FOAAssumptions] {\u03b2 : ConNF.\u039b} [ConNF.LeLevel \u2191\u03b2] [ConNF.StructApprox.FreedomOfActionHypothesis \u03b2] {\u03c0 : ConNF.StructApprox \u2191\u03b2} {c : ConNF.Address \u2191\u03b2} {d : ConNF.Address \u2191\u03b2} {B : ConNF.ExtendedIndex \u2191\u03b2} {L : ConNF.Litter} :(ConNF.StructApprox.ihsAction \u03c0 c d B).litterMap L = { Dom := { path := B, value := Sum.inr (ConNF.Litter.toNearLitter L) } \u2208 ConNF.StructApprox.transConstrained c d, get := fun (x : { path := B, value := Sum.inr (ConNF.Litter.toNearLitter L) } \u2208 ConNF.StructApprox.transConstrained c d) => ConNF.StructApprox.completeNearLitterMap \u03c0 B (ConNF.Litter.toNearLitter L) } := by sorry", "full_tactic_state": "inst\u271d\u2074 : ConNF.Params\ninst\u271d\u00b3 : ConNF.Level\ninst\u271d\u00b2 : ConNF.FOAAssumptions\n\u03b2 : ConNF.\u039b\ninst\u271d\u00b9 : ConNF.LeLevel \u2191\u03b2\ninst\u271d : ConNF.StructApprox.FreedomOfActionHypothesis \u03b2\n\u03c0 : ConNF.StructApprox \u2191\u03b2\nc d : ConNF.Address \u2191\u03b2\nB : ConNF.ExtendedIndex \u2191\u03b2\nL : ConNF.Litter\n\u22a2 (ConNF.StructApprox.ihsAction \u03c0 c d B).litterMap L =\n    { Dom := { path := B, value := Sum.inr (ConNF.Litter.toNearLitter L) } \u2208 ConNF.StructApprox.transConstrained c d,\n      get := fun x => ConNF.StructApprox.completeNearLitterMap \u03c0 B (ConNF.Litter.toNearLitter L) }", "dependency": [1, 402, 779, 781, 60, 60, 61, 966, 65, 483, 995, 65, 483, 995, 792, 483]}, "ConNF.StructApprox.ihsAction_symm": {"natural_language_statement": "The theorem `ConNF.StructApprox.ihsAction_symm` states that the `\u03b2`-structural action (defined by `ConNF.StructApprox.ihsAction`) is symmetric in the sense that swapping the arguments does not change the outcome. This property is crucial for establishing the well-definedness of the `\u03b2`-structural action when constructing proofs about the freedom of action in Constructive Ordinal Notation (ConNF).", "formal_statement": "example [ConNF.Params ] [ConNF.Level] [ConNF.FOAAssumptions] {\u03b2 : ConNF.\u039b} [ConNF.LeLevel \u2191\u03b2] [ConNF.StructApprox.FreedomOfActionHypothesis \u03b2] (\u03c0 : ConNF.StructApprox \u2191\u03b2) (c : ConNF.Address \u2191\u03b2) (d : ConNF.Address \u2191\u03b2) :ConNF.StructApprox.ihsAction \u03c0 c d = ConNF.StructApprox.ihsAction \u03c0 d c := by sorry", "full_tactic_state": "inst\u271d\u2074 : ConNF.Params\ninst\u271d\u00b3 : ConNF.Level\ninst\u271d\u00b2 : ConNF.FOAAssumptions\n\u03b2 : ConNF.\u039b\ninst\u271d\u00b9 : ConNF.LeLevel \u2191\u03b2\ninst\u271d : ConNF.StructApprox.FreedomOfActionHypothesis \u03b2\n\u03c0 : ConNF.StructApprox \u2191\u03b2\nc d : ConNF.Address \u2191\u03b2\n\u22a2 ConNF.StructApprox.ihsAction \u03c0 c d = ConNF.StructApprox.ihsAction \u03c0 d c", "dependency": [1, 402, 779, 781, 60, 60, 966, 966]}, "ConNF.StructApprox.constrainedAction_mono": {"natural_language_statement": "Let $s \\subseteq t$ be subsets of the set of $\\beta$-extended indices with the property that their cardinalities are strictly less than the cardinality of type $\\kappa$. Then, the constrained action of $\\pi$ on $s$ is less than or equal to the constrained action of $\\pi$ on $t$.", "formal_statement": "example [ConNF.Params ] [ConNF.Level] [ConNF.FOAAssumptions] {\u03b2 : ConNF.\u039b} [ConNF.LeLevel \u2191\u03b2] [ConNF.StructApprox.FreedomOfActionHypothesis \u03b2] {\u03c0 : ConNF.StructApprox \u2191\u03b2} {s : Set (ConNF.Address \u2191\u03b2)} {t : Set (ConNF.Address \u2191\u03b2)} {hs : ConNF.Small s} {ht : ConNF.Small t} (h : s \u2286 t) :ConNF.StructApprox.constrainedAction \u03c0 s hs \u2264 ConNF.StructApprox.constrainedAction \u03c0 t ht := by sorry", "full_tactic_state": "inst\u271d\u2074 : ConNF.Params\ninst\u271d\u00b3 : ConNF.Level\ninst\u271d\u00b2 : ConNF.FOAAssumptions\n\u03b2 : ConNF.\u039b\ninst\u271d\u00b9 : ConNF.LeLevel \u2191\u03b2\ninst\u271d : ConNF.StructApprox.FreedomOfActionHypothesis \u03b2\n\u03c0 : ConNF.StructApprox \u2191\u03b2\ns t : Set (ConNF.Address \u2191\u03b2)\nhs : ConNF.Small s\nht : ConNF.Small t\nh : s \u2286 t\n\u22a2 ConNF.StructApprox.constrainedAction \u03c0 s hs \u2264 ConNF.StructApprox.constrainedAction \u03c0 t ht", "dependency": [1, 402, 779, 781, 69, 60, 69, 60, 233, 233, 978, 978]}, "ConNF.NearLitterAction.mk_dom_symmDiff_le": {"natural_language_statement": "The theorem `ConNF.NearLitterAction.mk_dom_symmDiff_le` states that the cardinality of the symmetric difference of the domain of `\u03c6.litterMap` and the image of the domain of `\u03c6.litterMap` under `ConNF.NearLitterAction.roughLitterMapOrElse` is less than or equal to the cardinality of the set of litters that are not banned by `\u03c6`.", "formal_statement": "example [ConNF.Params ] (\u03c6 : ConNF.NearLitterAction) :Cardinal.mk \u2191(symmDiff (PFun.Dom \u03c6.litterMap) (ConNF.NearLitterAction.roughLitterMapOrElse \u03c6 '' PFun.Dom \u03c6.litterMap)) \u2264 Cardinal.mk \u2191{L : ConNF.Litter | \u00ac ConNF.NearLitterAction.BannedLitter \u03c6 L} := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03c6 : ConNF.NearLitterAction\n\u22a2 Cardinal.mk\n      \u2191(symmDiff (PFun.Dom \u03c6.litterMap) (ConNF.NearLitterAction.roughLitterMapOrElse \u03c6 '' PFun.Dom \u03c6.litterMap)) \u2264\n    Cardinal.mk \u2191{L | \u00acConNF.NearLitterAction.BannedLitter \u03c6 L}", "dependency": [1, 29, 62, 404, 1064, 404, 29, 1065]}, "ConNF.NearLitterAction.aleph0_le_not_bannedLitter": {"natural_language_statement": "The theorem `ConNF.NearLitterAction.aleph0_le_not_bannedLitter` states that the cardinality of the set of litters that are not banned is at least `\u2135\u2080`, the smallest infinite cardinal number.", "formal_statement": "example [ConNF.Params ] (\u03c6 : ConNF.NearLitterAction) :Cardinal.aleph0 \u2264 Cardinal.mk \u2191{L : ConNF.Litter | \u00ac ConNF.NearLitterAction.BannedLitter \u03c6 L} := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03c6 : ConNF.NearLitterAction\n\u22a2 Cardinal.aleph0 \u2264 Cardinal.mk \u2191{L | \u00acConNF.NearLitterAction.BannedLitter \u03c6 L}", "dependency": [1, 510, 29, 1065]}, "ConNF.NearLitterAction.litterPerm'_apply_eq": {"natural_language_statement": "The function ConNF.NearLitterAction.litterPerm'_apply_eq is a theorem that states that for any litter L in the domain of the map of a near litter action \u03c6, the application of the permutation litterPerm' to L is equal to the first component of the result of applying roughLitterMapOrElse to \u03c6 and L. This theorem ensures that the permutation on litters behaves as expected according to the laws of the near litter action.", "formal_statement": "example [ConNF.Params ] {\u03c6 : ConNF.NearLitterAction} {h\u03c6 : ConNF.NearLitterAction.Lawful \u03c6} (L : ConNF.Litter) (hL : L \u2208 PFun.Dom \u03c6.litterMap) :(ConNF.NearLitterAction.litterPerm' \u03c6 h\u03c6).toFun L = ConNF.NearLitterAction.roughLitterMapOrElse \u03c6 L := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03c6 : ConNF.NearLitterAction\nh\u03c6 : ConNF.NearLitterAction.Lawful \u03c6\nL : ConNF.Litter\nhL : L \u2208 PFun.Dom \u03c6.litterMap\n\u22a2 (ConNF.NearLitterAction.litterPerm' \u03c6 h\u03c6).toFun L = ConNF.NearLitterAction.roughLitterMapOrElse \u03c6 L", "dependency": [1, 825, 404, 1068, 1064]}, "ConNF.NearLitterAction.litterPerm_apply_eq": {"natural_language_statement": "The theorem states that for any lawful near litter action `\u03c6` and any litter `L` in the domain of the litter map, the partial permutation `ConNF.NearLitterAction.litterPerm \u03c6 h\u03c6` applied to `L` is equal to `ConNF.NearLitterAction.roughLitterMapOrElse \u03c6 L`.", "formal_statement": "example [ConNF.Params ] {\u03c6 : ConNF.NearLitterAction} {h\u03c6 : ConNF.NearLitterAction.Lawful \u03c6} (L : ConNF.Litter) (hL : L \u2208 PFun.Dom \u03c6.litterMap) :(ConNF.NearLitterAction.litterPerm \u03c6 h\u03c6).toFun L = ConNF.NearLitterAction.roughLitterMapOrElse \u03c6 L := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03c6 : ConNF.NearLitterAction\nh\u03c6 : ConNF.NearLitterAction.Lawful \u03c6\nL : ConNF.Litter\nhL : L \u2208 PFun.Dom \u03c6.litterMap\n\u22a2 (ConNF.NearLitterAction.litterPerm \u03c6 h\u03c6).toFun L = ConNF.NearLitterAction.roughLitterMapOrElse \u03c6 L", "dependency": [1, 825, 404, 1070, 1064]}, "ConNF.NearLitterAction.litterPerm'_domain_small": {"natural_language_statement": "The theorem `ConNF.NearLitterAction.litterPerm'_domain_small` states that the domain of the partial permutation `ConNF.NearLitterAction.litterPerm'` on the set of litters in the context of Constructive Ordinal Notation (ConNF) is small, meaning its cardinality is strictly less than the cardinality of the type `ConNF.\u03ba`.", "formal_statement": "example [ConNF.Params ] (\u03c6 : ConNF.NearLitterAction) (h\u03c6 : ConNF.NearLitterAction.Lawful \u03c6) :ConNF.Small (ConNF.NearLitterAction.litterPerm' \u03c6 h\u03c6).domain := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03c6 : ConNF.NearLitterAction\nh\u03c6 : ConNF.NearLitterAction.Lawful \u03c6\n\u22a2 ConNF.Small (ConNF.NearLitterAction.litterPerm' \u03c6 h\u03c6).domain", "dependency": [1, 825, 233, 1068]}, "ConNF.NearLitterAction.litterPerm_domain_small": {"natural_language_statement": "The theorem `ConNF.NearLitterAction.litterPerm_domain_small` states that the domain of the partial permutation `ConNF.NearLitterAction.litterPerm \u03c6 h\u03c6` is small, meaning its cardinality is strictly less than the cardinality of the type `ConNF.\u03ba` in the context of Constructive Ordinal Notation (ConNF).", "formal_statement": "example [ConNF.Params ] (\u03c6 : ConNF.NearLitterAction) (h\u03c6 : ConNF.NearLitterAction.Lawful \u03c6) :ConNF.Small (ConNF.NearLitterAction.litterPerm \u03c6 h\u03c6).domain := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03c6 : ConNF.NearLitterAction\nh\u03c6 : ConNF.NearLitterAction.Lawful \u03c6\n\u22a2 ConNF.Small (ConNF.NearLitterAction.litterPerm \u03c6 h\u03c6).domain", "dependency": [1, 825, 233, 1070]}, "ConNF.NearLitterAction.atomMap_ran_small": {"natural_language_statement": "In the context of Constructive Ordinal Notation (ConNF), the theorem `ConNF.NearLitterAction.atomMap_ran_small` asserts that the range of the partial function `\u03c6.atomMap`, which maps elements of a \"near-litter\" to \"atoms\" in ConNF, is a small set. This means that the cardinality of the set of all possible values that `\u03c6.atomMap` can produce is strictly less than the cardinality of the type `ConNF.\u03ba`. This property is crucial for the construction of the natural numbers in ConNF to avoid inconsistencies in the definition of subtraction.", "formal_statement": "example [ConNF.Params ] (\u03c6 : ConNF.NearLitterAction) :ConNF.Small (PFun.ran \u03c6.atomMap) := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03c6 : ConNF.NearLitterAction\n\u22a2 ConNF.Small (PFun.ran \u03c6.atomMap)", "dependency": [1, 233, 824]}, "ConNF.NearLitterAction.needForwardImages_small": {"natural_language_statement": "The theorem `ConNF.NearLitterAction.needForwardImages_small` states that the set of elements in the range of the partial function `\u03c6.atomMap` that are not in its domain has a cardinality strictly less than the cardinality of the type `ConNF.\u03ba`.", "formal_statement": "example [ConNF.Params ] (\u03c6 : ConNF.NearLitterAction) :ConNF.Small (ConNF.NearLitterAction.needForwardImages \u03c6) := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03c6 : ConNF.NearLitterAction\n\u22a2 ConNF.Small (ConNF.NearLitterAction.needForwardImages \u03c6)", "dependency": [1, 233, 1075]}, "ConNF.NearLitterAction.needBackwardImages_small": {"natural_language_statement": "The theorem `ConNF.NearLitterAction.needBackwardImages_small` states that the set of `ConNF.Atom`s that need backward images under the partial function `ConNF.NearLitterAction.atomMap` has a cardinality strictly less than the cardinality of the type `ConNF.\u03ba`.", "formal_statement": "example [ConNF.Params ] (\u03c6 : ConNF.NearLitterAction) :ConNF.Small (ConNF.NearLitterAction.needBackwardImages \u03c6) := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03c6 : ConNF.NearLitterAction\n\u22a2 ConNF.Small (ConNF.NearLitterAction.needBackwardImages \u03c6)", "dependency": [1, 233, 1077]}, "ConNF.NearLitterAction.mk_diff_dom_ran": {"natural_language_statement": "The theorem `ConNF.NearLitterAction.mk_diff_dom_ran` asserts that the difference between the number of atoms in a litter `L` (excluding those in the domain and range of the `NearLitterAction` function `\u03c6`) and the cardinality of the set of atoms in `ConNF.\u03ba` is equal to the cardinality of `ConNF.\u03ba`.", "formal_statement": "example [ConNF.Params ] (\u03c6 : ConNF.NearLitterAction) (L : ConNF.Litter) :Cardinal.mk \u2191(ConNF.litterSet L \\ (PFun.Dom \u03c6.atomMap \u222a PFun.ran \u03c6.atomMap)) = Cardinal.mk ConNF.\u03ba := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03c6 : ConNF.NearLitterAction\nL : ConNF.Litter\n\u22a2 Cardinal.mk \u2191(ConNF.litterSet L \\ (PFun.Dom \u03c6.atomMap \u222a PFun.ran \u03c6.atomMap)) = Cardinal.mk ConNF.\u03ba", "dependency": [1, 29, 467, 404, 824, 29]}, "ConNF.NearLitterAction.need_images_small": {"natural_language_statement": "The theorem states that the cardinality of the union of two sets, each being the product of `\u2115` (the natural numbers) with a subset of `ConNF.Atom`s (the atoms used in the notation system of Constructive Ordinal Notation, ConNF), is less than the cardinality of `ConNF.\u03ba`. The first set consists of pairs `(n, a)` where `n` is a natural number and `a` is an atom that needs backward images under the partial function `ConNF.NearLitterAction.atomMap`, and the second set consists of pairs `(n, b)` where `n` is a natural number and `b` is an element in the range of the partial function that is not in its domain. The inequality signifies that the union of these two sets is a small subset of `ConNF.\u03ba`, which is a key condition for the construction of the natural numbers in ConNF.", "formal_statement": "example [ConNF.Params ] (\u03c6 : ConNF.NearLitterAction) :Cardinal.mk (\u2115 \u00d7 \u2191(ConNF.NearLitterAction.needBackwardImages \u03c6) \u2295 \u2115 \u00d7 \u2191(ConNF.NearLitterAction.needForwardImages \u03c6)) < Cardinal.mk ConNF.\u03ba := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03c6 : ConNF.NearLitterAction\n\u22a2 Cardinal.mk (\u2115 \u00d7 \u2191(ConNF.NearLitterAction.needBackwardImages \u03c6) \u2295 \u2115 \u00d7 \u2191(ConNF.NearLitterAction.needForwardImages \u03c6)) <\n    Cardinal.mk ConNF.\u03ba", "dependency": [1, 29, 1077, 1075, 29]}, "ConNF.NearLitterAction.le_mk_diff_dom_ran": {"natural_language_statement": "In the context of Constructive Ordinal Notation (ConNF), the theorem `ConNF.NearLitterAction.le_mk_diff_dom_ran` states that the cardinality of the union of two sets, each representing the need for backward and forward images under a partial function `\u03c6.atomMap`, is less than or equal to the cardinality of the difference between the litter set corresponding to a given litter `L` and the union of the domain and range of `\u03c6.atomMap`.", "formal_statement": "example [ConNF.Params ] (\u03c6 : ConNF.NearLitterAction) (L : ConNF.Litter) :Cardinal.mk (\u2115 \u00d7 \u2191(ConNF.NearLitterAction.needBackwardImages \u03c6) \u2295 \u2115 \u00d7 \u2191(ConNF.NearLitterAction.needForwardImages \u03c6)) \u2264 Cardinal.mk \u2191(ConNF.litterSet L \\ (PFun.Dom \u03c6.atomMap \u222a PFun.ran \u03c6.atomMap)) := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03c6 : ConNF.NearLitterAction\nL : ConNF.Litter\n\u22a2 Cardinal.mk (\u2115 \u00d7 \u2191(ConNF.NearLitterAction.needBackwardImages \u03c6) \u2295 \u2115 \u00d7 \u2191(ConNF.NearLitterAction.needForwardImages \u03c6)) \u2264\n    Cardinal.mk \u2191(ConNF.litterSet L \\ (PFun.Dom \u03c6.atomMap \u222a PFun.ran \u03c6.atomMap))", "dependency": [1, 29, 1077, 1075, 29, 467, 404, 824]}, "ConNF.NearLitterAction.orbitSet_subset": {"natural_language_statement": "Given a `ConNF.NearLitterAction` object `\u03c6` and a `ConNF.Litter` object `L`, the set `ConNF.NearLitterAction.orbitSet \u03c6 L` represents the orbit of `L` under the action of `\u03c6`. This set contains all the `ConNF.Atom` objects that can be reached from `L` by repeatedly applying the action defined by `\u03c6`. The theorem `ConNF.NearLitterAction.orbitSet_subset` states that this orbit set is a subset of the set `ConNF.litterSet L` minus the union of the domain and range of the partial function `\u03c6.atomMap`.", "formal_statement": "example [ConNF.Params ] (\u03c6 : ConNF.NearLitterAction) (L : ConNF.Litter) :ConNF.NearLitterAction.orbitSet \u03c6 L \u2286 ConNF.litterSet L \\ (PFun.Dom \u03c6.atomMap \u222a PFun.ran \u03c6.atomMap) := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03c6 : ConNF.NearLitterAction\nL : ConNF.Litter\n\u22a2 ConNF.NearLitterAction.orbitSet \u03c6 L \u2286 ConNF.litterSet L \\ (PFun.Dom \u03c6.atomMap \u222a PFun.ran \u03c6.atomMap)", "dependency": [1, 1082, 467, 404, 824]}, "ConNF.NearLitterAction.not_mem_needForwardImages_of_mem_orbitSet": {"natural_language_statement": "Given a `ConNF.NearLitterAction` object `\u03c6` and a `ConNF.Litter` object `L`, if an `ConNF.Atom` object `a` is in the orbit of `L` under the action of `\u03c6`, then `a` is not in the set of elements in the range of the partial function `\u03c6.atomMap` that are not in its domain.", "formal_statement": "example [ConNF.Params ] (\u03c6 : ConNF.NearLitterAction) {a : ConNF.Atom} {L : ConNF.Litter} (h : a \u2208 ConNF.NearLitterAction.orbitSet \u03c6 L) :a \u2209 ConNF.NearLitterAction.needForwardImages \u03c6 := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03c6 : ConNF.NearLitterAction\na : ConNF.Atom\nL : ConNF.Litter\nh : a \u2208 ConNF.NearLitterAction.orbitSet \u03c6 L\n\u22a2 a \u2209 ConNF.NearLitterAction.needForwardImages \u03c6", "dependency": [1, 1082, 1075]}, "ConNF.NearLitterAction.not_mem_needBackwardImages_of_mem_orbitSet": {"natural_language_statement": "Given a `ConNF.NearLitterAction` object `\u03c6` and a `ConNF.Litter` object `L`, if an `ConNF.Atom` object `a` is in the orbit of `L` under the action of `\u03c6`, then `a` is not in the set of `ConNF.Atom`s that need backward images under the partial function `ConNF.NearLitterAction.atomMap`.", "formal_statement": "example [ConNF.Params ] (\u03c6 : ConNF.NearLitterAction) {a : ConNF.Atom} {L : ConNF.Litter} (h : a \u2208 ConNF.NearLitterAction.orbitSet \u03c6 L) :a \u2209 ConNF.NearLitterAction.needBackwardImages \u03c6 := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03c6 : ConNF.NearLitterAction\na : ConNF.Atom\nL : ConNF.Litter\nh : a \u2208 ConNF.NearLitterAction.orbitSet \u03c6 L\n\u22a2 a \u2209 ConNF.NearLitterAction.needBackwardImages \u03c6", "dependency": [1, 1082, 1077]}, "ConNF.NearLitterAction.mk_orbitSet": {"natural_language_statement": "The theorem `ConNF.NearLitterAction.mk_orbitSet` states that the cardinality of the orbit of a `ConNF.Litter` object `L` under the action of a `ConNF.NearLitterAction` object `\u03c6` is equal to the cardinality of the set `\u2115 \u00d7 \u2191(ConNF.NearLitterAction.needBackwardImages \u03c6) \u2295 \u2115 \u00d7 \u2191(ConNF.NearLitterAction.needForwardImages \u03c6)`.", "formal_statement": "example [ConNF.Params ] (\u03c6 : ConNF.NearLitterAction) (L : ConNF.Litter) :Cardinal.mk \u2191(ConNF.NearLitterAction.orbitSet \u03c6 L) = Cardinal.mk (\u2115 \u00d7 \u2191(ConNF.NearLitterAction.needBackwardImages \u03c6) \u2295 \u2115 \u00d7 \u2191(ConNF.NearLitterAction.needForwardImages \u03c6)) := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03c6 : ConNF.NearLitterAction\nL : ConNF.Litter\n\u22a2 Cardinal.mk \u2191(ConNF.NearLitterAction.orbitSet \u03c6 L) =\n    Cardinal.mk (\u2115 \u00d7 \u2191(ConNF.NearLitterAction.needBackwardImages \u03c6) \u2295 \u2115 \u00d7 \u2191(ConNF.NearLitterAction.needForwardImages \u03c6))", "dependency": [1, 29, 1082, 29, 1077, 1075]}, "ConNF.NearLitterAction.orbitSet_small": {"natural_language_statement": "Given a `ConNF.NearLitterAction` object `\u03c6` and a `ConNF.Litter` object `L`, the set of `ConNF.Atom` objects that can be reached from `L` by repeatedly applying the action defined by `\u03c6` has a cardinality that is strictly less than the cardinality of the type `ConNF.\u03ba`.", "formal_statement": "example [ConNF.Params ] (\u03c6 : ConNF.NearLitterAction) (L : ConNF.Litter) :ConNF.Small (ConNF.NearLitterAction.orbitSet \u03c6 L) := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03c6 : ConNF.NearLitterAction\nL : ConNF.Litter\n\u22a2 ConNF.Small (ConNF.NearLitterAction.orbitSet \u03c6 L)", "dependency": [1, 233, 1082]}, "ConNF.NearLitterAction.nextForwardImage_eq": {"natural_language_statement": "The `ConNF.NearLitterAction.nextForwardImage_eq` theorem in Lean 4 states that for a lawful near litter action \u03c6, if two elements `a` and `b` are mapped by `ConNF.NearLitterAction.nextForwardImage \u03c6 h\u03c6` to the same litter element, then the two litters containing `a` and `b` respectively must be equal.", "formal_statement": "example [ConNF.Params ] (\u03c6 : ConNF.NearLitterAction) (h\u03c6 : ConNF.NearLitterAction.Lawful \u03c6) {L\u2081 : ConNF.Litter} {L\u2082 : ConNF.Litter} {a : \u2115 \u00d7 \u2191(ConNF.NearLitterAction.needForwardImages \u03c6)} {b : \u2115 \u00d7 \u2191(ConNF.NearLitterAction.needForwardImages \u03c6)} (hL\u2081 : L\u2081 \u2208 (ConNF.NearLitterAction.litterPerm \u03c6 h\u03c6).domain) (hL\u2082 : L\u2082 \u2208 (ConNF.NearLitterAction.litterPerm \u03c6 h\u03c6).domain) (h : ConNF.NearLitterAction.nextForwardImage \u03c6 h\u03c6 L\u2081 a = ConNF.NearLitterAction.nextForwardImage \u03c6 h\u03c6 L\u2082 b) :L\u2081 = L\u2082 := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03c6 : ConNF.NearLitterAction\nh\u03c6 : ConNF.NearLitterAction.Lawful \u03c6\nL\u2081 L\u2082 : ConNF.Litter\na b : \u2115 \u00d7 \u2191(ConNF.NearLitterAction.needForwardImages \u03c6)\nhL\u2081 : L\u2081 \u2208 (ConNF.NearLitterAction.litterPerm \u03c6 h\u03c6).domain\nhL\u2082 : L\u2082 \u2208 (ConNF.NearLitterAction.litterPerm \u03c6 h\u03c6).domain\nh : ConNF.NearLitterAction.nextForwardImage \u03c6 h\u03c6 L\u2081 a = ConNF.NearLitterAction.nextForwardImage \u03c6 h\u03c6 L\u2082 b\n\u22a2 L\u2081 = L\u2082", "dependency": [1, 825, 1075, 1075, 1070, 1070, 1088, 1088]}, "ConNF.NearLitterAction.nextBackwardImage_eq": {"natural_language_statement": "Function `ConNF.NearLitterAction.nextBackwardImage` is used in the context of Constructive Ordinal Notation (ConNF) to compute the next backward image of an element in the set of `ConNF.Atom`s that need backward images under the partial function `ConNF.NearLitterAction.atomMap`. The theorem `ConNF.NearLitterAction.nextBackwardImage_eq` states that for two elements `a` and `b` in the domain of `ConNF.NearLitterAction.nextBackwardImage`, if their next backward images are equal, then the corresponding litters `L\u2081` and `L\u2082` must also be equal.", "formal_statement": "example [ConNF.Params ] (\u03c6 : ConNF.NearLitterAction) (h\u03c6 : ConNF.NearLitterAction.Lawful \u03c6) {L\u2081 : ConNF.Litter} {L\u2082 : ConNF.Litter} {a : \u2115 \u00d7 \u2191(ConNF.NearLitterAction.needBackwardImages \u03c6)} {b : \u2115 \u00d7 \u2191(ConNF.NearLitterAction.needBackwardImages \u03c6)} (ha : a \u2208 ConNF.NearLitterAction.nextBackwardImageDomain \u03c6 h\u03c6 L\u2081) (hb : b \u2208 ConNF.NearLitterAction.nextBackwardImageDomain \u03c6 h\u03c6 L\u2082) (hL\u2081 : L\u2081 \u2208 (ConNF.NearLitterAction.litterPerm \u03c6 h\u03c6).domain) (hL\u2082 : L\u2082 \u2208 (ConNF.NearLitterAction.litterPerm \u03c6 h\u03c6).domain) (h : ConNF.NearLitterAction.nextBackwardImage \u03c6 h\u03c6 L\u2081 a = ConNF.NearLitterAction.nextBackwardImage \u03c6 h\u03c6 L\u2082 b) :L\u2081 = L\u2082 := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03c6 : ConNF.NearLitterAction\nh\u03c6 : ConNF.NearLitterAction.Lawful \u03c6\nL\u2081 L\u2082 : ConNF.Litter\na b : \u2115 \u00d7 \u2191(ConNF.NearLitterAction.needBackwardImages \u03c6)\nha : a \u2208 ConNF.NearLitterAction.nextBackwardImageDomain \u03c6 h\u03c6 L\u2081\nhb : b \u2208 ConNF.NearLitterAction.nextBackwardImageDomain \u03c6 h\u03c6 L\u2082\nhL\u2081 : L\u2081 \u2208 (ConNF.NearLitterAction.litterPerm \u03c6 h\u03c6).domain\nhL\u2082 : L\u2082 \u2208 (ConNF.NearLitterAction.litterPerm \u03c6 h\u03c6).domain\nh : ConNF.NearLitterAction.nextBackwardImage \u03c6 h\u03c6 L\u2081 a = ConNF.NearLitterAction.nextBackwardImage \u03c6 h\u03c6 L\u2082 b\n\u22a2 L\u2081 = L\u2082", "dependency": [1, 825, 1077, 1077, 1090, 1090, 1070, 1070, 1091, 1091]}, "ConNF.NearLitterAction.nextForwardImage_injective": {"natural_language_statement": "The theorem `ConNF.NearLitterAction.nextForwardImage_injective` states that the function `ConNF.NearLitterAction.nextForwardImage`, which computes the next element in the range of the partial function `\u03c6.atomMap` that is not in its domain, given a lawful near litter action `\u03c6`, a litter `L`, and an element `a` in the set of elements in the range of `\u03c6.atomMap` that are not in its domain, is injective.", "formal_statement": "example [ConNF.Params ] (\u03c6 : ConNF.NearLitterAction) (h\u03c6 : ConNF.NearLitterAction.Lawful \u03c6) {L : ConNF.Litter} {a : \u2115 \u00d7 \u2191(ConNF.NearLitterAction.needForwardImages \u03c6)} {b : \u2115 \u00d7 \u2191(ConNF.NearLitterAction.needForwardImages \u03c6)} (h : ConNF.NearLitterAction.nextForwardImage \u03c6 h\u03c6 L a = ConNF.NearLitterAction.nextForwardImage \u03c6 h\u03c6 L b) :a = b := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03c6 : ConNF.NearLitterAction\nh\u03c6 : ConNF.NearLitterAction.Lawful \u03c6\nL : ConNF.Litter\na b : \u2115 \u00d7 \u2191(ConNF.NearLitterAction.needForwardImages \u03c6)\nh : ConNF.NearLitterAction.nextForwardImage \u03c6 h\u03c6 L a = ConNF.NearLitterAction.nextForwardImage \u03c6 h\u03c6 L b\n\u22a2 a = b", "dependency": [1, 825, 1075, 1075, 1088, 1088]}, "ConNF.NearLitterAction.nextBackwardImage_injective": {"natural_language_statement": "The theorem `ConNF.NearLitterAction.nextBackwardImage_injective` states that the function `ConNF.NearLitterAction.nextBackwardImage`, which computes the next backward image of an element in the set of `ConNF.Atom`s that need backward images under the partial function `ConNF.NearLitterAction.atomMap`, is injective.", "formal_statement": "example [ConNF.Params ] (\u03c6 : ConNF.NearLitterAction) (h\u03c6 : ConNF.NearLitterAction.Lawful \u03c6) {L : ConNF.Litter} {a : \u2115 \u00d7 \u2191(ConNF.NearLitterAction.needBackwardImages \u03c6)} {b : \u2115 \u00d7 \u2191(ConNF.NearLitterAction.needBackwardImages \u03c6)} (ha : a \u2208 ConNF.NearLitterAction.nextBackwardImageDomain \u03c6 h\u03c6 L) (hb : b \u2208 ConNF.NearLitterAction.nextBackwardImageDomain \u03c6 h\u03c6 L) (h : ConNF.NearLitterAction.nextBackwardImage \u03c6 h\u03c6 L a = ConNF.NearLitterAction.nextBackwardImage \u03c6 h\u03c6 L b) :a = b := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03c6 : ConNF.NearLitterAction\nh\u03c6 : ConNF.NearLitterAction.Lawful \u03c6\nL : ConNF.Litter\na b : \u2115 \u00d7 \u2191(ConNF.NearLitterAction.needBackwardImages \u03c6)\nha : a \u2208 ConNF.NearLitterAction.nextBackwardImageDomain \u03c6 h\u03c6 L\nhb : b \u2208 ConNF.NearLitterAction.nextBackwardImageDomain \u03c6 h\u03c6 L\nh : ConNF.NearLitterAction.nextBackwardImage \u03c6 h\u03c6 L a = ConNF.NearLitterAction.nextBackwardImage \u03c6 h\u03c6 L b\n\u22a2 a = b", "dependency": [1, 825, 1077, 1077, 1090, 1090, 1091, 1091]}, "ConNF.NearLitterAction.nextForwardImage_injective'": {"natural_language_statement": "The theorem `ConNF.NearLitterAction.nextForwardImage_injective'` states that the function `ConNF.NearLitterAction.nextForwardImage`, which computes the next element in the range of the partial function `\u03c6.atomMap` that is not in its domain, given a lawful near litter action `\u03c6`, a litter `L`, and an element `a` in the set of elements in the range of `\u03c6.atomMap` that are not in its domain, is injective.", "formal_statement": "example [ConNF.Params ] (\u03c6 : ConNF.NearLitterAction) (h\u03c6 : ConNF.NearLitterAction.Lawful \u03c6) {L\u2081 : ConNF.Litter} {L\u2082 : ConNF.Litter} {a : \u2115 \u00d7 \u2191(ConNF.NearLitterAction.needForwardImages \u03c6)} {b : \u2115 \u00d7 \u2191(ConNF.NearLitterAction.needForwardImages \u03c6)} (hL\u2081 : L\u2081 \u2208 (ConNF.NearLitterAction.litterPerm \u03c6 h\u03c6).domain) (hL\u2082 : L\u2082 \u2208 (ConNF.NearLitterAction.litterPerm \u03c6 h\u03c6).domain) (h : ConNF.NearLitterAction.nextForwardImage \u03c6 h\u03c6 L\u2081 a = ConNF.NearLitterAction.nextForwardImage \u03c6 h\u03c6 L\u2082 b) :a = b := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03c6 : ConNF.NearLitterAction\nh\u03c6 : ConNF.NearLitterAction.Lawful \u03c6\nL\u2081 L\u2082 : ConNF.Litter\na b : \u2115 \u00d7 \u2191(ConNF.NearLitterAction.needForwardImages \u03c6)\nhL\u2081 : L\u2081 \u2208 (ConNF.NearLitterAction.litterPerm \u03c6 h\u03c6).domain\nhL\u2082 : L\u2082 \u2208 (ConNF.NearLitterAction.litterPerm \u03c6 h\u03c6).domain\nh : ConNF.NearLitterAction.nextForwardImage \u03c6 h\u03c6 L\u2081 a = ConNF.NearLitterAction.nextForwardImage \u03c6 h\u03c6 L\u2082 b\n\u22a2 a = b", "dependency": [1, 825, 1075, 1075, 1070, 1070, 1088, 1088]}, "ConNF.NearLitterAction.nextBackwardImage_injective'": {"natural_language_statement": "The function `ConNF.NearLitterAction.nextBackwardImage` is used to compute the next backward image of an element in the set of `ConNF.Atom`s that need backward images under the partial function `ConNF.NearLitterAction.atomMap`. The theorem `ConNF.NearLitterAction.nextBackwardImage_injective'` states that this function is injective under certain conditions.", "formal_statement": "example [ConNF.Params ] (\u03c6 : ConNF.NearLitterAction) (h\u03c6 : ConNF.NearLitterAction.Lawful \u03c6) {L\u2081 : ConNF.Litter} {L\u2082 : ConNF.Litter} {a : \u2115 \u00d7 \u2191(ConNF.NearLitterAction.needBackwardImages \u03c6)} {b : \u2115 \u00d7 \u2191(ConNF.NearLitterAction.needBackwardImages \u03c6)} (ha : a \u2208 ConNF.NearLitterAction.nextBackwardImageDomain \u03c6 h\u03c6 L\u2081) (hb : b \u2208 ConNF.NearLitterAction.nextBackwardImageDomain \u03c6 h\u03c6 L\u2082) (hL\u2081 : L\u2081 \u2208 (ConNF.NearLitterAction.litterPerm \u03c6 h\u03c6).domain) (hL\u2082 : L\u2082 \u2208 (ConNF.NearLitterAction.litterPerm \u03c6 h\u03c6).domain) (h : ConNF.NearLitterAction.nextBackwardImage \u03c6 h\u03c6 L\u2081 a = ConNF.NearLitterAction.nextBackwardImage \u03c6 h\u03c6 L\u2082 b) :a = b := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03c6 : ConNF.NearLitterAction\nh\u03c6 : ConNF.NearLitterAction.Lawful \u03c6\nL\u2081 L\u2082 : ConNF.Litter\na b : \u2115 \u00d7 \u2191(ConNF.NearLitterAction.needBackwardImages \u03c6)\nha : a \u2208 ConNF.NearLitterAction.nextBackwardImageDomain \u03c6 h\u03c6 L\u2081\nhb : b \u2208 ConNF.NearLitterAction.nextBackwardImageDomain \u03c6 h\u03c6 L\u2082\nhL\u2081 : L\u2081 \u2208 (ConNF.NearLitterAction.litterPerm \u03c6 h\u03c6).domain\nhL\u2082 : L\u2082 \u2208 (ConNF.NearLitterAction.litterPerm \u03c6 h\u03c6).domain\nh : ConNF.NearLitterAction.nextBackwardImage \u03c6 h\u03c6 L\u2081 a = ConNF.NearLitterAction.nextBackwardImage \u03c6 h\u03c6 L\u2082 b\n\u22a2 a = b", "dependency": [1, 825, 1077, 1077, 1090, 1090, 1070, 1070, 1091, 1091]}, "ConNF.NearLitterAction.nextForwardImage_ne_nextBackwardImage": {"natural_language_statement": "The theorem `ConNF.NearLitterAction.nextForwardImage_ne_nextBackwardImage` states that the next element in the range of the partial function `\u03c6.atomMap` that is not in its domain, given a lawful near litter action `\u03c6`, a litter `L`, and an element `a` in the set of elements in the range of `\u03c6.atomMap` that are not in its domain, is not equal to the next backward image of an element in the set of `ConNF.Atom`s that need backward images under the partial function `ConNF.NearLitterAction.atomMap`.", "formal_statement": "example [ConNF.Params ] (\u03c6 : ConNF.NearLitterAction) (h\u03c6 : ConNF.NearLitterAction.Lawful \u03c6) {L\u2081 : ConNF.Litter} {L\u2082 : ConNF.Litter} {a : \u2115 \u00d7 \u2191(ConNF.NearLitterAction.needForwardImages \u03c6)} {b : \u2115 \u00d7 \u2191(ConNF.NearLitterAction.needBackwardImages \u03c6)} :ConNF.NearLitterAction.nextForwardImage \u03c6 h\u03c6 L\u2081 a \u2260 ConNF.NearLitterAction.nextBackwardImage \u03c6 h\u03c6 L\u2082 b := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03c6 : ConNF.NearLitterAction\nh\u03c6 : ConNF.NearLitterAction.Lawful \u03c6\nL\u2081 L\u2082 : ConNF.Litter\na : \u2115 \u00d7 \u2191(ConNF.NearLitterAction.needForwardImages \u03c6)\nb : \u2115 \u00d7 \u2191(ConNF.NearLitterAction.needBackwardImages \u03c6)\n\u22a2 ConNF.NearLitterAction.nextForwardImage \u03c6 h\u03c6 L\u2081 a \u2260 ConNF.NearLitterAction.nextBackwardImage \u03c6 h\u03c6 L\u2082 b", "dependency": [1, 825, 1075, 1077, 1088, 1091]}, "ConNF.NearLitterAction.nextImageCoreDomain_small": {"natural_language_statement": "The theorem `ConNF.NearLitterAction.nextImageCoreDomain_small` states that the domain of the next image function for a lawful near litter action in the context of Constructive Ordinal Notation (ConNF) is small, meaning its cardinality is strictly less than the cardinality of the type `ConNF.\u03ba`.", "formal_statement": "example [ConNF.Params ] (\u03c6 : ConNF.NearLitterAction) (h\u03c6 : ConNF.NearLitterAction.Lawful \u03c6) :ConNF.Small (ConNF.NearLitterAction.nextImageCoreDomain \u03c6 h\u03c6) := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03c6 : ConNF.NearLitterAction\nh\u03c6 : ConNF.NearLitterAction.Lawful \u03c6\n\u22a2 ConNF.Small (ConNF.NearLitterAction.nextImageCoreDomain \u03c6 h\u03c6)", "dependency": [1, 825, 233, 1098]}, "ConNF.NearLitterAction.litter_map_dom_of_mem_nextImageCoreDomain": {"natural_language_statement": "The theorem `ConNF.NearLitterAction.litter_map_dom_of_mem_nextImageCoreDomain` states that if an atom `a` is in the domain of the next image function for a lawful near litter action, then the litter of `a` is in the domain of the litter permutation.", "formal_statement": "example [ConNF.Params ] (\u03c6 : ConNF.NearLitterAction) (h\u03c6 : ConNF.NearLitterAction.Lawful \u03c6) {a : ConNF.Atom} (h : a \u2208 ConNF.NearLitterAction.nextImageCoreDomain \u03c6 h\u03c6) :a.1 \u2208 (ConNF.NearLitterAction.litterPerm \u03c6 h\u03c6).domain := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03c6 : ConNF.NearLitterAction\nh\u03c6 : ConNF.NearLitterAction.Lawful \u03c6\na : ConNF.Atom\nh : a \u2208 ConNF.NearLitterAction.nextImageCoreDomain \u03c6 h\u03c6\n\u22a2 a.1 \u2208 (ConNF.NearLitterAction.litterPerm \u03c6 h\u03c6).domain", "dependency": [1, 825, 1098, 1070]}, "ConNF.NearLitterAction.mem_orbitSet_of_mem_nextImageCoreDomain": {"natural_language_statement": "The theorem `ConNF.NearLitterAction.mem_orbitSet_of_mem_nextImageCoreDomain` states that if an atom `a` belongs to the domain of the next image function for a lawful near litter action `\u03c6`, then `a` also belongs to the orbit set of `a` under the action of `\u03c6`.", "formal_statement": "example [ConNF.Params ] (\u03c6 : ConNF.NearLitterAction) (h\u03c6 : ConNF.NearLitterAction.Lawful \u03c6) {a : ConNF.Atom} (h : a \u2208 ConNF.NearLitterAction.nextImageCoreDomain \u03c6 h\u03c6) :a \u2208 ConNF.NearLitterAction.orbitSet \u03c6 a.1 := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03c6 : ConNF.NearLitterAction\nh\u03c6 : ConNF.NearLitterAction.Lawful \u03c6\na : ConNF.Atom\nh : a \u2208 ConNF.NearLitterAction.nextImageCoreDomain \u03c6 h\u03c6\n\u22a2 a \u2208 ConNF.NearLitterAction.orbitSet \u03c6 a.1", "dependency": [1, 825, 1098, 1082]}, "ConNF.NearLitterAction.nextImageDomain_small": {"natural_language_statement": "The theorem `ConNF.NearLitterAction.nextImageDomain_small` states that the domain of the next image function for a lawful near litter action in the context of Constructive Ordinal Notation (ConNF) is small, meaning its cardinality is strictly less than the cardinality of the type `ConNF.\u03ba`.", "formal_statement": "example [ConNF.Params ] (\u03c6 : ConNF.NearLitterAction) (h\u03c6 : ConNF.NearLitterAction.Lawful \u03c6) :ConNF.Small (ConNF.NearLitterAction.nextImageDomain \u03c6 h\u03c6) := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03c6 : ConNF.NearLitterAction\nh\u03c6 : ConNF.NearLitterAction.Lawful \u03c6\n\u22a2 ConNF.Small (ConNF.NearLitterAction.nextImageDomain \u03c6 h\u03c6)", "dependency": [1, 825, 233, 1102]}, "ConNF.NearLitterAction.disjoint_needForwardImages_nextImageCoreDomain": {"natural_language_statement": "The theorem states that the set of elements in the range of the partial function `\u03c6.atomMap` that are not in its domain is disjoint from the domain of the next image function for a lawful near litter action.", "formal_statement": "example [ConNF.Params ] (\u03c6 : ConNF.NearLitterAction) (h\u03c6 : ConNF.NearLitterAction.Lawful \u03c6) :Disjoint (ConNF.NearLitterAction.needForwardImages \u03c6) (ConNF.NearLitterAction.nextImageCoreDomain \u03c6 h\u03c6) := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03c6 : ConNF.NearLitterAction\nh\u03c6 : ConNF.NearLitterAction.Lawful \u03c6\n\u22a2 Disjoint (ConNF.NearLitterAction.needForwardImages \u03c6) (ConNF.NearLitterAction.nextImageCoreDomain \u03c6 h\u03c6)", "dependency": [1, 825, 757, 1075, 1098]}, "ConNF.NearLitterAction.nextImage_injective": {"natural_language_statement": "The theorem `ConNF.NearLitterAction.nextImage_injective` states that the next image function for a lawful near litter action in the context of Constructive Ordinal Notation (ConNF) is injective. This means that if two atoms `a` and `b` are in the domain of the next image function and their next images are equal, then `a` must be equal to `b`.", "formal_statement": "example [ConNF.Params ] (\u03c6 : ConNF.NearLitterAction) (h\u03c6 : ConNF.NearLitterAction.Lawful \u03c6) (a : ConNF.Atom) (b : ConNF.Atom) (ha : a \u2208 ConNF.NearLitterAction.nextImageDomain \u03c6 h\u03c6) (hb : b \u2208 ConNF.NearLitterAction.nextImageDomain \u03c6 h\u03c6) (h : ConNF.NearLitterAction.nextImage \u03c6 h\u03c6 a ha = ConNF.NearLitterAction.nextImage \u03c6 h\u03c6 b hb) :a = b := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03c6 : ConNF.NearLitterAction\nh\u03c6 : ConNF.NearLitterAction.Lawful \u03c6\na b : ConNF.Atom\nha : a \u2208 ConNF.NearLitterAction.nextImageDomain \u03c6 h\u03c6\nhb : b \u2208 ConNF.NearLitterAction.nextImageDomain \u03c6 h\u03c6\nh : ConNF.NearLitterAction.nextImage \u03c6 h\u03c6 a ha = ConNF.NearLitterAction.nextImage \u03c6 h\u03c6 b hb\n\u22a2 a = b", "dependency": [1, 825, 1102, 1102, 1105, 1105]}, "ConNF.NearLitterAction.orbitAtomMap_dom_iff": {"natural_language_statement": "The theorem `ConNF.NearLitterAction.orbitAtomMap_dom_iff` states that the domain of the partial function `ConNF.NearLitterAction.orbitAtomMap` is determined by whether the atom `a` is in the domain of the atom map or in the next image domain of the near-litter action.", "formal_statement": "@[simp]example [ConNF.Params ] (\u03c6 : ConNF.NearLitterAction) (h\u03c6 : ConNF.NearLitterAction.Lawful \u03c6) (a : ConNF.Atom) :(ConNF.NearLitterAction.orbitAtomMap \u03c6 h\u03c6 a).Dom \u2194 (\u03c6.atomMap a).Dom \u2228 a \u2208 ConNF.NearLitterAction.nextImageDomain \u03c6 h\u03c6 := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03c6 : ConNF.NearLitterAction\nh\u03c6 : ConNF.NearLitterAction.Lawful \u03c6\na : ConNF.Atom\n\u22a2 (ConNF.NearLitterAction.orbitAtomMap \u03c6 h\u03c6 a).Dom \u2194 (\u03c6.atomMap a).Dom \u2228 a \u2208 ConNF.NearLitterAction.nextImageDomain \u03c6 h\u03c6", "dependency": [1, 825, 1107, 1102]}, "ConNF.NearLitterAction.orbitAtomMap_dom": {"natural_language_statement": "The domain of the partial function `ConNF.NearLitterAction.orbitAtomMap` is the union of the domain of the atom map `\u03c6.atomMap` and the next image domain `ConNF.NearLitterAction.nextImageDomain \u03c6 h\u03c6`.", "formal_statement": "@[simp]example [ConNF.Params ] (\u03c6 : ConNF.NearLitterAction) (h\u03c6 : ConNF.NearLitterAction.Lawful \u03c6) :PFun.Dom (ConNF.NearLitterAction.orbitAtomMap \u03c6 h\u03c6) = PFun.Dom \u03c6.atomMap \u222a ConNF.NearLitterAction.nextImageDomain \u03c6 h\u03c6 := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03c6 : ConNF.NearLitterAction\nh\u03c6 : ConNF.NearLitterAction.Lawful \u03c6\n\u22a2 PFun.Dom (ConNF.NearLitterAction.orbitAtomMap \u03c6 h\u03c6) = PFun.Dom \u03c6.atomMap \u222a ConNF.NearLitterAction.nextImageDomain \u03c6 h\u03c6", "dependency": [1, 825, 404, 1107, 404, 1102]}, "ConNF.NearLitterAction.disjoint_atomMap_dom_nextImageDomain": {"natural_language_statement": "The theorem `ConNF.NearLitterAction.disjoint_atomMap_dom_nextImageDomain` states that the domain of the atom map of a lawful near litter action in the context of Constructive Ordinal Notation (ConNF) is disjoint from the domain of the next image function.", "formal_statement": "example [ConNF.Params ] (\u03c6 : ConNF.NearLitterAction) (h\u03c6 : ConNF.NearLitterAction.Lawful \u03c6) :Disjoint (PFun.Dom \u03c6.atomMap) (ConNF.NearLitterAction.nextImageDomain \u03c6 h\u03c6) := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03c6 : ConNF.NearLitterAction\nh\u03c6 : ConNF.NearLitterAction.Lawful \u03c6\n\u22a2 Disjoint (PFun.Dom \u03c6.atomMap) (ConNF.NearLitterAction.nextImageDomain \u03c6 h\u03c6)", "dependency": [1, 825, 757, 404, 1102]}, "ConNF.NearLitterAction.orbitAtomMap_dom_small": {"natural_language_statement": "The theorem `ConNF.NearLitterAction.orbitAtomMap_dom_small` states that the domain of the partial function `ConNF.NearLitterAction.orbitAtomMap`, which represents the orbit of an atom under a near-litter action in the context of Constructive Ordinal Notation (ConNF), is a small set, meaning its cardinality is strictly less than the cardinality of the type `ConNF.\u03ba`.", "formal_statement": "example [ConNF.Params ] (\u03c6 : ConNF.NearLitterAction) (h\u03c6 : ConNF.NearLitterAction.Lawful \u03c6) :ConNF.Small (PFun.Dom (ConNF.NearLitterAction.orbitAtomMap \u03c6 h\u03c6)) := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03c6 : ConNF.NearLitterAction\nh\u03c6 : ConNF.NearLitterAction.Lawful \u03c6\n\u22a2 ConNF.Small (PFun.Dom (ConNF.NearLitterAction.orbitAtomMap \u03c6 h\u03c6))", "dependency": [1, 825, 233, 404, 1107]}, "ConNF.NearLitterAction.orbitAtomMap_injective": {"natural_language_statement": "The theorem `ConNF.NearLitterAction.orbitAtomMap_injective` states that the orbit of an atom under a lawful near-litter action in the context of Constructive Ordinal Notation (ConNF) is injective. This means that if two atoms have the same image under the orbit map, then they must be equal.", "formal_statement": "example [ConNF.Params ] (\u03c6 : ConNF.NearLitterAction) (h\u03c6 : ConNF.NearLitterAction.Lawful \u03c6) \u2983a : ConNF.Atom\u2984 \u2983b : ConNF.Atom\u2984 (ha : (ConNF.NearLitterAction.orbitAtomMap \u03c6 h\u03c6 a).Dom) (hb : (ConNF.NearLitterAction.orbitAtomMap \u03c6 h\u03c6 b).Dom) (h : (ConNF.NearLitterAction.orbitAtomMap \u03c6 h\u03c6 a).get ha = (ConNF.NearLitterAction.orbitAtomMap \u03c6 h\u03c6 b).get hb) :a = b := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03c6 : ConNF.NearLitterAction\nh\u03c6 : ConNF.NearLitterAction.Lawful \u03c6\na b : ConNF.Atom\nha : (ConNF.NearLitterAction.orbitAtomMap \u03c6 h\u03c6 a).Dom\nhb : (ConNF.NearLitterAction.orbitAtomMap \u03c6 h\u03c6 b).Dom\nh : (ConNF.NearLitterAction.orbitAtomMap \u03c6 h\u03c6 a).get ha = (ConNF.NearLitterAction.orbitAtomMap \u03c6 h\u03c6 b).get hb\n\u22a2 a = b", "dependency": [1, 825, 1107, 1107, 1107, 1107]}, "ConNF.NearLitterAction.orbit_atom_mem": {"natural_language_statement": "The theorem states that if an atom `a` is in a specific litter `L`, then its orbit under a lawful near-litter action `\u03c6` is also in the same litter `L`. The implication is proven by showing that the symmetric difference of the orbit and the litter set of `L` is a subset of the range of the atom map, which implies that the orbit is either in the domain of the atom map or in the next image domain of the near-litter action. Given that the near-litter action is lawful, the orbit must be in the domain of the atom map, and thus in the litter set of `L`.", "formal_statement": "example [ConNF.Params ] (\u03c6 : ConNF.NearLitterAction) (h\u03c6 : ConNF.NearLitterAction.Lawful \u03c6) (hdiff : \u2200 (L : ConNF.Litter) (hL : (\u03c6.litterMap L).Dom), symmDiff (\u2191((\u03c6.litterMap L).get hL)) (ConNF.litterSet ((\u03c6.litterMap L).get hL).fst) \u2286 PFun.ran \u03c6.atomMap) (a : ConNF.Atom) (ha : (ConNF.NearLitterAction.orbitAtomMap \u03c6 h\u03c6 a).Dom) (L : ConNF.Litter) (hL : (\u03c6.litterMap L).Dom) :a.1 = L \u2194 (ConNF.NearLitterAction.orbitAtomMap \u03c6 h\u03c6 a).get ha \u2208 (\u03c6.litterMap L).get hL := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03c6 : ConNF.NearLitterAction\nh\u03c6 : ConNF.NearLitterAction.Lawful \u03c6\nhdiff :\n  \u2200 (L : ConNF.Litter) (hL : (\u03c6.litterMap L).Dom),\n    symmDiff (\u2191((\u03c6.litterMap L).get hL)) (ConNF.litterSet ((\u03c6.litterMap L).get hL).fst) \u2286 PFun.ran \u03c6.atomMap\na : ConNF.Atom\nha : (ConNF.NearLitterAction.orbitAtomMap \u03c6 h\u03c6 a).Dom\nL : ConNF.Litter\nhL : (\u03c6.litterMap L).Dom\n\u22a2 a.1 = L \u2194 (ConNF.NearLitterAction.orbitAtomMap \u03c6 h\u03c6 a).get ha \u2208 (\u03c6.litterMap L).get hL", "dependency": [1, 825, 62, 467, 824, 1107, 1107]}, "ConNF.NearLitterAction.fillAtomOrbitsLawful": {"natural_language_statement": "`ConNF.NearLitterAction.fillAtomOrbitsLawful` is a theorem in the context of Constructive Ordinal Notation (ConNF) in Lean 4. It states that if we have a lawful near litter action `\u03c6` and a condition `hdiff` on the symmetric difference of the image of the litter map and the litter set, then the filled near litter action `ConNF.NearLitterAction.fillAtomOrbits \u03c6 h\u03c6` is also lawful.", "formal_statement": "example [ConNF.Params ] (\u03c6 : ConNF.NearLitterAction) (h\u03c6 : ConNF.NearLitterAction.Lawful \u03c6) (hdiff : \u2200 (L : ConNF.Litter) (hL : (\u03c6.litterMap L).Dom), symmDiff (\u2191((\u03c6.litterMap L).get hL)) (ConNF.litterSet ((\u03c6.litterMap L).get hL).fst) \u2286 PFun.ran \u03c6.atomMap) :ConNF.NearLitterAction.Lawful (ConNF.NearLitterAction.fillAtomOrbits \u03c6 h\u03c6) := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03c6 : ConNF.NearLitterAction\nh\u03c6 : ConNF.NearLitterAction.Lawful \u03c6\nhdiff :\n  \u2200 (L : ConNF.Litter) (hL : (\u03c6.litterMap L).Dom),\n    symmDiff (\u2191((\u03c6.litterMap L).get hL)) (ConNF.litterSet ((\u03c6.litterMap L).get hL).fst) \u2286 PFun.ran \u03c6.atomMap\n\u22a2 ConNF.NearLitterAction.Lawful (ConNF.NearLitterAction.fillAtomOrbits \u03c6 h\u03c6)", "dependency": [1, 825, 62, 467, 824, 825, 1114]}, "ConNF.NearLitterAction.fillAtomOrbits_atomMap": {"natural_language_statement": "The theorem `ConNF.NearLitterAction.fillAtomOrbits_atomMap` states that the atom map of the filled near-litter action `ConNF.NearLitterAction.fillAtomOrbits \u03c6 h\u03c6` is equal to the orbit atom map `ConNF.NearLitterAction.orbitAtomMap \u03c6 h\u03c6`.", "formal_statement": "@[simp]example [ConNF.Params ] {\u03c6 : ConNF.NearLitterAction} (h\u03c6 : ConNF.NearLitterAction.Lawful \u03c6) :(ConNF.NearLitterAction.fillAtomOrbits \u03c6 h\u03c6).atomMap = ConNF.NearLitterAction.orbitAtomMap \u03c6 h\u03c6 := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03c6 : ConNF.NearLitterAction\nh\u03c6 : ConNF.NearLitterAction.Lawful \u03c6\n\u22a2 (ConNF.NearLitterAction.fillAtomOrbits \u03c6 h\u03c6).atomMap = ConNF.NearLitterAction.orbitAtomMap \u03c6 h\u03c6", "dependency": [1, 825, 1114, 1107]}, "ConNF.NearLitterAction.fillAtomOrbits_litterMap": {"natural_language_statement": "The theorem `ConNF.NearLitterAction.fillAtomOrbits_litterMap` states that the litter map of a lawful near litter action remains unchanged after extending the domain of the atom map to include all possible orbits of atoms under the action of the near litter action.", "formal_statement": "@[simp]example [ConNF.Params ] {\u03c6 : ConNF.NearLitterAction} (h\u03c6 : ConNF.NearLitterAction.Lawful \u03c6) :(ConNF.NearLitterAction.fillAtomOrbits \u03c6 h\u03c6).litterMap = \u03c6.litterMap := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03c6 : ConNF.NearLitterAction\nh\u03c6 : ConNF.NearLitterAction.Lawful \u03c6\n\u22a2 (ConNF.NearLitterAction.fillAtomOrbits \u03c6 h\u03c6).litterMap = \u03c6.litterMap", "dependency": [1, 825, 1114]}, "ConNF.NearLitterAction.subset_orbitAtomMap_dom": {"natural_language_statement": "The theorem `ConNF.NearLitterAction.subset_orbitAtomMap_dom` states that the domain of the atom map of a lawful near-litter action is a subset of the domain of the orbit atom map. This means that if an atom is in the domain of the atom map, it is also in the domain of the orbit atom map.", "formal_statement": "example [ConNF.Params ] {\u03c6 : ConNF.NearLitterAction} (h\u03c6 : ConNF.NearLitterAction.Lawful \u03c6) :PFun.Dom \u03c6.atomMap \u2286 PFun.Dom (ConNF.NearLitterAction.orbitAtomMap \u03c6 h\u03c6) := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03c6 : ConNF.NearLitterAction\nh\u03c6 : ConNF.NearLitterAction.Lawful \u03c6\n\u22a2 PFun.Dom \u03c6.atomMap \u2286 PFun.Dom (ConNF.NearLitterAction.orbitAtomMap \u03c6 h\u03c6)", "dependency": [1, 825, 404, 404, 1107]}, "ConNF.NearLitterAction.subset_orbitAtomMap_ran": {"natural_language_statement": "In the context of Constructive Ordinal Notation (ConNF), this theorem states that the range of the atom map, which represents the set of atoms that are mapped to by the near-litter action, is a subset of the range of the orbit atom map. This orbit atom map is defined as the orbit of an atom under the near-litter action, considering the domain of the atom map and the next image domain of the near-litter action.", "formal_statement": "example [ConNF.Params ] {\u03c6 : ConNF.NearLitterAction} (h\u03c6 : ConNF.NearLitterAction.Lawful \u03c6) :PFun.ran \u03c6.atomMap \u2286 PFun.ran (ConNF.NearLitterAction.orbitAtomMap \u03c6 h\u03c6) := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03c6 : ConNF.NearLitterAction\nh\u03c6 : ConNF.NearLitterAction.Lawful \u03c6\n\u22a2 PFun.ran \u03c6.atomMap \u2286 PFun.ran (ConNF.NearLitterAction.orbitAtomMap \u03c6 h\u03c6)", "dependency": [1, 825, 824, 824, 1107]}, "ConNF.NearLitterAction.fst_mem_litterPerm_domain_of_mem_map": {"natural_language_statement": "This theorem states that if `L` is a litter and `a` is an atom that belongs to the image of `L` under the litter map `\u03c6`, then the first component of `a` (which is a natural number) belongs to the domain of the litter permutation `ConNF.NearLitterAction.litterPerm \u03c6 h\u03c6`. This is a useful result because it allows us to apply the litter permutation to the first component of `a`, which is crucial for recursive definitions in the ConNF library.", "formal_statement": "example [ConNF.Params ] {\u03c6 : ConNF.NearLitterAction} (h\u03c6 : ConNF.NearLitterAction.Lawful \u03c6) \u2983L : ConNF.Litter\u2984 (hL : (\u03c6.litterMap L).Dom) \u2983a : ConNF.Atom\u2984 (ha : a \u2208 (\u03c6.litterMap L).get hL) :a.1 \u2208 (ConNF.NearLitterAction.litterPerm \u03c6 h\u03c6).domain := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03c6 : ConNF.NearLitterAction\nh\u03c6 : ConNF.NearLitterAction.Lawful \u03c6\nL : ConNF.Litter\nhL : (\u03c6.litterMap L).Dom\na : ConNF.Atom\nha : a \u2208 (\u03c6.litterMap L).get hL\n\u22a2 a.1 \u2208 (ConNF.NearLitterAction.litterPerm \u03c6 h\u03c6).domain", "dependency": [1, 825, 1070]}, "ConNF.NearLitterAction.fst_mem_litterPerm_domain_of_dom": {"natural_language_statement": "The theorem `ConNF.NearLitterAction.fst_mem_litterPerm_domain_of_dom` states that if `a` is an element of the domain of the partial function `\u03c6.atomMap`, then the first component of `a`, denoted as `a.1`, is an element of the domain of the partial permutation `ConNF.NearLitterAction.litterPerm \u03c6 h\u03c6`.", "formal_statement": "example [ConNF.Params ] {\u03c6 : ConNF.NearLitterAction} (h\u03c6 : ConNF.NearLitterAction.Lawful \u03c6) \u2983a : ConNF.Atom\u2984 (ha : a \u2208 PFun.Dom \u03c6.atomMap) :a.1 \u2208 (ConNF.NearLitterAction.litterPerm \u03c6 h\u03c6).domain := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03c6 : ConNF.NearLitterAction\nh\u03c6 : ConNF.NearLitterAction.Lawful \u03c6\na : ConNF.Atom\nha : a \u2208 PFun.Dom \u03c6.atomMap\n\u22a2 a.1 \u2208 (ConNF.NearLitterAction.litterPerm \u03c6 h\u03c6).domain", "dependency": [1, 825, 404, 1070]}, "ConNF.NearLitterAction.fst_mem_litterPerm_domain_of_ran": {"natural_language_statement": "The theorem `ConNF.NearLitterAction.fst_mem_litterPerm_domain_of_ran` proves that given a lawful near litter action `\u03c6` in the context of Constructive Ordinal Notation (ConNF), for any atom `a` in the range of the atom map `\u03c6.atomMap`, the first component of `a` is in the domain of the permutation of litters `ConNF.NearLitterAction.litterPerm \u03c6 h\u03c6`. This theorem is crucial for ensuring that the near litter action is well-defined.", "formal_statement": "example [ConNF.Params ] {\u03c6 : ConNF.NearLitterAction} (h\u03c6 : ConNF.NearLitterAction.Lawful \u03c6) \u2983a : ConNF.Atom\u2984 (ha : a \u2208 PFun.ran \u03c6.atomMap) :a.1 \u2208 (ConNF.NearLitterAction.litterPerm \u03c6 h\u03c6).domain := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03c6 : ConNF.NearLitterAction\nh\u03c6 : ConNF.NearLitterAction.Lawful \u03c6\na : ConNF.Atom\nha : a \u2208 PFun.ran \u03c6.atomMap\n\u22a2 a.1 \u2208 (ConNF.NearLitterAction.litterPerm \u03c6 h\u03c6).domain", "dependency": [1, 825, 824, 1070]}, "ConNF.NearLitterAction.fillAtomOrbits_precise": {"natural_language_statement": "Given a lawful near litter action \u03c6, if the symmetric difference of the litter set of any given litter L with the values of the litter map of \u03c6 applied to L (excluding any undefined values) is a subset of the range of the atom map of \u03c6, then the near litter action obtained by filling the orbits of any undefined atoms under \u03c6 is precise.", "formal_statement": "example [ConNF.Params ] {\u03c6 : ConNF.NearLitterAction} (h\u03c6 : ConNF.NearLitterAction.Lawful \u03c6) (hdiff : \u2200 (L : ConNF.Litter) (hL : (\u03c6.litterMap L).Dom), symmDiff (\u2191((\u03c6.litterMap L).get hL)) (ConNF.litterSet ((\u03c6.litterMap L).get hL).fst) \u2286 PFun.ran \u03c6.atomMap) :ConNF.NearLitterAction.Precise (ConNF.NearLitterAction.fillAtomOrbits \u03c6 h\u03c6) := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03c6 : ConNF.NearLitterAction\nh\u03c6 : ConNF.NearLitterAction.Lawful \u03c6\nhdiff :\n  \u2200 (L : ConNF.Litter) (hL : (\u03c6.litterMap L).Dom),\n    symmDiff (\u2191((\u03c6.litterMap L).get hL)) (ConNF.litterSet ((\u03c6.litterMap L).get hL).fst) \u2286 PFun.ran \u03c6.atomMap\n\u22a2 ConNF.NearLitterAction.Precise (ConNF.NearLitterAction.fillAtomOrbits \u03c6 h\u03c6)", "dependency": [1, 825, 62, 467, 824, 1123, 1114]}, "Or.elim'_left": {"natural_language_statement": "`Or.elim'_left` is a theorem that states that if we have a disjunction `p \u2228 q` and two functions `f : p \u2192 \u03b1` and `g : q \u2192 \u03b1`, and we know that `p` is true, then `Or.elim' h f g` is equal to `f hp`, where `hp` is a proof of `p`.", "formal_statement": "example {\u03b1 : Sort u_1} {p : Prop } {q : Prop } (h : p \u2228 q) (f : p \u2192 \u03b1) (g : q \u2192 \u03b1) (hp : p) :Or.elim' h f g = f hp := by sorry", "full_tactic_state": "\u03b1 : Sort u_1\np q : Prop\nh : p \u2228 q\nf : p \u2192 \u03b1\ng : q \u2192 \u03b1\nhp : p\n\u22a2 Or.elim' h f g = f hp", "dependency": [1125]}, "ConNF.NearLitterAction.ext": {"natural_language_statement": "`ConNF.NearLitterAction.ext` is an extensionality theorem for the `ConNF.NearLitterAction` structure. It states that two `ConNF.NearLitterAction`s are equal if their `atomMap` and `litterMap` fields are equal.", "formal_statement": "example :\u2200 {inst : ConNF.Params } (x y : ConNF.NearLitterAction), x.atomMap = y.atomMap \u2192 x.litterMap = y.litterMap \u2192 x = y := by sorry", "full_tactic_state": "\u22a2 \u2200 {inst : ConNF.Params} (x y : ConNF.NearLitterAction), x.atomMap = y.atomMap \u2192 x.litterMap = y.litterMap \u2192 x = y", "dependency": [1]}, "ConNF.NearLitterAction.ext_iff": {"natural_language_statement": "The `ConNF.NearLitterAction.ext_iff` theorem states that two `ConNF.NearLitterAction` objects are equal if and only if their `atomMap` and `litterMap` fields are equal.", "formal_statement": "example :\u2200 {inst : ConNF.Params } (x y : ConNF.NearLitterAction), x = y \u2194 x.atomMap = y.atomMap \u2227 x.litterMap = y.litterMap := by sorry", "full_tactic_state": "\u22a2 \u2200 {inst : ConNF.Params} (x y : ConNF.NearLitterAction), x = y \u2194 x.atomMap = y.atomMap \u2227 x.litterMap = y.litterMap", "dependency": [1]}, "ConNF.NearLitterAction.bannedLitter_iff": {"natural_language_statement": "The theorem `ConNF.NearLitterAction.bannedLitter_iff` states that a litter `a` is considered \"banned\" by a near litter action `\u03c6` if and only if there exists an atom `a_1` such that `\u03c6.atomMap a_1` is defined and `a = a_1.1`, or `\u03c6.litterMap a` is defined, or there exists an atom `a_1` such that `\u03c6.atomMap a_1` is defined and `a = ((\u03c6.atomMap a_1).get h).1`, or there exists a litter `L` such that `\u03c6.litterMap L` is defined and `a = ((\u03c6.litterMap L).get h).fst`, or there exists a litter `L` such that `\u03c6.litterMap L` is defined and there exists an atom `a_1` in `((\u03c6.litterMap L).get h) \\ ConNF.litterSet ((\u03c6.litterMap L).get h).fst` with `a = a_1.1`.", "formal_statement": "example [ConNF.Params ] (\u03c6 : ConNF.NearLitterAction) :\u2200 (a : ConNF.Litter), ConNF.NearLitterAction.BannedLitter \u03c6 a \u2194 (\u2203 (a_1 : ConNF.Atom), (\u03c6.atomMap a_1).Dom \u2227 a = a_1.1) \u2228 (\u03c6.litterMap a).Dom \u2228 (\u2203 (a_1 : ConNF.Atom) (h : (\u03c6.atomMap a_1).Dom), a = ((\u03c6.atomMap a_1).get h).1) \u2228 (\u2203 (L : ConNF.Litter) (h : (\u03c6.litterMap L).Dom), a = ((\u03c6.litterMap L).get h).fst) \u2228 \u2203 (L : ConNF.Litter) (h : (\u03c6.litterMap L).Dom), \u2203 a_1 \u2208 \u2191((\u03c6.litterMap L).get h) \\ ConNF.litterSet ((\u03c6.litterMap L).get h).fst, a = a_1.1 := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03c6 : ConNF.NearLitterAction\n\u22a2 \u2200 (a : ConNF.Litter),\n    ConNF.NearLitterAction.BannedLitter \u03c6 a \u2194\n      (\u2203 a_1, (\u03c6.atomMap a_1).Dom \u2227 a = a_1.1) \u2228\n        (\u03c6.litterMap a).Dom \u2228\n          (\u2203 a_1, \u2203 (h : (\u03c6.atomMap a_1).Dom), a = ((\u03c6.atomMap a_1).get h).1) \u2228\n            (\u2203 L, \u2203 (h : (\u03c6.litterMap L).Dom), a = ((\u03c6.litterMap L).get h).fst) \u2228\n              \u2203 L,\n                \u2203 (h : (\u03c6.litterMap L).Dom),\n                  \u2203 a_1 \u2208 \u2191((\u03c6.litterMap L).get h) \\ ConNF.litterSet ((\u03c6.litterMap L).get h).fst, a = a_1.1", "dependency": [1, 1065, 467]}, "ConNF.NearLitterAction.BannedLitter.memMap": {"natural_language_statement": "The theorem `ConNF.NearLitterAction.BannedLitter.memMap` is a result in the context of Constructive Ordinal Notation (ConNF) which is a mathematical formalization of the Von Neumann universe of ordinals. The theorem is about the type `ConNF.NearLitterAction.BannedLitter`, which represents a litter that is not allowed as a sandbox because it appears somewhere that we need to preserve. The theorem states that if an atom `a` with a given litter `L` is in the domain of the litter map of a near litter action `\u03c6`, and it is also in the image of the litter map, then the litter of `a` is banned.", "formal_statement": "example [ConNF.Params ] (\u03c6 : ConNF.NearLitterAction) (a : ConNF.Atom) (L : ConNF.Litter) (hL : (\u03c6.litterMap L).Dom) (ha : a \u2208 \u2191((\u03c6.litterMap L).get hL)) :ConNF.NearLitterAction.BannedLitter \u03c6 a.1 := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03c6 : ConNF.NearLitterAction\na : ConNF.Atom\nL : ConNF.Litter\nhL : (\u03c6.litterMap L).Dom\nha : a \u2208 (\u03c6.litterMap L).get hL\n\u22a2 ConNF.NearLitterAction.BannedLitter \u03c6 a.1", "dependency": [1, 1065]}, "ConNF.NearLitterAction.bannedLitter_small": {"natural_language_statement": "The theorem `ConNF.NearLitterAction.bannedLitter_small` states that the set of banned litters in the context of Constructive Ordinal Notation (ConNF) is small, meaning its cardinality is strictly less than the cardinality of the type `ConNF.\u03ba`.", "formal_statement": "example [ConNF.Params ] (\u03c6 : ConNF.NearLitterAction) :ConNF.Small {L : ConNF.Litter | ConNF.NearLitterAction.BannedLitter \u03c6 L} := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03c6 : ConNF.NearLitterAction\n\u22a2 ConNF.Small {L | ConNF.NearLitterAction.BannedLitter \u03c6 L}", "dependency": [1, 233, 1065]}, "ConNF.NearLitterAction.mk_not_bannedLitter": {"natural_language_statement": "The theorem `ConNF.NearLitterAction.mk_not_bannedLitter` states that the cardinality of the set of litters that are not banned by the near litter action `\u03c6` is equal to the cardinality of the type `\u03bc`.", "formal_statement": "example [ConNF.Params ] (\u03c6 : ConNF.NearLitterAction) :Cardinal.mk \u2191{L : ConNF.Litter | \u00ac ConNF.NearLitterAction.BannedLitter \u03c6 L} = Cardinal.mk ConNF.\u03bc := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03c6 : ConNF.NearLitterAction\n\u22a2 Cardinal.mk \u2191{L | \u00acConNF.NearLitterAction.BannedLitter \u03c6 L} = Cardinal.mk ConNF.\u03bc", "dependency": [1, 29, 1065, 29]}, "ConNF.NearLitterAction.not_bannedLitter_nonempty": {"natural_language_statement": "The theorem `ConNF.NearLitterAction.not_bannedLitter_nonempty` states that in the context of Constructive Ordinal Notation (ConNF), given a near litter action `\u03c6`, there exists at least one litter `L` that is not banned, meaning it can be used as a sandbox.", "formal_statement": "example [ConNF.Params ] (\u03c6 : ConNF.NearLitterAction) :Nonempty \u2191{L : ConNF.Litter | \u00ac ConNF.NearLitterAction.BannedLitter \u03c6 L} := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03c6 : ConNF.NearLitterAction\n\u22a2 Nonempty \u2191{L | \u00acConNF.NearLitterAction.BannedLitter \u03c6 L}", "dependency": [1, 212, 1065]}, "ConNF.NearLitterAction.atomMapOrElse_of_dom": {"natural_language_statement": "Given a `ConNF.NearLitterAction` object `\u03c6` and an `ConNF.Atom` object `a`, if `a` is in the domain of `\u03c6.atomMap`, then `ConNF.NearLitterAction.atomMapOrElse \u03c6 a` returns the value of `\u03c6.atomMap a`.", "formal_statement": "example [ConNF.Params ] (\u03c6 : ConNF.NearLitterAction) {a : ConNF.Atom} (ha : (\u03c6.atomMap a).Dom) :ConNF.NearLitterAction.atomMapOrElse \u03c6 a = (\u03c6.atomMap a).get ha := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03c6 : ConNF.NearLitterAction\na : ConNF.Atom\nha : (\u03c6.atomMap a).Dom\n\u22a2 ConNF.NearLitterAction.atomMapOrElse \u03c6 a = (\u03c6.atomMap a).get ha", "dependency": [1, 1134]}, "ConNF.NearLitterAction.atomMapOrElse_injective": {"natural_language_statement": "The theorem `ConNF.NearLitterAction.atomMapOrElse_injective` states that the function `ConNF.NearLitterAction.atomMapOrElse` is injective when restricted to the domain of `\u03c6.atomMap`. This means that for any two atoms `a\u2081` and `a\u2082` in the domain of `\u03c6.atomMap`, if `ConNF.NearLitterAction.atomMapOrElse \u03c6 a\u2081 = ConNF.NearLitterAction.atomMapOrElse \u03c6 a\u2082`, then `a\u2081 = a\u2082`.", "formal_statement": "example [ConNF.Params ] (\u03c6 : ConNF.NearLitterAction) (h\u03c6 : ConNF.NearLitterAction.Lawful \u03c6) :Set.InjOn (ConNF.NearLitterAction.atomMapOrElse \u03c6) (PFun.Dom \u03c6.atomMap) := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03c6 : ConNF.NearLitterAction\nh\u03c6 : ConNF.NearLitterAction.Lawful \u03c6\n\u22a2 Set.InjOn (ConNF.NearLitterAction.atomMapOrElse \u03c6) (PFun.Dom \u03c6.atomMap)", "dependency": [1, 825, 111, 1134, 404]}, "ConNF.NearLitterAction.litterMapOrElse_of_dom": {"natural_language_statement": "Function `ConNF.NearLitterAction.litterMapOrElse` takes a `ConNF.NearLitterAction` and a `ConNF.Litter`, and returns a `ConNF.NearLitter`. If the `ConNF.Litter` is in the domain of the `ConNF.NearLitterAction`, it returns the result of the litter map. Otherwise, it returns an arbitrary near-litter. The theorem `ConNF.NearLitterAction.litterMapOrElse_of_dom` states that if the `ConNF.Litter` is in the domain of the `ConNF.NearLitterAction`, then `ConNF.NearLitterAction.litterMapOrElse` returns the result of the litter map.", "formal_statement": "example [ConNF.Params ] (\u03c6 : ConNF.NearLitterAction) {L : ConNF.Litter} (hL : (\u03c6.litterMap L).Dom) :ConNF.NearLitterAction.litterMapOrElse \u03c6 L = (\u03c6.litterMap L).get hL := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03c6 : ConNF.NearLitterAction\nL : ConNF.Litter\nhL : (\u03c6.litterMap L).Dom\n\u22a2 ConNF.NearLitterAction.litterMapOrElse \u03c6 L = (\u03c6.litterMap L).get hL", "dependency": [1, 1137]}, "ConNF.NearLitterAction.roughLitterMapOrElse_of_dom": {"natural_language_statement": "Function `ConNF.NearLitterAction.roughLitterMapOrElse` takes a `ConNF.NearLitterAction` object `\u03c6` and a `ConNF.Litter` object `L`, and returns the first component of the result of applying `ConNF.NearLitterAction.litterMapOrElse` to `\u03c6` and `L`.", "formal_statement": "example [ConNF.Params ] (\u03c6 : ConNF.NearLitterAction) {L : ConNF.Litter} (hL : (\u03c6.litterMap L).Dom) :ConNF.NearLitterAction.roughLitterMapOrElse \u03c6 L = ((\u03c6.litterMap L).get hL).fst := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03c6 : ConNF.NearLitterAction\nL : ConNF.Litter\nhL : (\u03c6.litterMap L).Dom\n\u22a2 ConNF.NearLitterAction.roughLitterMapOrElse \u03c6 L = ((\u03c6.litterMap L).get hL).fst", "dependency": [1, 1064]}, "ConNF.NearLitterAction.Lawful.le": {"natural_language_statement": "The theorem `ConNF.NearLitterAction.Lawful.le` states that if `\u03c6` is a lawful near litter action and `\u03c8` is a near litter action that is less than or equal to `\u03c6`, then `\u03c8` is also a lawful near litter action.", "formal_statement": "example [ConNF.Params ] {\u03c6 : ConNF.NearLitterAction} {\u03c8 : ConNF.NearLitterAction} (h : ConNF.NearLitterAction.Lawful \u03c6) (h\u03c8 : \u03c8 \u2264 \u03c6) :ConNF.NearLitterAction.Lawful \u03c8 := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03c6 \u03c8 : ConNF.NearLitterAction\nh : ConNF.NearLitterAction.Lawful \u03c6\nh\u03c8 : \u03c8 \u2264 \u03c6\n\u22a2 ConNF.NearLitterAction.Lawful \u03c8", "dependency": [1, 825, 825]}, "ConNF.NearLitterAction.preciseAt_iff": {"natural_language_statement": "The theorem `ConNF.NearLitterAction.preciseAt_iff` states that a near litter action `\u03c6` is precise at a litter `L` in its domain if and only if the symmetric difference of the image of `L` under `\u03c6` and the litter set of `L` is a subset of the range of `\u03c6`, and for any atom `a` in the domain of `\u03c6`, if `\u03c6(a)` is in the litter set of `L`, then `\u03c6(\u03c6(a))` is also in the domain of `\u03c6`. Additionally, the intersection of the domain of `\u03c6` and the image of `L` under `\u03c6` is a subset of the range of `\u03c6`.", "formal_statement": "example [ConNF.Params ] (\u03c6 : ConNF.NearLitterAction) \u2983L : ConNF.Litter\u2984 (hL : (\u03c6.litterMap L).Dom) :ConNF.NearLitterAction.PreciseAt \u03c6 hL \u2194 symmDiff (\u2191((\u03c6.litterMap L).get hL)) (ConNF.litterSet ((\u03c6.litterMap L).get hL).fst) \u2286 PFun.ran \u03c6.atomMap \u2227 (\u2200 (a : ConNF.Atom) (ha : (\u03c6.atomMap a).Dom), (\u03c6.atomMap a).get ha \u2208 ConNF.litterSet L \u2192 (\u03c6.atomMap ((\u03c6.atomMap a).get ha)).Dom) \u2227 PFun.Dom \u03c6.atomMap \u2229 \u2191((\u03c6.litterMap L).get hL) \u2286 PFun.ran \u03c6.atomMap := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03c6 : ConNF.NearLitterAction\nL : ConNF.Litter\nhL : (\u03c6.litterMap L).Dom\n\u22a2 ConNF.NearLitterAction.PreciseAt \u03c6 hL \u2194\n    symmDiff (\u2191((\u03c6.litterMap L).get hL)) (ConNF.litterSet ((\u03c6.litterMap L).get hL).fst) \u2286 PFun.ran \u03c6.atomMap \u2227\n      (\u2200 (a : ConNF.Atom) (ha : (\u03c6.atomMap a).Dom),\n          (\u03c6.atomMap a).get ha \u2208 ConNF.litterSet L \u2192 (\u03c6.atomMap ((\u03c6.atomMap a).get ha)).Dom) \u2227\n        PFun.Dom \u03c6.atomMap \u2229 \u2191((\u03c6.litterMap L).get hL) \u2286 PFun.ran \u03c6.atomMap", "dependency": [1, 1141, 62, 467, 824, 467, 404, 824]}, "ConNF.NearLitterAction.disjoint_dom_not_bannedLitter": {"natural_language_statement": "The theorem `ConNF.NearLitterAction.disjoint_dom_not_bannedLitter` states that the union of the domain of the partial function `\u03c6.litterMap` and the image of the domain of `\u03c6.litterMap` under the function `ConNF.NearLitterAction.roughLitterMapOrElse` is disjoint from the set of litters that are not banned by `\u03c6`.", "formal_statement": "example [ConNF.Params ] (\u03c6 : ConNF.NearLitterAction) :Disjoint (PFun.Dom \u03c6.litterMap \u222a ConNF.NearLitterAction.roughLitterMapOrElse \u03c6 '' PFun.Dom \u03c6.litterMap) {L : ConNF.Litter | \u00ac ConNF.NearLitterAction.BannedLitter \u03c6 L} := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03c6 : ConNF.NearLitterAction\n\u22a2 Disjoint (PFun.Dom \u03c6.litterMap \u222a ConNF.NearLitterAction.roughLitterMapOrElse \u03c6 '' PFun.Dom \u03c6.litterMap)\n    {L | \u00acConNF.NearLitterAction.BannedLitter \u03c6 L}", "dependency": [1, 757, 404, 1064, 404, 1065]}, "ConNF.NearLitterAction.roughLitterMapOrElse_injOn": {"natural_language_statement": "The function `ConNF.NearLitterAction.roughLitterMapOrElse` is injective when restricted to the domain of `\u03c6.litterMap`.", "formal_statement": "example [ConNF.Params ] (\u03c6 : ConNF.NearLitterAction) (h\u03c6 : ConNF.NearLitterAction.Lawful \u03c6) :Set.InjOn (ConNF.NearLitterAction.roughLitterMapOrElse \u03c6) (PFun.Dom \u03c6.litterMap) := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03c6 : ConNF.NearLitterAction\nh\u03c6 : ConNF.NearLitterAction.Lawful \u03c6\n\u22a2 Set.InjOn (ConNF.NearLitterAction.roughLitterMapOrElse \u03c6) (PFun.Dom \u03c6.litterMap)", "dependency": [1, 825, 111, 1064, 404]}, "ConNF.NearLitterAction.mk_not_bannedLitter_and_flexible": {"natural_language_statement": "The theorem `ConNF.NearLitterAction.mk_not_bannedLitter_and_flexible` states that in the context of Constructive Ordinal Notation (ConNF), the cardinality of the set of litters that are not banned and are also flexible is equal to the cardinality of the base type `\u03bc`. This theorem is crucial in ensuring that the construction of the natural numbers in ConNF is well-defined and consistent.", "formal_statement": "example [ConNF.Params ] (\u03c6 : ConNF.NearLitterAction) [ConNF.Level] [ConNF.FOAAssumptions] {\u03b2 : ConNF.\u039b} {A : ConNF.ExtendedIndex \u2191\u03b2} :Cardinal.mk \u2191{L : ConNF.Litter | \u00ac ConNF.NearLitterAction.BannedLitter \u03c6 L \u2227 ConNF.Flexible A L} = Cardinal.mk ConNF.\u03bc := by sorry", "full_tactic_state": "inst\u271d\u00b2 : ConNF.Params\n\u03c6 : ConNF.NearLitterAction\ninst\u271d\u00b9 : ConNF.Level\ninst\u271d : ConNF.FOAAssumptions\n\u03b2 : ConNF.\u039b\nA : ConNF.ExtendedIndex \u2191\u03b2\n\u22a2 Cardinal.mk \u2191{L | \u00acConNF.NearLitterAction.BannedLitter \u03c6 L \u2227 ConNF.Flexible A L} = Cardinal.mk ConNF.\u03bc", "dependency": [1, 61, 29, 1065, 842, 29]}, "ConNF.NearLitterAction.mk_dom_inter_flexible_symmDiff_le": {"natural_language_statement": "The theorem is proving an inequality involving the cardinalities of two sets related to Constructive Ordinal Notation (ConNF). The left-hand side of the inequality represents the cardinality of the symmetric difference between two sets of litters. The first set contains litters that are both in the domain of `\u03c6.litterMap` and are considered *flexible* by `A`, while the second set contains the results of applying `ConNF.NearLitterAction.roughLitterMapOrElse` to the first set. The right-hand side of the inequality represents the cardinality of a set of litters that are both not *banned* and *flexible* by `A`. The theorem shows that the cardinality of the left-hand side is less than or equal to the cardinality of the right-hand side.", "formal_statement": "example [ConNF.Params ] (\u03c6 : ConNF.NearLitterAction) [ConNF.Level] [ConNF.FOAAssumptions] {\u03b2 : ConNF.\u039b} {A : ConNF.ExtendedIndex \u2191\u03b2} :Cardinal.mk \u2191(symmDiff (PFun.Dom \u03c6.litterMap \u2229 {L : ConNF.Litter | ConNF.Flexible A L}) (ConNF.NearLitterAction.roughLitterMapOrElse \u03c6 '' (PFun.Dom \u03c6.litterMap \u2229 {L : ConNF.Litter | ConNF.Flexible A L}))) \u2264 Cardinal.mk \u2191{L : ConNF.Litter | \u00ac ConNF.NearLitterAction.BannedLitter \u03c6 L \u2227 ConNF.Flexible A L} := by sorry", "full_tactic_state": "inst\u271d\u00b2 : ConNF.Params\n\u03c6 : ConNF.NearLitterAction\ninst\u271d\u00b9 : ConNF.Level\ninst\u271d : ConNF.FOAAssumptions\n\u03b2 : ConNF.\u039b\nA : ConNF.ExtendedIndex \u2191\u03b2\n\u22a2 Cardinal.mk\n      \u2191(symmDiff (PFun.Dom \u03c6.litterMap \u2229 {L | ConNF.Flexible A L})\n          (ConNF.NearLitterAction.roughLitterMapOrElse \u03c6 '' (PFun.Dom \u03c6.litterMap \u2229 {L | ConNF.Flexible A L}))) \u2264\n    Cardinal.mk \u2191{L | \u00acConNF.NearLitterAction.BannedLitter \u03c6 L \u2227 ConNF.Flexible A L}", "dependency": [1, 61, 29, 62, 404, 842, 1064, 404, 842, 29, 1065, 842]}, "ConNF.NearLitterAction.aleph0_le_not_bannedLitter_and_flexible": {"natural_language_statement": "The theorem `ConNF.NearLitterAction.aleph0_le_not_bannedLitter_and_flexible` states that the cardinality of the set of litters that are not banned and are considered flexible is at least as large as the cardinality of the natural numbers (denoted as `\u2135\u2080`). This theorem is an important step in the proof that the natural numbers can be constructed within the context of Constructive Ordinal Notation (ConNF), using the properties of litters and f-maps.", "formal_statement": "example [ConNF.Params ] (\u03c6 : ConNF.NearLitterAction) [ConNF.Level] [ConNF.FOAAssumptions] {\u03b2 : ConNF.\u039b} {A : ConNF.ExtendedIndex \u2191\u03b2} :Cardinal.aleph0 \u2264 Cardinal.mk \u2191{L : ConNF.Litter | \u00ac ConNF.NearLitterAction.BannedLitter \u03c6 L \u2227 ConNF.Flexible A L} := by sorry", "full_tactic_state": "inst\u271d\u00b2 : ConNF.Params\n\u03c6 : ConNF.NearLitterAction\ninst\u271d\u00b9 : ConNF.Level\ninst\u271d : ConNF.FOAAssumptions\n\u03b2 : ConNF.\u039b\nA : ConNF.ExtendedIndex \u2191\u03b2\n\u22a2 Cardinal.aleph0 \u2264 Cardinal.mk \u2191{L | \u00acConNF.NearLitterAction.BannedLitter \u03c6 L \u2227 ConNF.Flexible A L}", "dependency": [1, 61, 510, 29, 1065, 842]}, "ConNF.NearLitterAction.disjoint_dom_inter_flexible_not_bannedLitter": {"natural_language_statement": "In the context of Constructive Ordinal Notation (ConNF), this result establishes that the intersection of the domain of the litter map of a `ConNF.NearLitterAction` object and the set of `ConNF.Flexible` litters is disjoint from the set of litters that are not `ConNF.NearLitterAction.BannedLitter` and are `ConNF.Flexible`. This is an important property that ensures the consistency of the construction of the natural numbers in ConNF.", "formal_statement": "example [ConNF.Params ] (\u03c6 : ConNF.NearLitterAction) [ConNF.Level] [ConNF.FOAAssumptions] {\u03b2 : ConNF.\u039b} {A : ConNF.ExtendedIndex \u2191\u03b2} :Disjoint (PFun.Dom \u03c6.litterMap \u2229 {L : ConNF.Litter | ConNF.Flexible A L} \u222a ConNF.NearLitterAction.roughLitterMapOrElse \u03c6 '' (PFun.Dom \u03c6.litterMap \u2229 {L : ConNF.Litter | ConNF.Flexible A L})) {L : ConNF.Litter | \u00ac ConNF.NearLitterAction.BannedLitter \u03c6 L \u2227 ConNF.Flexible A L} := by sorry", "full_tactic_state": "inst\u271d\u00b2 : ConNF.Params\n\u03c6 : ConNF.NearLitterAction\ninst\u271d\u00b9 : ConNF.Level\ninst\u271d : ConNF.FOAAssumptions\n\u03b2 : ConNF.\u039b\nA : ConNF.ExtendedIndex \u2191\u03b2\n\u22a2 Disjoint\n    (PFun.Dom \u03c6.litterMap \u2229 {L | ConNF.Flexible A L} \u222a\n      ConNF.NearLitterAction.roughLitterMapOrElse \u03c6 '' (PFun.Dom \u03c6.litterMap \u2229 {L | ConNF.Flexible A L}))\n    {L | \u00acConNF.NearLitterAction.BannedLitter \u03c6 L \u2227 ConNF.Flexible A L}", "dependency": [1, 61, 757, 404, 842, 1064, 404, 842, 1065, 842]}, "ConNF.NearLitterAction.roughLitterMapOrElse_injOn_dom_inter_flexible": {"natural_language_statement": "The theorem `ConNF.NearLitterAction.roughLitterMapOrElse_injOn_dom_inter_flexible` states that the function `ConNF.NearLitterAction.roughLitterMapOrElse`, which takes a `ConNF.NearLitterAction` object `\u03c6` and a `ConNF.Litter` object `L`, and returns the first component of the result of applying `ConNF.NearLitterAction.litterMapOrElse` to `\u03c6` and `L`, is injective when restricted to the intersection of the domain of `\u03c6.litterMap` and the set of *flexible* litters. This property is crucial in ensuring that the construction of the natural numbers in ConNF is well-defined and consistent.", "formal_statement": "example [ConNF.Params ] (\u03c6 : ConNF.NearLitterAction) [ConNF.Level] [ConNF.FOAAssumptions] {\u03b2 : ConNF.\u039b} {A : ConNF.ExtendedIndex \u2191\u03b2} (h\u03c6 : ConNF.NearLitterAction.Lawful \u03c6) :Set.InjOn (ConNF.NearLitterAction.roughLitterMapOrElse \u03c6) (PFun.Dom \u03c6.litterMap \u2229 {L : ConNF.Litter | ConNF.Flexible A L}) := by sorry", "full_tactic_state": "inst\u271d\u00b2 : ConNF.Params\n\u03c6 : ConNF.NearLitterAction\ninst\u271d\u00b9 : ConNF.Level\ninst\u271d : ConNF.FOAAssumptions\n\u03b2 : ConNF.\u039b\nA : ConNF.ExtendedIndex \u2191\u03b2\nh\u03c6 : ConNF.NearLitterAction.Lawful \u03c6\n\u22a2 Set.InjOn (ConNF.NearLitterAction.roughLitterMapOrElse \u03c6) (PFun.Dom \u03c6.litterMap \u2229 {L | ConNF.Flexible A L})", "dependency": [1, 61, 825, 111, 1064, 404, 842]}, "ConNF.NearLitterAction.flexibleLitterPartialPerm_apply_eq": {"natural_language_statement": "To summarize the explanation of the Lean 4 object `ConNF.NearLitterAction.flexibleLitterPartialPerm_apply_eq` in one line, it states that the application of the partial permutation `ConNF.NearLitterAction.flexibleLitterPartialPerm` to a litter `L` that is both not banned and flexible with respect to the extended index `A` yields the same result as applying the `ConNF.NearLitterAction.roughLitterMapOrElse` to `L`.", "formal_statement": "example [ConNF.Params ] [ConNF.Level] [ConNF.FOAAssumptions] {\u03b2 : ConNF.\u039b} {A : ConNF.ExtendedIndex \u2191\u03b2} {\u03c6 : ConNF.NearLitterAction} {h\u03c6 : ConNF.NearLitterAction.Lawful \u03c6} (L : ConNF.Litter) (hL\u2081 : L \u2208 PFun.Dom \u03c6.litterMap) (hL\u2082 : ConNF.Flexible A L) :(ConNF.NearLitterAction.flexibleLitterPartialPerm \u03c6 h\u03c6 A).toFun L = ConNF.NearLitterAction.roughLitterMapOrElse \u03c6 L := by sorry", "full_tactic_state": "inst\u271d\u00b2 : ConNF.Params\ninst\u271d\u00b9 : ConNF.Level\ninst\u271d : ConNF.FOAAssumptions\n\u03b2 : ConNF.\u039b\nA : ConNF.ExtendedIndex \u2191\u03b2\n\u03c6 : ConNF.NearLitterAction\nh\u03c6 : ConNF.NearLitterAction.Lawful \u03c6\nL : ConNF.Litter\nhL\u2081 : L \u2208 PFun.Dom \u03c6.litterMap\nhL\u2082 : ConNF.Flexible A L\n\u22a2 (ConNF.NearLitterAction.flexibleLitterPartialPerm \u03c6 h\u03c6 A).toFun L = ConNF.NearLitterAction.roughLitterMapOrElse \u03c6 L", "dependency": [1, 61, 825, 404, 842, 1150, 1064]}, "ConNF.NearLitterAction.flexibleLitterPartialPerm_domain_small": {"natural_language_statement": "In the context of Constructive Ordinal Notation (ConNF), given a lawful near litter action `\u03c6` and an extended index `A`, the domain of the partial permutation `ConNF.NearLitterAction.flexibleLitterPartialPerm \u03c6 h\u03c6 A` is small, meaning its cardinality is strictly less than the cardinality of the type `ConNF.\u03ba`.", "formal_statement": "example [ConNF.Params ] (\u03c6 : ConNF.NearLitterAction) [ConNF.Level] [ConNF.FOAAssumptions] {\u03b2 : ConNF.\u039b} {A : ConNF.ExtendedIndex \u2191\u03b2} (h\u03c6 : ConNF.NearLitterAction.Lawful \u03c6) :ConNF.Small (ConNF.NearLitterAction.flexibleLitterPartialPerm \u03c6 h\u03c6 A).domain := by sorry", "full_tactic_state": "inst\u271d\u00b2 : ConNF.Params\n\u03c6 : ConNF.NearLitterAction\ninst\u271d\u00b9 : ConNF.Level\ninst\u271d : ConNF.FOAAssumptions\n\u03b2 : ConNF.\u039b\nA : ConNF.ExtendedIndex \u2191\u03b2\nh\u03c6 : ConNF.NearLitterAction.Lawful \u03c6\n\u22a2 ConNF.Small (ConNF.NearLitterAction.flexibleLitterPartialPerm \u03c6 h\u03c6 A).domain", "dependency": [1, 61, 825, 233, 1150]}, "ConNF.NearLitterAction.refineLawful": {"natural_language_statement": "Function `ConNF.NearLitterAction.refine` takes a lawful near litter action `\u03c6` and refines it to ensure that the atom and litter maps are injective and that the images of atoms in litters are mapped to atoms inside the corresponding near-litters. The theorem `ConNF.NearLitterAction.refineLawful` asserts that the refined near litter action is lawful.", "formal_statement": "example [ConNF.Params ] {\u03c6 : ConNF.NearLitterAction} {h\u03c6 : ConNF.NearLitterAction.Lawful \u03c6} :ConNF.NearLitterAction.Lawful (ConNF.NearLitterAction.refine \u03c6 h\u03c6) := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03c6 : ConNF.NearLitterAction\nh\u03c6 : ConNF.NearLitterAction.Lawful \u03c6\n\u22a2 ConNF.NearLitterAction.Lawful (ConNF.NearLitterAction.refine \u03c6 h\u03c6)", "dependency": [1, 825, 825, 1153]}, "ConNF.NearLitterAction.refine_atomMap": {"natural_language_statement": "Function `ConNF.NearLitterAction.refine_atomMap` is a part of the Constructive Ordinal Notation (ConNF) library in Lean 4. It states that the refined atom map of a lawful near litter action `\u03c6` is equal to the original atom map of `\u03c6`.", "formal_statement": "@[simp]example [ConNF.Params ] {\u03c6 : ConNF.NearLitterAction} {h\u03c6 : ConNF.NearLitterAction.Lawful \u03c6} {a : ConNF.Atom} (ha : (\u03c6.atomMap a).Dom) :(ConNF.NearLitterAction.refine \u03c6 h\u03c6).atomMap a = \u03c6.atomMap a := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03c6 : ConNF.NearLitterAction\nh\u03c6 : ConNF.NearLitterAction.Lawful \u03c6\na : ConNF.Atom\nha : (\u03c6.atomMap a).Dom\n\u22a2 (ConNF.NearLitterAction.refine \u03c6 h\u03c6).atomMap a = \u03c6.atomMap a", "dependency": [1, 825, 1153]}, "ConNF.NearLitterAction.refine_litterMap": {"natural_language_statement": "The function `ConNF.NearLitterAction.refine` takes a lawful near litter action `\u03c6` and refines it to ensure that the atom and litter maps are injective and that the images of atoms in litters are mapped to atoms inside the corresponding near-litters. The theorem `ConNF.NearLitterAction.refine_litterMap` states that the refined litter map is equal to the original litter map.", "formal_statement": "@[simp]example [ConNF.Params ] {\u03c6 : ConNF.NearLitterAction} {h\u03c6 : ConNF.NearLitterAction.Lawful \u03c6} :(ConNF.NearLitterAction.refine \u03c6 h\u03c6).litterMap = \u03c6.litterMap := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03c6 : ConNF.NearLitterAction\nh\u03c6 : ConNF.NearLitterAction.Lawful \u03c6\n\u22a2 (ConNF.NearLitterAction.refine \u03c6 h\u03c6).litterMap = \u03c6.litterMap", "dependency": [1, 825, 1153]}, "ConNF.NearLitterAction.refine_precise": {"natural_language_statement": "The function `ConNF.NearLitterAction.refine` takes a lawful near litter action `\u03c6` and refines it to ensure that the atom and litter maps are injective and that the images of atoms in litters are mapped to atoms inside the corresponding near-litters. The theorem `ConNF.NearLitterAction.refine_precise` states that the refined near litter action is precise, meaning it is precise at every litter in its domain.", "formal_statement": "example [ConNF.Params ] {\u03c6 : ConNF.NearLitterAction} {h\u03c6 : ConNF.NearLitterAction.Lawful \u03c6} :ConNF.NearLitterAction.Precise (ConNF.NearLitterAction.refine \u03c6 h\u03c6) := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03c6 : ConNF.NearLitterAction\nh\u03c6 : ConNF.NearLitterAction.Lawful \u03c6\n\u22a2 ConNF.NearLitterAction.Precise (ConNF.NearLitterAction.refine \u03c6 h\u03c6)", "dependency": [1, 825, 1123, 1153]}, "ConNF.StructAction.refine_lawful": {"natural_language_statement": "Function `ConNF.StructAction.refine_lawful` proves that the refined `\u03b2`-structural action satisfies the lawfulness condition for each `\u03b2`-extended index.", "formal_statement": "example [ConNF.Params ] {\u03b2 : ConNF.TypeIndex} {\u03c6 : ConNF.StructAction \u03b2} {h\u03c6 : ConNF.StructAction.Lawful \u03c6} :ConNF.StructAction.Lawful (ConNF.StructAction.refine \u03c6 h\u03c6) := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03b2 : ConNF.TypeIndex\n\u03c6 : ConNF.StructAction \u03b2\nh\u03c6 : ConNF.StructAction.Lawful \u03c6\n\u22a2 ConNF.StructAction.Lawful (ConNF.StructAction.refine \u03c6 h\u03c6)", "dependency": [1, 808, 809, 809, 1158]}, "ConNF.StructAction.refine_precise": {"natural_language_statement": "The theorem `ConNF.StructAction.refine_precise` states that if `\u03c6` is a `\u03b2`-structural action that satisfies the lawfulness condition for each `\u03b2`-extended index, then the refined `\u03b2`-structural action `ConNF.StructAction.refine \u03c6 h\u03c6` is precise, meaning it assigns a precise near-litter action to each `\u03b2`-extended index.", "formal_statement": "example [ConNF.Params ] {\u03b2 : ConNF.TypeIndex} {\u03c6 : ConNF.StructAction \u03b2} {h\u03c6 : ConNF.StructAction.Lawful \u03c6} :ConNF.StructAction.Precise (ConNF.StructAction.refine \u03c6 h\u03c6) := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03b2 : ConNF.TypeIndex\n\u03c6 : ConNF.StructAction \u03b2\nh\u03c6 : ConNF.StructAction.Lawful \u03c6\n\u22a2 ConNF.StructAction.Precise (ConNF.StructAction.refine \u03c6 h\u03c6)", "dependency": [1, 808, 809, 1160, 1158]}, "ConNF.StructAction.rc_smul_atom_eq": {"natural_language_statement": "The theorem `ConNF.StructAction.rc_smul_atom_eq` is a part of the Constructive Ordinal Notation (ConNF) project in Lean 4. It states that for any `\u03b2`-structural action `\u03c6` that is lawful, any `\u03b2`-extended index `B`, and any `Atom` `a`, if the domain of `\u03c6 B`'s atom map on `a` is not empty, then the `\u03b2`-structural approximation of `\u03c6` applied to `B` and `a` is equal to the value of `\u03c6 B`'s atom map on `a` at the given domain element. This indicates that the `\u03b2`-structural approximation correctly extends the `\u03b2`-structural action.", "formal_statement": "example [ConNF.Params ] [ConNF.Level] [ConNF.FOAAssumptions] {\u03b2 : ConNF.\u039b} {\u03c6 : ConNF.StructAction \u2191\u03b2} {h : ConNF.StructAction.Lawful \u03c6} {B : ConNF.ExtendedIndex \u2191\u03b2} {a : ConNF.Atom} (ha : ((\u03c6 B).atomMap a).Dom) :ConNF.StructAction.rc \u03c6 h B \u2022 a = ((\u03c6 B).atomMap a).get ha := by sorry", "full_tactic_state": "inst\u271d\u00b2 : ConNF.Params\ninst\u271d\u00b9 : ConNF.Level\ninst\u271d : ConNF.FOAAssumptions\n\u03b2 : ConNF.\u039b\n\u03c6 : ConNF.StructAction \u2191\u03b2\nh : ConNF.StructAction.Lawful \u03c6\nB : ConNF.ExtendedIndex \u2191\u03b2\na : ConNF.Atom\nha : ((\u03c6 B).atomMap a).Dom\n\u22a2 ConNF.StructAction.rc \u03c6 h B \u2022 a = ((\u03c6 B).atomMap a).get ha", "dependency": [1, 808, 809, 61, 810]}, "ConNF.StructAction.rc_free": {"natural_language_statement": "The `ConNF.StructAction.rc_free` theorem proves that the `\u03b2`-structural approximation `ConNF.StructAction.rc \u03c6 h\u2081` is free. This means that for every `\u03b2`-extended index `A`, the near-litter approximation `(\u03c0\u2080 A)` is free with respect to `A`. This theorem is a key part of the ConNF construction, which aims to define a well-founded, transitive relation on the ordinals using a recursive process that leverages the properties of `\u03b2`-extended indices, near-litters, and `\u03b2`-structural approximations.", "formal_statement": "example [ConNF.Params ] [ConNF.Level] [ConNF.FOAAssumptions] {\u03b2 : ConNF.\u039b} (\u03c6 : ConNF.StructAction \u2191\u03b2) (h\u2081 : ConNF.StructAction.Lawful \u03c6) (h\u2082 : ConNF.StructAction.MapFlexible \u03c6) :ConNF.StructApprox.Free (ConNF.StructAction.rc \u03c6 h\u2081) := by sorry", "full_tactic_state": "inst\u271d\u00b2 : ConNF.Params\ninst\u271d\u00b9 : ConNF.Level\ninst\u271d : ConNF.FOAAssumptions\n\u03b2 : ConNF.\u039b\n\u03c6 : ConNF.StructAction \u2191\u03b2\nh\u2081 : ConNF.StructAction.Lawful \u03c6\nh\u2082 : ConNF.StructAction.MapFlexible \u03c6\n\u22a2 ConNF.StructApprox.Free (ConNF.StructAction.rc \u03c6 h\u2081)", "dependency": [1, 808, 809, 814, 782, 810]}, "ConNF.StructAction.smul_atom_eq": {"natural_language_statement": "The theorem `ConNF.StructAction.smul_atom_eq` is a part of the Constructive Ordinal Notation (ConNF) framework in Lean 4. It states that for a lawful `\u03b2`-structural action `\u03c6`, the action of a `\u03b2`-structural permutation `\u03c0` on an atom `a` at an extended index `B` is equal to the value of the atom map at `a` given the domain condition `ha`. This theorem is crucial for ensuring that the `\u03b2`-structural approximation is an exact approximation of the `\u03b2`-structural permutation in the context of ConNF.", "formal_statement": "example [ConNF.Params ] [ConNF.Level] [ConNF.FOAAssumptions] {\u03b2 : ConNF.\u039b} (\u03c6 : ConNF.StructAction \u2191\u03b2) {h\u03c6 : ConNF.StructAction.Lawful \u03c6} {\u03c0 : ConNF.StructPerm \u2191\u03b2} (h\u03c0 : ConNF.StructApprox.ExactlyApproximates (ConNF.StructAction.complete \u03c6 h\u03c6) \u03c0) {a : ConNF.Atom} {B : ConNF.ExtendedIndex \u2191\u03b2} (ha : ((\u03c6 B).atomMap a).Dom) :\u03c0 B \u2022 a = ((\u03c6 B).atomMap a).get ha := by sorry", "full_tactic_state": "inst\u271d\u00b2 : ConNF.Params\ninst\u271d\u00b9 : ConNF.Level\ninst\u271d : ConNF.FOAAssumptions\n\u03b2 : ConNF.\u039b\n\u03c6 : ConNF.StructAction \u2191\u03b2\nh\u03c6 : ConNF.StructAction.Lawful \u03c6\n\u03c0 : ConNF.StructPerm \u2191\u03b2\nh\u03c0 : ConNF.StructApprox.ExactlyApproximates (ConNF.StructAction.complete \u03c6 h\u03c6) \u03c0\na : ConNF.Atom\nB : ConNF.ExtendedIndex \u2191\u03b2\nha : ((\u03c6 B).atomMap a).Dom\n\u22a2 \u03c0 B \u2022 a = ((\u03c6 B).atomMap a).get ha", "dependency": [1, 808, 809, 55, 803, 1164, 61]}, "ConNF.StructAction.smul_toNearLitter_eq_of_precise": {"natural_language_statement": "In the context of Constructive Ordinal Notation (ConNF), the theorem `ConNF.StructAction.smul_toNearLitter_eq_of_precise` states that if a `\u03b2`-structural action `\u03c6` is precise, meaning it assigns a precise near-litter action to each `\u03b2`-extended index, and if a `\u03b2`-structural permutation `\u03c0` exactly approximates the `\u03b2`-structural approximation constructed from `\u03c6`, then for any `\u03b2`-extended index `B` and any litter `L` such that the near-litter action of `\u03c6` at `B` applied to `L` is defined, the near-litter action of `\u03c0` at `B` applied to the near-litter `L` is equal to the precise near-litter action of `\u03c6` at `B` applied to `L`.", "formal_statement": "example [ConNF.Params ] [ConNF.Level] [ConNF.FOAAssumptions] {\u03b2 : ConNF.\u039b} (\u03c6 : ConNF.StructAction \u2191\u03b2) {h\u03c6 : ConNF.StructAction.Lawful \u03c6} (h\u03c6p : ConNF.StructAction.Precise \u03c6) {\u03c0 : ConNF.StructPerm \u2191\u03b2} (h\u03c0 : ConNF.StructApprox.ExactlyApproximates (ConNF.StructAction.complete \u03c6 h\u03c6) \u03c0) {L : ConNF.Litter} {B : ConNF.ExtendedIndex \u2191\u03b2} (hL : ((\u03c6 B).litterMap L).Dom) (h\u03c0L : \u03c0 B \u2022 L = (((\u03c6 B).litterMap L).get hL).fst) :\u03c0 B \u2022 ConNF.Litter.toNearLitter L = ((\u03c6 B).litterMap L).get hL := by sorry", "full_tactic_state": "inst\u271d\u00b2 : ConNF.Params\ninst\u271d\u00b9 : ConNF.Level\ninst\u271d : ConNF.FOAAssumptions\n\u03b2 : ConNF.\u039b\n\u03c6 : ConNF.StructAction \u2191\u03b2\nh\u03c6 : ConNF.StructAction.Lawful \u03c6\nh\u03c6p : ConNF.StructAction.Precise \u03c6\n\u03c0 : ConNF.StructPerm \u2191\u03b2\nh\u03c0 : ConNF.StructApprox.ExactlyApproximates (ConNF.StructAction.complete \u03c6 h\u03c6) \u03c0\nL : ConNF.Litter\nB : ConNF.ExtendedIndex \u2191\u03b2\nhL : ((\u03c6 B).litterMap L).Dom\nh\u03c0L : \u03c0 B \u2022 L = (((\u03c6 B).litterMap L).get hL).fst\n\u22a2 \u03c0 B \u2022 ConNF.Litter.toNearLitter L = ((\u03c6 B).litterMap L).get hL", "dependency": [1, 808, 809, 1160, 55, 803, 1164, 61, 483]}, "ConNF.StructAction.Lawful.le": {"natural_language_statement": "The theorem `ConNF.StructAction.Lawful.le` states that if `\u03c6` is a lawful `\u03b2`-structural action and `\u03c8` is a `\u03b2`-structural action that is less than or equal to `\u03c6`, then `\u03c8` is also a lawful `\u03b2`-structural action.", "formal_statement": "example [ConNF.Params ] {\u03b2 : ConNF.TypeIndex} {\u03c6 : ConNF.StructAction \u03b2} {\u03c8 : ConNF.StructAction \u03b2} (h : ConNF.StructAction.Lawful \u03c6) (h\u03c8 : \u03c8 \u2264 \u03c6) :ConNF.StructAction.Lawful \u03c8 := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03b2 : ConNF.TypeIndex\n\u03c6 \u03c8 : ConNF.StructAction \u03b2\nh : ConNF.StructAction.Lawful \u03c6\nh\u03c8 : \u03c8 \u2264 \u03c6\n\u22a2 ConNF.StructAction.Lawful \u03c8", "dependency": [1, 808, 808, 809, 809]}, "ConNF.StructAction.le_comp": {"natural_language_statement": "Given a `\u03b2`-structural action `\u03c6` that is less than or equal to another `\u03b2`-structural action `\u03c8`, and a path `A` from type index `\u03b2` to type index `\u03b3`, the derivative functor `ConNF.Tree.comp A \u03c6` is less than or equal to the derivative functor `ConNF.Tree.comp A \u03c8`.", "formal_statement": "example [ConNF.Params ] {\u03b2 : ConNF.TypeIndex} {\u03b3 : ConNF.TypeIndex} {\u03c6 : ConNF.StructAction \u03b2} {\u03c8 : ConNF.StructAction \u03b2} (h : \u03c6 \u2264 \u03c8) (A : Quiver.Path \u03b2 \u03b3) :ConNF.Tree.comp A \u03c6 \u2264 ConNF.Tree.comp A \u03c8 := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03b2 \u03b3 : ConNF.TypeIndex\n\u03c6 \u03c8 : ConNF.StructAction \u03b2\nh : \u03c6 \u2264 \u03c8\nA : Quiver.Path \u03b2 \u03b3\n\u22a2 ConNF.Tree.comp A \u03c6 \u2264 ConNF.Tree.comp A \u03c8", "dependency": [1, 808, 808, 76, 304, 304]}, "ConNF.StructAction.Lawful.comp": {"natural_language_statement": "The theorem `ConNF.StructAction.Lawful.comp` states that if `\u03c6` is a lawful `\u03b2`-structural action, then the composition of `\u03c6` with any path `A` from `\u03b2` to `\u03b3` is also lawful, forming a lawful `\u03b3`-structural action. This property is crucial for showing that every lawful `\u03b2`-structural action can be extended to a lawful `\u03b3`-structural action, which is a key step in the proof of the consistency of Constructive Ordinal Notation (ConNF) with ZFC.", "formal_statement": "example [ConNF.Params ] {\u03b2 : ConNF.TypeIndex} {\u03b3 : ConNF.TypeIndex} {\u03c6 : ConNF.StructAction \u03b2} (h : ConNF.StructAction.Lawful \u03c6) (A : Quiver.Path \u03b2 \u03b3) :ConNF.StructAction.Lawful (ConNF.Tree.comp A \u03c6) := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03b2 \u03b3 : ConNF.TypeIndex\n\u03c6 : ConNF.StructAction \u03b2\nh : ConNF.StructAction.Lawful \u03c6\nA : Quiver.Path \u03b2 \u03b3\n\u22a2 ConNF.StructAction.Lawful (ConNF.Tree.comp A \u03c6)", "dependency": [1, 808, 809, 76, 809, 304]}, "ConNF.NearLitterAction.sandboxLitter_not_banned": {"natural_language_statement": "The sandbox litter for a near-litter action is not banned.", "formal_statement": "example [ConNF.Params ] (\u03c6 : ConNF.NearLitterAction) :\u00ac ConNF.NearLitterAction.BannedLitter \u03c6 (ConNF.NearLitterAction.sandboxLitter \u03c6) := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03c6 : ConNF.NearLitterAction\n\u22a2 \u00acConNF.NearLitterAction.BannedLitter \u03c6 (ConNF.NearLitterAction.sandboxLitter \u03c6)", "dependency": [1, 1065, 1170]}, "ConNF.NearLitterAction.mk_atomMap_image_le_mk_sandbox": {"natural_language_statement": "The theorem `ConNF.NearLitterAction.mk_atomMap_image_le_mk_sandbox` in Lean 4 is a statement about the sizes of two sets related to a `ConNF.NearLitterAction` object `\u03c6`. It asserts that the cardinality of the symmetric difference between the domain of `\u03c6.atomMap` and its image under `\u03c6.atomMapOrElse`, is less than or equal to the cardinality of the litter set corresponding to the sandbox litter of `\u03c6`. This theorem is crucial in the ConNF theory for proving the existence of a member of a specific litter in the context of Constructive Ordinal Notation.", "formal_statement": "example [ConNF.Params ] (\u03c6 : ConNF.NearLitterAction) :Cardinal.mk \u2191(symmDiff (PFun.Dom \u03c6.atomMap) (ConNF.NearLitterAction.atomMapOrElse \u03c6 '' PFun.Dom \u03c6.atomMap)) \u2264 Cardinal.mk \u2191(ConNF.litterSet (ConNF.NearLitterAction.sandboxLitter \u03c6)) := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03c6 : ConNF.NearLitterAction\n\u22a2 Cardinal.mk \u2191(symmDiff (PFun.Dom \u03c6.atomMap) (ConNF.NearLitterAction.atomMapOrElse \u03c6 '' PFun.Dom \u03c6.atomMap)) \u2264\n    Cardinal.mk \u2191(ConNF.litterSet (ConNF.NearLitterAction.sandboxLitter \u03c6))", "dependency": [1, 29, 62, 404, 1134, 404, 29, 467, 1170]}, "ConNF.NearLitterAction.disjoint_sandbox": {"natural_language_statement": "The theorem `ConNF.NearLitterAction.disjoint_sandbox` in Lean 4 states that for any near-litter action `\u03c6`, the union of the domain of `\u03c6.atomMap` and its image under `ConNF.NearLitterAction.atomMapOrElse` is disjoint from the litter set corresponding to the sandbox litter of `\u03c6`. This theorem is crucial for the construction of the natural numbers in the context of Constructive Ordinal Notation (ConNF), as it ensures that the sandbox litter is distinct from the atoms that are relevant for the definition of natural numbers.", "formal_statement": "example [ConNF.Params ] (\u03c6 : ConNF.NearLitterAction) :Disjoint (PFun.Dom \u03c6.atomMap \u222a ConNF.NearLitterAction.atomMapOrElse \u03c6 '' PFun.Dom \u03c6.atomMap) (ConNF.litterSet (ConNF.NearLitterAction.sandboxLitter \u03c6)) := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03c6 : ConNF.NearLitterAction\n\u22a2 Disjoint (PFun.Dom \u03c6.atomMap \u222a ConNF.NearLitterAction.atomMapOrElse \u03c6 '' PFun.Dom \u03c6.atomMap)\n    (ConNF.litterSet (ConNF.NearLitterAction.sandboxLitter \u03c6))", "dependency": [1, 757, 404, 1134, 404, 467, 1170]}, "ConNF.NearLitterAction.atomPartialPerm_domain_small": {"natural_language_statement": "The theorem `ConNF.NearLitterAction.atomPartialPerm_domain_small` asserts that the domain of the partial permutation `ConNF.NearLitterAction.atomPartialPerm \u03c6 h\u03c6` is small, meaning its cardinality is strictly less than the cardinality of the type `ConNF.\u03ba` in the context of Constructive Ordinal Notation (ConNF).", "formal_statement": "example [ConNF.Params ] (\u03c6 : ConNF.NearLitterAction) (h\u03c6 : ConNF.NearLitterAction.Lawful \u03c6) :ConNF.Small (ConNF.NearLitterAction.atomPartialPerm \u03c6 h\u03c6).domain := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03c6 : ConNF.NearLitterAction\nh\u03c6 : ConNF.NearLitterAction.Lawful \u03c6\n\u22a2 ConNF.Small (ConNF.NearLitterAction.atomPartialPerm \u03c6 h\u03c6).domain", "dependency": [1, 825, 233, 1174]}, "ConNF.NearLitterAction.atomPartialPerm_apply_eq": {"natural_language_statement": "The function `ConNF.NearLitterAction.atomPartialPerm_apply_eq` establishes an equality between the application of the function `ConNF.NearLitterAction.atomPartialPerm` to an atom `a` and the value obtained by applying the atom map `\u03c6.atomMap a` directly. This function is crucial in showing that the near-litter action is lawful by ensuring that the atom permutation is well-defined and that the resulting action does not alter the essential properties of the `ConNF.Params` structure.", "formal_statement": "example [ConNF.Params ] (\u03c6 : ConNF.NearLitterAction) (h\u03c6 : ConNF.NearLitterAction.Lawful \u03c6) {a : ConNF.Atom} (ha : (\u03c6.atomMap a).Dom) :(ConNF.NearLitterAction.atomPartialPerm \u03c6 h\u03c6).toFun a = (\u03c6.atomMap a).get ha := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03c6 : ConNF.NearLitterAction\nh\u03c6 : ConNF.NearLitterAction.Lawful \u03c6\na : ConNF.Atom\nha : (\u03c6.atomMap a).Dom\n\u22a2 (ConNF.NearLitterAction.atomPartialPerm \u03c6 h\u03c6).toFun a = (\u03c6.atomMap a).get ha", "dependency": [1, 825, 1174]}, "ConNF.NearLitterAction.complete_smul_atom_eq": {"natural_language_statement": "Given a lawful near-litter action \u03c6, a finite path A from a type \u03b2 to the base type \u22a5, and an atom a that is mapped to a near-litter by \u03c6, the near-litter approximation (\u03c6.complete A) applied to a is equal to the atom a itself.", "formal_statement": "example [ConNF.Params ] (\u03c6 : ConNF.NearLitterAction) [ConNF.Level] [ConNF.FOAAssumptions] {\u03b2 : ConNF.\u039b} {A : ConNF.ExtendedIndex \u2191\u03b2} {h\u03c6 : ConNF.NearLitterAction.Lawful \u03c6} {a : ConNF.Atom} (ha : (\u03c6.atomMap a).Dom) :ConNF.NearLitterAction.complete \u03c6 h\u03c6 A \u2022 a = (\u03c6.atomMap a).get ha := by sorry", "full_tactic_state": "inst\u271d\u00b2 : ConNF.Params\n\u03c6 : ConNF.NearLitterAction\ninst\u271d\u00b9 : ConNF.Level\ninst\u271d : ConNF.FOAAssumptions\n\u03b2 : ConNF.\u039b\nA : ConNF.ExtendedIndex \u2191\u03b2\nh\u03c6 : ConNF.NearLitterAction.Lawful \u03c6\na : ConNF.Atom\nha : (\u03c6.atomMap a).Dom\n\u22a2 ConNF.NearLitterAction.complete \u03c6 h\u03c6 A \u2022 a = (\u03c6.atomMap a).get ha", "dependency": [1, 61, 825, 1177]}, "ConNF.NearLitterAction.complete_smul_litter_eq": {"natural_language_statement": "The theorem `ConNF.NearLitterAction.complete_smul_litter_eq` is a simplification of the action of a lawful near-litter action on a litter in the context of Constructive Ordinal Notation (ConNF). It states that the action of a near-litter approximation (which is constructed by completing a near-litter action on a finite path from a type to the base type) on a litter is equal to the action of a partial permutation on the set of litters. This theorem is important because it helps in understanding the relationship between the abstract actions of the near-litter approximation and the concrete actions of the partial permutation.", "formal_statement": "@[simp]example [ConNF.Params ] (\u03c6 : ConNF.NearLitterAction) [ConNF.Level] [ConNF.FOAAssumptions] {\u03b2 : ConNF.\u039b} {A : ConNF.ExtendedIndex \u2191\u03b2} {h\u03c6 : ConNF.NearLitterAction.Lawful \u03c6} (L : ConNF.Litter) :ConNF.NearLitterAction.complete \u03c6 h\u03c6 A \u2022 L = (ConNF.NearLitterAction.flexibleLitterPartialPerm \u03c6 h\u03c6 A).toFun L := by sorry", "full_tactic_state": "inst\u271d\u00b2 : ConNF.Params\n\u03c6 : ConNF.NearLitterAction\ninst\u271d\u00b9 : ConNF.Level\ninst\u271d : ConNF.FOAAssumptions\n\u03b2 : ConNF.\u039b\nA : ConNF.ExtendedIndex \u2191\u03b2\nh\u03c6 : ConNF.NearLitterAction.Lawful \u03c6\nL : ConNF.Litter\n\u22a2 ConNF.NearLitterAction.complete \u03c6 h\u03c6 A \u2022 L = (ConNF.NearLitterAction.flexibleLitterPartialPerm \u03c6 h\u03c6 A).toFun L", "dependency": [1, 61, 825, 1177, 1150]}, "ConNF.NearLitterAction.smul_atom_eq": {"natural_language_statement": "The theorem `ConNF.NearLitterAction.smul_atom_eq` in Lean 4 is a statement about a lawful near-litter action `\u03c6` in the context of Constructive Ordinal Notation (ConNF). It states that if `\u03c6` is lawful and `\u03c0` is a near-litter permutation that exactly approximates the near-litter action `complete \u03c6 h\u03c6 A` where `A` is a finite path from a type `\u03b2` to the base type `\u22a5`, then for any atom `a` in the domain of `\u03c6.atomMap`, the action of `\u03c0` on `a` is equal to the value obtained by applying `\u03c6.atomMap` to `a`. This means that the action of the near-litter permutation on atoms is consistent with the action defined by the near-litter action.", "formal_statement": "example [ConNF.Params ] (\u03c6 : ConNF.NearLitterAction) [ConNF.Level] [ConNF.FOAAssumptions] {\u03b2 : ConNF.\u039b} {A : ConNF.ExtendedIndex \u2191\u03b2} {h\u03c6 : ConNF.NearLitterAction.Lawful \u03c6} {\u03c0 : ConNF.NearLitterPerm} (h\u03c0 : ConNF.NearLitterApprox.ExactlyApproximates (ConNF.NearLitterAction.complete \u03c6 h\u03c6 A) \u03c0) {a : ConNF.Atom} (ha : (\u03c6.atomMap a).Dom) :\u03c0 \u2022 a = (\u03c6.atomMap a).get ha := by sorry", "full_tactic_state": "inst\u271d\u00b2 : ConNF.Params\n\u03c6 : ConNF.NearLitterAction\ninst\u271d\u00b9 : ConNF.Level\ninst\u271d : ConNF.FOAAssumptions\n\u03b2 : ConNF.\u039b\nA : ConNF.ExtendedIndex \u2191\u03b2\nh\u03c6 : ConNF.NearLitterAction.Lawful \u03c6\n\u03c0 : ConNF.NearLitterPerm\nh\u03c0 : ConNF.NearLitterApprox.ExactlyApproximates (ConNF.NearLitterAction.complete \u03c6 h\u03c6 A) \u03c0\na : ConNF.Atom\nha : (\u03c6.atomMap a).Dom\n\u22a2 \u03c0 \u2022 a = (\u03c6.atomMap a).get ha", "dependency": [1, 61, 825, 1180, 1177]}, "ConNF.NearLitterAction.smul_toNearLitter_eq_of_preciseAt": {"natural_language_statement": "In the context of Constructive Ordinal Notation (ConNF), given a lawful near-litter action `\u03c6`, a finite path `A` from a type `\u03b2` to the base type `\u22a5`, and a near-litter approximation `\u03c0` that exactly approximates `\u03c6` along `A`, if `\u03c6` is precise at a litter `L` in its domain, and `\u03c0` acts on `L` in the same way as `\u03c6` does, then `\u03c0` acts on the near-litter corresponding to `L` in the same way as `\u03c6` does.", "formal_statement": "example [ConNF.Params ] (\u03c6 : ConNF.NearLitterAction) [ConNF.Level] [ConNF.FOAAssumptions] {\u03b2 : ConNF.\u039b} {A : ConNF.ExtendedIndex \u2191\u03b2} {h\u03c6 : ConNF.NearLitterAction.Lawful \u03c6} {\u03c0 : ConNF.NearLitterPerm} (h\u03c0 : ConNF.NearLitterApprox.ExactlyApproximates (ConNF.NearLitterAction.complete \u03c6 h\u03c6 A) \u03c0) {L : ConNF.Litter} (hL : (\u03c6.litterMap L).Dom) (h\u03c6L : ConNF.NearLitterAction.PreciseAt \u03c6 hL) (h\u03c0L : \u03c0 \u2022 L = ((\u03c6.litterMap L).get hL).fst) :\u03c0 \u2022 ConNF.Litter.toNearLitter L = (\u03c6.litterMap L).get hL := by sorry", "full_tactic_state": "inst\u271d\u00b2 : ConNF.Params\n\u03c6 : ConNF.NearLitterAction\ninst\u271d\u00b9 : ConNF.Level\ninst\u271d : ConNF.FOAAssumptions\n\u03b2 : ConNF.\u039b\nA : ConNF.ExtendedIndex \u2191\u03b2\nh\u03c6 : ConNF.NearLitterAction.Lawful \u03c6\n\u03c0 : ConNF.NearLitterPerm\nh\u03c0 : ConNF.NearLitterApprox.ExactlyApproximates (ConNF.NearLitterAction.complete \u03c6 h\u03c6 A) \u03c0\nL : ConNF.Litter\nhL : (\u03c6.litterMap L).Dom\nh\u03c6L : ConNF.NearLitterAction.PreciseAt \u03c6 hL\nh\u03c0L : \u03c0 \u2022 L = ((\u03c6.litterMap L).get hL).fst\n\u22a2 \u03c0 \u2022 ConNF.Litter.toNearLitter L = (\u03c6.litterMap L).get hL", "dependency": [1, 61, 825, 1180, 1177, 1141, 483]}, "ConNF.NearLitterAction.preimageLitter_not_banned": {"natural_language_statement": "The theorem `ConNF.NearLitterAction.preimageLitter_not_banned` states that for any `ConNF.NearLitterAction` object `\u03c6`, the `ConNF.NearLitterAction.preimageLitter` of `\u03c6` is not a `ConNF.NearLitterAction.BannedLitter`. This means that the litter returned by the `preimageLitter` method is not a litter that is not allowed to be used as a sandbox because it appears somewhere that we need to preserve.", "formal_statement": "example [ConNF.Params ] (\u03c6 : ConNF.NearLitterAction) :\u00ac ConNF.NearLitterAction.BannedLitter \u03c6 (ConNF.NearLitterAction.preimageLitter \u03c6) := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03c6 : ConNF.NearLitterAction\n\u22a2 \u00acConNF.NearLitterAction.BannedLitter \u03c6 (ConNF.NearLitterAction.preimageLitter \u03c6)", "dependency": [1, 1065, 1184]}, "ConNF.NearLitterAction.withoutPreimage_iff": {"natural_language_statement": "In the context of Constructive Ordinal Notation (ConNF), an atom is called \"without preimage\" if it is not in the range of the approximation, but it is in a litter near some near-litter in the range. Atoms without preimage need to have something map to it, so that the resulting map that we use in the freedom of action theorem actually maps to the correct near-litter. The theorem `ConNF.NearLitterAction.withoutPreimage_iff` states that an atom is without preimage if and only if there exists a litter `L` such that the first projection of `a` is equal to `L`, and `a` is not in the range of the atom map.", "formal_statement": "example [ConNF.Params ] (\u03c6 : ConNF.NearLitterAction) (a : ConNF.Atom) :ConNF.NearLitterAction.WithoutPreimage \u03c6 a \u2194 (\u2203 (L : ConNF.Litter) (hL : (\u03c6.litterMap L).Dom), a \u2208 ConNF.litterSet ((\u03c6.litterMap L).get hL).fst) \u2227 (\u2200 (L : ConNF.Litter) (hL : (\u03c6.litterMap L).Dom), a \u2209 (\u03c6.litterMap L).get hL) \u2227 a \u2209 PFun.ran \u03c6.atomMap := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03c6 : ConNF.NearLitterAction\na : ConNF.Atom\n\u22a2 ConNF.NearLitterAction.WithoutPreimage \u03c6 a \u2194\n    (\u2203 L, \u2203 (hL : (\u03c6.litterMap L).Dom), a \u2208 ConNF.litterSet ((\u03c6.litterMap L).get hL).fst) \u2227\n      (\u2200 (L : ConNF.Litter) (hL : (\u03c6.litterMap L).Dom), a \u2209 (\u03c6.litterMap L).get hL) \u2227 a \u2209 PFun.ran \u03c6.atomMap", "dependency": [1, 1186, 467, 824]}, "ConNF.NearLitterAction.withoutPreimage_small": {"natural_language_statement": "In the context of Constructive Ordinal Notation (ConNF), the theorem `ConNF.NearLitterAction.withoutPreimage_small` states that the set of \"without preimage\" atoms, which are atoms that are not in the range of the approximation but are in a litter near some near-litter in the range, has a cardinality that is strictly less than the cardinality of the type `ConNF.\u03ba`.", "formal_statement": "example [ConNF.Params ] (\u03c6 : ConNF.NearLitterAction) :ConNF.Small {a : ConNF.Atom | ConNF.NearLitterAction.WithoutPreimage \u03c6 a} := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03c6 : ConNF.NearLitterAction\n\u22a2 ConNF.Small {a | ConNF.NearLitterAction.WithoutPreimage \u03c6 a}", "dependency": [1, 233, 1186]}, "ConNF.NearLitterAction.preimageLitterSubset_spec": {"natural_language_statement": "Function `ConNF.NearLitterAction.preimageLitterSubset` is a subset of the preimage litter that is put in correspondence with the set of atoms without preimage in the context of Constructive Ordinal Notation. The theorem `ConNF.NearLitterAction.preimageLitterSubset_spec` states that this subset is a subset of the litter set corresponding to the preimage litter and has the same cardinality as the set of atoms without preimage.", "formal_statement": "example [ConNF.Params ] (\u03c6 : ConNF.NearLitterAction) :ConNF.NearLitterAction.preimageLitterSubset \u03c6 \u2286 ConNF.litterSet (ConNF.NearLitterAction.preimageLitter \u03c6) \u2227 Cardinal.mk \u2191(ConNF.NearLitterAction.preimageLitterSubset \u03c6) = Cardinal.mk \u2191{a : ConNF.Atom | ConNF.NearLitterAction.WithoutPreimage \u03c6 a} := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03c6 : ConNF.NearLitterAction\n\u22a2 ConNF.NearLitterAction.preimageLitterSubset \u03c6 \u2286 ConNF.litterSet (ConNF.NearLitterAction.preimageLitter \u03c6) \u2227\n    Cardinal.mk \u2191(ConNF.NearLitterAction.preimageLitterSubset \u03c6) =\n      Cardinal.mk \u2191{a | ConNF.NearLitterAction.WithoutPreimage \u03c6 a}", "dependency": [1, 1189, 467, 1184, 29, 1189, 29, 1186]}, "ConNF.NearLitterAction.preimageLitterSubset_subset": {"natural_language_statement": "Function `ConNF.NearLitterAction.preimageLitterSubset` is a subset of the preimage litter that is put in correspondence with the set of atoms without preimage in the context of Constructive Ordinal Notation. The theorem `ConNF.NearLitterAction.preimageLitterSubset_subset` states that this subset is a subset of the litter set corresponding to the preimage litter.", "formal_statement": "example [ConNF.Params ] (\u03c6 : ConNF.NearLitterAction) :ConNF.NearLitterAction.preimageLitterSubset \u03c6 \u2286 ConNF.litterSet (ConNF.NearLitterAction.preimageLitter \u03c6) := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03c6 : ConNF.NearLitterAction\n\u22a2 ConNF.NearLitterAction.preimageLitterSubset \u03c6 \u2286 ConNF.litterSet (ConNF.NearLitterAction.preimageLitter \u03c6)", "dependency": [1, 1189, 467, 1184]}, "ConNF.NearLitterAction.preimageLitterSubset_small": {"natural_language_statement": "Function `ConNF.NearLitterAction.preimageLitterSubset_small` proves that the subset of the preimage litter that is put in correspondence with the set of atoms without preimage in the context of Constructive Ordinal Notation has a cardinality strictly less than the cardinality of the type `ConNF.\u03ba`.", "formal_statement": "example [ConNF.Params ] (\u03c6 : ConNF.NearLitterAction) :ConNF.Small (ConNF.NearLitterAction.preimageLitterSubset \u03c6) := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03c6 : ConNF.NearLitterAction\n\u22a2 ConNF.Small (ConNF.NearLitterAction.preimageLitterSubset \u03c6)", "dependency": [1, 233, 1189]}, "ConNF.NearLitterAction.mappedOutside_iff": {"natural_language_statement": "The theorem `ConNF.NearLitterAction.mappedOutside_iff` provides a criterion for determining whether an atom is \"mapped outside\" a litter in the context of Constructive Ordinal Notation (ConNF). Specifically, it states that an atom `a` is mapped outside a litter `L` if and only if `a` is an image of an atom in `L` under the partial function `\u03c6.litterMap L`, but `a` is not in the domain of `\u03c6.litterMap L`, and `a` is not in the range of `\u03c6.atomMap`. This condition is crucial to ensure the correctness of the ConNF construction.", "formal_statement": "example [ConNF.Params ] (\u03c6 : ConNF.NearLitterAction) (L : ConNF.Litter) (hL : (\u03c6.litterMap L).Dom) (a : ConNF.Atom) :ConNF.NearLitterAction.MappedOutside \u03c6 L hL a \u2194 a \u2208 (\u03c6.litterMap L).get hL \u2227 a \u2209 ConNF.litterSet ((\u03c6.litterMap L).get hL).fst \u2227 a \u2209 PFun.ran \u03c6.atomMap := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03c6 : ConNF.NearLitterAction\nL : ConNF.Litter\nhL : (\u03c6.litterMap L).Dom\na : ConNF.Atom\n\u22a2 ConNF.NearLitterAction.MappedOutside \u03c6 L hL a \u2194\n    a \u2208 (\u03c6.litterMap L).get hL \u2227 a \u2209 ConNF.litterSet ((\u03c6.litterMap L).get hL).fst \u2227 a \u2209 PFun.ran \u03c6.atomMap", "dependency": [1, 1193, 467, 824]}, "ConNF.NearLitterAction.mappedOutside_small": {"natural_language_statement": "The theorem `ConNF.NearLitterAction.mappedOutside_small` states that in the context of Constructive Ordinal Notation (ConNF), there are only `< \u03ba`-many atoms in a litter `L` that are mapped outside the image litter, and that are not already in the domain. This result is crucial for ensuring the correctness of the construction of ordinals in ConNF.", "formal_statement": "example [ConNF.Params ] (\u03c6 : ConNF.NearLitterAction) (L : ConNF.Litter) (hL : (\u03c6.litterMap L).Dom) :ConNF.Small {a : ConNF.Atom | ConNF.NearLitterAction.MappedOutside \u03c6 L hL a} := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03c6 : ConNF.NearLitterAction\nL : ConNF.Litter\nhL : (\u03c6.litterMap L).Dom\n\u22a2 ConNF.Small {a | ConNF.NearLitterAction.MappedOutside \u03c6 L hL a}", "dependency": [1, 233, 1193]}, "ConNF.NearLitterAction.WithoutPreimage.not_mappedOutside": {"natural_language_statement": "The theorem `ConNF.NearLitterAction.WithoutPreimage.not_mappedOutside` states that if an atom `a` is \"without preimage\" under a partial function `\u03c6.litterMap L`, then `a` is not an image of any atom in the litter `L` under `\u03c6.litterMap L`. This is a key property used in the ConNF (Constructive Ordinal Notation) project to ensure the correctness of the construction of ordinals.", "formal_statement": "example [ConNF.Params ] (\u03c6 : ConNF.NearLitterAction) {a : ConNF.Atom} (ha : ConNF.NearLitterAction.WithoutPreimage \u03c6 a) (L : ConNF.Litter) (hL : (\u03c6.litterMap L).Dom) :\u00ac ConNF.NearLitterAction.MappedOutside \u03c6 L hL a := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03c6 : ConNF.NearLitterAction\na : ConNF.Atom\nha : ConNF.NearLitterAction.WithoutPreimage \u03c6 a\nL : ConNF.Litter\nhL : (\u03c6.litterMap L).Dom\n\u22a2 \u00acConNF.NearLitterAction.MappedOutside \u03c6 L hL a", "dependency": [1, 1186, 1193]}, "ConNF.NearLitterAction.MappedOutside.not_withoutPreimage": {"natural_language_statement": "The theorem `ConNF.NearLitterAction.MappedOutside.not_withoutPreimage` in the context of Constructive Ordinal Notation (ConNF) states that if an atom `a` is an image of an atom in a litter `L` under a partial function `\u03c6.litterMap L`, but `a` is not in the domain of `\u03c6.litterMap L`, and `a` is not in the range of `\u03c6.atomMap`, then `a` cannot be \"without preimage\". This means that `a` must have something that maps to it in order to satisfy the condition for the Freedom of Action theorem.", "formal_statement": "example [ConNF.Params ] (\u03c6 : ConNF.NearLitterAction) {a : ConNF.Atom} {L : ConNF.Litter} {hL : (\u03c6.litterMap L).Dom} (ha : ConNF.NearLitterAction.MappedOutside \u03c6 L hL a) :\u00ac ConNF.NearLitterAction.WithoutPreimage \u03c6 a := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03c6 : ConNF.NearLitterAction\na : ConNF.Atom\nL : ConNF.Litter\nhL : (\u03c6.litterMap L).Dom\nha : ConNF.NearLitterAction.MappedOutside \u03c6 L hL a\n\u22a2 \u00acConNF.NearLitterAction.WithoutPreimage \u03c6 a", "dependency": [1, 1193, 1186]}, "ConNF.NearLitterAction.mk_mapped_outside_domain": {"natural_language_statement": "The theorem `ConNF.NearLitterAction.mk_mapped_outside_domain` states that the cardinality of the set of atoms in a litter `L` that are not in the domain of the partial function `\u03c6.atomMap` is equal to the cardinality of the type `\u03ba`.", "formal_statement": "example [ConNF.Params ] (\u03c6 : ConNF.NearLitterAction) (L : ConNF.Litter) :Cardinal.mk \u2191(ConNF.litterSet L \\ PFun.Dom \u03c6.atomMap) = Cardinal.mk ConNF.\u03ba := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03c6 : ConNF.NearLitterAction\nL : ConNF.Litter\n\u22a2 Cardinal.mk \u2191(ConNF.litterSet L \\ PFun.Dom \u03c6.atomMap) = Cardinal.mk ConNF.\u03ba", "dependency": [1, 29, 467, 404, 29]}, "ConNF.NearLitterAction.mappedOutsideSubset_spec": {"natural_language_statement": "Function `ConNF.NearLitterAction.mappedOutsideSubset` defines a subset of atoms that are mapped outside a given litter `L`, under the condition that `L` is within the domain of the litter map `\u03c6.litterMap L`. The theorem `ConNF.NearLitterAction.mappedOutsideSubset_spec` states that this subset is a subset of the litter set `ConNF.litterSet L` minus the domain of the atom map `\u03c6.atomMap`, and that the cardinality of this subset is equal to the cardinality of the set of atoms that satisfy the condition `ConNF.NearLitterAction.MappedOutside`.", "formal_statement": "example [ConNF.Params ] (\u03c6 : ConNF.NearLitterAction) (L : ConNF.Litter) (hL : (\u03c6.litterMap L).Dom) :ConNF.NearLitterAction.mappedOutsideSubset \u03c6 L hL \u2286 ConNF.litterSet L \\ PFun.Dom \u03c6.atomMap \u2227 Cardinal.mk \u2191(ConNF.NearLitterAction.mappedOutsideSubset \u03c6 L hL) = Cardinal.mk \u2191{a : ConNF.Atom | ConNF.NearLitterAction.MappedOutside \u03c6 L hL a} := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03c6 : ConNF.NearLitterAction\nL : ConNF.Litter\nhL : (\u03c6.litterMap L).Dom\n\u22a2 ConNF.NearLitterAction.mappedOutsideSubset \u03c6 L hL \u2286 ConNF.litterSet L \\ PFun.Dom \u03c6.atomMap \u2227\n    Cardinal.mk \u2191(ConNF.NearLitterAction.mappedOutsideSubset \u03c6 L hL) =\n      Cardinal.mk \u2191{a | ConNF.NearLitterAction.MappedOutside \u03c6 L hL a}", "dependency": [1, 1199, 467, 404, 29, 1199, 29, 1193]}, "ConNF.NearLitterAction.mappedOutsideSubset_subset": {"natural_language_statement": "The theorem `ConNF.NearLitterAction.mappedOutsideSubset_subset` states that the subset of atoms that are mapped outside a given litter `L`, under the condition that `L` is within the domain of the litter map `\u03c6.litterMap L`, is a subset of the set corresponding to `L`.", "formal_statement": "example [ConNF.Params ] (\u03c6 : ConNF.NearLitterAction) (L : ConNF.Litter) (hL : (\u03c6.litterMap L).Dom) :ConNF.NearLitterAction.mappedOutsideSubset \u03c6 L hL \u2286 ConNF.litterSet L := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03c6 : ConNF.NearLitterAction\nL : ConNF.Litter\nhL : (\u03c6.litterMap L).Dom\n\u22a2 ConNF.NearLitterAction.mappedOutsideSubset \u03c6 L hL \u2286 ConNF.litterSet L", "dependency": [1, 1199, 467]}, "ConNF.NearLitterAction.mappedOutsideSubset_closure": {"natural_language_statement": "The theorem `ConNF.NearLitterAction.mappedOutsideSubset_closure` states that the set of atoms that are mapped outside a given litter `L`, under the condition that `L` is within the domain of the litter map `\u03c6.litterMap L`, is a subset of the complement of the domain of the atom map `\u03c6.atomMap`.", "formal_statement": "example [ConNF.Params ] (\u03c6 : ConNF.NearLitterAction) (L : ConNF.Litter) (hL : (\u03c6.litterMap L).Dom) :ConNF.NearLitterAction.mappedOutsideSubset \u03c6 L hL \u2286 (PFun.Dom \u03c6.atomMap)\u1d9c := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03c6 : ConNF.NearLitterAction\nL : ConNF.Litter\nhL : (\u03c6.litterMap L).Dom\n\u22a2 ConNF.NearLitterAction.mappedOutsideSubset \u03c6 L hL \u2286 (PFun.Dom \u03c6.atomMap)\u1d9c", "dependency": [1, 1199, 404]}, "ConNF.NearLitterAction.mappedOutsideSubset_small": {"natural_language_statement": "The theorem `ConNF.NearLitterAction.mappedOutsideSubset_small` states that the set of atoms that are mapped outside a given litter `L`, under the condition that `L` is within the domain of the litter map `\u03c6.litterMap L`, has a cardinality strictly less than the cardinality of the type `ConNF.\u03ba` in the context of Constructive Ordinal Notation (ConNF).", "formal_statement": "example [ConNF.Params ] (\u03c6 : ConNF.NearLitterAction) (L : ConNF.Litter) (hL : (\u03c6.litterMap L).Dom) :ConNF.Small (ConNF.NearLitterAction.mappedOutsideSubset \u03c6 L hL) := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03c6 : ConNF.NearLitterAction\nL : ConNF.Litter\nhL : (\u03c6.litterMap L).Dom\n\u22a2 ConNF.Small (ConNF.NearLitterAction.mappedOutsideSubset \u03c6 L hL)", "dependency": [1, 233, 1199]}, "ConNF.NearLitterAction.mem_supportedActionAtomMapCore_dom_iff": {"natural_language_statement": "The theorem `ConNF.NearLitterAction.mem_supportedActionAtomMapCore_dom_iff` states that an atom `a` is in the domain of the partial function `ConNF.NearLitterAction.supportedActionAtomMapCore \u03c6 a` if and only if `a` is in the union of three sets: the domain of the atom map `\u03c6.atomMap`, the preimage litter subset `ConNF.NearLitterAction.preimageLitterSubset \u03c6`, and the union of the mapped outside subsets `ConNF.NearLitterAction.mappedOutsideSubset \u03c6 L hL` for all litters `L` within the domain of the litter map `\u03c6.litterMap L`.", "formal_statement": "example [ConNF.Params ] (\u03c6 : ConNF.NearLitterAction) (a : ConNF.Atom) :(ConNF.NearLitterAction.supportedActionAtomMapCore \u03c6 a).Dom \u2194 a \u2208 PFun.Dom \u03c6.atomMap \u222a ConNF.NearLitterAction.preimageLitterSubset \u03c6 \u222a \u22c3 (L : ConNF.Litter), \u22c3 (hL : (\u03c6.litterMap L).Dom), ConNF.NearLitterAction.mappedOutsideSubset \u03c6 L hL := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03c6 : ConNF.NearLitterAction\na : ConNF.Atom\n\u22a2 (ConNF.NearLitterAction.supportedActionAtomMapCore \u03c6 a).Dom \u2194\n    a \u2208\n      PFun.Dom \u03c6.atomMap \u222a ConNF.NearLitterAction.preimageLitterSubset \u03c6 \u222a\n        \u22c3 L, \u22c3 (hL : (\u03c6.litterMap L).Dom), ConNF.NearLitterAction.mappedOutsideSubset \u03c6 L hL", "dependency": [1, 1204, 404, 1189, 1199]}, "ConNF.NearLitterAction.supportedActionAtomMapCore_dom_eq": {"natural_language_statement": "The theorem `ConNF.NearLitterAction.supportedActionAtomMapCore_dom_eq` states that the domain of the partial function `ConNF.NearLitterAction.supportedActionAtomMapCore` is equal to the union of three sets: the domain of the partial function `\u03c6.atomMap`, the set `ConNF.NearLitterAction.preimageLitterSubset`, and the union of the sets `ConNF.NearLitterAction.mappedOutsideSubset` over all litters `L` in the domain of the litter map `\u03c6.litterMap L`.", "formal_statement": "example [ConNF.Params ] (\u03c6 : ConNF.NearLitterAction) :PFun.Dom (ConNF.NearLitterAction.supportedActionAtomMapCore \u03c6) = PFun.Dom \u03c6.atomMap \u222a ConNF.NearLitterAction.preimageLitterSubset \u03c6 \u222a \u22c3 (L : ConNF.Litter), \u22c3 (hL : (\u03c6.litterMap L).Dom), ConNF.NearLitterAction.mappedOutsideSubset \u03c6 L hL := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03c6 : ConNF.NearLitterAction\n\u22a2 PFun.Dom (ConNF.NearLitterAction.supportedActionAtomMapCore \u03c6) =\n    PFun.Dom \u03c6.atomMap \u222a ConNF.NearLitterAction.preimageLitterSubset \u03c6 \u222a\n      \u22c3 L, \u22c3 (hL : (\u03c6.litterMap L).Dom), ConNF.NearLitterAction.mappedOutsideSubset \u03c6 L hL", "dependency": [1, 404, 1204, 404, 1189, 1199]}, "ConNF.NearLitterAction.supportedActionAtomMapCore_dom_small": {"natural_language_statement": "The theorem `ConNF.NearLitterAction.supportedActionAtomMapCore_dom_small` states that the domain of the partial function `ConNF.NearLitterAction.supportedActionAtomMapCore`, which is used in the construction of the natural numbers in the context of Constructive Ordinal Notation (ConNF), is a small set in the sense that its cardinality is strictly less than the cardinality of the type `ConNF.\u03ba`.", "formal_statement": "example [ConNF.Params ] (\u03c6 : ConNF.NearLitterAction) :ConNF.Small (PFun.Dom (ConNF.NearLitterAction.supportedActionAtomMapCore \u03c6)) := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03c6 : ConNF.NearLitterAction\n\u22a2 ConNF.Small (PFun.Dom (ConNF.NearLitterAction.supportedActionAtomMapCore \u03c6))", "dependency": [1, 233, 404, 1204]}, "ConNF.NearLitterAction.supportedActionAtomMapCore_injective": {"natural_language_statement": "The theorem `ConNF.NearLitterAction.supportedActionAtomMapCore_injective` states that the partial function `ConNF.NearLitterAction.supportedActionAtomMapCore` is injective. This function is part of the `ConNF.Params` class, which defines a set of parameters that are used in the construction of the natural numbers in the context of Constructive Ordinal Notation (ConNF). These parameters include the types `\u039b`, `\u03ba`, and `\u03bc`, along with various properties and relationships between these types, such as linear orders, well-orders, zero elements, successor orders, and subtraction operations. Additionally, there are conditions on the cardinalities of these types and their cofinalities.", "formal_statement": "example [ConNF.Params ] (\u03c6 : ConNF.NearLitterAction) \u2983a : ConNF.Atom\u2984 \u2983b : ConNF.Atom\u2984 (h\u03c6 : ConNF.NearLitterAction.Lawful \u03c6) (ha : (ConNF.NearLitterAction.supportedActionAtomMapCore \u03c6 a).Dom) (hb : (ConNF.NearLitterAction.supportedActionAtomMapCore \u03c6 b).Dom) (hab : (ConNF.NearLitterAction.supportedActionAtomMapCore \u03c6 a).get ha = (ConNF.NearLitterAction.supportedActionAtomMapCore \u03c6 b).get hb) :a = b := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03c6 : ConNF.NearLitterAction\na b : ConNF.Atom\nh\u03c6 : ConNF.NearLitterAction.Lawful \u03c6\nha : (ConNF.NearLitterAction.supportedActionAtomMapCore \u03c6 a).Dom\nhb : (ConNF.NearLitterAction.supportedActionAtomMapCore \u03c6 b).Dom\nhab :\n  (ConNF.NearLitterAction.supportedActionAtomMapCore \u03c6 a).get ha =\n    (ConNF.NearLitterAction.supportedActionAtomMapCore \u03c6 b).get hb\n\u22a2 a = b", "dependency": [1, 825, 1204, 1204, 1204, 1204]}, "ConNF.NearLitterAction.supportedActionAtomMapCore_mem": {"natural_language_statement": "The theorem `ConNF.NearLitterAction.supportedActionAtomMapCore_mem` is a statement about the constructible ordinal notation (ConNF) in Lean 4. It describes a property of the function `ConNF.NearLitterAction.supportedActionAtomMapCore`, which is a partial function from `ConNF.Atom` to `ConNF.Atom`. The theorem states that, given a near litter action `\u03c6` and an atom `a` with a certain property, if `a` is in the litter `L`, then the output of the `supportedActionAtomMapCore` function on `a` is in the near litter `\u03c6.litterMap L`. This property is crucial for ensuring that the natural numbers constructed in ConNF are well-defined and follow the rules of the notation.", "formal_statement": "example [ConNF.Params ] (\u03c6 : ConNF.NearLitterAction) (h\u03c6 : ConNF.NearLitterAction.Lawful \u03c6) (a : ConNF.Atom) (ha : (ConNF.NearLitterAction.supportedActionAtomMapCore \u03c6 a).Dom) (L : ConNF.Litter) (hL : (\u03c6.litterMap L).Dom) :a.1 = L \u2194 (ConNF.NearLitterAction.supportedActionAtomMapCore \u03c6 a).get ha \u2208 (\u03c6.litterMap L).get hL := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03c6 : ConNF.NearLitterAction\nh\u03c6 : ConNF.NearLitterAction.Lawful \u03c6\na : ConNF.Atom\nha : (ConNF.NearLitterAction.supportedActionAtomMapCore \u03c6 a).Dom\nL : ConNF.Litter\nhL : (\u03c6.litterMap L).Dom\n\u22a2 a.1 = L \u2194 (ConNF.NearLitterAction.supportedActionAtomMapCore \u03c6 a).get ha \u2208 (\u03c6.litterMap L).get hL", "dependency": [1, 825, 1204, 1204]}, "ConNF.NearLitterAction.fillAtomRangeLawful": {"natural_language_statement": "`ConNF.NearLitterAction.fillAtomRange \u03c6` returns a new `ConNF.NearLitterAction`, adjusted to have a small domain for the `atomMap`, and the resulting action is lawful. This theorem ensures that the adjusted action still satisfies the conditions for being lawful, meaning that the atom and litter maps are injective and the images of atoms in litters are mapped to atoms inside the corresponding near-litters.", "formal_statement": "example [ConNF.Params ] (\u03c6 : ConNF.NearLitterAction) (h\u03c6 : ConNF.NearLitterAction.Lawful \u03c6) :ConNF.NearLitterAction.Lawful (ConNF.NearLitterAction.fillAtomRange \u03c6) := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03c6 : ConNF.NearLitterAction\nh\u03c6 : ConNF.NearLitterAction.Lawful \u03c6\n\u22a2 ConNF.NearLitterAction.Lawful (ConNF.NearLitterAction.fillAtomRange \u03c6)", "dependency": [1, 825, 825, 1210]}, "ConNF.NearLitterAction.fillAtomRange_atomMap": {"natural_language_statement": "The `ConNF.NearLitterAction.fillAtomRange_atomMap` theorem states that the `atomMap` of the `ConNF.NearLitterAction` object returned by the `ConNF.NearLitterAction.fillAtomRange` function is equal to the `ConNF.NearLitterAction.supportedActionAtomMapCore` function.", "formal_statement": "@[simp]example [ConNF.Params ] {\u03c6 : ConNF.NearLitterAction} :(ConNF.NearLitterAction.fillAtomRange \u03c6).atomMap = ConNF.NearLitterAction.supportedActionAtomMapCore \u03c6 := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03c6 : ConNF.NearLitterAction\n\u22a2 (ConNF.NearLitterAction.fillAtomRange \u03c6).atomMap = ConNF.NearLitterAction.supportedActionAtomMapCore \u03c6", "dependency": [1, 1210, 1204]}, "ConNF.NearLitterAction.fillAtomRange_litterMap": {"natural_language_statement": "Function `ConNF.NearLitterAction.fillAtomRange` is a noncomputable function that takes a `ConNF.NearLitterAction` object `\u03c6` and returns a new `ConNF.NearLitterAction` object. The returned object has the same `litterMap` as `\u03c6`, but its `atomMap` is adjusted to ensure that the domain of `atomMap` is small. This adjustment is necessary because the domain of `atomMap` in `\u03c6` might not be small, which is a requirement for `ConNF.NearLitterAction`. The theorem `ConNF.NearLitterAction.fillAtomRange_litterMap` states that the `litterMap` of the returned object is equal to the `litterMap` of the original object `\u03c6`.", "formal_statement": "@[simp]example [ConNF.Params ] {\u03c6 : ConNF.NearLitterAction} :(ConNF.NearLitterAction.fillAtomRange \u03c6).litterMap = \u03c6.litterMap := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03c6 : ConNF.NearLitterAction\n\u22a2 (ConNF.NearLitterAction.fillAtomRange \u03c6).litterMap = \u03c6.litterMap", "dependency": [1, 1210]}, "ConNF.NearLitterAction.subset_supportedActionAtomMapCore_dom": {"natural_language_statement": "The theorem `ConNF.NearLitterAction.subset_supportedActionAtomMapCore_dom` states that the domain of the partial function `\u03c6.atomMap` is a subset of the domain of the partial function `ConNF.NearLitterAction.supportedActionAtomMapCore \u03c6`. This theorem is part of the `ConNF.Params` class, which defines a set of parameters that are used in the construction of the natural numbers in the context of Constructive Ordinal Notation (ConNF). These parameters include the types `\u039b`, `\u03ba`, and `\u03bc`, along with various properties and relationships between these types, such as linear orders, well-orders, zero elements, successor orders, and subtraction operations. Additionally, there are conditions on the cardinalities of these types and their cofinalities.", "formal_statement": "example [ConNF.Params ] {\u03c6 : ConNF.NearLitterAction} :PFun.Dom \u03c6.atomMap \u2286 PFun.Dom (ConNF.NearLitterAction.supportedActionAtomMapCore \u03c6) := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03c6 : ConNF.NearLitterAction\n\u22a2 PFun.Dom \u03c6.atomMap \u2286 PFun.Dom (ConNF.NearLitterAction.supportedActionAtomMapCore \u03c6)", "dependency": [1, 404, 404, 1204]}, "ConNF.NearLitterAction.subset_supportedActionAtomMapCore_ran": {"natural_language_statement": "The theorem `ConNF.NearLitterAction.subset_supportedActionAtomMapCore_ran` states that the range of the partial function `\u03c6.atomMap` is a subset of the range of the partial function `ConNF.NearLitterAction.supportedActionAtomMapCore \u03c6`. This theorem is part of the `ConNF.Params` class, which defines a set of parameters that are used in the construction of the natural numbers in the context of Constructive Ordinal Notation (ConNF). These parameters include the types `\u039b`, `\u03ba`, and `\u03bc`, along with various properties and relationships between these types, such as linear orders, well-orders, zero elements, successor orders, and subtraction operations. Additionally, there are conditions on the cardinalities of these types and their cofinalities.", "formal_statement": "example [ConNF.Params ] {\u03c6 : ConNF.NearLitterAction} :PFun.ran \u03c6.atomMap \u2286 PFun.ran (ConNF.NearLitterAction.supportedActionAtomMapCore \u03c6) := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03c6 : ConNF.NearLitterAction\n\u22a2 PFun.ran \u03c6.atomMap \u2286 PFun.ran (ConNF.NearLitterAction.supportedActionAtomMapCore \u03c6)", "dependency": [1, 824, 824, 1204]}, "ConNF.NearLitterAction.fillAtomRange_symmDiff_subset_ran": {"natural_language_statement": "The theorem `ConNF.NearLitterAction.fillAtomRange_symmDiff_subset_ran` is a part of the Constructive Ordinal Notation (ConNF) project in Lean 4. It states that for a lawful near litter action `\u03c6`, the symmetric difference between the set of atoms in a litter `L` and the litter set corresponding to `L` is a subset of the range of the atom map of the filled atom range of `\u03c6`.", "formal_statement": "example [ConNF.Params ] {\u03c6 : ConNF.NearLitterAction} (h\u03c6 : ConNF.NearLitterAction.Lawful \u03c6) (L : ConNF.Litter) (hL : ((ConNF.NearLitterAction.fillAtomRange \u03c6).litterMap L).Dom) :symmDiff (\u2191(((ConNF.NearLitterAction.fillAtomRange \u03c6).litterMap L).get hL)) (ConNF.litterSet (((ConNF.NearLitterAction.fillAtomRange \u03c6).litterMap L).get hL).fst) \u2286 PFun.ran (ConNF.NearLitterAction.fillAtomRange \u03c6).atomMap := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03c6 : ConNF.NearLitterAction\nh\u03c6 : ConNF.NearLitterAction.Lawful \u03c6\nL : ConNF.Litter\nhL : ((ConNF.NearLitterAction.fillAtomRange \u03c6).litterMap L).Dom\n\u22a2 symmDiff (\u2191(((ConNF.NearLitterAction.fillAtomRange \u03c6).litterMap L).get hL))\n      (ConNF.litterSet (((ConNF.NearLitterAction.fillAtomRange \u03c6).litterMap L).get hL).fst) \u2286\n    PFun.ran (ConNF.NearLitterAction.fillAtomRange \u03c6).atomMap", "dependency": [1, 825, 1210, 62, 1210, 467, 1210, 824, 1210]}, "ConNF.NearLitterApprox.ext": {"natural_language_statement": "The `ConNF.NearLitterApprox.ext` theorem states that two `ConNF.NearLitterApprox` objects are equal if their `atomPerm` and `litterPerm` fields are equal.", "formal_statement": "example :\u2200 {inst : ConNF.Params } (x y : ConNF.NearLitterApprox), x.atomPerm = y.atomPerm \u2192 x.litterPerm = y.litterPerm \u2192 x = y := by sorry", "full_tactic_state": "\u22a2 \u2200 {inst : ConNF.Params} (x y : ConNF.NearLitterApprox), x.atomPerm = y.atomPerm \u2192 x.litterPerm = y.litterPerm \u2192 x = y", "dependency": [1]}, "ConNF.NearLitterApprox.ext_iff": {"natural_language_statement": "The `ConNF.NearLitterApprox.ext_iff` theorem states that two `ConNF.NearLitterApprox` objects are equal if and only if their `atomPerm` and `litterPerm` fields are equal.", "formal_statement": "example :\u2200 {inst : ConNF.Params } (x y : ConNF.NearLitterApprox), x = y \u2194 x.atomPerm = y.atomPerm \u2227 x.litterPerm = y.litterPerm := by sorry", "full_tactic_state": "\u22a2 \u2200 {inst : ConNF.Params} (x y : ConNF.NearLitterApprox), x = y \u2194 x.atomPerm = y.atomPerm \u2227 x.litterPerm = y.litterPerm", "dependency": [1]}, "ConNF.NearLitterApprox.smul_atom_eq": {"natural_language_statement": "The theorem `ConNF.NearLitterApprox.smul_atom_eq` states that for any `ConNF.NearLitterApprox` object `\u03c0` and any `ConNF.Atom` object `a`, the function `\u03c0.atomPerm.toFun` applied to `a` is equal to the action of `\u03c0` on `a`, denoted as `\u03c0 \u2022 a`.", "formal_statement": "example [ConNF.Params ] (\u03c0 : ConNF.NearLitterApprox) {a : ConNF.Atom} :\u03c0.atomPerm.toFun a = \u03c0 \u2022 a := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03c0 : ConNF.NearLitterApprox\na : ConNF.Atom\n\u22a2 \u03c0.atomPerm.toFun a = \u03c0 \u2022 a", "dependency": [1]}, "ConNF.NearLitterApprox.smul_litter_eq": {"natural_language_statement": "The theorem `ConNF.NearLitterApprox.smul_litter_eq` states that for any `ConNF.NearLitterApprox` object `\u03c0` and a `ConNF.Litter` object `L`, the permutation action of `\u03c0` on `L` (denoted as `\u03c0.litterPerm.toFun L`) is equal to the scalar multiplication of `\u03c0` with `L` (denoted as `\u03c0 \u2022 L`).", "formal_statement": "example [ConNF.Params ] (\u03c0 : ConNF.NearLitterApprox) {L : ConNF.Litter} :\u03c0.litterPerm.toFun L = \u03c0 \u2022 L := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03c0 : ConNF.NearLitterApprox\nL : ConNF.Litter\n\u22a2 \u03c0.litterPerm.toFun L = \u03c0 \u2022 L", "dependency": [1]}, "ConNF.NearLitterApprox.smul_eq_smul_atom": {"natural_language_statement": "The theorem `ConNF.NearLitterApprox.smul_eq_smul_atom` states that for any two atoms `a\u2081` and `a\u2082` in the domain of a near litter approximation `\u03c0`, `\u03c0 \u2022 a\u2081 = \u03c0 \u2022 a\u2082` if and only if `a\u2081 = a\u2082`.", "formal_statement": "example [ConNF.Params ] (\u03c0 : ConNF.NearLitterApprox) {a\u2081 : ConNF.Atom} {a\u2082 : ConNF.Atom} (h\u2081 : a\u2081 \u2208 \u03c0.atomPerm.domain) (h\u2082 : a\u2082 \u2208 \u03c0.atomPerm.domain) :\u03c0 \u2022 a\u2081 = \u03c0 \u2022 a\u2082 \u2194 a\u2081 = a\u2082 := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03c0 : ConNF.NearLitterApprox\na\u2081 a\u2082 : ConNF.Atom\nh\u2081 : a\u2081 \u2208 \u03c0.atomPerm.domain\nh\u2082 : a\u2082 \u2208 \u03c0.atomPerm.domain\n\u22a2 \u03c0 \u2022 a\u2081 = \u03c0 \u2022 a\u2082 \u2194 a\u2081 = a\u2082", "dependency": [1]}, "ConNF.NearLitterApprox.smul_eq_smul_litter": {"natural_language_statement": "The theorem `ConNF.NearLitterApprox.smul_eq_smul_litter` states that for any two litters `L\u2081` and `L\u2082` in the domain of a near litter approximation `\u03c0`, `\u03c0 \u2022 L\u2081 = \u03c0 \u2022 L\u2082` if and only if `L\u2081 = L\u2082`.", "formal_statement": "example [ConNF.Params ] (\u03c0 : ConNF.NearLitterApprox) {L\u2081 : ConNF.Litter} {L\u2082 : ConNF.Litter} (h\u2081 : L\u2081 \u2208 \u03c0.litterPerm.domain) (h\u2082 : L\u2082 \u2208 \u03c0.litterPerm.domain) :\u03c0 \u2022 L\u2081 = \u03c0 \u2022 L\u2082 \u2194 L\u2081 = L\u2082 := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03c0 : ConNF.NearLitterApprox\nL\u2081 L\u2082 : ConNF.Litter\nh\u2081 : L\u2081 \u2208 \u03c0.litterPerm.domain\nh\u2082 : L\u2082 \u2208 \u03c0.litterPerm.domain\n\u22a2 \u03c0 \u2022 L\u2081 = \u03c0 \u2022 L\u2082 \u2194 L\u2081 = L\u2082", "dependency": [1]}, "ConNF.NearLitterApprox.symm_atomPerm": {"natural_language_statement": "The theorem `ConNF.NearLitterApprox.symm_atomPerm` states that the `atomPerm` component of the symmetric of a `ConNF.NearLitterApprox` object `\u03c0` is equal to the inverse of the `atomPerm` component of `\u03c0`.", "formal_statement": "@[simp]example [ConNF.Params ] (\u03c0 : ConNF.NearLitterApprox) :(ConNF.NearLitterApprox.symm \u03c0).atomPerm = PartialPerm.symm \u03c0.atomPerm := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03c0 : ConNF.NearLitterApprox\n\u22a2 (ConNF.NearLitterApprox.symm \u03c0).atomPerm = PartialPerm.symm \u03c0.atomPerm", "dependency": [1, 1223, 644]}, "ConNF.NearLitterApprox.symm_litterPerm": {"natural_language_statement": "The theorem `ConNF.NearLitterApprox.symm_litterPerm` states that the `litterPerm` component of the symmetric of a `ConNF.NearLitterApprox` object `\u03c0` is equal to the inverse of the `litterPerm` component of `\u03c0`.", "formal_statement": "@[simp]example [ConNF.Params ] (\u03c0 : ConNF.NearLitterApprox) :(ConNF.NearLitterApprox.symm \u03c0).litterPerm = PartialPerm.symm \u03c0.litterPerm := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03c0 : ConNF.NearLitterApprox\n\u22a2 (ConNF.NearLitterApprox.symm \u03c0).litterPerm = PartialPerm.symm \u03c0.litterPerm", "dependency": [1, 1223, 644]}, "ConNF.NearLitterApprox.left_inv_atom": {"natural_language_statement": "The theorem `ConNF.NearLitterApprox.left_inv_atom` states that for any `ConNF.NearLitterApprox` object `\u03c0`, if an `ConNF.Atom` `a` is in the domain of `\u03c0.atomPerm`, then applying `ConNF.NearLitterApprox.symm \u03c0` followed by `\u03c0` to `a` results in `a` itself. This theorem is a part of the proof that `ConNF.NearLitterApprox` forms a group action on `ConNF.Atom`.", "formal_statement": "@[simp]example [ConNF.Params ] (\u03c0 : ConNF.NearLitterApprox) {a : ConNF.Atom} :a \u2208 \u03c0.atomPerm.domain \u2192 ConNF.NearLitterApprox.symm \u03c0 \u2022 \u03c0 \u2022 a = a := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03c0 : ConNF.NearLitterApprox\na : ConNF.Atom\n\u22a2 a \u2208 \u03c0.atomPerm.domain \u2192 ConNF.NearLitterApprox.symm \u03c0 \u2022 \u03c0 \u2022 a = a", "dependency": [1, 1223]}, "ConNF.NearLitterApprox.left_inv_litter": {"natural_language_statement": "The theorem `ConNF.NearLitterApprox.left_inv_litter` states that for any `ConNF.NearLitterApprox` object `\u03c0` and a `ConNF.Litter` object `L`, if `L` is in the domain of the `litterPerm` component of `\u03c0`, then applying `ConNF.NearLitterApprox.symm \u03c0` followed by `\u03c0` to `L` results in `L` itself.", "formal_statement": "@[simp]example [ConNF.Params ] (\u03c0 : ConNF.NearLitterApprox) {L : ConNF.Litter} :L \u2208 \u03c0.litterPerm.domain \u2192 ConNF.NearLitterApprox.symm \u03c0 \u2022 \u03c0 \u2022 L = L := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03c0 : ConNF.NearLitterApprox\nL : ConNF.Litter\n\u22a2 L \u2208 \u03c0.litterPerm.domain \u2192 ConNF.NearLitterApprox.symm \u03c0 \u2022 \u03c0 \u2022 L = L", "dependency": [1, 1223]}, "ConNF.NearLitterApprox.right_inv_atom": {"natural_language_statement": "The theorem `ConNF.NearLitterApprox.right_inv_atom` states that for any `ConNF.NearLitterApprox` object `\u03c0` and any `ConNF.Atom` `a` that is in the domain of `\u03c0.atomPerm`, applying `\u03c0` and then its symmetric counterpart `ConNF.NearLitterApprox.symm \u03c0` to `a` results in `a` itself. This property is crucial for establishing that `ConNF.NearLitterApprox` objects form a group action on `ConNF.Atom`s.", "formal_statement": "@[simp]example [ConNF.Params ] (\u03c0 : ConNF.NearLitterApprox) {a : ConNF.Atom} :a \u2208 \u03c0.atomPerm.domain \u2192 \u03c0 \u2022 ConNF.NearLitterApprox.symm \u03c0 \u2022 a = a := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03c0 : ConNF.NearLitterApprox\na : ConNF.Atom\n\u22a2 a \u2208 \u03c0.atomPerm.domain \u2192 \u03c0 \u2022 ConNF.NearLitterApprox.symm \u03c0 \u2022 a = a", "dependency": [1, 1223]}, "ConNF.NearLitterApprox.right_inv_litter": {"natural_language_statement": "The theorem `ConNF.NearLitterApprox.right_inv_litter` states that for any `ConNF.NearLitterApprox` object `\u03c0` and any `ConNF.Litter` object `L`, if `L` is in the domain of `\u03c0.litterPerm`, then `\u03c0 \u2022 ConNF.NearLitterApprox.symm \u03c0 \u2022 L = L`. This means that applying `\u03c0` and then its symmetric counterpart `ConNF.NearLitterApprox.symm \u03c0` to `L` results in `L` itself.", "formal_statement": "@[simp]example [ConNF.Params ] (\u03c0 : ConNF.NearLitterApprox) {L : ConNF.Litter} :L \u2208 \u03c0.litterPerm.domain \u2192 \u03c0 \u2022 ConNF.NearLitterApprox.symm \u03c0 \u2022 L = L := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03c0 : ConNF.NearLitterApprox\nL : ConNF.Litter\n\u22a2 L \u2208 \u03c0.litterPerm.domain \u2192 \u03c0 \u2022 ConNF.NearLitterApprox.symm \u03c0 \u2022 L = L", "dependency": [1, 1223]}, "ConNF.NearLitterApprox.symm_smul_atom_eq_iff": {"natural_language_statement": "Given a `ConNF.NearLitterApprox` object `\u03c0`, this theorem states that for any two `ConNF.Atom`s `a` and `b` in the domain of `\u03c0.atomPerm`, `a = \u03c0 \u2022 b` if and only if `ConNF.NearLitterApprox.symm \u03c0 \u2022 a = b`. This theorem is used to relate actions of the `ConNF.NearLitterApprox` object `\u03c0` and its symmetric counterpart `ConNF.NearLitterApprox.symm \u03c0`.", "formal_statement": "example [ConNF.Params ] (\u03c0 : ConNF.NearLitterApprox) {a : ConNF.Atom} {b : ConNF.Atom} :a \u2208 \u03c0.atomPerm.domain \u2192 b \u2208 \u03c0.atomPerm.domain \u2192 (ConNF.NearLitterApprox.symm \u03c0 \u2022 a = b \u2194 a = \u03c0 \u2022 b) := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03c0 : ConNF.NearLitterApprox\na b : ConNF.Atom\n\u22a2 a \u2208 \u03c0.atomPerm.domain \u2192 b \u2208 \u03c0.atomPerm.domain \u2192 (ConNF.NearLitterApprox.symm \u03c0 \u2022 a = b \u2194 a = \u03c0 \u2022 b)", "dependency": [1, 1223]}, "ConNF.NearLitterApprox.symm_smul_litter_eq_iff": {"natural_language_statement": "The theorem `ConNF.NearLitterApprox.symm_smul_litter_eq_iff` states that for a `ConNF.NearLitterApprox` object `\u03c0` and two litters `L\u2081` and `L\u2082`, if `L\u2081` and `L\u2082` are both in the domain of `\u03c0.litterPerm`, then `ConNF.NearLitterApprox.symm \u03c0 \u2022 L\u2081 = L\u2082` if and only if `L\u2081 = \u03c0 \u2022 L\u2082`.", "formal_statement": "example [ConNF.Params ] (\u03c0 : ConNF.NearLitterApprox) {L\u2081 : ConNF.Litter} {L\u2082 : ConNF.Litter} :L\u2081 \u2208 \u03c0.litterPerm.domain \u2192 L\u2082 \u2208 \u03c0.litterPerm.domain \u2192 (ConNF.NearLitterApprox.symm \u03c0 \u2022 L\u2081 = L\u2082 \u2194 L\u2081 = \u03c0 \u2022 L\u2082) := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03c0 : ConNF.NearLitterApprox\nL\u2081 L\u2082 : ConNF.Litter\n\u22a2 L\u2081 \u2208 \u03c0.litterPerm.domain \u2192 L\u2082 \u2208 \u03c0.litterPerm.domain \u2192 (ConNF.NearLitterApprox.symm \u03c0 \u2022 L\u2081 = L\u2082 \u2194 L\u2081 = \u03c0 \u2022 L\u2082)", "dependency": [1, 1223]}, "ConNF.NearLitterApprox.eq_symm_apply_atom": {"natural_language_statement": "Function `ConNF.NearLitterApprox.symm` is a method that takes a `ConNF.NearLitterApprox` object `\u03c0` and returns a new `ConNF.NearLitterApprox` object, where the `atomPerm` and `litterPerm` components of `\u03c0` are replaced by their symmetric counterparts. The `domain_small` component remains unchanged. The theorem `ConNF.NearLitterApprox.eq_symm_apply_atom` states that for any two atoms `a\u2081` and `a\u2082` in the domain of `\u03c0.atomPerm`, `a\u2081` is equal to `ConNF.NearLitterApprox.symm \u03c0 \u2022 a\u2082` if and only if `\u03c0 \u2022 a\u2081` is equal to `a\u2082`.", "formal_statement": "example [ConNF.Params ] (\u03c0 : ConNF.NearLitterApprox) {a\u2081 : ConNF.Atom} {a\u2082 : ConNF.Atom} :a\u2081 \u2208 \u03c0.atomPerm.domain \u2192 a\u2082 \u2208 \u03c0.atomPerm.domain \u2192 (a\u2081 = ConNF.NearLitterApprox.symm \u03c0 \u2022 a\u2082 \u2194 \u03c0 \u2022 a\u2081 = a\u2082) := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03c0 : ConNF.NearLitterApprox\na\u2081 a\u2082 : ConNF.Atom\n\u22a2 a\u2081 \u2208 \u03c0.atomPerm.domain \u2192 a\u2082 \u2208 \u03c0.atomPerm.domain \u2192 (a\u2081 = ConNF.NearLitterApprox.symm \u03c0 \u2022 a\u2082 \u2194 \u03c0 \u2022 a\u2081 = a\u2082)", "dependency": [1, 1223]}, "ConNF.NearLitterApprox.eq_symm_apply_litter": {"natural_language_statement": "Function `ConNF.NearLitterApprox.symm` is a method that takes a `ConNF.NearLitterApprox` object `\u03c0` and returns a new `ConNF.NearLitterApprox` object, where the `atomPerm` and `litterPerm` components of `\u03c0` are replaced by their symmetric counterparts. The `domain_small` component remains unchanged. The theorem `ConNF.NearLitterApprox.eq_symm_apply_litter` states that for any two litters `L\u2081` and `L\u2082` in the domain of `\u03c0.litterPerm`, `L\u2081` equals `ConNF.NearLitterApprox.symm \u03c0 \u2022 L\u2082` if and only if `\u03c0 \u2022 L\u2081` equals `L\u2082`.", "formal_statement": "example [ConNF.Params ] (\u03c0 : ConNF.NearLitterApprox) {L\u2081 : ConNF.Litter} {L\u2082 : ConNF.Litter} :L\u2081 \u2208 \u03c0.litterPerm.domain \u2192 L\u2082 \u2208 \u03c0.litterPerm.domain \u2192 (L\u2081 = ConNF.NearLitterApprox.symm \u03c0 \u2022 L\u2082 \u2194 \u03c0 \u2022 L\u2081 = L\u2082) := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03c0 : ConNF.NearLitterApprox\nL\u2081 L\u2082 : ConNF.Litter\n\u22a2 L\u2081 \u2208 \u03c0.litterPerm.domain \u2192 L\u2082 \u2208 \u03c0.litterPerm.domain \u2192 (L\u2081 = ConNF.NearLitterApprox.symm \u03c0 \u2022 L\u2082 \u2194 \u03c0 \u2022 L\u2081 = L\u2082)", "dependency": [1, 1223]}, "ConNF.NearLitterApprox.nearLitter_domain_small": {"natural_language_statement": "In the context of Constructive Ordinal Notation (ConNF), the theorem `ConNF.NearLitterApprox.nearLitter_domain_small` states that the intersection of a near-litter `N` and the domain of a near-litter approximation `\u03c0` is a small set, meaning its cardinality is strictly less than the cardinality of the type `ConNF.\u03ba`.", "formal_statement": "example [ConNF.Params ] (\u03c0 : ConNF.NearLitterApprox) (N : ConNF.NearLitter) :ConNF.Small (\u2191N \u2229 \u03c0.atomPerm.domain) := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03c0 : ConNF.NearLitterApprox\nN : ConNF.NearLitter\n\u22a2 ConNF.Small (\u2191N \u2229 \u03c0.atomPerm.domain)", "dependency": [1, 233]}, "ConNF.NearLitterApprox.largestSublitter_litter": {"natural_language_statement": "The function `ConNF.NearLitterApprox.largestSublitter` returns the largest sublitter of `\u03c0` on which `\u03c0.atom_perm` is not defined. The theorem `ConNF.NearLitterApprox.largestSublitter_litter` states that the litter of the largest sublitter of `\u03c0` is equal to `L`.", "formal_statement": "@[simp]example [ConNF.Params ] (\u03c0 : ConNF.NearLitterApprox) (L : ConNF.Litter) :(ConNF.NearLitterApprox.largestSublitter \u03c0 L).litter = L := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03c0 : ConNF.NearLitterApprox\nL : ConNF.Litter\n\u22a2 (ConNF.NearLitterApprox.largestSublitter \u03c0 L).litter = L", "dependency": [1, 1235]}, "ConNF.NearLitterApprox.coe_largestSublitter": {"natural_language_statement": "The theorem `ConNF.NearLitterApprox.coe_largestSublitter` states that the largest sublitter of `\u03c0` on which `\u03c0.atom_perm` is not defined is equal to the set of all atoms `a` such that the first projection of `a` is equal to `L`, minus the domain of `\u03c0.atom_perm`.", "formal_statement": "@[simp]example [ConNF.Params ] (\u03c0 : ConNF.NearLitterApprox) (L : ConNF.Litter) :\u2191(ConNF.NearLitterApprox.largestSublitter \u03c0 L) = ConNF.litterSet L \\ \u03c0.atomPerm.domain := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03c0 : ConNF.NearLitterApprox\nL : ConNF.Litter\n\u22a2 \u2191(ConNF.NearLitterApprox.largestSublitter \u03c0 L) = ConNF.litterSet L \\ \u03c0.atomPerm.domain", "dependency": [1, 1235, 467]}, "ConNF.NearLitterApprox.mem_largestSublitter_of_not_mem_domain": {"natural_language_statement": "Given a `ConNF.NearLitterApprox` object `\u03c0` and an `ConNF.Atom` object `a`, if `a` is not in the domain of `\u03c0.atomPerm`, then `a` is in the largest sublitter of `\u03c0` on which `\u03c0.atom_perm` is not defined.", "formal_statement": "example [ConNF.Params ] (\u03c0 : ConNF.NearLitterApprox) (a : ConNF.Atom) (h : a \u2209 \u03c0.atomPerm.domain) :a \u2208 ConNF.NearLitterApprox.largestSublitter \u03c0 a.1 := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03c0 : ConNF.NearLitterApprox\na : ConNF.Atom\nh : a \u2209 \u03c0.atomPerm.domain\n\u22a2 a \u2208 ConNF.NearLitterApprox.largestSublitter \u03c0 a.1", "dependency": [1, 1235]}, "ConNF.NearLitterApprox.not_mem_domain_of_mem_largestSublitter": {"natural_language_statement": "The theorem `ConNF.NearLitterApprox.not_mem_domain_of_mem_largestSublitter` states that if an atom `a` belongs to the largest sublitter of a near litter approximation `\u03c0` on which `\u03c0.atom_perm` is not defined, then `a` does not belong to the domain of `\u03c0.atom_perm`.", "formal_statement": "example [ConNF.Params ] (\u03c0 : ConNF.NearLitterApprox) {a : ConNF.Atom} {L : ConNF.Litter} (h : a \u2208 ConNF.NearLitterApprox.largestSublitter \u03c0 L) :a \u2209 \u03c0.atomPerm.domain := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03c0 : ConNF.NearLitterApprox\na : ConNF.Atom\nL : ConNF.Litter\nh : a \u2208 ConNF.NearLitterApprox.largestSublitter \u03c0 L\n\u22a2 a \u2209 \u03c0.atomPerm.domain", "dependency": [1, 1235]}, "ConNF.NearLitterApprox.approximates_iff": {"natural_language_statement": "`ConNF.NearLitterApprox.approximates_iff` is a theorem in the context of Constructive Ordinal Notation (ConNF), which defines a relationship between two objects of type `ConNF.NearLitterApprox` and `ConNF.NearLitterPerm`. It states that a `ConNF.NearLitterApprox` object `\u03c0\u2080` approximates a `ConNF.NearLitterPerm` object `\u03c0` if and only if for any atom `a` in the domain of `\u03c0\u2080.atomPerm`, the action of `\u03c0\u2080` on `a` is the same as the action of `\u03c0` on `a`, and for any litter `L` in the domain of `\u03c0\u2080.litterPerm`, the action of `\u03c0\u2080` on `L` is the same as the action of `\u03c0` on `L`.", "formal_statement": "example [ConNF.Params ] (\u03c0\u2080 : ConNF.NearLitterApprox) (\u03c0 : ConNF.NearLitterPerm) :ConNF.NearLitterApprox.Approximates \u03c0\u2080 \u03c0 \u2194 (\u2200 a \u2208 \u03c0\u2080.atomPerm.domain, \u03c0\u2080 \u2022 a = \u03c0 \u2022 a) \u2227 \u2200 L \u2208 \u03c0\u2080.litterPerm.domain, \u03c0\u2080 \u2022 L = \u03c0 \u2022 L := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03c0\u2080 : ConNF.NearLitterApprox\n\u03c0 : ConNF.NearLitterPerm\n\u22a2 ConNF.NearLitterApprox.Approximates \u03c0\u2080 \u03c0 \u2194\n    (\u2200 a \u2208 \u03c0\u2080.atomPerm.domain, \u03c0\u2080 \u2022 a = \u03c0 \u2022 a) \u2227 \u2200 L \u2208 \u03c0\u2080.litterPerm.domain, \u03c0\u2080 \u2022 L = \u03c0 \u2022 L", "dependency": [1, 1181]}, "ConNF.NearLitterApprox.Approximates.symm_map_atom": {"natural_language_statement": "The theorem states that for any `ConNF.NearLitterApprox` object `\u03c0\u2080`, any `ConNF.NearLitterPerm` object `\u03c0`, and an `ConNF.Atom` `a` that is in the domain of `\u03c0\u2080.atomPerm`, the symmetric action of `\u03c0\u2080` on `a` is equal to the inverse action of `\u03c0` on `a`. This is proven under the assumption that `\u03c0\u2080` approximates `\u03c0` in the sense defined by the `ConNF.NearLitterApprox.Approximates` structure.", "formal_statement": "example [ConNF.Params ] {\u03c0\u2080 : ConNF.NearLitterApprox} {\u03c0 : ConNF.NearLitterPerm} (h\u03c0 : ConNF.NearLitterApprox.Approximates \u03c0\u2080 \u03c0) (a : ConNF.Atom) (ha : a \u2208 \u03c0\u2080.atomPerm.domain) :ConNF.NearLitterApprox.symm \u03c0\u2080 \u2022 a = \u03c0\u207b\u00b9 \u2022 a := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03c0\u2080 : ConNF.NearLitterApprox\n\u03c0 : ConNF.NearLitterPerm\nh\u03c0 : ConNF.NearLitterApprox.Approximates \u03c0\u2080 \u03c0\na : ConNF.Atom\nha : a \u2208 \u03c0\u2080.atomPerm.domain\n\u22a2 ConNF.NearLitterApprox.symm \u03c0\u2080 \u2022 a = \u03c0\u207b\u00b9 \u2022 a", "dependency": [1, 1181, 1223]}, "ConNF.NearLitterApprox.Approximates.symm_map_litter": {"natural_language_statement": "`ConNF.NearLitterApprox.Approximates.symm_map_litter` is a theorem in the `ConNF` library, which is a part of the `mathlib` library for formalizing Constructive Ordinal Notation (ConNF) in the Lean 4 proof assistant. This theorem states that if `\u03c0\u2080` is an approximation of `\u03c0` (in the sense defined by the `ConNF.NearLitterApprox.Approximates` structure), then the symmetric version of `\u03c0\u2080` (obtained by taking the symmetric permutation of both the `atomPerm` and `litterPerm` components) applied to a litter `L` in the domain of `\u03c0\u2080` is the same as the inverse of `\u03c0` applied to `L`.", "formal_statement": "example [ConNF.Params ] {\u03c0\u2080 : ConNF.NearLitterApprox} {\u03c0 : ConNF.NearLitterPerm} (h\u03c0 : ConNF.NearLitterApprox.Approximates \u03c0\u2080 \u03c0) (L : ConNF.Litter) (hL : L \u2208 \u03c0\u2080.litterPerm.domain) :ConNF.NearLitterApprox.symm \u03c0\u2080 \u2022 L = \u03c0\u207b\u00b9 \u2022 L := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03c0\u2080 : ConNF.NearLitterApprox\n\u03c0 : ConNF.NearLitterPerm\nh\u03c0 : ConNF.NearLitterApprox.Approximates \u03c0\u2080 \u03c0\nL : ConNF.Litter\nhL : L \u2208 \u03c0\u2080.litterPerm.domain\n\u22a2 ConNF.NearLitterApprox.symm \u03c0\u2080 \u2022 L = \u03c0\u207b\u00b9 \u2022 L", "dependency": [1, 1181, 1223]}, "ConNF.NearLitterApprox.exactlyApproximates_iff": {"natural_language_statement": "The theorem `ConNF.NearLitterApprox.exactlyApproximates_iff` states that a near litter approximation `\u03c0\u2080` exactly approximates a near litter permutation `\u03c0` if and only if `\u03c0\u2080` approximates `\u03c0` in the sense that their actions on atoms and litters are consistent, and for any atom `a`, if `\u03c0` is an exception with respect to `a`, then `a` must be in the domain of `\u03c0\u2080.atomPerm`.", "formal_statement": "example [ConNF.Params ] (\u03c0\u2080 : ConNF.NearLitterApprox) (\u03c0 : ConNF.NearLitterPerm) :ConNF.NearLitterApprox.ExactlyApproximates \u03c0\u2080 \u03c0 \u2194 ConNF.NearLitterApprox.Approximates \u03c0\u2080 \u03c0 \u2227 \u2200 (a : ConNF.Atom), ConNF.NearLitterPerm.IsException \u03c0 a \u2192 a \u2208 \u03c0\u2080.atomPerm.domain := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03c0\u2080 : ConNF.NearLitterApprox\n\u03c0 : ConNF.NearLitterPerm\n\u22a2 ConNF.NearLitterApprox.ExactlyApproximates \u03c0\u2080 \u03c0 \u2194\n    ConNF.NearLitterApprox.Approximates \u03c0\u2080 \u03c0 \u2227\n      \u2200 (a : ConNF.Atom), ConNF.NearLitterPerm.IsException \u03c0 a \u2192 a \u2208 \u03c0\u2080.atomPerm.domain", "dependency": [1, 1180, 1181, 801]}, "ConNF.NearLitterApprox.ExactlyApproximates.of_isException": {"natural_language_statement": "In the context of Constructive Ordinal Notation (ConNF), `ConNF.NearLitterApprox.ExactlyApproximates.of_isException` is a theorem that proves a property of near liter `ConNF.NearLitterApprox` objects. It states that if `\u03c0` is an exception with respect to an atom `a`, and `\u03c0\u2080` exactly approximates `\u03c0`, then either `\u03c0\u2080 \u2022 a` is not in the litter set corresponding to `\u03c0\u2080 \u2022 a.1`, or `ConNF.NearLitterApprox.symm \u03c0\u2080 \u2022 a` is not in the litter set corresponding to `ConNF.NearLitterApprox.symm \u03c0\u2080 \u2022 a.1`. This theorem is crucial in the construction of `ConNF`, as it helps to determine the behavior of approximations when they are exceptions.", "formal_statement": "example [ConNF.Params ] {\u03c0\u2080 : ConNF.NearLitterApprox} {\u03c0 : ConNF.NearLitterPerm} (h\u03c0 : ConNF.NearLitterApprox.ExactlyApproximates \u03c0\u2080 \u03c0) (a : ConNF.Atom) (ha : a.1 \u2208 \u03c0\u2080.litterPerm.domain) :ConNF.NearLitterPerm.IsException \u03c0 a \u2192 \u03c0\u2080 \u2022 a \u2209 ConNF.litterSet (\u03c0\u2080 \u2022 a.1) \u2228 ConNF.NearLitterApprox.symm \u03c0\u2080 \u2022 a \u2209 ConNF.litterSet (ConNF.NearLitterApprox.symm \u03c0\u2080 \u2022 a.1) := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03c0\u2080 : ConNF.NearLitterApprox\n\u03c0 : ConNF.NearLitterPerm\nh\u03c0 : ConNF.NearLitterApprox.ExactlyApproximates \u03c0\u2080 \u03c0\na : ConNF.Atom\nha : a.1 \u2208 \u03c0\u2080.litterPerm.domain\n\u22a2 ConNF.NearLitterPerm.IsException \u03c0 a \u2192\n    \u03c0\u2080 \u2022 a \u2209 ConNF.litterSet (\u03c0\u2080 \u2022 a.1) \u2228\n      ConNF.NearLitterApprox.symm \u03c0\u2080 \u2022 a \u2209 ConNF.litterSet (ConNF.NearLitterApprox.symm \u03c0\u2080 \u2022 a.1)", "dependency": [1, 1180, 801, 467, 1223, 467, 1223]}, "ConNF.NearLitterApprox.ExactlyApproximates.mem_litterSet": {"natural_language_statement": "The theorem `ConNF.NearLitterApprox.ExactlyApproximates.mem_litterSet` in the context of Constructive Ordinal Notation (ConNF) states that if `\u03c0\u2080` exactly approximates `\u03c0`, and `a` is an atom not in the domain of `\u03c0\u2080.atomPerm`, then the action of `\u03c0` on `a` results in an element of the litter set corresponding to the first projection of `\u03c0 \u2022 a`.", "formal_statement": "example [ConNF.Params ] {\u03c0\u2080 : ConNF.NearLitterApprox} {\u03c0 : ConNF.NearLitterPerm} (h\u03c0 : ConNF.NearLitterApprox.ExactlyApproximates \u03c0\u2080 \u03c0) (a : ConNF.Atom) (ha : a \u2209 \u03c0\u2080.atomPerm.domain) :\u03c0 \u2022 a \u2208 ConNF.litterSet (\u03c0 \u2022 a.1) := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03c0\u2080 : ConNF.NearLitterApprox\n\u03c0 : ConNF.NearLitterPerm\nh\u03c0 : ConNF.NearLitterApprox.ExactlyApproximates \u03c0\u2080 \u03c0\na : ConNF.Atom\nha : a \u2209 \u03c0\u2080.atomPerm.domain\n\u22a2 \u03c0 \u2022 a \u2208 ConNF.litterSet (\u03c0 \u2022 a.1)", "dependency": [1, 1180, 467]}, "ConNF.NearLitterApprox.ExactlyApproximates.mem_litterSet_inv": {"natural_language_statement": "This theorem states that if `\u03c0` is an exactly approximating permutation that does not map an atom `a` to itself, then the inverse permutation `\u03c0\u207b\u00b9` applied to `a` results in an atom that is an element of the litter set corresponding to the litter `\u03c0\u207b\u00b9 \u2022 a.1`.", "formal_statement": "example [ConNF.Params ] {\u03c0\u2080 : ConNF.NearLitterApprox} {\u03c0 : ConNF.NearLitterPerm} (h\u03c0 : ConNF.NearLitterApprox.ExactlyApproximates \u03c0\u2080 \u03c0) (a : ConNF.Atom) (ha : a \u2209 \u03c0\u2080.atomPerm.domain) :\u03c0\u207b\u00b9 \u2022 a \u2208 ConNF.litterSet (\u03c0\u207b\u00b9 \u2022 a.1) := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03c0\u2080 : ConNF.NearLitterApprox\n\u03c0 : ConNF.NearLitterPerm\nh\u03c0 : ConNF.NearLitterApprox.ExactlyApproximates \u03c0\u2080 \u03c0\na : ConNF.Atom\nha : a \u2209 \u03c0\u2080.atomPerm.domain\n\u22a2 \u03c0\u207b\u00b9 \u2022 a \u2208 ConNF.litterSet (\u03c0\u207b\u00b9 \u2022 a.1)", "dependency": [1, 1180, 467]}, "ConNF.StructApprox.Approximates.comp": {"natural_language_statement": "Function `ConNF.StructApprox.Approximates.comp` proves that if a `\u03b2`-structural approximation `\u03c0\u2080` approximates a `\u03b2`-structural permutation `\u03c0`, then for any path `A` from type index `\u03b2` to type index `\u03b3`, the `\u03b3`-structural approximation obtained by composing `\u03c0\u2080` with `A` approximates the `\u03b3`-structural permutation obtained by composing `\u03c0` with `A`.", "formal_statement": "example [ConNF.Params ] {\u03b2 : ConNF.TypeIndex} {\u03b3 : ConNF.TypeIndex} {\u03c0\u2080 : ConNF.StructApprox \u03b2} {\u03c0 : ConNF.StructPerm \u03b2} (h : ConNF.StructApprox.Approximates \u03c0\u2080 \u03c0) (A : Quiver.Path \u03b2 \u03b3) :ConNF.StructApprox.Approximates (ConNF.Tree.comp A \u03c0\u2080) (ConNF.Tree.comp A \u03c0) := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03b2 \u03b3 : ConNF.TypeIndex\n\u03c0\u2080 : ConNF.StructApprox \u03b2\n\u03c0 : ConNF.StructPerm \u03b2\nh : ConNF.StructApprox.Approximates \u03c0\u2080 \u03c0\nA : Quiver.Path \u03b2 \u03b3\n\u22a2 ConNF.StructApprox.Approximates (ConNF.Tree.comp A \u03c0\u2080) (ConNF.Tree.comp A \u03c0)", "dependency": [1, 781, 55, 1247, 76, 1247, 304, 304]}, "ConNF.StructApprox.ExactlyApproximates.comp": {"natural_language_statement": "Function `ConNF.StructApprox.ExactlyApproximates.comp` proves that if a `\u03b2`-structural approximation `\u03c0\u2080` exactly approximates a `\u03b2`-structural permutation `\u03c0`, then for any path `A` from type index `\u03b2` to type index `\u03b3`, the `\u03b3`-structural approximation `ConNF.Tree.comp A \u03c0\u2080` exactly approximates the `\u03b3`-structural permutation `ConNF.Tree.comp A \u03c0`.", "formal_statement": "example [ConNF.Params ] {\u03b2 : ConNF.TypeIndex} {\u03b3 : ConNF.TypeIndex} {\u03c0\u2080 : ConNF.StructApprox \u03b2} {\u03c0 : ConNF.StructPerm \u03b2} (h : ConNF.StructApprox.ExactlyApproximates \u03c0\u2080 \u03c0) (A : Quiver.Path \u03b2 \u03b3) :ConNF.StructApprox.ExactlyApproximates (ConNF.Tree.comp A \u03c0\u2080) (ConNF.Tree.comp A \u03c0) := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03b2 \u03b3 : ConNF.TypeIndex\n\u03c0\u2080 : ConNF.StructApprox \u03b2\n\u03c0 : ConNF.StructPerm \u03b2\nh : ConNF.StructApprox.ExactlyApproximates \u03c0\u2080 \u03c0\nA : Quiver.Path \u03b2 \u03b3\n\u22a2 ConNF.StructApprox.ExactlyApproximates (ConNF.Tree.comp A \u03c0\u2080) (ConNF.Tree.comp A \u03c0)", "dependency": [1, 781, 55, 803, 76, 803, 304, 304]}, "ConNF.StructBehaviour.withLitters_lawful": {"natural_language_statement": "The theorem `ConNF.StructBehaviour.withLitters_lawful` states that if `\u03be` is a lawful `\u03b2`-structural action, then the `\u03b2`-structural action obtained by replacing each near-litter action in `\u03be` with its lawful version is also lawful.", "formal_statement": "example [ConNF.Params ] {\u03b2 : ConNF.TypeIndex} (\u03be : ConNF.StructBehaviour \u03b2) (h\u03be : ConNF.StructBehaviour.Lawful \u03be) :ConNF.StructBehaviour.Lawful (ConNF.StructBehaviour.withLitters \u03be h\u03be) := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03b2 : ConNF.TypeIndex\n\u03be : ConNF.StructBehaviour \u03b2\nh\u03be : ConNF.StructBehaviour.Lawful \u03be\n\u22a2 ConNF.StructBehaviour.Lawful (ConNF.StructBehaviour.withLitters \u03be h\u03be)", "dependency": [1, 828, 829, 829, 1250]}, "ConNF.NearLitterBehaviour.ext_iff": {"natural_language_statement": "`ConNF.NearLitterBehaviour.ext_iff` is an extensionality theorem for the `ConNF.NearLitterBehaviour` structure. It states that two instances of `ConNF.NearLitterBehaviour` are equal if and only if their `atomMap` and `nearLitterMap` fields are equal.", "formal_statement": "example :\u2200 {inst : ConNF.Params } (x y : ConNF.NearLitterBehaviour), x = y \u2194 x.atomMap = y.atomMap \u2227 x.nearLitterMap = y.nearLitterMap := by sorry", "full_tactic_state": "\u22a2 \u2200 {inst : ConNF.Params} (x y : ConNF.NearLitterBehaviour),\n    x = y \u2194 x.atomMap = y.atomMap \u2227 x.nearLitterMap = y.nearLitterMap", "dependency": [1]}, "ConNF.NearLitterBehaviour.ext": {"natural_language_statement": "The `ConNF.NearLitterBehaviour.ext` theorem states that two `ConNF.NearLitterBehaviour` objects are equal if their `atomMap` and `nearLitterMap` fields are equal.", "formal_statement": "example :\u2200 {inst : ConNF.Params } (x y : ConNF.NearLitterBehaviour), x.atomMap = y.atomMap \u2192 x.nearLitterMap = y.nearLitterMap \u2192 x = y := by sorry", "full_tactic_state": "\u22a2 \u2200 {inst : ConNF.Params} (x y : ConNF.NearLitterBehaviour),\n    x.atomMap = y.atomMap \u2192 x.nearLitterMap = y.nearLitterMap \u2192 x = y", "dependency": [1]}, "ConNF.NearLitterBehaviour.map_nearLitter_fst": {"natural_language_statement": "The theorem `ConNF.NearLitterBehaviour.map_nearLitter_fst` states that for two near-litters `N\u2081` and `N\u2082`, the first component of `N\u2081` is equal to the first component of `N\u2082` if and only if the first component of the image of `N\u2081` under the near-litter map is equal to the first component of the image of `N\u2082` under the near-litter map.", "formal_statement": "example [ConNF.Params ] {\u03be : ConNF.NearLitterBehaviour} (h\u03be : ConNF.NearLitterBehaviour.Lawful \u03be) \u2983N\u2081 : ConNF.NearLitter\u2984 \u2983N\u2082 : ConNF.NearLitter\u2984 (hN\u2081 : (\u03be.nearLitterMap N\u2081).Dom) (hN\u2082 : (\u03be.nearLitterMap N\u2082).Dom) :N\u2081.fst = N\u2082.fst \u2194 ((\u03be.nearLitterMap N\u2081).get hN\u2081).fst = ((\u03be.nearLitterMap N\u2082).get hN\u2082).fst := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03be : ConNF.NearLitterBehaviour\nh\u03be : ConNF.NearLitterBehaviour.Lawful \u03be\nN\u2081 N\u2082 : ConNF.NearLitter\nhN\u2081 : (\u03be.nearLitterMap N\u2081).Dom\nhN\u2082 : (\u03be.nearLitterMap N\u2082).Dom\n\u22a2 N\u2081.fst = N\u2082.fst \u2194 ((\u03be.nearLitterMap N\u2081).get hN\u2081).fst = ((\u03be.nearLitterMap N\u2082).get hN\u2082).fst", "dependency": [1, 823]}, "ConNF.NearLitterBehaviour.extraAtoms_small": {"natural_language_statement": "The theorem `ConNF.NearLitterBehaviour.extraAtoms_small` states that for any `ConNF.NearLitterBehaviour` object `\u03be`, the cardinality of the set `ConNF.NearLitterBehaviour.extraAtoms \u03be` is strictly less than the cardinality of the type `ConNF.\u03ba` in the context of Constructive Ordinal Notation (ConNF).", "formal_statement": "example [ConNF.Params ] (\u03be : ConNF.NearLitterBehaviour) :ConNF.Small (ConNF.NearLitterBehaviour.extraAtoms \u03be) := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03be : ConNF.NearLitterBehaviour\n\u22a2 ConNF.Small (ConNF.NearLitterBehaviour.extraAtoms \u03be)", "dependency": [1, 233, 1255]}, "ConNF.NearLitterBehaviour.bannedLitter_iff": {"natural_language_statement": "In the context of Constructive Ordinal Notation (ConNF), a litter is considered \"banned\" if it is the image of an atom under the atom map, the image of a near-litter under the near-litter map, or if it is the difference of a near-litter's image under the near-litter map and its own litter set. The theorem `ConNF.NearLitterBehaviour.bannedLitter_iff` states that a litter is banned if and only if it satisfies one of these three conditions.", "formal_statement": "example [ConNF.Params ] (\u03be : ConNF.NearLitterBehaviour) :\u2200 (a : ConNF.Litter), ConNF.NearLitterBehaviour.BannedLitter \u03be a \u2194 (\u2203 (a_1 : ConNF.Atom) (h : (\u03be.atomMap a_1).Dom), a = ((\u03be.atomMap a_1).get h).1) \u2228 (\u2203 (N : ConNF.NearLitter) (h : (\u03be.nearLitterMap N).Dom), a = ((\u03be.nearLitterMap N).get h).fst) \u2228 \u2203 (N : ConNF.NearLitter) (h : (\u03be.nearLitterMap N).Dom), \u2203 a_1 \u2208 \u2191((\u03be.nearLitterMap N).get h) \\ ConNF.litterSet ((\u03be.nearLitterMap N).get h).fst, a = a_1.1 := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03be : ConNF.NearLitterBehaviour\n\u22a2 \u2200 (a : ConNF.Litter),\n    ConNF.NearLitterBehaviour.BannedLitter \u03be a \u2194\n      (\u2203 a_1, \u2203 (h : (\u03be.atomMap a_1).Dom), a = ((\u03be.atomMap a_1).get h).1) \u2228\n        (\u2203 N, \u2203 (h : (\u03be.nearLitterMap N).Dom), a = ((\u03be.nearLitterMap N).get h).fst) \u2228\n          \u2203 N,\n            \u2203 (h : (\u03be.nearLitterMap N).Dom),\n              \u2203 a_1 \u2208 \u2191((\u03be.nearLitterMap N).get h) \\ ConNF.litterSet ((\u03be.nearLitterMap N).get h).fst, a = a_1.1", "dependency": [1, 1257, 467]}, "ConNF.NearLitterBehaviour.bannedLitter_of_mem": {"natural_language_statement": "The theorem `ConNF.NearLitterBehaviour.bannedLitter_of_mem` states that if an atom `a` is a member of the image of a near-litter `N` under the near-litter map `\u03be.nearLitterMap N`, then `a` is a banned litter in the context of Constructive Ordinal Notation (ConNF).", "formal_statement": "example [ConNF.Params ] {\u03be : ConNF.NearLitterBehaviour} (a : ConNF.Atom) (N : ConNF.NearLitter) (hN : (\u03be.nearLitterMap N).Dom) (ha : a \u2208 (\u03be.nearLitterMap N).get hN) :ConNF.NearLitterBehaviour.BannedLitter \u03be a.1 := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03be : ConNF.NearLitterBehaviour\na : ConNF.Atom\nN : ConNF.NearLitter\nhN : (\u03be.nearLitterMap N).Dom\nha : a \u2208 (\u03be.nearLitterMap N).get hN\n\u22a2 ConNF.NearLitterBehaviour.BannedLitter \u03be a.1", "dependency": [1, 1257]}, "ConNF.NearLitterBehaviour.bannedLitter_small": {"natural_language_statement": "The theorem `ConNF.NearLitterBehaviour.bannedLitter_small` states that the set of litters that are considered \"banned\" in the context of Constructive Ordinal Notation (ConNF) has a cardinality that is strictly less than the cardinality of the type `ConNF.\u03ba`.", "formal_statement": "example [ConNF.Params ] (\u03be : ConNF.NearLitterBehaviour) :ConNF.Small {L : ConNF.Litter | ConNF.NearLitterBehaviour.BannedLitter \u03be L} := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03be : ConNF.NearLitterBehaviour\n\u22a2 ConNF.Small {L | ConNF.NearLitterBehaviour.BannedLitter \u03be L}", "dependency": [1, 233, 1257]}, "ConNF.NearLitterBehaviour.mk_not_bannedLitter": {"natural_language_statement": "The theorem `ConNF.NearLitterBehaviour.mk_not_bannedLitter` states that the cardinality of the set of litters that are not considered \"banned\" in the context of Constructive Ordinal Notation (ConNF) is equal to the cardinality of the type `\u03bc` from the `ConNF.Params` class.", "formal_statement": "example [ConNF.Params ] (\u03be : ConNF.NearLitterBehaviour) :Cardinal.mk \u2191{L : ConNF.Litter | \u00ac ConNF.NearLitterBehaviour.BannedLitter \u03be L} = Cardinal.mk ConNF.\u03bc := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03be : ConNF.NearLitterBehaviour\n\u22a2 Cardinal.mk \u2191{L | \u00acConNF.NearLitterBehaviour.BannedLitter \u03be L} = Cardinal.mk ConNF.\u03bc", "dependency": [1, 29, 1257, 29]}, "ConNF.NearLitterBehaviour.not_bannedLitter_nonempty": {"natural_language_statement": "The theorem `ConNF.NearLitterBehaviour.not_bannedLitter_nonempty` asserts that for any `ConNF.NearLitterBehaviour` `\u03be`, there exists at least one `ConNF.Litter` that is not `ConNF.NearLitterBehaviour.BannedLitter`.", "formal_statement": "example [ConNF.Params ] (\u03be : ConNF.NearLitterBehaviour) :Nonempty \u2191{L : ConNF.Litter | \u00ac ConNF.NearLitterBehaviour.BannedLitter \u03be L} := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03be : ConNF.NearLitterBehaviour\n\u22a2 Nonempty \u2191{L | \u00acConNF.NearLitterBehaviour.BannedLitter \u03be L}", "dependency": [1, 212, 1257]}, "ConNF.NearLitterBehaviour.sandboxLitter_not_banned": {"natural_language_statement": "Function `ConNF.NearLitterBehaviour.sandboxLitter` takes a `ConNF.NearLitterBehaviour` object `\u03be` and returns a `ConNF.Litter` object that is not banned by `\u03be`.", "formal_statement": "example [ConNF.Params ] (\u03be : ConNF.NearLitterBehaviour) :\u00ac ConNF.NearLitterBehaviour.BannedLitter \u03be (ConNF.NearLitterBehaviour.sandboxLitter \u03be) := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03be : ConNF.NearLitterBehaviour\n\u22a2 \u00acConNF.NearLitterBehaviour.BannedLitter \u03be (ConNF.NearLitterBehaviour.sandboxLitter \u03be)", "dependency": [1, 1257, 1263]}, "ConNF.NearLitterBehaviour.mem_innerAtoms_iff": {"natural_language_statement": "The theorem `ConNF.NearLitterBehaviour.mem_innerAtoms_iff` states that an atom `a` belongs to the inner atoms of a near litter `L` if and only if the first component of `a` is not equal to `L` and for all near litters `N` such that the near litter map `\u03be.nearLitterMap N` is defined and the first component of `N` is equal to `L`, `a` belongs to `N`.", "formal_statement": "example [ConNF.Params ] {\u03be : ConNF.NearLitterBehaviour} (L : ConNF.Litter) (hL : ConNF.NearLitterBehaviour.LitterPresent \u03be L) (a : ConNF.Atom) :a \u2208 ConNF.NearLitterBehaviour.innerAtoms \u03be L \u2194 a.1 \u2260 L \u2227 \u2200 (N : ConNF.NearLitter), (\u03be.nearLitterMap N).Dom \u2227 N.fst = L \u2192 a \u2208 N := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03be : ConNF.NearLitterBehaviour\nL : ConNF.Litter\nhL : ConNF.NearLitterBehaviour.LitterPresent \u03be L\na : ConNF.Atom\n\u22a2 a \u2208 ConNF.NearLitterBehaviour.innerAtoms \u03be L \u2194\n    a.1 \u2260 L \u2227 \u2200 (N : ConNF.NearLitter), (\u03be.nearLitterMap N).Dom \u2227 N.fst = L \u2192 a \u2208 N", "dependency": [1, 838, 1265]}, "ConNF.NearLitterBehaviour.mem_outerAtoms_iff": {"natural_language_statement": "The theorem `ConNF.NearLitterBehaviour.mem_outerAtoms_iff` is a membership condition for the set of outer atoms of a given litter `L` in the context of Constructive Ordinal Notation (ConNF). It states that an atom `a` belongs to the set of outer atoms of `L` if and only if `a` is equal to `L` and `a` does not belong to any near litter `N` for which the near litter map `\u03be.nearLitterMap N` is defined.", "formal_statement": "@[simp]example [ConNF.Params ] {\u03be : ConNF.NearLitterBehaviour} (L : ConNF.Litter) (a : ConNF.Atom) :a \u2208 ConNF.NearLitterBehaviour.outerAtoms \u03be L \u2194 a.1 = L \u2227 \u2200 (N : ConNF.NearLitter), (\u03be.nearLitterMap N).Dom \u2192 a \u2209 N := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03be : ConNF.NearLitterBehaviour\nL : ConNF.Litter\na : ConNF.Atom\n\u22a2 a \u2208 ConNF.NearLitterBehaviour.outerAtoms \u03be L \u2194 a.1 = L \u2227 \u2200 (N : ConNF.NearLitter), (\u03be.nearLitterMap N).Dom \u2192 a \u2209 N", "dependency": [1, 1267]}, "ConNF.NearLitterBehaviour.mem_allOuterAtoms_iff": {"natural_language_statement": "The theorem `ConNF.NearLitterBehaviour.mem_allOuterAtoms_iff` states that an atom `a` is an element of the set `ConNF.NearLitterBehaviour.allOuterAtoms \u03be` if and only if there exists a near litter `N` such that the near litter map `\u03be.nearLitterMap N` is defined and the first component of `N` is equal to `a.1`, and for all near litters `N` such that `\u03be.nearLitterMap N` is defined, `a` is not an element of `N`.", "formal_statement": "@[simp]example [ConNF.Params ] {\u03be : ConNF.NearLitterBehaviour} (a : ConNF.Atom) :a \u2208 ConNF.NearLitterBehaviour.allOuterAtoms \u03be \u2194 ConNF.NearLitterBehaviour.LitterPresent \u03be a.1 \u2227 \u2200 (N : ConNF.NearLitter), (\u03be.nearLitterMap N).Dom \u2192 a \u2209 N := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03be : ConNF.NearLitterBehaviour\na : ConNF.Atom\n\u22a2 a \u2208 ConNF.NearLitterBehaviour.allOuterAtoms \u03be \u2194\n    ConNF.NearLitterBehaviour.LitterPresent \u03be a.1 \u2227 \u2200 (N : ConNF.NearLitter), (\u03be.nearLitterMap N).Dom \u2192 a \u2209 N", "dependency": [1, 1269, 838]}, "ConNF.NearLitterBehaviour.litterPresent_small": {"natural_language_statement": "The theorem `ConNF.NearLitterBehaviour.litterPresent_small` states that the set of litters `L` for which there exists a near litter `N` such that the near litter map `\u03be.nearLitterMap N` is defined and the first component of `N` is equal to `L`, has a cardinality strictly less than the cardinality of the type `ConNF.\u03ba`.", "formal_statement": "example [ConNF.Params ] (\u03be : ConNF.NearLitterBehaviour) :ConNF.Small {L : ConNF.Litter | ConNF.NearLitterBehaviour.LitterPresent \u03be L} := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03be : ConNF.NearLitterBehaviour\n\u22a2 ConNF.Small {L | ConNF.NearLitterBehaviour.LitterPresent \u03be L}", "dependency": [1, 233, 838]}, "ConNF.NearLitterBehaviour.litterPresent_small'": {"natural_language_statement": "The theorem `ConNF.NearLitterBehaviour.litterPresent_small'` states that the set of near-litters that are of the form `L.toNearLitter` for some litter `L` and for which there exists a near-litter `N'` such that `\u03be.nearLitterMap N'` is defined and `N'.fst = N.fst`, has a cardinality that is strictly less than the cardinality of the type `ConNF.\u03ba`.", "formal_statement": "example [ConNF.Params ] (\u03be : ConNF.NearLitterBehaviour) :ConNF.Small {N : ConNF.NearLitter | ConNF.NearLitter.IsLitter N \u2227 \u2203 (N' : ConNF.NearLitter), (\u03be.nearLitterMap N').Dom \u2227 N'.fst = N.fst} := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03be : ConNF.NearLitterBehaviour\n\u22a2 ConNF.Small {N | ConNF.NearLitter.IsLitter N \u2227 \u2203 N', (\u03be.nearLitterMap N').Dom \u2227 N'.fst = N.fst}", "dependency": [1, 233, 495]}, "ConNF.NearLitterBehaviour.innerAtoms_small": {"natural_language_statement": "Function `ConNF.NearLitterBehaviour.innerAtoms_small` proves that the inner atoms of a near litter `L` in the context of Constructive Ordinal Notation (ConNF) are small, meaning their cardinality is strictly less than the cardinality of the type `ConNF.\u03ba`.", "formal_statement": "example [ConNF.Params ] {\u03be : ConNF.NearLitterBehaviour} (L : ConNF.Litter) (hL : ConNF.NearLitterBehaviour.LitterPresent \u03be L) :ConNF.Small (ConNF.NearLitterBehaviour.innerAtoms \u03be L) := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03be : ConNF.NearLitterBehaviour\nL : ConNF.Litter\nhL : ConNF.NearLitterBehaviour.LitterPresent \u03be L\n\u22a2 ConNF.Small (ConNF.NearLitterBehaviour.innerAtoms \u03be L)", "dependency": [1, 838, 233, 1265]}, "ConNF.NearLitterBehaviour.outerAtoms_small": {"natural_language_statement": "The theorem `ConNF.NearLitterBehaviour.outerAtoms_small` states that the set of outer atoms of a given litter `L` in the context of Constructive Ordinal Notation (ConNF) is small, meaning its cardinality is strictly less than the cardinality of the type `ConNF.\u03ba`.", "formal_statement": "example [ConNF.Params ] {\u03be : ConNF.NearLitterBehaviour} (L : ConNF.Litter) (hL : ConNF.NearLitterBehaviour.LitterPresent \u03be L) :ConNF.Small (ConNF.NearLitterBehaviour.outerAtoms \u03be L) := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03be : ConNF.NearLitterBehaviour\nL : ConNF.Litter\nhL : ConNF.NearLitterBehaviour.LitterPresent \u03be L\n\u22a2 ConNF.Small (ConNF.NearLitterBehaviour.outerAtoms \u03be L)", "dependency": [1, 838, 233, 1267]}, "ConNF.NearLitterBehaviour.allOuterAtoms_small": {"natural_language_statement": "The theorem `ConNF.NearLitterBehaviour.allOuterAtoms_small` states that the set of all outer atoms in the context of Constructive Ordinal Notation (ConNF) is small, meaning its cardinality is strictly less than the cardinality of the type `ConNF.\u03ba`.", "formal_statement": "example [ConNF.Params ] {\u03be : ConNF.NearLitterBehaviour} :ConNF.Small (ConNF.NearLitterBehaviour.allOuterAtoms \u03be) := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03be : ConNF.NearLitterBehaviour\n\u22a2 ConNF.Small (ConNF.NearLitterBehaviour.allOuterAtoms \u03be)", "dependency": [1, 233, 1269]}, "ConNF.NearLitterBehaviour.innerAtomsCod_subset": {"natural_language_statement": "Function `ConNF.NearLitterBehaviour.innerAtomsCod` computes the set of inner atoms for a given litter `L` in the context of Constructive Ordinal Notation (ConNF). This set is defined as the intersection of the images of all near litters `N` that map to `L` under `\u03be.nearLitterMap`, excluding the range of `\u03be.atomMap`. The theorem `ConNF.NearLitterBehaviour.innerAtomsCod_subset` states that the set of inner atoms for a given litter `L` is a subset of the image of any near litter `N` that maps to `L` under `\u03be.nearLitterMap`.", "formal_statement": "example [ConNF.Params ] (\u03be : ConNF.NearLitterBehaviour) (N : ConNF.NearLitter) (hN : (\u03be.nearLitterMap N).Dom) :ConNF.NearLitterBehaviour.innerAtomsCod \u03be N.fst \u2286 \u2191((\u03be.nearLitterMap N).get hN) := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03be : ConNF.NearLitterBehaviour\nN : ConNF.NearLitter\nhN : (\u03be.nearLitterMap N).Dom\n\u22a2 ConNF.NearLitterBehaviour.innerAtomsCod \u03be N.fst \u2286 \u2191((\u03be.nearLitterMap N).get hN)", "dependency": [1, 1276]}, "ConNF.NearLitterBehaviour.mk_innerAtomsCod": {"natural_language_statement": "The function `ConNF.NearLitterBehaviour.innerAtomsCod` computes the set of inner atoms for a given litter `L` in the context of Constructive Ordinal Notation (ConNF). This set is defined as the intersection of the images of all near litters `N` that map to `L` under `\u03be.nearLitterMap`, excluding the range of `\u03be.atomMap`. The theorem `ConNF.NearLitterBehaviour.mk_innerAtomsCod` states that the cardinality of the set of inner atoms for `L` is equal to the cardinality of `ConNF.\u03ba`.", "formal_statement": "example [ConNF.Params ] {\u03be : ConNF.NearLitterBehaviour} (h\u03be : ConNF.NearLitterBehaviour.Lawful \u03be) (L : ConNF.Litter) (hL : ConNF.NearLitterBehaviour.LitterPresent \u03be L) :Cardinal.mk \u2191(ConNF.NearLitterBehaviour.innerAtomsCod \u03be L) = Cardinal.mk ConNF.\u03ba := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03be : ConNF.NearLitterBehaviour\nh\u03be : ConNF.NearLitterBehaviour.Lawful \u03be\nL : ConNF.Litter\nhL : ConNF.NearLitterBehaviour.LitterPresent \u03be L\n\u22a2 Cardinal.mk \u2191(ConNF.NearLitterBehaviour.innerAtomsCod \u03be L) = Cardinal.mk ConNF.\u03ba", "dependency": [1, 823, 838, 29, 1276, 29]}, "ConNF.NearLitterBehaviour.mk_innerAtoms_lt": {"natural_language_statement": "The theorem `ConNF.NearLitterBehaviour.mk_innerAtoms_lt` states that the cardinality of the set of inner atoms of a near litter `L` in the context of Constructive Ordinal Notation (ConNF) is strictly less than the cardinality of the set of inner atoms for `L`, excluding the range of the atom map.", "formal_statement": "example [ConNF.Params ] {\u03be : ConNF.NearLitterBehaviour} (h\u03be : ConNF.NearLitterBehaviour.Lawful \u03be) (L : ConNF.Litter) (hL : ConNF.NearLitterBehaviour.LitterPresent \u03be L) :Cardinal.mk \u2191(ConNF.NearLitterBehaviour.innerAtoms \u03be L) < Cardinal.mk \u2191(ConNF.NearLitterBehaviour.innerAtomsCod \u03be L) := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03be : ConNF.NearLitterBehaviour\nh\u03be : ConNF.NearLitterBehaviour.Lawful \u03be\nL : ConNF.Litter\nhL : ConNF.NearLitterBehaviour.LitterPresent \u03be L\n\u22a2 Cardinal.mk \u2191(ConNF.NearLitterBehaviour.innerAtoms \u03be L) < Cardinal.mk \u2191(ConNF.NearLitterBehaviour.innerAtomsCod \u03be L)", "dependency": [1, 823, 838, 29, 1265, 29, 1276]}, "ConNF.NearLitterBehaviour.eq_of_mem_innerAtoms": {"natural_language_statement": "The theorem `ConNF.NearLitterBehaviour.eq_of_mem_innerAtoms` states that if `a` is an inner atom of two near litters `L\u2081` and `L\u2082`, then `L\u2081` must be equal to `L\u2082`.", "formal_statement": "example [ConNF.Params ] {\u03be : ConNF.NearLitterBehaviour} (h\u03be : ConNF.NearLitterBehaviour.Lawful \u03be) (a : ConNF.Atom) (ha : \u00ac (\u03be.atomMap a).Dom) {L\u2081 : ConNF.Litter} {L\u2082 : ConNF.Litter} (hL\u2081 : ConNF.NearLitterBehaviour.LitterPresent \u03be L\u2081) (hL\u2082 : ConNF.NearLitterBehaviour.LitterPresent \u03be L\u2082) (ha\u2081 : a \u2208 ConNF.NearLitterBehaviour.innerAtoms \u03be L\u2081) (ha\u2082 : a \u2208 ConNF.NearLitterBehaviour.innerAtoms \u03be L\u2082) :L\u2081 = L\u2082 := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03be : ConNF.NearLitterBehaviour\nh\u03be : ConNF.NearLitterBehaviour.Lawful \u03be\na : ConNF.Atom\nha : \u00ac(\u03be.atomMap a).Dom\nL\u2081 L\u2082 : ConNF.Litter\nhL\u2081 : ConNF.NearLitterBehaviour.LitterPresent \u03be L\u2081\nhL\u2082 : ConNF.NearLitterBehaviour.LitterPresent \u03be L\u2082\nha\u2081 : a \u2208 ConNF.NearLitterBehaviour.innerAtoms \u03be L\u2081\nha\u2082 : a \u2208 ConNF.NearLitterBehaviour.innerAtoms \u03be L\u2082\n\u22a2 L\u2081 = L\u2082", "dependency": [1, 823, 838, 838, 1265, 1265]}, "ConNF.NearLitterBehaviour.innerAtoms_allOuterAtoms": {"natural_language_statement": "The theorem `ConNF.NearLitterBehaviour.innerAtoms_allOuterAtoms` states that in the context of Constructive Ordinal Notation (ConNF), given a near litter behaviour `\u03be`, an atom `a`, and a litter `L` that is present in `\u03be`, if `a` is an inner atom of `L` and `a` is also an outer atom of `\u03be`, then there is a logical contradiction, represented by `False`.", "formal_statement": "example [ConNF.Params ] {\u03be : ConNF.NearLitterBehaviour} (a : ConNF.Atom) {L : ConNF.Litter} (hL : ConNF.NearLitterBehaviour.LitterPresent \u03be L) (ha\u2081 : a \u2208 ConNF.NearLitterBehaviour.innerAtoms \u03be L) (ha\u2082 : a \u2208 ConNF.NearLitterBehaviour.allOuterAtoms \u03be) :False := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03be : ConNF.NearLitterBehaviour\na : ConNF.Atom\nL : ConNF.Litter\nhL : ConNF.NearLitterBehaviour.LitterPresent \u03be L\nha\u2081 : a \u2208 ConNF.NearLitterBehaviour.innerAtoms \u03be L\nha\u2082 : a \u2208 ConNF.NearLitterBehaviour.allOuterAtoms \u03be\n\u22a2 False", "dependency": [1, 838, 1265, 1269, 891]}, "ConNF.NearLitterBehaviour.extraAtomMap_dom_small": {"natural_language_statement": "The theorem `ConNF.NearLitterBehaviour.extraAtomMap_dom_small` states that the domain of the partial function `ConNF.NearLitterBehaviour.extraAtomMap`, which is used to extend the domain of the near-litter-behaviour's atom map, is strictly less than the cardinality of the type `ConNF.\u03ba` in the context of Constructive Ordinal Notation (ConNF).", "formal_statement": "example [ConNF.Params ] (\u03be : ConNF.NearLitterBehaviour) (h\u03be : ConNF.NearLitterBehaviour.Lawful \u03be) :ConNF.Small (PFun.Dom (ConNF.NearLitterBehaviour.extraAtomMap \u03be h\u03be)) := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03be : ConNF.NearLitterBehaviour\nh\u03be : ConNF.NearLitterBehaviour.Lawful \u03be\n\u22a2 ConNF.Small (PFun.Dom (ConNF.NearLitterBehaviour.extraAtomMap \u03be h\u03be))", "dependency": [1, 823, 233, 404, 1282]}, "ConNF.NearLitterBehaviour.innerAtomsEmbedding_ne_atomMap": {"natural_language_statement": "The theorem `ConNF.NearLitterBehaviour.innerAtomsEmbedding_ne_atomMap` in Lean 4 states that the atom map of an atom `a` is not equal to the inner atoms embedding of a near litter `L` for any inner atom `b` in the set of inner atoms of `L`. This is part of the correctness proof for the inner atoms definition in the context of Constructive Ordinal Notation (ConNF).", "formal_statement": "example [ConNF.Params ] {\u03be : ConNF.NearLitterBehaviour} {h\u03be : ConNF.NearLitterBehaviour.Lawful \u03be} {a : ConNF.Atom} (ha : (\u03be.atomMap a).Dom) {L : ConNF.Litter} {hL : ConNF.NearLitterBehaviour.LitterPresent \u03be L} (b : \u2191(ConNF.NearLitterBehaviour.innerAtoms \u03be L)) :(\u03be.atomMap a).get ha \u2260 \u2191((ConNF.NearLitterBehaviour.innerAtomsEmbedding h\u03be L hL) b) := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03be : ConNF.NearLitterBehaviour\nh\u03be : ConNF.NearLitterBehaviour.Lawful \u03be\na : ConNF.Atom\nha : (\u03be.atomMap a).Dom\nL : ConNF.Litter\nhL : ConNF.NearLitterBehaviour.LitterPresent \u03be L\nb : \u2191(ConNF.NearLitterBehaviour.innerAtoms \u03be L)\n\u22a2 (\u03be.atomMap a).get ha \u2260 \u2191((ConNF.NearLitterBehaviour.innerAtomsEmbedding h\u03be L hL) b)", "dependency": [1, 823, 838, 1265, 1284]}, "ConNF.NearLitterBehaviour.outerAtomsEmbedding_ne_atomMap": {"natural_language_statement": "Function `ConNF.NearLitterBehaviour.outerAtomsEmbedding` defines an embedding from the set of all outer atoms in the context of Constructive Ordinal Notation (ConNF), as determined by the near litter behaviour `\u03be`, into the set of all atoms whose first projection is equal to the sandbox litter of `\u03be`. The theorem `ConNF.NearLitterBehaviour.outerAtomsEmbedding_ne_atomMap` states that for any atom `a` whose first projection is equal to the sandbox litter of `\u03be`, and any outer atom `b` in the context of `\u03be`, the image of `b` under the embedding is not equal to `a`.", "formal_statement": "example [ConNF.Params ] {\u03be : ConNF.NearLitterBehaviour} {a : ConNF.Atom} (ha : (\u03be.atomMap a).Dom) (b : \u2191(ConNF.NearLitterBehaviour.allOuterAtoms \u03be)) :(\u03be.atomMap a).get ha \u2260 \u2191((ConNF.NearLitterBehaviour.outerAtomsEmbedding \u03be) b) := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03be : ConNF.NearLitterBehaviour\na : ConNF.Atom\nha : (\u03be.atomMap a).Dom\nb : \u2191(ConNF.NearLitterBehaviour.allOuterAtoms \u03be)\n\u22a2 (\u03be.atomMap a).get ha \u2260 \u2191((ConNF.NearLitterBehaviour.outerAtomsEmbedding \u03be) b)", "dependency": [1, 1269, 1286]}, "ConNF.NearLitterBehaviour.extraAtomMap_injective": {"natural_language_statement": "The theorem `ConNF.NearLitterBehaviour.extraAtomMap_injective` states that the `extraAtomMap` function defined in the context of Constructive Ordinal Notation (ConNF) in Lean 4 is injective. This function is used to extend the domain of the near-litter-behaviour's atom map, ensuring that every `ConNF.Atom` has an image under the atom map.", "formal_statement": "example [ConNF.Params ] {\u03be : ConNF.NearLitterBehaviour} {h\u03be : ConNF.NearLitterBehaviour.Lawful \u03be} \u2983a : ConNF.Atom\u2984 \u2983b : ConNF.Atom\u2984 (ha : (ConNF.NearLitterBehaviour.extraAtomMap \u03be h\u03be a).Dom) (hb : (ConNF.NearLitterBehaviour.extraAtomMap \u03be h\u03be b).Dom) (h : (ConNF.NearLitterBehaviour.extraAtomMap \u03be h\u03be a).get ha = (ConNF.NearLitterBehaviour.extraAtomMap \u03be h\u03be b).get hb) :a = b := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03be : ConNF.NearLitterBehaviour\nh\u03be : ConNF.NearLitterBehaviour.Lawful \u03be\na b : ConNF.Atom\nha : (ConNF.NearLitterBehaviour.extraAtomMap \u03be h\u03be a).Dom\nhb : (ConNF.NearLitterBehaviour.extraAtomMap \u03be h\u03be b).Dom\nh : (ConNF.NearLitterBehaviour.extraAtomMap \u03be h\u03be a).get ha = (ConNF.NearLitterBehaviour.extraAtomMap \u03be h\u03be b).get hb\n\u22a2 a = b", "dependency": [1, 823, 1282, 1282, 1282, 1282]}, "ConNF.NearLitterBehaviour.mem_iff_of_mem_innerAtoms": {"natural_language_statement": "In the context of Constructive Ordinal Notation (ConNF) in Lean 4, the theorem `ConNF.NearLitterBehaviour.mem_iff_of_mem_innerAtoms` states that for a lawful near-litter-behaviour `\u03be`, an atom `a` is a member of a near-litter `N` if and only if the first component of `N` is equal to the given litter `L`, provided that `a` is not in the domain of the atom map `\u03be.atomMap`, `a` is in the inner atoms of `L`, and the near-litter map `\u03be.nearLitterMap N` is defined.", "formal_statement": "example [ConNF.Params ] {\u03be : ConNF.NearLitterBehaviour} (h\u03be : ConNF.NearLitterBehaviour.Lawful \u03be) {a : ConNF.Atom} {L : ConNF.Litter} (hL : ConNF.NearLitterBehaviour.LitterPresent \u03be L) (ha' : \u00ac (\u03be.atomMap a).Dom) (ha : a \u2208 ConNF.NearLitterBehaviour.innerAtoms \u03be L) {N : ConNF.NearLitter} (hN : (\u03be.nearLitterMap N).Dom) :a \u2208 N \u2194 N.fst = L := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03be : ConNF.NearLitterBehaviour\nh\u03be : ConNF.NearLitterBehaviour.Lawful \u03be\na : ConNF.Atom\nL : ConNF.Litter\nhL : ConNF.NearLitterBehaviour.LitterPresent \u03be L\nha' : \u00ac(\u03be.atomMap a).Dom\nha : a \u2208 ConNF.NearLitterBehaviour.innerAtoms \u03be L\nN : ConNF.NearLitter\nhN : (\u03be.nearLitterMap N).Dom\n\u22a2 a \u2208 N \u2194 N.fst = L", "dependency": [1, 823, 838, 1265]}, "ConNF.NearLitterBehaviour.extraAtomMap_mem_iff": {"natural_language_statement": "The theorem `ConNF.NearLitterBehaviour.extraAtomMap_mem_iff` states that for a lawful near-litter-behaviour `\u03be`, an atom `a` belongs to a near-litter `N` if and only if the image of `a` under the extended atom map belongs to the image of `N` under the near-litter map.", "formal_statement": "example [ConNF.Params ] {\u03be : ConNF.NearLitterBehaviour} {h\u03be : ConNF.NearLitterBehaviour.Lawful \u03be} \u2983a : ConNF.Atom\u2984 (ha : (ConNF.NearLitterBehaviour.extraAtomMap \u03be h\u03be a).Dom) \u2983N : ConNF.NearLitter\u2984 (hN : (\u03be.nearLitterMap N).Dom) :(ConNF.NearLitterBehaviour.extraAtomMap \u03be h\u03be a).get ha \u2208 (\u03be.nearLitterMap N).get hN \u2194 a \u2208 N := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03be : ConNF.NearLitterBehaviour\nh\u03be : ConNF.NearLitterBehaviour.Lawful \u03be\na : ConNF.Atom\nha : (ConNF.NearLitterBehaviour.extraAtomMap \u03be h\u03be a).Dom\nN : ConNF.NearLitter\nhN : (\u03be.nearLitterMap N).Dom\n\u22a2 (ConNF.NearLitterBehaviour.extraAtomMap \u03be h\u03be a).get ha \u2208 (\u03be.nearLitterMap N).get hN \u2194 a \u2208 N", "dependency": [1, 823, 1282, 1282]}, "ConNF.NearLitterBehaviour.extraAtomMap_dom_of_mem_symmDiff": {"natural_language_statement": "The theorem `ConNF.NearLitterBehaviour.extraAtomMap_dom_of_mem_symmDiff` is a result in the context of Constructive Ordinal Notation (ConNF) in Lean 4. It states that if `\u03be` is a lawful near-litter-behaviour, `N` is a near-litter, and `a` is an atom that belongs to the symmetric difference of the litter set of `N`'s first projection and `N` itself, then the domain of `ConNF.NearLitterBehaviour.extraAtomMap \u03be h\u03be a` is nonempty, meaning `a` has an image under the extended atom map.", "formal_statement": "example [ConNF.Params ] {\u03be : ConNF.NearLitterBehaviour} (h\u03be : ConNF.NearLitterBehaviour.Lawful \u03be) {N : ConNF.NearLitter} (hN : (\u03be.nearLitterMap N).Dom) {a : ConNF.Atom} (ha : a \u2208 symmDiff (ConNF.litterSet N.fst) \u2191N) :(ConNF.NearLitterBehaviour.extraAtomMap \u03be h\u03be a).Dom := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03be : ConNF.NearLitterBehaviour\nh\u03be : ConNF.NearLitterBehaviour.Lawful \u03be\nN : ConNF.NearLitter\nhN : (\u03be.nearLitterMap N).Dom\na : ConNF.Atom\nha : a \u2208 symmDiff (ConNF.litterSet N.fst) \u2191N\n\u22a2 (ConNF.NearLitterBehaviour.extraAtomMap \u03be h\u03be a).Dom", "dependency": [1, 823, 62, 467, 1282]}, "ConNF.NearLitterBehaviour.extraAtomMap_dom_of_mem_inter": {"natural_language_statement": "Given a lawful near-litter-behaviour $\\xi$, an extension of the near-litter-behaviour's atom map is defined to ensure that every `ConNF.Atom` has an image under the atom map. The theorem states that if an atom `a` belongs to a near-litter `N` with a different source litter `L`, and `a`'s source is equal to `L`, then the domain of the extended atom map is nonempty for `a`.", "formal_statement": "example [ConNF.Params ] {\u03be : ConNF.NearLitterBehaviour} (h\u03be : ConNF.NearLitterBehaviour.Lawful \u03be) {N : ConNF.NearLitter} (hN : (\u03be.nearLitterMap N).Dom) {L : ConNF.Litter} (h : N.fst \u2260 L) {a : ConNF.Atom} (ha\u2081 : a \u2208 N) (ha\u2082 : a.1 = L) :(ConNF.NearLitterBehaviour.extraAtomMap \u03be h\u03be a).Dom := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03be : ConNF.NearLitterBehaviour\nh\u03be : ConNF.NearLitterBehaviour.Lawful \u03be\nN : ConNF.NearLitter\nhN : (\u03be.nearLitterMap N).Dom\nL : ConNF.Litter\nh : N.fst \u2260 L\na : ConNF.Atom\nha\u2081 : a \u2208 N\nha\u2082 : a.1 = L\n\u22a2 (ConNF.NearLitterBehaviour.extraAtomMap \u03be h\u03be a).Dom", "dependency": [1, 823, 1282]}, "ConNF.NearLitterBehaviour.extraLitterMap'_subset": {"natural_language_statement": "Given a lawful near-litter-behaviour `\u03be`, two near-litters `N\u2081` and `N\u2082` with the same litter set, and proofs that both `N\u2081` and `N\u2082` are in the domain of the near-litter map of `\u03be`, the extra litter map of `N\u2081` is a subset of the extra litter map of `N\u2082`.", "formal_statement": "example [ConNF.Params ] {\u03be : ConNF.NearLitterBehaviour} {h\u03be : ConNF.NearLitterBehaviour.Lawful \u03be} {N\u2081 : ConNF.NearLitter} {N\u2082 : ConNF.NearLitter} (h : N\u2081.fst = N\u2082.fst) (hN\u2081 : (\u03be.nearLitterMap N\u2081).Dom) (hN\u2082 : (\u03be.nearLitterMap N\u2082).Dom) :ConNF.NearLitterBehaviour.extraLitterMap' \u03be h\u03be N\u2081 hN\u2081 \u2286 ConNF.NearLitterBehaviour.extraLitterMap' \u03be h\u03be N\u2082 hN\u2082 := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03be : ConNF.NearLitterBehaviour\nh\u03be : ConNF.NearLitterBehaviour.Lawful \u03be\nN\u2081 N\u2082 : ConNF.NearLitter\nh : N\u2081.fst = N\u2082.fst\nhN\u2081 : (\u03be.nearLitterMap N\u2081).Dom\nhN\u2082 : (\u03be.nearLitterMap N\u2082).Dom\n\u22a2 ConNF.NearLitterBehaviour.extraLitterMap' \u03be h\u03be N\u2081 hN\u2081 \u2286 ConNF.NearLitterBehaviour.extraLitterMap' \u03be h\u03be N\u2082 hN\u2082", "dependency": [1, 823, 1293, 1293]}, "ConNF.NearLitterBehaviour.extraLitterMap'_eq": {"natural_language_statement": "Given a lawful near-litter-behaviour `\u03be`, two near-litters `N\u2081` and `N\u2082` with the same litter set, and proofs that both `N\u2081` and `N\u2082` are in the domain of the near-litter map of `\u03be`, the function `ConNF.NearLitterBehaviour.extraLitterMap'` returns the same set of atoms for both `N\u2081` and `N\u2082`.", "formal_statement": "example [ConNF.Params ] {\u03be : ConNF.NearLitterBehaviour} {h\u03be : ConNF.NearLitterBehaviour.Lawful \u03be} {N\u2081 : ConNF.NearLitter} {N\u2082 : ConNF.NearLitter} (h : N\u2081.fst = N\u2082.fst) (hN\u2081 : (\u03be.nearLitterMap N\u2081).Dom) (hN\u2082 : (\u03be.nearLitterMap N\u2082).Dom) :ConNF.NearLitterBehaviour.extraLitterMap' \u03be h\u03be N\u2081 hN\u2081 = ConNF.NearLitterBehaviour.extraLitterMap' \u03be h\u03be N\u2082 hN\u2082 := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03be : ConNF.NearLitterBehaviour\nh\u03be : ConNF.NearLitterBehaviour.Lawful \u03be\nN\u2081 N\u2082 : ConNF.NearLitter\nh : N\u2081.fst = N\u2082.fst\nhN\u2081 : (\u03be.nearLitterMap N\u2081).Dom\nhN\u2082 : (\u03be.nearLitterMap N\u2082).Dom\n\u22a2 ConNF.NearLitterBehaviour.extraLitterMap' \u03be h\u03be N\u2081 hN\u2081 = ConNF.NearLitterBehaviour.extraLitterMap' \u03be h\u03be N\u2082 hN\u2082", "dependency": [1, 823, 1293, 1293]}, "ConNF.NearLitterBehaviour.extraLitterMap'_isNearLitter": {"natural_language_statement": "Given a lawful near-litter-behaviour `\u03be`, a near-litter `N`, and a proof that `N` is in the domain of the near-litter map of `\u03be`, the function `ConNF.NearLitterBehaviour.extraLitterMap' \u03be h\u03be N hN` returns a set of atoms that is near the litter set of `N`.", "formal_statement": "example [ConNF.Params ] {\u03be : ConNF.NearLitterBehaviour} (h\u03be : ConNF.NearLitterBehaviour.Lawful \u03be) {N : ConNF.NearLitter} (hN : (\u03be.nearLitterMap N).Dom) :ConNF.IsNearLitter ((\u03be.nearLitterMap N).get hN).fst (ConNF.NearLitterBehaviour.extraLitterMap' \u03be h\u03be N hN) := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03be : ConNF.NearLitterBehaviour\nh\u03be : ConNF.NearLitterBehaviour.Lawful \u03be\nN : ConNF.NearLitter\nhN : (\u03be.nearLitterMap N).Dom\n\u22a2 ConNF.IsNearLitter ((\u03be.nearLitterMap N).get hN).fst (ConNF.NearLitterBehaviour.extraLitterMap' \u03be h\u03be N hN)", "dependency": [1, 823, 466, 1293]}, "ConNF.NearLitterBehaviour.extraLitterMap'_disjoint": {"natural_language_statement": "The theorem `ConNF.NearLitterBehaviour.extraLitterMap'_disjoint` asserts that the intersection of the sets `ConNF.NearLitterBehaviour.extraLitterMap' \u03be h\u03be N\u2081 hN\u2081` and `ConNF.NearLitterBehaviour.extraLitterMap' \u03be h\u03be N\u2082 hN\u2082` is empty, i.e., the two sets are disjoint. This is true provided that `N\u2081` and `N\u2082` are different near-litters, and both `N\u2081` and `N\u2082` are in the domain of the near-litter map of `\u03be`. The proof involves using properties of the near-litter-behaviour `\u03be` and the fact that `N\u2081` and `N\u2082` are different.", "formal_statement": "example [ConNF.Params ] {\u03be : ConNF.NearLitterBehaviour} {h\u03be : ConNF.NearLitterBehaviour.Lawful \u03be} {N\u2081 : ConNF.NearLitter} {N\u2082 : ConNF.NearLitter} (h : N\u2081.fst \u2260 N\u2082.fst) (hN\u2081 : (\u03be.nearLitterMap N\u2081).Dom) (hN\u2082 : (\u03be.nearLitterMap N\u2082).Dom) (a : ConNF.Atom) :a \u2209 ConNF.NearLitterBehaviour.extraLitterMap' \u03be h\u03be N\u2081 hN\u2081 \u2229 ConNF.NearLitterBehaviour.extraLitterMap' \u03be h\u03be N\u2082 hN\u2082 := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03be : ConNF.NearLitterBehaviour\nh\u03be : ConNF.NearLitterBehaviour.Lawful \u03be\nN\u2081 N\u2082 : ConNF.NearLitter\nh : N\u2081.fst \u2260 N\u2082.fst\nhN\u2081 : (\u03be.nearLitterMap N\u2081).Dom\nhN\u2082 : (\u03be.nearLitterMap N\u2082).Dom\na : ConNF.Atom\n\u22a2 a \u2209 ConNF.NearLitterBehaviour.extraLitterMap' \u03be h\u03be N\u2081 hN\u2081 \u2229 ConNF.NearLitterBehaviour.extraLitterMap' \u03be h\u03be N\u2082 hN\u2082", "dependency": [1, 823, 1293, 1293]}, "ConNF.NearLitterBehaviour.mem_extraLitterMap_iff": {"natural_language_statement": "The theorem `ConNF.NearLitterBehaviour.mem_extraLitterMap_iff` states that for a lawful near-litter-behaviour `\u03be`, a near-litter `N`, and a proof that `N` is in the domain of the near-litter map of `\u03be`, an atom `a` is in the extra-litter map of `\u03be` applied to `N` if and only if `a` is in the extra-litter map' of `\u03be` applied to `N`.", "formal_statement": "example [ConNF.Params ] {\u03be : ConNF.NearLitterBehaviour} {h\u03be : ConNF.NearLitterBehaviour.Lawful \u03be} {N : ConNF.NearLitter} {hN : (\u03be.nearLitterMap N).Dom} (a : ConNF.Atom) :a \u2208 ConNF.NearLitterBehaviour.extraLitterMap \u03be h\u03be N hN \u2194 a \u2208 ConNF.NearLitterBehaviour.extraLitterMap' \u03be h\u03be N hN := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03be : ConNF.NearLitterBehaviour\nh\u03be : ConNF.NearLitterBehaviour.Lawful \u03be\nN : ConNF.NearLitter\nhN : (\u03be.nearLitterMap N).Dom\na : ConNF.Atom\n\u22a2 a \u2208 ConNF.NearLitterBehaviour.extraLitterMap \u03be h\u03be N hN \u2194 a \u2208 ConNF.NearLitterBehaviour.extraLitterMap' \u03be h\u03be N hN", "dependency": [1, 823, 1298, 1293]}, "ConNF.NearLitterBehaviour.extraLitterMap_eq": {"natural_language_statement": "Given a lawful near-litter-behaviour `\u03be`, two near-litters `N\u2081` and `N\u2082` with the same first component, and proofs that both `N\u2081` and `N\u2082` are in the domain of the near-litter map of `\u03be`, the function `ConNF.NearLitterBehaviour.extraLitterMap` returns the same near-litter for both `N\u2081` and `N\u2082`.", "formal_statement": "example [ConNF.Params ] {\u03be : ConNF.NearLitterBehaviour} {h\u03be : ConNF.NearLitterBehaviour.Lawful \u03be} {N\u2081 : ConNF.NearLitter} {N\u2082 : ConNF.NearLitter} (h : N\u2081.fst = N\u2082.fst) (hN\u2081 : (\u03be.nearLitterMap N\u2081).Dom) (hN\u2082 : (\u03be.nearLitterMap N\u2082).Dom) :ConNF.NearLitterBehaviour.extraLitterMap \u03be h\u03be N\u2081 hN\u2081 = ConNF.NearLitterBehaviour.extraLitterMap \u03be h\u03be N\u2082 hN\u2082 := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03be : ConNF.NearLitterBehaviour\nh\u03be : ConNF.NearLitterBehaviour.Lawful \u03be\nN\u2081 N\u2082 : ConNF.NearLitter\nh : N\u2081.fst = N\u2082.fst\nhN\u2081 : (\u03be.nearLitterMap N\u2081).Dom\nhN\u2082 : (\u03be.nearLitterMap N\u2082).Dom\n\u22a2 ConNF.NearLitterBehaviour.extraLitterMap \u03be h\u03be N\u2081 hN\u2081 = ConNF.NearLitterBehaviour.extraLitterMap \u03be h\u03be N\u2082 hN\u2082", "dependency": [1, 823, 1298, 1298]}, "ConNF.NearLitterBehaviour.extraAtomMap_mem_iff'": {"natural_language_statement": "Given a lawful near-litter-behaviour `\u03be`, `ConNF.NearLitterBehaviour.extraAtomMap_mem_iff'` states that for any atom `a` in the domain of the extended atom map, and any near-litter `N` in the domain of the near-litter map, `a` is a member of the extended near-litter map of `N` if and only if the first component of `a` is equal to the first component of the near-litter `N`.", "formal_statement": "example [ConNF.Params ] {\u03be : ConNF.NearLitterBehaviour} {h\u03be : ConNF.NearLitterBehaviour.Lawful \u03be} {a : ConNF.Atom} (ha : (ConNF.NearLitterBehaviour.extraAtomMap \u03be h\u03be a).Dom) {N : ConNF.NearLitter} (hN : (\u03be.nearLitterMap N).Dom) :(ConNF.NearLitterBehaviour.extraAtomMap \u03be h\u03be a).get ha \u2208 ConNF.NearLitterBehaviour.extraLitterMap \u03be h\u03be N hN \u2194 a.1 = N.fst := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03be : ConNF.NearLitterBehaviour\nh\u03be : ConNF.NearLitterBehaviour.Lawful \u03be\na : ConNF.Atom\nha : (ConNF.NearLitterBehaviour.extraAtomMap \u03be h\u03be a).Dom\nN : ConNF.NearLitter\nhN : (\u03be.nearLitterMap N).Dom\n\u22a2 (ConNF.NearLitterBehaviour.extraAtomMap \u03be h\u03be a).get ha \u2208 ConNF.NearLitterBehaviour.extraLitterMap \u03be h\u03be N hN \u2194\n    a.1 = N.fst", "dependency": [1, 823, 1282, 1282, 1298]}, "ConNF.NearLitterBehaviour.extraAtomMap_ran_of_mem_symmDiff": {"natural_language_statement": "The Lean 4 object `ConNF.NearLitterBehaviour.extraAtomMap_ran_of_mem_symmDiff` is a theorem in the context of Constructive Ordinal Notation (ConNF) in Lean 4. It states that if `\u03be` is a lawful near-litter-behaviour, `N\u2081` and `N\u2082` are near-litters, `a` is an atom, and `a` is in the symmetric difference of the image of `N\u2081` under the near-litter map of `\u03be` and the union of the images of the atoms in the symmetric difference of the litter set of `N\u2082` and `N\u2082` itself, under the extra-atom map of `\u03be`, then `a` is in the range of the extra-atom map of `\u03be`.", "formal_statement": "example [ConNF.Params ] {\u03be : ConNF.NearLitterBehaviour} (h\u03be : ConNF.NearLitterBehaviour.Lawful \u03be) {N\u2081 : ConNF.NearLitter} {N\u2082 : ConNF.NearLitter} (hN\u2081 : (\u03be.nearLitterMap N\u2081).Dom) (hN\u2082 : (\u03be.nearLitterMap N\u2082).Dom) (hN : N\u2081.fst = (ConNF.Litter.toNearLitter N\u2082.fst).fst) {a : ConNF.Atom} (ha : a \u2208 symmDiff (\u2191((\u03be.nearLitterMap N\u2081).get hN\u2081)) (ConNF.NearLitterBehaviour.extraLitterMap' \u03be h\u03be N\u2082 hN\u2082)) :a \u2208 PFun.ran (ConNF.NearLitterBehaviour.extraAtomMap \u03be h\u03be) := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03be : ConNF.NearLitterBehaviour\nh\u03be : ConNF.NearLitterBehaviour.Lawful \u03be\nN\u2081 N\u2082 : ConNF.NearLitter\nhN\u2081 : (\u03be.nearLitterMap N\u2081).Dom\nhN\u2082 : (\u03be.nearLitterMap N\u2082).Dom\nhN : N\u2081.fst = (ConNF.Litter.toNearLitter N\u2082.fst).fst\na : ConNF.Atom\nha : a \u2208 symmDiff (\u2191((\u03be.nearLitterMap N\u2081).get hN\u2081)) (ConNF.NearLitterBehaviour.extraLitterMap' \u03be h\u03be N\u2082 hN\u2082)\n\u22a2 a \u2208 PFun.ran (ConNF.NearLitterBehaviour.extraAtomMap \u03be h\u03be)", "dependency": [1, 823, 483, 62, 1293, 824, 1282]}, "ConNF.NearLitterBehaviour.extraAtomMap_ran_of_mem_inter": {"natural_language_statement": "Given a lawful near-litter-behaviour $\\xi$, two near-litters $N_1$ and $N_2$, with $N_1$ not equal to $N_2$ as litters, and an atom $a$ that is in the intersection of the image of $N_1$ under the near-litter map of $\\xi$ and the extra-litter map of $\\xi$ applied to $N_2$, then $a$ is in the range of the extra-atom map of $\\xi$.", "formal_statement": "example [ConNF.Params ] {\u03be : ConNF.NearLitterBehaviour} (h\u03be : ConNF.NearLitterBehaviour.Lawful \u03be) {N\u2081 : ConNF.NearLitter} {N\u2082 : ConNF.NearLitter} (hN\u2081 : (\u03be.nearLitterMap N\u2081).Dom) (hN\u2082 : (\u03be.nearLitterMap N\u2082).Dom) (hN : N\u2081.fst \u2260 (ConNF.Litter.toNearLitter N\u2082.fst).fst) {a : ConNF.Atom} (ha : a \u2208 \u2191((\u03be.nearLitterMap N\u2081).get hN\u2081) \u2229 ConNF.NearLitterBehaviour.extraLitterMap' \u03be h\u03be N\u2082 hN\u2082) :a \u2208 PFun.ran (ConNF.NearLitterBehaviour.extraAtomMap \u03be h\u03be) := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03be : ConNF.NearLitterBehaviour\nh\u03be : ConNF.NearLitterBehaviour.Lawful \u03be\nN\u2081 N\u2082 : ConNF.NearLitter\nhN\u2081 : (\u03be.nearLitterMap N\u2081).Dom\nhN\u2082 : (\u03be.nearLitterMap N\u2082).Dom\nhN : N\u2081.fst \u2260 (ConNF.Litter.toNearLitter N\u2082.fst).fst\na : ConNF.Atom\nha : a \u2208 \u2191((\u03be.nearLitterMap N\u2081).get hN\u2081) \u2229 ConNF.NearLitterBehaviour.extraLitterMap' \u03be h\u03be N\u2082 hN\u2082\n\u22a2 a \u2208 PFun.ran (ConNF.NearLitterBehaviour.extraAtomMap \u03be h\u03be)", "dependency": [1, 823, 483, 1293, 824, 1282]}, "ConNF.NearLitterBehaviour.withLitters_lawful": {"natural_language_statement": "The theorem `ConNF.NearLitterBehaviour.withLitters_lawful` states that given a lawful near-litter-behaviour `\u03be`, the modified near-litter-behaviour `ConNF.NearLitterBehaviour.withLitters \u03be h\u03be` is also lawful.", "formal_statement": "example [ConNF.Params ] (\u03be : ConNF.NearLitterBehaviour) (h\u03be : ConNF.NearLitterBehaviour.Lawful \u03be) :ConNF.NearLitterBehaviour.Lawful (ConNF.NearLitterBehaviour.withLitters \u03be h\u03be) := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u03be : ConNF.NearLitterBehaviour\nh\u03be : ConNF.NearLitterBehaviour.Lawful \u03be\n\u22a2 ConNF.NearLitterBehaviour.Lawful (ConNF.NearLitterBehaviour.withLitters \u03be h\u03be)", "dependency": [1, 823, 823, 832]}, "ConNF.StructApprox.ihAction_atomMap": {"natural_language_statement": "In the context of Constructive Ordinal Notation (ConNF), the function `ConNF.StructApprox.ihAction_atomMap` defines the atom map of a `\u03b2`-structural action as a product that assigns a near-litter action to each `\u03b2`-extended index, given an inductive hypothesis. It injects an element of type `\u03b1` into the left side of the sum type `\u03b1 \u2295 \u03b2`.", "formal_statement": "@[simp]example [ConNF.Params ] [ConNF.Level] [ConNF.FOAAssumptions] {\u03b2 : ConNF.\u039b} {c : ConNF.Address \u2191\u03b2} {H : ConNF.HypAction c} {B : ConNF.ExtendedIndex \u2191\u03b2} {a : ConNF.Atom} :(ConNF.StructApprox.ihAction H B).atomMap a = { Dom := { path := B, value := Sum.inl a } < c, get := fun (h : { path := B, value := Sum.inl a } < c) => H.atomImage B a h } := by sorry", "full_tactic_state": "inst\u271d\u00b2 : ConNF.Params\ninst\u271d\u00b9 : ConNF.Level\ninst\u271d : ConNF.FOAAssumptions\n\u03b2 : ConNF.\u039b\nc : ConNF.Address \u2191\u03b2\nH : ConNF.HypAction c\nB : ConNF.ExtendedIndex \u2191\u03b2\na : ConNF.Atom\n\u22a2 (ConNF.StructApprox.ihAction H B).atomMap a =\n    { Dom := { path := B, value := Sum.inl a } < c, get := fun h => H.atomImage B a h }", "dependency": [1, 60, 1305, 61, 1306, 67, 67]}, "ConNF.StructApprox.ihAction_litterMap": {"natural_language_statement": "The theorem `ConNF.StructApprox.ihAction_litterMap` is a part of the Constructive Ordinal Notation (ConNF) project in Lean 4. It defines the litter map of a `\u03b2`-structural action as a product that assigns a near-litter action to each `\u03b2`-extended index, given an inductive hypothesis in the context of ConNF.", "formal_statement": "@[simp]example [ConNF.Params ] [ConNF.Level] [ConNF.FOAAssumptions] {\u03b2 : ConNF.\u039b} {c : ConNF.Address \u2191\u03b2} {H : ConNF.HypAction c} {B : ConNF.ExtendedIndex \u2191\u03b2} {L : ConNF.Litter} :(ConNF.StructApprox.ihAction H B).litterMap L = { Dom := { path := B, value := Sum.inr (ConNF.Litter.toNearLitter L) } < c, get := fun (h : { path := B, value := Sum.inr (ConNF.Litter.toNearLitter L) } < c) => H.nearLitterImage B (ConNF.Litter.toNearLitter L) h } := by sorry", "full_tactic_state": "inst\u271d\u00b2 : ConNF.Params\ninst\u271d\u00b9 : ConNF.Level\ninst\u271d : ConNF.FOAAssumptions\n\u03b2 : ConNF.\u039b\nc : ConNF.Address \u2191\u03b2\nH : ConNF.HypAction c\nB : ConNF.ExtendedIndex \u2191\u03b2\nL : ConNF.Litter\n\u22a2 (ConNF.StructApprox.ihAction H B).litterMap L =\n    { Dom := { path := B, value := Sum.inr (ConNF.Litter.toNearLitter L) } < c,\n      get := fun h => H.nearLitterImage B (ConNF.Litter.toNearLitter L) h }", "dependency": [1, 60, 1305, 61, 1306, 65, 483, 65, 483, 483]}, "ConNF.StructAction.allowable_exactlyApproximates": {"natural_language_statement": "In the context of Constructive Ordinal Notation (ConNF), the theorem `ConNF.StructAction.allowable_exactlyApproximates` states that given a `\u03b3`-structural action `\u03c6`, a proof `h` that `\u03b3 < \u03b2`, a proof `h\u2081` that `\u03c6` is lawful, and a proof `h\u2082` that `\u03c6` maps flexible litters to flexible litters, the refined and completed `\u03b3`-structural approximation `ConNF.StructAction.rc \u03c6 h\u2081` exactly approximates the `\u03b3`-allowable permutation `ConNF.Allowable.toStructPerm (ConNF.StructAction.allowable \u03c6 h h\u2081 h\u2082)`.", "formal_statement": "example [ConNF.Params ] [ConNF.Level] [ConNF.FOAAssumptions] {\u03b2 : ConNF.\u039b} [ConNF.LeLevel \u2191\u03b2] [ConNF.StructApprox.FreedomOfActionHypothesis \u03b2] {\u03b3 : ConNF.\u039b} [ConNF.LtLevel \u2191\u03b3] (\u03c6 : ConNF.StructAction \u2191\u03b3) (h : \u03b3 < \u03b2) (h\u2081 : ConNF.StructAction.Lawful \u03c6) (h\u2082 : ConNF.StructAction.MapFlexible \u03c6) :ConNF.StructApprox.ExactlyApproximates (ConNF.StructAction.rc \u03c6 h\u2081) (ConNF.Allowable.toStructPerm (ConNF.StructAction.allowable \u03c6 h h\u2081 h\u2082)) := by sorry", "full_tactic_state": "inst\u271d\u2075 : ConNF.Params\ninst\u271d\u2074 : ConNF.Level\ninst\u271d\u00b3 : ConNF.FOAAssumptions\n\u03b2 : ConNF.\u039b\ninst\u271d\u00b2 : ConNF.LeLevel \u2191\u03b2\ninst\u271d\u00b9 : ConNF.StructApprox.FreedomOfActionHypothesis \u03b2\n\u03b3 : ConNF.\u039b\ninst\u271d : ConNF.LtLevel \u2191\u03b3\n\u03c6 : ConNF.StructAction \u2191\u03b3\nh : \u03b3 < \u03b2\nh\u2081 : ConNF.StructAction.Lawful \u03c6\nh\u2082 : ConNF.StructAction.MapFlexible \u03c6\n\u22a2 ConNF.StructApprox.ExactlyApproximates (ConNF.StructAction.rc \u03c6 h\u2081)\n    (ConNF.Allowable.toStructPerm (ConNF.StructAction.allowable \u03c6 h h\u2081 h\u2082))", "dependency": [1, 402, 779, 98, 808, 809, 814, 803, 810, 1309]}, "ConNF.StructAction.hypothesisedAllowable_exactlyApproximates": {"natural_language_statement": "The theorem `ConNF.StructAction.hypothesisedAllowable_exactlyApproximates` states that given a `\u03b2`-structural action `\u03c6`, an inflexible coe path `A`, and two hypotheses (lawfulness and map flexibility), the refined and completed `\u03b2`-structural approximation `ConNF.StructAction.rc (ConNF.Tree.comp (Quiver.Path.cons h.B \u22ef) \u03c6) h\u2081` exactly approximates the allowable permutation `ConNF.Allowable.toStructPerm (ConNF.StructAction.hypothesisedAllowable \u03c6 h h\u2081 h\u2082)`.", "formal_statement": "example [ConNF.Params ] [ConNF.Level] [ConNF.FOAAssumptions] {\u03b2 : ConNF.\u039b} [ConNF.LeLevel \u2191\u03b2] [ConNF.StructApprox.FreedomOfActionHypothesis \u03b2] (\u03c6 : ConNF.StructAction \u2191\u03b2) {A : ConNF.ExtendedIndex \u2191\u03b2} (h : ConNF.InflexibleCoePath A) (h\u2081 : ConNF.StructAction.Lawful (ConNF.Tree.comp (Quiver.Path.cons h.B \u22ef) \u03c6)) (h\u2082 : ConNF.StructAction.MapFlexible (ConNF.Tree.comp (Quiver.Path.cons h.B \u22ef) \u03c6)) :ConNF.StructApprox.ExactlyApproximates (ConNF.StructAction.rc (ConNF.Tree.comp (Quiver.Path.cons h.B \u22ef) \u03c6) h\u2081) (ConNF.Allowable.toStructPerm (ConNF.StructAction.hypothesisedAllowable \u03c6 h h\u2081 h\u2082)) := by sorry", "full_tactic_state": "inst\u271d\u2074 : ConNF.Params\ninst\u271d\u00b3 : ConNF.Level\ninst\u271d\u00b2 : ConNF.FOAAssumptions\n\u03b2 : ConNF.\u039b\ninst\u271d\u00b9 : ConNF.LeLevel \u2191\u03b2\ninst\u271d : ConNF.StructApprox.FreedomOfActionHypothesis \u03b2\n\u03c6 : ConNF.StructAction \u2191\u03b2\nA : ConNF.ExtendedIndex \u2191\u03b2\nh : ConNF.InflexibleCoePath A\nh\u2081 : ConNF.StructAction.Lawful (ConNF.Tree.comp (Quiver.Path.cons h.B \u22ef) \u03c6)\nh\u2082 : ConNF.StructAction.MapFlexible (ConNF.Tree.comp (Quiver.Path.cons h.B \u22ef) \u03c6)\n\u22a2 ConNF.StructApprox.ExactlyApproximates (ConNF.StructAction.rc (ConNF.Tree.comp (Quiver.Path.cons h.B \u22ef) \u03c6) h\u2081)\n    (ConNF.Allowable.toStructPerm (ConNF.StructAction.hypothesisedAllowable \u03c6 h h\u2081 h\u2082))", "dependency": [1, 402, 779, 808, 61, 890, 809, 304, 301, 814, 304, 301, 803, 810, 304, 301, 1311]}, "ConNF.StructApprox.litterCompletion_of_flexible": {"natural_language_statement": "The theorem `ConNF.StructApprox.litterCompletion_of_flexible` is a part of the proof of freedom of action in Constructive Ordinal Notation (ConNF). It states that, given a `\u03b2`-structural approximation `\u03c0`, an extended index `A`, a litter `L`, and a hypothesis `H` about the action of `\u03c0` on `A` and `L`, the litter completion `ConNF.StructApprox.litterCompletion \u03c0 A L H` is equal to the flexible completion `ConNF.NearLitterApprox.flexibleCompletion (\u03c0 A) A \u2022 L`.", "formal_statement": "example [ConNF.Params ] [ConNF.Level] [ConNF.FOAAssumptions] {\u03b2 : ConNF.\u039b} [ConNF.LeLevel \u2191\u03b2] [ConNF.StructApprox.FreedomOfActionHypothesis \u03b2] (\u03c0 : ConNF.StructApprox \u2191\u03b2) (A : ConNF.ExtendedIndex \u2191\u03b2) (L : ConNF.Litter) (H : ConNF.HypAction { path := A, value := Sum.inr (ConNF.Litter.toNearLitter L) }) (hflex : ConNF.Flexible A L) :ConNF.StructApprox.litterCompletion \u03c0 A L H = ConNF.NearLitterApprox.flexibleCompletion (\u03c0 A) A \u2022 L := by sorry", "full_tactic_state": "inst\u271d\u2074 : ConNF.Params\ninst\u271d\u00b3 : ConNF.Level\ninst\u271d\u00b2 : ConNF.FOAAssumptions\n\u03b2 : ConNF.\u039b\ninst\u271d\u00b9 : ConNF.LeLevel \u2191\u03b2\ninst\u271d : ConNF.StructApprox.FreedomOfActionHypothesis \u03b2\n\u03c0 : ConNF.StructApprox \u2191\u03b2\nA : ConNF.ExtendedIndex \u2191\u03b2\nL : ConNF.Litter\nH : ConNF.HypAction { path := A, value := Sum.inr (ConNF.Litter.toNearLitter L) }\nhflex : ConNF.Flexible A L\n\u22a2 ConNF.StructApprox.litterCompletion \u03c0 A L H = ConNF.NearLitterApprox.flexibleCompletion (\u03c0 A) A \u2022 L", "dependency": [1, 402, 779, 781, 61, 1305, 65, 483, 842, 1313, 1314]}, "ConNF.StructApprox.completeAtomMap_eq": {"natural_language_statement": "The theorem `ConNF.StructApprox.completeAtomMap_eq` states that the function `ConNF.StructApprox.completeAtomMap`, which maps each `\u03b2`-extended index to an atom, is equal to the function `ConNF.StructApprox.atomCompletion`, which defines the action of a `\u03b2`-structural approximation `\u03c0` on an atom `a`.", "formal_statement": "example [ConNF.Params ] [ConNF.Level] [ConNF.FOAAssumptions] {\u03b2 : ConNF.\u039b} [ConNF.LeLevel \u2191\u03b2] [ConNF.StructApprox.FreedomOfActionHypothesis \u03b2] {\u03c0 : ConNF.StructApprox \u2191\u03b2} {A : ConNF.ExtendedIndex \u2191\u03b2} {a : ConNF.Atom} :ConNF.StructApprox.completeAtomMap \u03c0 A a = ConNF.StructApprox.atomCompletion \u03c0 A a (ConNF.StructApprox.foaHypothesis \u03c0) := by sorry", "full_tactic_state": "inst\u271d\u2074 : ConNF.Params\ninst\u271d\u00b3 : ConNF.Level\ninst\u271d\u00b2 : ConNF.FOAAssumptions\n\u03b2 : ConNF.\u039b\ninst\u271d\u00b9 : ConNF.LeLevel \u2191\u03b2\ninst\u271d : ConNF.StructApprox.FreedomOfActionHypothesis \u03b2\n\u03c0 : ConNF.StructApprox \u2191\u03b2\nA : ConNF.ExtendedIndex \u2191\u03b2\na : ConNF.Atom\n\u22a2 ConNF.StructApprox.completeAtomMap \u03c0 A a =\n    ConNF.StructApprox.atomCompletion \u03c0 A a (ConNF.StructApprox.foaHypothesis \u03c0)", "dependency": [1, 402, 779, 781, 61, 784, 1316, 1317]}, "ConNF.StructApprox.completeNearLitterMap_eq": {"natural_language_statement": "The theorem `ConNF.StructApprox.completeNearLitterMap_eq` is a part of the proof of freedom of action (FOA) in the context of Constructive Ordinal Notation (ConNF). It states that the function `ConNF.StructApprox.completeNearLitterMap` is equivalent to the function `ConNF.StructApprox.nearLitterCompletion` applied to the inductive hypothesis `ConNF.StructApprox.foaHypothesis`, which is a crucial part of the proof to establish that every free approximation exactly approximates some allowable permutation. This theorem is a key step in demonstrating that the FOA is consistent with the ConNF system, ensuring that the natural numbers can be constructed constructively with the desired properties.", "formal_statement": "example [ConNF.Params ] [ConNF.Level] [ConNF.FOAAssumptions] {\u03b2 : ConNF.\u039b} [ConNF.LeLevel \u2191\u03b2] [ConNF.StructApprox.FreedomOfActionHypothesis \u03b2] {\u03c0 : ConNF.StructApprox \u2191\u03b2} {A : ConNF.ExtendedIndex \u2191\u03b2} {N : ConNF.NearLitter} :ConNF.StructApprox.completeNearLitterMap \u03c0 A N = ConNF.StructApprox.nearLitterCompletion \u03c0 A N (ConNF.StructApprox.foaHypothesis \u03c0) := by sorry", "full_tactic_state": "inst\u271d\u2074 : ConNF.Params\ninst\u271d\u00b3 : ConNF.Level\ninst\u271d\u00b2 : ConNF.FOAAssumptions\n\u03b2 : ConNF.\u039b\ninst\u271d\u00b9 : ConNF.LeLevel \u2191\u03b2\ninst\u271d : ConNF.StructApprox.FreedomOfActionHypothesis \u03b2\n\u03c0 : ConNF.StructApprox \u2191\u03b2\nA : ConNF.ExtendedIndex \u2191\u03b2\nN : ConNF.NearLitter\n\u22a2 ConNF.StructApprox.completeNearLitterMap \u03c0 A N =\n    ConNF.StructApprox.nearLitterCompletion \u03c0 A N (ConNF.StructApprox.foaHypothesis \u03c0)", "dependency": [1, 402, 779, 781, 61, 792, 1319, 1317]}, "ConNF.StructApprox.completeLitterMap_eq": {"natural_language_statement": "The theorem `ConNF.StructApprox.completeLitterMap_eq` states that the function `ConNF.StructApprox.completeLitterMap` is equal to the function `ConNF.StructApprox.litterCompletion` applied to a `\u03b2`-structural approximation `\u03c0`, a `\u03b2`-extended index `A`, a litter `L`, and a hypothesis `ConNF.StructApprox.foaHypothesis \u03c0` about the action of `\u03c0` on `A` and `L`.", "formal_statement": "example [ConNF.Params ] [ConNF.Level] [ConNF.FOAAssumptions] {\u03b2 : ConNF.\u039b} [ConNF.LeLevel \u2191\u03b2] [ConNF.StructApprox.FreedomOfActionHypothesis \u03b2] {\u03c0 : ConNF.StructApprox \u2191\u03b2} {A : ConNF.ExtendedIndex \u2191\u03b2} {L : ConNF.Litter} :ConNF.StructApprox.completeLitterMap \u03c0 A L = ConNF.StructApprox.litterCompletion \u03c0 A L (ConNF.StructApprox.foaHypothesis \u03c0) := by sorry", "full_tactic_state": "inst\u271d\u2074 : ConNF.Params\ninst\u271d\u00b3 : ConNF.Level\ninst\u271d\u00b2 : ConNF.FOAAssumptions\n\u03b2 : ConNF.\u039b\ninst\u271d\u00b9 : ConNF.LeLevel \u2191\u03b2\ninst\u271d : ConNF.StructApprox.FreedomOfActionHypothesis \u03b2\n\u03c0 : ConNF.StructApprox \u2191\u03b2\nA : ConNF.ExtendedIndex \u2191\u03b2\nL : ConNF.Litter\n\u22a2 ConNF.StructApprox.completeLitterMap \u03c0 A L =\n    ConNF.StructApprox.litterCompletion \u03c0 A L (ConNF.StructApprox.foaHypothesis \u03c0)", "dependency": [1, 402, 779, 781, 61, 787, 1313, 1317]}, "ConNF.StructApprox.completeNearLitterMap_fst_eq": {"natural_language_statement": "The theorem `ConNF.StructApprox.completeNearLitterMap_fst_eq` states that for a `\u03b2`-structural approximation `\u03c0`, a `\u03b2`-extended index `A`, and a litter `L`, the first component of the near-litter returned by `ConNF.StructApprox.completeNearLitterMap \u03c0 A (ConNF.Litter.toNearLitter L)` is equal to the litter returned by `ConNF.StructApprox.completeLitterMap \u03c0 A L`.", "formal_statement": "example [ConNF.Params ] [ConNF.Level] [ConNF.FOAAssumptions] {\u03b2 : ConNF.\u039b} [ConNF.LeLevel \u2191\u03b2] [ConNF.StructApprox.FreedomOfActionHypothesis \u03b2] {\u03c0 : ConNF.StructApprox \u2191\u03b2} {A : ConNF.ExtendedIndex \u2191\u03b2} {L : ConNF.Litter} :(ConNF.StructApprox.completeNearLitterMap \u03c0 A (ConNF.Litter.toNearLitter L)).fst = ConNF.StructApprox.completeLitterMap \u03c0 A L := by sorry", "full_tactic_state": "inst\u271d\u2074 : ConNF.Params\ninst\u271d\u00b3 : ConNF.Level\ninst\u271d\u00b2 : ConNF.FOAAssumptions\n\u03b2 : ConNF.\u039b\ninst\u271d\u00b9 : ConNF.LeLevel \u2191\u03b2\ninst\u271d : ConNF.StructApprox.FreedomOfActionHypothesis \u03b2\n\u03c0 : ConNF.StructApprox \u2191\u03b2\nA : ConNF.ExtendedIndex \u2191\u03b2\nL : ConNF.Litter\n\u22a2 (ConNF.StructApprox.completeNearLitterMap \u03c0 A (ConNF.Litter.toNearLitter L)).fst =\n    ConNF.StructApprox.completeLitterMap \u03c0 A L", "dependency": [1, 402, 779, 781, 61, 792, 483, 787]}, "ConNF.StructApprox.completeNearLitterMap_fst_eq'": {"natural_language_statement": "The theorem `ConNF.StructApprox.completeNearLitterMap_fst_eq'` is a part of the proof of freedom of action in Constructive Ordinal Notation (ConNF). It states that the first component of the result of the function `ConNF.StructApprox.completeNearLitterMap` applied to a `\u03b2`-structural approximation `\u03c0`, a `\u03b2`-extended index `A`, and a near-litter `N`, is equal to the result of the function `ConNF.StructApprox.completeLitterMap` applied to `\u03c0`, `A`, and the first component of `N`.", "formal_statement": "@[simp]example [ConNF.Params ] [ConNF.Level] [ConNF.FOAAssumptions] {\u03b2 : ConNF.\u039b} [ConNF.LeLevel \u2191\u03b2] [ConNF.StructApprox.FreedomOfActionHypothesis \u03b2] {\u03c0 : ConNF.StructApprox \u2191\u03b2} {A : ConNF.ExtendedIndex \u2191\u03b2} {N : ConNF.NearLitter} :(ConNF.StructApprox.completeNearLitterMap \u03c0 A N).fst = ConNF.StructApprox.completeLitterMap \u03c0 A N.fst := by sorry", "full_tactic_state": "inst\u271d\u2074 : ConNF.Params\ninst\u271d\u00b3 : ConNF.Level\ninst\u271d\u00b2 : ConNF.FOAAssumptions\n\u03b2 : ConNF.\u039b\ninst\u271d\u00b9 : ConNF.LeLevel \u2191\u03b2\ninst\u271d : ConNF.StructApprox.FreedomOfActionHypothesis \u03b2\n\u03c0 : ConNF.StructApprox \u2191\u03b2\nA : ConNF.ExtendedIndex \u2191\u03b2\nN : ConNF.NearLitter\n\u22a2 (ConNF.StructApprox.completeNearLitterMap \u03c0 A N).fst = ConNF.StructApprox.completeLitterMap \u03c0 A N.fst", "dependency": [1, 402, 779, 781, 61, 792, 787]}, "ConNF.StructApprox.foaHypothesis_atomImage": {"natural_language_statement": "The theorem `ConNF.StructApprox.foaHypothesis_atomImage` is a part of the proof of Freedom of Action in Constructive Ordinal Notation (ConNF). It states that for a `\u03b2`-structural approximation `\u03c0` and a `\u03b2`-extended index `A`, the image of an atom `a` under the function `ConNF.StructApprox.foaHypothesis` is equal to the complete atom map of `\u03c0` applied to `A` and `a`.", "formal_statement": "@[simp]example [ConNF.Params ] [ConNF.Level] [ConNF.FOAAssumptions] {\u03b2 : ConNF.\u039b} [ConNF.LeLevel \u2191\u03b2] [ConNF.StructApprox.FreedomOfActionHypothesis \u03b2] {\u03c0 : ConNF.StructApprox \u2191\u03b2} {A : ConNF.ExtendedIndex \u2191\u03b2} {a : ConNF.Atom} {c : ConNF.Address \u2191\u03b2} (h : { path := A, value := Sum.inl a } < c) :(ConNF.StructApprox.foaHypothesis \u03c0).atomImage A a h = ConNF.StructApprox.completeAtomMap \u03c0 A a := by sorry", "full_tactic_state": "inst\u271d\u2074 : ConNF.Params\ninst\u271d\u00b3 : ConNF.Level\ninst\u271d\u00b2 : ConNF.FOAAssumptions\n\u03b2 : ConNF.\u039b\ninst\u271d\u00b9 : ConNF.LeLevel \u2191\u03b2\ninst\u271d : ConNF.StructApprox.FreedomOfActionHypothesis \u03b2\n\u03c0 : ConNF.StructApprox \u2191\u03b2\nA : ConNF.ExtendedIndex \u2191\u03b2\na : ConNF.Atom\nc : ConNF.Address \u2191\u03b2\nh : { path := A, value := Sum.inl a } < c\n\u22a2 (ConNF.StructApprox.foaHypothesis \u03c0).atomImage A a h = ConNF.StructApprox.completeAtomMap \u03c0 A a", "dependency": [1, 402, 779, 781, 61, 60, 67, 1317, 784]}, "ConNF.StructApprox.foaHypothesis_nearLitterImage": {"natural_language_statement": "The theorem `ConNF.StructApprox.foaHypothesis_nearLitterImage` is a part of the proof of Freedom of Action in Constructive Ordinal Notation (ConNF). It states that for any `\u03b2`-structural approximation `\u03c0`, any `\u03b2`-extended index `A`, and any near-litter `N`, the near-litter image of `A` and `N` under the Freedom of Action hypothesis is equal to the complete near-litter map of `\u03c0` applied to `A` and `N`.", "formal_statement": "@[simp]example [ConNF.Params ] [ConNF.Level] [ConNF.FOAAssumptions] {\u03b2 : ConNF.\u039b} [ConNF.LeLevel \u2191\u03b2] [ConNF.StructApprox.FreedomOfActionHypothesis \u03b2] {\u03c0 : ConNF.StructApprox \u2191\u03b2} {A : ConNF.ExtendedIndex \u2191\u03b2} {N : ConNF.NearLitter} {c : ConNF.Address \u2191\u03b2} (h : { path := A, value := Sum.inr N } < c) :(ConNF.StructApprox.foaHypothesis \u03c0).nearLitterImage A N h = ConNF.StructApprox.completeNearLitterMap \u03c0 A N := by sorry", "full_tactic_state": "inst\u271d\u2074 : ConNF.Params\ninst\u271d\u00b3 : ConNF.Level\ninst\u271d\u00b2 : ConNF.FOAAssumptions\n\u03b2 : ConNF.\u039b\ninst\u271d\u00b9 : ConNF.LeLevel \u2191\u03b2\ninst\u271d : ConNF.StructApprox.FreedomOfActionHypothesis \u03b2\n\u03c0 : ConNF.StructApprox \u2191\u03b2\nA : ConNF.ExtendedIndex \u2191\u03b2\nN : ConNF.NearLitter\nc : ConNF.Address \u2191\u03b2\nh : { path := A, value := Sum.inr N } < c\n\u22a2 (ConNF.StructApprox.foaHypothesis \u03c0).nearLitterImage A N h = ConNF.StructApprox.completeNearLitterMap \u03c0 A N", "dependency": [1, 402, 779, 781, 61, 60, 65, 1317, 792]}, "ConNF.StructApprox.completeAtomMap_eq_of_mem_domain": {"natural_language_statement": "The theorem `ConNF.StructApprox.completeAtomMap_eq_of_mem_domain` states that for a `\u03b2`-structural approximation `\u03c0` and a `\u03b2`-extended index `A`, if an atom `a` is in the domain of the atom permutation of `\u03c0 A`, then the complete atom map of `\u03c0` at `A` applied to `a` is equal to the action of `\u03c0 A` on `a`.", "formal_statement": "example [ConNF.Params ] [ConNF.Level] [ConNF.FOAAssumptions] {\u03b2 : ConNF.\u039b} [ConNF.LeLevel \u2191\u03b2] [ConNF.StructApprox.FreedomOfActionHypothesis \u03b2] {\u03c0 : ConNF.StructApprox \u2191\u03b2} {A : ConNF.ExtendedIndex \u2191\u03b2} {a : ConNF.Atom} (h : a \u2208 (\u03c0 A).atomPerm.domain) :ConNF.StructApprox.completeAtomMap \u03c0 A a = \u03c0 A \u2022 a := by sorry", "full_tactic_state": "inst\u271d\u2074 : ConNF.Params\ninst\u271d\u00b3 : ConNF.Level\ninst\u271d\u00b2 : ConNF.FOAAssumptions\n\u03b2 : ConNF.\u039b\ninst\u271d\u00b9 : ConNF.LeLevel \u2191\u03b2\ninst\u271d : ConNF.StructApprox.FreedomOfActionHypothesis \u03b2\n\u03c0 : ConNF.StructApprox \u2191\u03b2\nA : ConNF.ExtendedIndex \u2191\u03b2\na : ConNF.Atom\nh : a \u2208 (\u03c0 A).atomPerm.domain\n\u22a2 ConNF.StructApprox.completeAtomMap \u03c0 A a = \u03c0 A \u2022 a", "dependency": [1, 402, 779, 781, 61, 784]}, "ConNF.StructApprox.completeLitterMap_eq_of_flexible": {"natural_language_statement": "In the context of Constructive Ordinal Notation (ConNF), the theorem `ConNF.StructApprox.completeLitterMap_eq_of_flexible` states that for a `\u03b2`-structural approximation `\u03c0`, a `\u03b2`-extended index `A`, and a litter `L` that is `A`-flexible, the litter `ConNF.StructApprox.completeLitterMap \u03c0 A L` is equal to `ConNF.NearLitterApprox.flexibleCompletion (\u03c0 A) A \u2022 L`. This theorem serves as a basic definition unfold in the proof of Freedom of Action in Constructive Ordinal Notation (ConNF). The `ConNF.NearLitterApprox.flexibleCompletion` function is crucial in ensuring that the construction of the natural numbers in ConNF is well-defined and consistent.", "formal_statement": "example [ConNF.Params ] [ConNF.Level] [ConNF.FOAAssumptions] {\u03b2 : ConNF.\u039b} [ConNF.LeLevel \u2191\u03b2] [ConNF.StructApprox.FreedomOfActionHypothesis \u03b2] {\u03c0 : ConNF.StructApprox \u2191\u03b2} {A : ConNF.ExtendedIndex \u2191\u03b2} {L : ConNF.Litter} (h : ConNF.Flexible A L) :ConNF.StructApprox.completeLitterMap \u03c0 A L = ConNF.NearLitterApprox.flexibleCompletion (\u03c0 A) A \u2022 L := by sorry", "full_tactic_state": "inst\u271d\u2074 : ConNF.Params\ninst\u271d\u00b3 : ConNF.Level\ninst\u271d\u00b2 : ConNF.FOAAssumptions\n\u03b2 : ConNF.\u039b\ninst\u271d\u00b9 : ConNF.LeLevel \u2191\u03b2\ninst\u271d : ConNF.StructApprox.FreedomOfActionHypothesis \u03b2\n\u03c0 : ConNF.StructApprox \u2191\u03b2\nA : ConNF.ExtendedIndex \u2191\u03b2\nL : ConNF.Litter\nh : ConNF.Flexible A L\n\u22a2 ConNF.StructApprox.completeLitterMap \u03c0 A L = ConNF.NearLitterApprox.flexibleCompletion (\u03c0 A) A \u2022 L", "dependency": [1, 402, 779, 781, 61, 842, 787, 1314]}, "ConNF.StructApprox.toStructPerm_bot": {"natural_language_statement": "The theorem `ConNF.StructApprox.toStructPerm_bot` states that the function `ConNF.Allowable.toStructPerm` is equal to the monoid homomorphism obtained from the multiplicative equivalence `ConNF.Tree.toBotIso`.", "formal_statement": "example [ConNF.Params ] :\u21d1ConNF.Allowable.toStructPerm = \u21d1(MulEquiv.toMonoidHom ConNF.Tree.toBotIso) := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\n\u22a2 \u21d1ConNF.Allowable.toStructPerm = \u21d1(MulEquiv.toMonoidHom ConNF.Tree.toBotIso)", "dependency": [1, 1328]}, "ConNF.StructApprox.completeNearLitterMap_eq'": {"natural_language_statement": "In the context of Constructive Ordinal Notation (ConNF), the theorem `ConNF.StructApprox.completeNearLitterMap_eq'` states that for a `\u03b2`-structural approximation `\u03c0`, a `\u03b2`-extended index `A`, and a near-litter `N`, the near-litter `ConNF.StructApprox.completeNearLitterMap \u03c0 A N` is equal to the symmetric difference of the near-litter `ConNF.StructApprox.completeNearLitterMap \u03c0 A (ConNF.Litter.toNearLitter N.fst)` and the set of atoms `ConNF.StructApprox.completeAtomMap \u03c0 A '' symmDiff (ConNF.litterSet N.fst) \u2191N`.", "formal_statement": "example [ConNF.Params ] [ConNF.Level] [ConNF.FOAAssumptions] {\u03b2 : ConNF.\u039b} [ConNF.LeLevel \u2191\u03b2] [ConNF.StructApprox.FreedomOfActionHypothesis \u03b2] {\u03c0 : ConNF.StructApprox \u2191\u03b2} (A : ConNF.ExtendedIndex \u2191\u03b2) (N : ConNF.NearLitter) :\u2191(ConNF.StructApprox.completeNearLitterMap \u03c0 A N) = symmDiff (\u2191(ConNF.StructApprox.completeNearLitterMap \u03c0 A (ConNF.Litter.toNearLitter N.fst))) (ConNF.StructApprox.completeAtomMap \u03c0 A '' symmDiff (ConNF.litterSet N.fst) \u2191N) := by sorry", "full_tactic_state": "inst\u271d\u2074 : ConNF.Params\ninst\u271d\u00b3 : ConNF.Level\ninst\u271d\u00b2 : ConNF.FOAAssumptions\n\u03b2 : ConNF.\u039b\ninst\u271d\u00b9 : ConNF.LeLevel \u2191\u03b2\ninst\u271d : ConNF.StructApprox.FreedomOfActionHypothesis \u03b2\n\u03c0 : ConNF.StructApprox \u2191\u03b2\nA : ConNF.ExtendedIndex \u2191\u03b2\nN : ConNF.NearLitter\n\u22a2 \u2191(ConNF.StructApprox.completeNearLitterMap \u03c0 A N) =\n    symmDiff (\u2191(ConNF.StructApprox.completeNearLitterMap \u03c0 A (ConNF.Litter.toNearLitter N.fst)))\n      (ConNF.StructApprox.completeAtomMap \u03c0 A '' symmDiff (ConNF.litterSet N.fst) \u2191N)", "dependency": [1, 402, 779, 781, 61, 792, 62, 792, 483, 784, 62, 467]}, "ConNF.StructApprox.eq_of_mem_completeNearLitterMap": {"natural_language_statement": "The theorem `eq_of_mem_completeNearLitterMap` states that, under certain conditions, if two litters both contain an atom `a` that is also contained in the near-litter approximation of a `\u03b2`-extended index `A` for a `\u03b2`-structural approximation `\u03c0`, then the litter maps of `L\u2081` and `L\u2082` will be equal. This theorem is a key step in the proof of freedom of action in Constructive Ordinal Notation (ConNF).", "formal_statement": "example [ConNF.Params ] [ConNF.Level] [ConNF.FOAAssumptions] {\u03b2 : ConNF.\u039b} [ConNF.LeLevel \u2191\u03b2] [ConNF.StructApprox.FreedomOfActionHypothesis \u03b2] {\u03c0 : ConNF.StructApprox \u2191\u03b2} {L\u2081 : ConNF.Litter} {L\u2082 : ConNF.Litter} {A : ConNF.ExtendedIndex \u2191\u03b2} (a : ConNF.Atom) (ha\u2081 : a \u2208 ConNF.StructApprox.completeNearLitterMap \u03c0 A (ConNF.Litter.toNearLitter L\u2081)) (ha\u2082 : a \u2208 ConNF.StructApprox.completeNearLitterMap \u03c0 A (ConNF.Litter.toNearLitter L\u2082)) :ConNF.StructApprox.completeLitterMap \u03c0 A L\u2081 = ConNF.StructApprox.completeLitterMap \u03c0 A L\u2082 := by sorry", "full_tactic_state": "inst\u271d\u2074 : ConNF.Params\ninst\u271d\u00b3 : ConNF.Level\ninst\u271d\u00b2 : ConNF.FOAAssumptions\n\u03b2 : ConNF.\u039b\ninst\u271d\u00b9 : ConNF.LeLevel \u2191\u03b2\ninst\u271d : ConNF.StructApprox.FreedomOfActionHypothesis \u03b2\n\u03c0 : ConNF.StructApprox \u2191\u03b2\nL\u2081 L\u2082 : ConNF.Litter\nA : ConNF.ExtendedIndex \u2191\u03b2\na : ConNF.Atom\nha\u2081 : a \u2208 ConNF.StructApprox.completeNearLitterMap \u03c0 A (ConNF.Litter.toNearLitter L\u2081)\nha\u2082 : a \u2208 ConNF.StructApprox.completeNearLitterMap \u03c0 A (ConNF.Litter.toNearLitter L\u2082)\n\u22a2 ConNF.StructApprox.completeLitterMap \u03c0 A L\u2081 = ConNF.StructApprox.completeLitterMap \u03c0 A L\u2082", "dependency": [1, 402, 779, 781, 61, 792, 483, 792, 483, 787, 787]}, "ConNF.NearLitterApprox.idOnFlexible_domain": {"natural_language_statement": "The theorem `ConNF.NearLitterApprox.idOnFlexible_domain` states that the domain of the partial permutation `ConNF.NearLitterApprox.idOnFlexible` is the set of litters that are `Flexible` with respect to a given `ConNF.ExtendedIndex` `A`, excluding those litters that are already in the domain of the `ConNF.NearLitterApprox` `\u03c0.litterPerm`.", "formal_statement": "example [ConNF.Params ] [ConNF.Level] [ConNF.FOAAssumptions] {\u03b2 : ConNF.TypeIndex} (\u03c0 : ConNF.NearLitterApprox) (A : ConNF.ExtendedIndex \u03b2) :(ConNF.NearLitterApprox.idOnFlexible \u03c0 A).domain = {L : ConNF.Litter | ConNF.Flexible A L} \\ \u03c0.litterPerm.domain := by sorry", "full_tactic_state": "inst\u271d\u00b2 : ConNF.Params\ninst\u271d\u00b9 : ConNF.Level\ninst\u271d : ConNF.FOAAssumptions\n\u03b2 : ConNF.TypeIndex\n\u03c0 : ConNF.NearLitterApprox\nA : ConNF.ExtendedIndex \u03b2\n\u22a2 (ConNF.NearLitterApprox.idOnFlexible \u03c0 A).domain = {L | ConNF.Flexible A L} \\ \u03c0.litterPerm.domain", "dependency": [1, 61, 1332, 842]}, "ConNF.NearLitterApprox.idOnFlexible_domain_disjoint": {"natural_language_statement": "The theorem `ConNF.NearLitterApprox.idOnFlexible_domain_disjoint` asserts that two sets, the domain of the permutation `\u03c0.litterPerm` and the domain of the partial permutation `ConNF.NearLitterApprox.idOnFlexible \u03c0 A`, are disjoint. The domain of `\u03c0.litterPerm` represents the set of litters that are permuted by the `ConNF.NearLitterApprox`, while `ConNF.NearLitterApprox.idOnFlexible \u03c0 A` is a partial permutation that operates only on the set of `Flexible` litters with respect to the `ConNF.ExtendedIndex` `A`, excluding those litters that are already in the domain of `\u03c0.litterPerm`. The theorem states that there is no overlap between these two sets, i.e., no litter is both in the domain of `\u03c0.litterPerm` and in the domain of `ConNF.NearLitterApprox.idOnFlexible \u03c0 A`.", "formal_statement": "example [ConNF.Params ] [ConNF.Level] [ConNF.FOAAssumptions] {\u03b2 : ConNF.TypeIndex} (\u03c0 : ConNF.NearLitterApprox) (A : ConNF.ExtendedIndex \u03b2) :Disjoint \u03c0.litterPerm.domain (ConNF.NearLitterApprox.idOnFlexible \u03c0 A).domain := by sorry", "full_tactic_state": "inst\u271d\u00b2 : ConNF.Params\ninst\u271d\u00b9 : ConNF.Level\ninst\u271d : ConNF.FOAAssumptions\n\u03b2 : ConNF.TypeIndex\n\u03c0 : ConNF.NearLitterApprox\nA : ConNF.ExtendedIndex \u03b2\n\u22a2 Disjoint \u03c0.litterPerm.domain (ConNF.NearLitterApprox.idOnFlexible \u03c0 A).domain", "dependency": [1, 61, 757, 1332]}, "ConNF.NearLitterApprox.flexibleCompletionLitterPerm_domain": {"natural_language_statement": "The theorem `ConNF.NearLitterApprox.flexibleCompletionLitterPerm_domain` states that the domain of the partial permutation `ConNF.NearLitterApprox.flexibleCompletionLitterPerm \u03c0 A` is equal to the union of the domain of the partial permutation `\u03c0.litterPerm` and the set of all *flexible* litters with respect to the extended index `A`.", "formal_statement": "example [ConNF.Params ] [ConNF.Level] [ConNF.FOAAssumptions] {\u03b2 : ConNF.TypeIndex} (\u03c0 : ConNF.NearLitterApprox) (A : ConNF.ExtendedIndex \u03b2) :(ConNF.NearLitterApprox.flexibleCompletionLitterPerm \u03c0 A).domain = \u03c0.litterPerm.domain \u222a {L : ConNF.Litter | ConNF.Flexible A L} := by sorry", "full_tactic_state": "inst\u271d\u00b2 : ConNF.Params\ninst\u271d\u00b9 : ConNF.Level\ninst\u271d : ConNF.FOAAssumptions\n\u03b2 : ConNF.TypeIndex\n\u03c0 : ConNF.NearLitterApprox\nA : ConNF.ExtendedIndex \u03b2\n\u22a2 (ConNF.NearLitterApprox.flexibleCompletionLitterPerm \u03c0 A).domain = \u03c0.litterPerm.domain \u222a {L | ConNF.Flexible A L}", "dependency": [1, 61, 1335, 842]}, "ConNF.NearLitterApprox.flexibleCompletion_litterPerm_domain": {"natural_language_statement": "The theorem `ConNF.NearLitterApprox.flexibleCompletion_litterPerm_domain` states that the domain of the `litterPerm` of the `ConNF.NearLitterApprox` object obtained by applying the `ConNF.NearLitterApprox.flexibleCompletion` function to a `ConNF.NearLitterApprox` object `\u03c0` and an `ConNF.ExtendedIndex` object `A` is equal to the union of the domain of `\u03c0.litterPerm` and the set of all `ConNF.Litter`s that are `ConNF.Flexible` with respect to `A`.", "formal_statement": "example [ConNF.Params ] [ConNF.Level] [ConNF.FOAAssumptions] {\u03b2 : ConNF.TypeIndex} (\u03c0 : ConNF.NearLitterApprox) (A : ConNF.ExtendedIndex \u03b2) :(ConNF.NearLitterApprox.flexibleCompletion \u03c0 A).litterPerm.domain = \u03c0.litterPerm.domain \u222a {L : ConNF.Litter | ConNF.Flexible A L} := by sorry", "full_tactic_state": "inst\u271d\u00b2 : ConNF.Params\ninst\u271d\u00b9 : ConNF.Level\ninst\u271d : ConNF.FOAAssumptions\n\u03b2 : ConNF.TypeIndex\n\u03c0 : ConNF.NearLitterApprox\nA : ConNF.ExtendedIndex \u03b2\n\u22a2 (ConNF.NearLitterApprox.flexibleCompletion \u03c0 A).litterPerm.domain = \u03c0.litterPerm.domain \u222a {L | ConNF.Flexible A L}", "dependency": [1, 61, 1314, 842]}, "ConNF.NearLitterApprox.flexibleCompletion_litterPerm_domain_free": {"natural_language_statement": "The theorem `ConNF.NearLitterApprox.flexibleCompletion_litterPerm_domain_free` states that the domain of the `litterPerm` of the `ConNF.NearLitterApprox` object obtained by applying the `ConNF.NearLitterApprox.flexibleCompletion` function to a `ConNF.NearLitterApprox` object `\u03c0` and an `ConNF.ExtendedIndex` object `A` is exactly the set of all `ConNF.Litter`s that are `ConNF.Flexible` with respect to `A`.", "formal_statement": "example [ConNF.Params ] [ConNF.Level] [ConNF.FOAAssumptions] {\u03b2 : ConNF.TypeIndex} (\u03c0 : ConNF.NearLitterApprox) (A : ConNF.ExtendedIndex \u03b2) (h\u03c0 : ConNF.NearLitterApprox.Free \u03c0 A) :(ConNF.NearLitterApprox.flexibleCompletion \u03c0 A).litterPerm.domain = {L : ConNF.Litter | ConNF.Flexible A L} := by sorry", "full_tactic_state": "inst\u271d\u00b2 : ConNF.Params\ninst\u271d\u00b9 : ConNF.Level\ninst\u271d : ConNF.FOAAssumptions\n\u03b2 : ConNF.TypeIndex\n\u03c0 : ConNF.NearLitterApprox\nA : ConNF.ExtendedIndex \u03b2\nh\u03c0 : ConNF.NearLitterApprox.Free \u03c0 A\n\u22a2 (ConNF.NearLitterApprox.flexibleCompletion \u03c0 A).litterPerm.domain = {L | ConNF.Flexible A L}", "dependency": [1, 61, 1338, 1314, 842]}, "ConNF.NearLitterApprox.flexibleCompletion_smul_eq": {"natural_language_statement": "The theorem `ConNF.NearLitterApprox.flexibleCompletion_smul_eq` states that for a `ConNF.NearLitterApprox` object `\u03c0` and an `ConNF.ExtendedIndex` object `A`, the action of `ConNF.NearLitterApprox.flexibleCompletion \u03c0 A` on a `ConNF.Litter` object `L` is equal to the application of the partial permutation `ConNF.NearLitterApprox.flexibleCompletionLitterPerm \u03c0 A` to `L`.", "formal_statement": "example [ConNF.Params ] [ConNF.Level] [ConNF.FOAAssumptions] {\u03b2 : ConNF.TypeIndex} (\u03c0 : ConNF.NearLitterApprox) (A : ConNF.ExtendedIndex \u03b2) (L : ConNF.Litter) :ConNF.NearLitterApprox.flexibleCompletion \u03c0 A \u2022 L = (ConNF.NearLitterApprox.flexibleCompletionLitterPerm \u03c0 A).toFun L := by sorry", "full_tactic_state": "inst\u271d\u00b2 : ConNF.Params\ninst\u271d\u00b9 : ConNF.Level\ninst\u271d : ConNF.FOAAssumptions\n\u03b2 : ConNF.TypeIndex\n\u03c0 : ConNF.NearLitterApprox\nA : ConNF.ExtendedIndex \u03b2\nL : ConNF.Litter\n\u22a2 ConNF.NearLitterApprox.flexibleCompletion \u03c0 A \u2022 L = (ConNF.NearLitterApprox.flexibleCompletionLitterPerm \u03c0 A).toFun L", "dependency": [1, 61, 1314, 1335]}, "ConNF.NearLitterApprox.flexibleCompletion_smul_of_mem_domain": {"natural_language_statement": "The theorem `ConNF.NearLitterApprox.flexibleCompletion_smul_of_mem_domain` states that for any `ConNF.NearLitterApprox` object `\u03c0`, any `ConNF.ExtendedIndex` object `A`, and any `ConNF.Litter` object `L` that is in the domain of `\u03c0.litterPerm`, the action of `ConNF.NearLitterApprox.flexibleCompletion \u03c0 A` on `L` is equal to the action of `\u03c0.litterPerm` on `L`.", "formal_statement": "example [ConNF.Params ] [ConNF.Level] [ConNF.FOAAssumptions] {\u03b2 : ConNF.TypeIndex} (\u03c0 : ConNF.NearLitterApprox) (A : ConNF.ExtendedIndex \u03b2) (L : ConNF.Litter) (hL : L \u2208 \u03c0.litterPerm.domain) :ConNF.NearLitterApprox.flexibleCompletion \u03c0 A \u2022 L = \u03c0.litterPerm.toFun L := by sorry", "full_tactic_state": "inst\u271d\u00b2 : ConNF.Params\ninst\u271d\u00b9 : ConNF.Level\ninst\u271d : ConNF.FOAAssumptions\n\u03b2 : ConNF.TypeIndex\n\u03c0 : ConNF.NearLitterApprox\nA : ConNF.ExtendedIndex \u03b2\nL : ConNF.Litter\nhL : L \u2208 \u03c0.litterPerm.domain\n\u22a2 ConNF.NearLitterApprox.flexibleCompletion \u03c0 A \u2022 L = \u03c0.litterPerm.toFun L", "dependency": [1, 61, 1314]}, "ConNF.NearLitterApprox.flexibleCompletion_smul_flexible": {"natural_language_statement": "The theorem `ConNF.NearLitterApprox.flexibleCompletion_smul_flexible` states that if `\u03c0` is a `ConNF.NearLitterApprox` object that is `ConNF.NearLitterApprox.Free` with respect to an `ConNF.ExtendedIndex` object `A`, and `L` is a `ConNF.Litter` object that is `ConNF.Flexible` with respect to `A`, then the `ConNF.NearLitterApprox.flexibleCompletion` of `\u03c0` with respect to `A` applied to `L` is also `ConNF.Flexible` with respect to `A`.", "formal_statement": "example [ConNF.Params ] [ConNF.Level] [ConNF.FOAAssumptions] {\u03b2 : ConNF.TypeIndex} (\u03c0 : ConNF.NearLitterApprox) (A : ConNF.ExtendedIndex \u03b2) (h\u03c0 : ConNF.NearLitterApprox.Free \u03c0 A) (L : ConNF.Litter) (hL : ConNF.Flexible A L) :ConNF.Flexible A (ConNF.NearLitterApprox.flexibleCompletion \u03c0 A \u2022 L) := by sorry", "full_tactic_state": "inst\u271d\u00b2 : ConNF.Params\ninst\u271d\u00b9 : ConNF.Level\ninst\u271d : ConNF.FOAAssumptions\n\u03b2 : ConNF.TypeIndex\n\u03c0 : ConNF.NearLitterApprox\nA : ConNF.ExtendedIndex \u03b2\nh\u03c0 : ConNF.NearLitterApprox.Free \u03c0 A\nL : ConNF.Litter\nhL : ConNF.Flexible A L\n\u22a2 ConNF.Flexible A (ConNF.NearLitterApprox.flexibleCompletion \u03c0 A \u2022 L)", "dependency": [1, 61, 1338, 842, 842, 1314]}, "ConNF.NearLitterApprox.flexibleCompletion_symm_smul_flexible": {"natural_language_statement": "In the context of Constructive Ordinal Notation (ConNF), the theorem `ConNF.NearLitterApprox.flexibleCompletion_symm_smul_flexible` asserts that given a `ConNF.NearLitterApprox` object `\u03c0`, an `ConNF.ExtendedIndex` object `A`, and a `ConNF.Litter` object `L`, if `\u03c0` is `ConNF.NearLitterApprox.Free` with respect to `A` and `L` is `ConNF.Flexible` with respect to `A`, then `ConNF.NearLitterApprox.symm (ConNF.NearLitterApprox.flexibleCompletion \u03c0 A) \u2022 L` is also `ConNF.Flexible` with respect to `A`. This property is crucial in ensuring that the construction of the natural numbers in ConNF is well-defined and consistent.", "formal_statement": "example [ConNF.Params ] [ConNF.Level] [ConNF.FOAAssumptions] {\u03b2 : ConNF.TypeIndex} (\u03c0 : ConNF.NearLitterApprox) (A : ConNF.ExtendedIndex \u03b2) (h\u03c0 : ConNF.NearLitterApprox.Free \u03c0 A) (L : ConNF.Litter) (hL : ConNF.Flexible A L) :ConNF.Flexible A (ConNF.NearLitterApprox.symm (ConNF.NearLitterApprox.flexibleCompletion \u03c0 A) \u2022 L) := by sorry", "full_tactic_state": "inst\u271d\u00b2 : ConNF.Params\ninst\u271d\u00b9 : ConNF.Level\ninst\u271d : ConNF.FOAAssumptions\n\u03b2 : ConNF.TypeIndex\n\u03c0 : ConNF.NearLitterApprox\nA : ConNF.ExtendedIndex \u03b2\nh\u03c0 : ConNF.NearLitterApprox.Free \u03c0 A\nL : ConNF.Litter\nhL : ConNF.Flexible A L\n\u22a2 ConNF.Flexible A (ConNF.NearLitterApprox.symm (ConNF.NearLitterApprox.flexibleCompletion \u03c0 A) \u2022 L)", "dependency": [1, 61, 1338, 842, 842, 1223, 1314]}, "ConNF.StructApprox.nearLitterCompletionMap_isNearLitter": {"natural_language_statement": "In the context of Constructive Ordinal Notation (ConNF), the theorem `ConNF.StructApprox.nearLitterCompletionMap_isNearLitter` states that given a `\u03b2`-structural approximation `\u03c0`, an extended index `A`, a near-litter `N`, and a hypothesis `H` about the action of `\u03c0` on `A` and `N`, the litter returned by the function `ConNF.StructApprox.litterCompletion` is near the near-litter returned by the function `ConNF.StructApprox.nearLitterCompletionMap`.", "formal_statement": "example [ConNF.Params ] [ConNF.Level] [ConNF.FOAAssumptions] {\u03b2 : ConNF.\u039b} [ConNF.LeLevel \u2191\u03b2] [ConNF.StructApprox.FreedomOfActionHypothesis \u03b2] (\u03c0 : ConNF.StructApprox \u2191\u03b2) (A : ConNF.ExtendedIndex \u2191\u03b2) (N : ConNF.NearLitter) (H : ConNF.HypAction { path := A, value := Sum.inr N }) :ConNF.IsNearLitter (ConNF.StructApprox.litterCompletion \u03c0 A N.fst (ConNF.StructApprox.nearLitterHypothesis A N H)) (ConNF.StructApprox.nearLitterCompletionMap \u03c0 A N H) := by sorry", "full_tactic_state": "inst\u271d\u2074 : ConNF.Params\ninst\u271d\u00b3 : ConNF.Level\ninst\u271d\u00b2 : ConNF.FOAAssumptions\n\u03b2 : ConNF.\u039b\ninst\u271d\u00b9 : ConNF.LeLevel \u2191\u03b2\ninst\u271d : ConNF.StructApprox.FreedomOfActionHypothesis \u03b2\n\u03c0 : ConNF.StructApprox \u2191\u03b2\nA : ConNF.ExtendedIndex \u2191\u03b2\nN : ConNF.NearLitter\nH : ConNF.HypAction { path := A, value := Sum.inr N }\n\u22a2 ConNF.IsNearLitter (ConNF.StructApprox.litterCompletion \u03c0 A N.fst (ConNF.StructApprox.nearLitterHypothesis A N H))\n    (ConNF.StructApprox.nearLitterCompletionMap \u03c0 A N H)", "dependency": [1, 402, 779, 781, 61, 1305, 65, 466, 1313, 1344, 1345]}, "ConNF.StructApprox.nearLitterCompletion_fst_eq": {"natural_language_statement": "The theorem `ConNF.StructApprox.nearLitterCompletion_fst_eq` is a part of the proof of freedom of action in Constructive Ordinal Notation (ConNF). It states that for a `\u03b2`-structural approximation `\u03c0`, a `\u03b2`-extended index `A`, a near-litter `N`, and a hypothesis `H` about the action of `\u03c0` on `A` and `N`, the first component of the near-litter completion `ConNF.StructApprox.nearLitterCompletion \u03c0 A N H` is equal to the litter completion `ConNF.StructApprox.litterCompletion \u03c0 A N.fst (ConNF.StructApprox.nearLitterHypothesis A N H)`.", "formal_statement": "@[simp]example [ConNF.Params ] [ConNF.Level] [ConNF.FOAAssumptions] {\u03b2 : ConNF.\u039b} [ConNF.LeLevel \u2191\u03b2] [ConNF.StructApprox.FreedomOfActionHypothesis \u03b2] (\u03c0 : ConNF.StructApprox \u2191\u03b2) (A : ConNF.ExtendedIndex \u2191\u03b2) (N : ConNF.NearLitter) (H : ConNF.HypAction { path := A, value := Sum.inr N }) :(ConNF.StructApprox.nearLitterCompletion \u03c0 A N H).fst = ConNF.StructApprox.litterCompletion \u03c0 A N.fst (ConNF.StructApprox.nearLitterHypothesis A N H) := by sorry", "full_tactic_state": "inst\u271d\u2074 : ConNF.Params\ninst\u271d\u00b3 : ConNF.Level\ninst\u271d\u00b2 : ConNF.FOAAssumptions\n\u03b2 : ConNF.\u039b\ninst\u271d\u00b9 : ConNF.LeLevel \u2191\u03b2\ninst\u271d : ConNF.StructApprox.FreedomOfActionHypothesis \u03b2\n\u03c0 : ConNF.StructApprox \u2191\u03b2\nA : ConNF.ExtendedIndex \u2191\u03b2\nN : ConNF.NearLitter\nH : ConNF.HypAction { path := A, value := Sum.inr N }\n\u22a2 (ConNF.StructApprox.nearLitterCompletion \u03c0 A N H).fst =\n    ConNF.StructApprox.litterCompletion \u03c0 A N.fst (ConNF.StructApprox.nearLitterHypothesis A N H)", "dependency": [1, 402, 779, 781, 61, 1305, 65, 1319, 1313, 1344]}, "ConNF.StructApprox.equiv_apply_mem": {"natural_language_statement": "The theorem `ConNF.StructApprox.equiv_apply_mem` states that for any two sublitters `S` and `T` in the context of Constructive Ordinal Notation (ConNF), and any atom `a` in `S`, if the image of `a` under the equivalence `ConNF.Sublitter.equiv S T` belongs to the set `ConNF.litterSet L` for some litter `L`, then the litter corresponding to `T` is equal to `L`.", "formal_statement": "example [ConNF.Params ] {S : ConNF.Sublitter} {T : ConNF.Sublitter} {a : \u21a5S} {L : ConNF.Litter} (h : \u2191((ConNF.Sublitter.equiv S T) a) \u2208 ConNF.litterSet L) :T.litter = L := by sorry", "full_tactic_state": "inst\u271d : ConNF.Params\nS T : ConNF.Sublitter\na : \u21a5S\nL : ConNF.Litter\nh : \u2191((ConNF.Sublitter.equiv S T) a) \u2208 ConNF.litterSet L\n\u22a2 T.litter = L", "dependency": [1, 876, 467]}}