{"full_name": "ConNF.mem_cloud", "url": "ConNF/NewTangle/Cloud.html#ConNF.mem_cloud", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.mem_cloud [ConNF.Params🔗<|PREMISE|>🔗 ] {γ : ConNF.TypeIndex} [ConNF.TangleData🔗<|PREMISE|>🔗 γ] [ConNF.PositionedTangles🔗<|PREMISE|>🔗 γ] {β : ConNF.Λ} [ConNF.TangleData🔗<|PREMISE|>🔗 ↑β] [ConNF.PositionedTangles🔗<|PREMISE|>🔗 ↑β] [ConNF.TypedObjects🔗<|PREMISE|>🔗 β] {hγβ : γ ≠ ↑β} {t : ConNF.Tangle ↑β} {s : Set🔗<|PREMISE|>🔗 (ConNF.Tangle γ)} :t ∈ ConNF.cloud🔗<|PREMISE|>🔗 hγβ s ↔ ∃ t' ∈ s, ∃ (N : ConNF.NearLitter), N.fst = ConNF.fuzz🔗<|PREMISE|>🔗 hγβ t' ∧ t = ConNF.typedNearLitter N", "code": "theorem mem_cloud {t : Tangle β} {s : Set (Tangle γ)} :\n    t ∈ cloud hγβ s ↔\n      ∃ t' ∈ s, ∃ (N : NearLitter), N.1 = fuzz hγβ t' ∧ t = typedNearLitter N := by\n  simp only [cloud, mem_image, mem_iUnion, mem_localCardinal, exists_prop]\n  constructor\n  · rintro ⟨N, ⟨t, ht₁, ht₂⟩, rfl⟩\n    exact ⟨t, ht₁, N, ht₂, rfl⟩\n  · rintro ⟨t, ht₁, N, ht₂, rfl⟩\n    exact ⟨N, ⟨t, ht₁, ht₂⟩, rfl⟩\n", "additional_info": "", "used_premises": [1, 39, 72, 39, 72, 73, 69, 77, 78], "def_path": "ConNF/NewTangle/Cloud.lean", "pos": [56, 65], "informalization": "The `ConNF.mem_cloud` theorem in the context of Constructive Ordinal Notation (ConNF) in Lean 4 states that a tangle `t` of type `β` belongs to the `ConNF.cloud` of a set `s` of tangles of type `γ` if and only if there exists a tangle `t'` in `s` and a near-litter `N` such that `N` is the `ConNF.fuzz` of `t'` and `t` is the `ConNF.typedNearLitter` of `N`."}
{"full_name": "ConNF.Params", "url": "ConNF/BaseType/Params.html#ConNF.Params", "code_src": "con-nf", "ptype": "class", "header": "class ConNF.Params :Type (u + 1)\n | Λ : Type  u\n | Λ_linearOrder : LinearOrder🔗<|PREMISE|>🔗  ConNF.Λ\n | Λ_isWellOrder : IsWellOrder🔗<|PREMISE|>🔗  ConNF.Λ fun (x x_1 : ConNF.Λ) => x <  x_1\n | Λ_zero : Zero🔗<|PREMISE|>🔗  ConNF.Λ\n | Λ_succ : SuccOrder🔗<|PREMISE|>🔗  ConNF.Λ\n | Λ_zero_le : ∀ (α : ConNF.Λ), 0 ≤  α\n | Λ_isLimit : Ordinal.IsLimit🔗<|PREMISE|>🔗  (Ordinal.type🔗<|PREMISE|>🔗  fun (x x_1 : ConNF.Λ) => x <  x_1)\n | κ : Type  u\n | κ_linearOrder : LinearOrder🔗<|PREMISE|>🔗  ConNF.κ\n | κ_isWellOrder : IsWellOrder🔗<|PREMISE|>🔗  ConNF.κ fun (x x_1 : ConNF.κ) => x <  x_1\n | κ_ord : (Ordinal.type🔗<|PREMISE|>🔗  fun (x x_1 : ConNF.κ) => x <  x_1) =  Cardinal.ord🔗<|PREMISE|>🔗  (Cardinal.mk🔗<|PREMISE|>🔗  ConNF.κ)\n | κ_isRegular : Cardinal.IsRegular🔗<|PREMISE|>🔗  (Cardinal.mk🔗<|PREMISE|>🔗  ConNF.κ)\n | κ_succ : SuccOrder🔗<|PREMISE|>🔗  ConNF.κ\n | κ_addMonoid : AddMonoid🔗<|PREMISE|>🔗  ConNF.κ\n | κ_sub : Sub🔗<|PREMISE|>🔗  ConNF.κ\n | κ_add_typein : ∀ (i j : ConNF.κ),\n Ordinal.typein🔗<|PREMISE|>🔗  (fun (x x_1 : ConNF.κ) => x <  x_1) (i +  j) =  Ordinal.typein🔗<|PREMISE|>🔗  (fun (x x_1 : ConNF.κ) => x <  x_1) i +  Ordinal.typein🔗<|PREMISE|>🔗  (fun (x x_1 : ConNF.κ) => x <  x_1) j\n | κ_sub_typein : ∀ (i j : ConNF.κ),\n Ordinal.typein🔗<|PREMISE|>🔗  (fun (x x_1 : ConNF.κ) => x <  x_1) (i -  j) =  Ordinal.typein🔗<|PREMISE|>🔗  (fun (x x_1 : ConNF.κ) => x <  x_1) i -  Ordinal.typein🔗<|PREMISE|>🔗  (fun (x x_1 : ConNF.κ) => x <  x_1) j\n | Λ_lt_κ : Cardinal.mk🔗<|PREMISE|>🔗  ConNF.Λ <  Cardinal.mk🔗<|PREMISE|>🔗  ConNF.κ\n | μ : Type  u\n | μ_linearOrder : LinearOrder🔗<|PREMISE|>🔗  ConNF.μ\n | μ_isWellOrder : IsWellOrder🔗<|PREMISE|>🔗  ConNF.μ fun (x x_1 : ConNF.μ) => x <  x_1\n | μ_ord : (Ordinal.type🔗<|PREMISE|>🔗  fun (x x_1 : ConNF.μ) => x <  x_1) =  Cardinal.ord🔗<|PREMISE|>🔗  (Cardinal.mk🔗<|PREMISE|>🔗  ConNF.μ)\n | μ_isStrongLimit : Cardinal.IsStrongLimit🔗<|PREMISE|>🔗  (Cardinal.mk🔗<|PREMISE|>🔗  ConNF.μ)\n | κ_lt_μ : Cardinal.mk🔗<|PREMISE|>🔗  ConNF.κ <  Cardinal.mk🔗<|PREMISE|>🔗  ConNF.μ\n | κ_le_μ_ord_cof : Cardinal.mk🔗<|PREMISE|>🔗  ConNF.κ ≤  Ordinal.cof🔗<|PREMISE|>🔗  (Cardinal.ord🔗<|PREMISE|>🔗  (Cardinal.mk🔗<|PREMISE|>🔗  ConNF.μ))", "code": "class Params where\n  /--\n  The type indexing the levels of our model.\n  This type is well-ordered.\n  We inductively construct each type level by induction over `Λ`.\n  Its cardinality is smaller than `κ` and `μ`.\n  -/\n  Λ : Type u\n  [Λ_linearOrder : LinearOrder Λ]\n  [Λ_isWellOrder : IsWellOrder Λ (· < ·)]\n  [Λ_zero : Zero Λ]\n  [Λ_succ : SuccOrder Λ]\n  Λ_zero_le (α : Λ) : 0 ≤ α\n  Λ_isLimit : (Ordinal.type ((· < ·) : Λ → Λ → Prop)).IsLimit\n  /--\n  The type indexing the atoms in each litter.\n  Its cardinality is regular, and is larger than `Λ` but smaller than `κ`.\n  It also has an additive monoid structure, which is covariant in both variables with respect to the\n  ordering.\n  -/\n  κ : Type u\n  [κ_linearOrder : LinearOrder κ]\n  [κ_isWellOrder : IsWellOrder κ (· < ·)]\n  κ_ord : Ordinal.type ((· < ·) : κ → κ → Prop) = (#κ).ord\n  κ_isRegular : (#κ).IsRegular\n  [κ_succ : SuccOrder κ]\n  [κ_addMonoid : AddMonoid κ]\n  [κ_sub : Sub κ]\n  κ_add_typein (i j : κ) : Ordinal.typein (· < ·) (i + j : κ) =\n    Ordinal.typein (· < ·) i + Ordinal.typein (· < ·) j\n  κ_sub_typein (i j : κ) : Ordinal.typein (· < ·) (i - j : κ) =\n    Ordinal.typein (· < ·) i - Ordinal.typein (· < ·) j\n  Λ_lt_κ : #Λ < #κ\n  /--\n  A large type used in indexing the litters.\n  This type is well-ordered.\n  Its cardinality is a strong limit, larger than `Λ` and `κ`.\n  The cofinality of the order type of `μ` is at least `κ`.\n  -/\n  μ : Type u\n  [μ_linearOrder : LinearOrder μ]\n  [μ_isWellOrder : IsWellOrder μ (· < ·)]\n  μ_ord : Ordinal.type ((· < ·) : μ → μ → Prop) = (#μ).ord\n  μ_isStrongLimit : (#μ).IsStrongLimit\n  κ_lt_μ : #κ < #μ\n  κ_le_μ_ord_cof : #κ ≤ (#μ).ord.cof\n", "additional_info": "The parameters of the construction. We collect them all in one class for simplicity.\nNote that the ordinal `λ` in the paper is instead referred to here as `🗟Λ🗟🔗../.././ConNF/BaseType/Params.html#ConNF.Params.Λ🔗` , since the symbol `λ` is\nused for lambda abstractions.\nOrdinals and cardinals are represented here as arbitrary types (not sets) with certain properties.\nFor instance, `🗟Λ🗟🔗../.././ConNF/BaseType/Params.html#ConNF.Params.Λ🔗`  is an arbitrary type that has an ordering `<`, which is assumed to be a\nwell-ordering (the `Λwo` term is a proof of this fact).\nThe prefix `#` denotes the cardinality of a type.\n- ConNF.Params.Λ: The type indexing the levels of our model.\nThis type is well-ordered.\nWe inductively construct each type level by induction over `🗟Λ🗟🔗../.././ConNF/BaseType/Params.html#ConNF.Params.Λ🔗` .\nIts cardinality is smaller than `🗟κ🗟🔗../.././ConNF/BaseType/Params.html#ConNF.Params.κ🔗`  and `🗟μ🗟🔗../.././ConNF/BaseType/Params.html#ConNF.Params.μ🔗` .\n\n\n- ConNF.Params.κ: The type indexing the atoms in each litter.\nIts cardinality is regular, and is larger than `🗟Λ🗟🔗../.././ConNF/BaseType/Params.html#ConNF.Params.Λ🔗`  but smaller than `🗟κ🗟🔗../.././ConNF/BaseType/Params.html#ConNF.Params.κ🔗` .\nIt also has an additive monoid structure, which is covariant in both variables with respect to the\nordering.\n\n\n- ConNF.Params.μ: A large type used in indexing the litters.\nThis type is well-ordered.\nIts cardinality is a strong limit, larger than `🗟Λ🗟🔗../.././ConNF/BaseType/Params.html#ConNF.Params.Λ🔗`  and `🗟κ🗟🔗../.././ConNF/BaseType/Params.html#ConNF.Params.κ🔗` .\nThe cofinality of the order type of `🗟μ🗟🔗../.././ConNF/BaseType/Params.html#ConNF.Params.μ🔗`  is at least `🗟κ🗟🔗../.././ConNF/BaseType/Params.html#ConNF.Params.κ🔗` .\n\n\n", "used_premises": [2, 15, 20, 21, 24, 26, 2, 15, 26, 27, 29, 30, 29, 21, 31, 35, 36, 36, 36, 36, 36, 36, 29, 29, 2, 15, 26, 27, 29, 37, 29, 29, 29, 29, 38, 27, 29], "def_path": "ConNF/BaseType/Params.lean", "pos": [32, 78], "informalization": "The `ConNF.Params` class in Lean 4 defines a set of parameters that are used in the construction of the natural numbers in the context of Constructive Ordinal Notation (ConNF). These parameters include the types `Λ`, `κ`, and `μ`, along with various properties and relationships between these types, such as linear orders, well-orders, zero elements, successor orders, and subtraction operations. Additionally, there are conditions on the cardinalities of these types and their cofinalities."}
{"full_name": "LinearOrder", "url": "Mathlib/Init/Order/Defs.html#LinearOrder", "code_src": "mathlib4", "ptype": "class", "header": "class LinearOrder (α : Type u) extends PartialOrder🔗<|PREMISE|>🔗 , Min🔗<|PREMISE|>🔗 , Max🔗<|PREMISE|>🔗 , Ord🔗<|PREMISE|>🔗 :Type u\n | le : α → α → Prop \n | lt : α → α → Prop \n | le_refl : ∀ (a : α), a ≤  a\n | le_trans : ∀ (a b c : α), a ≤  b → b ≤  c → a ≤  c\n | lt_iff_le_not_le : ∀ (a b : α), a <  b ↔  a ≤  b ∧  ¬ b ≤  a\n | le_antisymm : ∀ (a b : α), a ≤  b → b ≤  a → a =  b\n | min : α → α → α\n | max : α → α → α\n | compare : α → α → Ordering🔗<|PREMISE|>🔗 \n | le_total : ∀ (a b : α), a ≤  b ∨  b ≤  a\n | decidableLE : DecidableRel🔗<|PREMISE|>🔗  fun (x x_1 : α) => x ≤  x_1\n | decidableEq : DecidableEq🔗<|PREMISE|>🔗  α\n | decidableLT : DecidableRel🔗<|PREMISE|>🔗  fun (x x_1 : α) => x <  x_1\n | min_def : ∀ (a b : α), min  a b =  if a ≤  b then a else b\n | max_def : ∀ (a b : α), max  a b =  if a ≤  b then b else a\n | compare_eq_compareOfLessAndEq : ∀ (a b : α), compare  a b =  compareOfLessAndEq🔗<|PREMISE|>🔗  a b", "code": "class LinearOrder (α : Type u) extends PartialOrder α, Min α, Max α, Ord α :=\n  /-- A linear order is total. -/\n  le_total (a b : α) : a ≤ b ∨ b ≤ a\n  /-- In a linearly ordered type, we assume the order relations are all decidable. -/\n  decidableLE : DecidableRel (· ≤ · : α → α → Prop)\n  /-- In a linearly ordered type, we assume the order relations are all decidable. -/\n  decidableEq : DecidableEq α := @decidableEqOfDecidableLE _ _ decidableLE\n  /-- In a linearly ordered type, we assume the order relations are all decidable. -/\n  decidableLT : DecidableRel (· < · : α → α → Prop) :=\n    @decidableLTOfDecidableLE _ _ decidableLE\n  min := fun a b => if a ≤ b then a else b\n  max := fun a b => if a ≤ b then b else a\n  /-- The minimum function is equivalent to the one you get from `minOfLe`. -/\n  min_def : ∀ a b, min a b = if a ≤ b then a else b := by intros; rfl\n  /-- The minimum function is equivalent to the one you get from `maxOfLe`. -/\n  max_def : ∀ a b, max a b = if a ≤ b then b else a := by intros; rfl\n  compare a b := compareOfLessAndEq a b\n  /-- Comparison via `compare` is equal to the canonical comparison given decidable `<` and `=`. -/\n  compare_eq_compareOfLessAndEq : ∀ a b, compare a b = compareOfLessAndEq a b := by\n    compareOfLessAndEq_rfl\n", "additional_info": "A linear order is reflexive, transitive, antisymmetric and total relation `≤`.\nWe assume that every linear ordered type has decidable `(≤)`, `(<)`, and `(=)`.\n- LinearOrder.le_total: A linear order is total.\n\n\n- LinearOrder.decidableLE: In a linearly ordered type, we assume the order relations are all decidable.\n\n\n- LinearOrder.decidableEq: In a linearly ordered type, we assume the order relations are all decidable.\n\n\n- LinearOrder.decidableLT: In a linearly ordered type, we assume the order relations are all decidable.\n\n\n- LinearOrder.min_def: The minimum function is equivalent to the one you get from `🗟minOfLe🗟🔗../../.././Init/Prelude.html#minOfLe🔗` .\n\n\n- LinearOrder.max_def: The minimum function is equivalent to the one you get from `🗟maxOfLe🗟🔗../../.././Init/Prelude.html#maxOfLe🔗` .\n\n\n- LinearOrder.compare_eq_compareOfLessAndEq: Comparison via `compare` is equal to the canonical comparison given decidable `<` and `=`.\n\n\n", "used_premises": [3, 7, 8, 9, 10, 11, 12, 11, 13], "def_path": "Mathlib/Init/Order/Defs.lean", "pos": [262, 282], "informalization": "Class `LinearOrder` represents a type `α` with a total, reflexive, transitive, and antisymmetric binary relation `≤`, along with decidable comparisons and operations for minimum and maximum."}
{"full_name": "PartialOrder", "url": "Mathlib/Init/Order/Defs.html#PartialOrder", "code_src": "mathlib4", "ptype": "class", "header": "class PartialOrder (α : Type u) extends Preorder🔗<|PREMISE|>🔗 :Type u\n | le : α → α → Prop \n | lt : α → α → Prop \n | le_refl : ∀ (a : α), a ≤  a\n | le_trans : ∀ (a b c : α), a ≤  b → b ≤  c → a ≤  c\n | lt_iff_le_not_le : ∀ (a b : α), a <  b ↔  a ≤  b ∧  ¬ b ≤  a\n | le_antisymm : ∀ (a b : α), a ≤  b → b ≤  a → a =  b", "code": "class PartialOrder (α : Type u) extends Preorder α where\n  le_antisymm : ∀ a b : α, a ≤ b → b ≤ a → a = b\n", "additional_info": "A partial order is a reflexive, transitive, antisymmetric relation `≤`.\n", "used_premises": [4], "def_path": "Mathlib/Init/Order/Defs.lean", "pos": [175, 177], "informalization": "Class `PartialOrder` represents a type with a reflexive, transitive, and antisymmetric binary relation `≤`, where `a ≤ b ∧ b ≤ a → a = b`."}
{"full_name": "Preorder", "url": "Mathlib/Init/Order/Defs.html#Preorder", "code_src": "mathlib4", "ptype": "class", "header": "class Preorder (α : Type u) extends LE🔗<|PREMISE|>🔗 , LT🔗<|PREMISE|>🔗 :Type u\n | le : α → α → Prop \n | lt : α → α → Prop \n | le_refl : ∀ (a : α), a ≤  a\n | le_trans : ∀ (a b c : α), a ≤  b → b ≤  c → a ≤  c\n | lt_iff_le_not_le : ∀ (a b : α), a <  b ↔  a ≤  b ∧  ¬ b ≤  a", "code": "class Preorder (α : Type u) extends LE α, LT α where\n  le_refl : ∀ a : α, a ≤ a\n  le_trans : ∀ a b c : α, a ≤ b → b ≤ c → a ≤ c\n  lt := fun a b => a ≤ b ∧ ¬b ≤ a\n  lt_iff_le_not_le : ∀ a b : α, a < b ↔ a ≤ b ∧ ¬b ≤ a := by intros; rfl\n", "additional_info": "A preorder is a reflexive, transitive relation `≤` with `a < b` defined in the obvious way.\n", "used_premises": [5, 6], "def_path": "Mathlib/Init/Order/Defs.lean", "pos": [30, 35], "informalization": "Class `Preorder` represents a type with a reflexive and transitive binary relation `≤`, and defines `a < b` as `a ≤ b ∧ ¬b ≤ a`."}
{"full_name": "LE", "url": "Init/Prelude.html#LE", "code_src": "lean4", "ptype": "class", "header": "class LE (α : Type u) :Type u\n | le : α → α → Prop ", "code": "class LE (α : Type u) where\n  /-- The less-equal relation: `x ≤ y` -/\n  le : α → α → Prop\n", "additional_info": "`🗟LE🗟🔗.././Init/Prelude.html#LE🔗  α` is the typeclass which supports the notation `x ≤ y` where `x y : α`.\n- LE.le: The less-equal relation: `x ≤ y`\n\n\n", "used_premises": [], "def_path": "Init/Prelude.lean", "pos": [1099, 1102], "informalization": "Class `LE` represents the concept of a less-equal relation, which is a binary relation that defines an ordering on elements of a type `α`."}
{"full_name": "LT", "url": "Init/Prelude.html#LT", "code_src": "lean4", "ptype": "class", "header": "class LT (α : Type u) :Type u\n | lt : α → α → Prop ", "code": "class LT (α : Type u) where\n  /-- The less-than relation: `x < y` -/\n  lt : α → α → Prop\n", "additional_info": "`🗟LT🗟🔗.././Init/Prelude.html#LT🔗  α` is the typeclass which supports the notation `x < y` where `x y : α`.\n- LT.lt: The less-than relation: `x < y`\n\n\n", "used_premises": [], "def_path": "Init/Prelude.lean", "pos": [1104, 1107], "informalization": "Class `LT` represents the concept of a less-than relation on a type `α`, defining a binary predicate `lt` that determines whether one element is less than another."}
{"full_name": "Min", "url": "Init/Prelude.html#Min", "code_src": "lean4", "ptype": "class", "header": "class Min (α : Type u) :Type u\n | min : α → α → α", "code": "class Min (α : Type u) where\n  /-- The minimum operation: `min x y`. -/\n  min : α → α → α\n", "additional_info": "`🗟Min🗟🔗.././Init/Prelude.html#Min🔗  α` is the typeclass which supports the operation `🗟min🗟🔗.././Init/Prelude.html#Min.min🔗  x y` where `x y : α`.\n- Min.min: The minimum operation: `🗟min🗟🔗.././Init/Prelude.html#Min.min🔗  x y`.\n\n\n", "used_premises": [], "def_path": "Init/Prelude.lean", "pos": [1127, 1130], "informalization": "Class `Min` represents the concept of a binary minimum operation on a type `α`, which returns the lesser of two elements."}
{"full_name": "Max", "url": "Init/Prelude.html#Max", "code_src": "lean4", "ptype": "class", "header": "class Max (α : Type u) :Type u\n | max : α → α → α", "code": "class Max (α : Type u) where\n  /-- The maximum operation: `max x y`. -/\n  max : α → α → α\n", "additional_info": "`🗟Max🗟🔗.././Init/Prelude.html#Max🔗  α` is the typeclass which supports the operation `🗟max🗟🔗.././Init/Prelude.html#Max.max🔗  x y` where `x y : α`.\n- Max.max: The maximum operation: `🗟max🗟🔗.././Init/Prelude.html#Max.max🔗  x y`.\n\n\n", "used_premises": [], "def_path": "Init/Prelude.lean", "pos": [1114, 1117], "informalization": "Class `Max` represents the concept of a maximum operation, which is a binary operation that returns the greater of two elements of a type `α`."}
{"full_name": "Ord", "url": "Init/Data/Ord.html#Ord", "code_src": "lean4", "ptype": "class", "header": "class Ord (α : Type u) :Type u\n | compare : α → α → Ordering🔗<|PREMISE|>🔗 ", "code": "class Ord (α : Type u) where\n  compare : α → α → Ordering\n", "additional_info": "", "used_premises": [10], "def_path": "Init/Data/Ord.lean", "pos": [103, 105], "informalization": "Class `Ord` represents the concept of a total ordering for a type `α`, providing a function `compare` that returns the `Ordering` of two elements."}
{"full_name": "Ordering", "url": "Init/Data/Ord.html#Ordering", "code_src": "lean4", "ptype": "inductive", "header": "inductive Ordering :Type", "code": "inductive Ordering where\n  | lt | eq | gt\nderiving Inhabited, BEq\n", "additional_info": "", "used_premises": [], "def_path": "Init/Data/Ord.lean", "pos": [10, 13], "informalization": "Type `Ordering` represents the result of a comparison operation, indicating whether one element is less than (`lt`), equal to (`eq`), or greater than (`gt`) another."}
{"full_name": "DecidableRel", "url": "Init/Prelude.html#DecidableRel", "code_src": "lean4", "ptype": "abbrev", "header": "@[inline, reducible]abbrev DecidableRel {α : Sort u} (r : α → α → Prop ) :Sort (max 1 u)", "code": "abbrev DecidableRel {α : Sort u} (r : α → α → Prop) :=\n  (a b : α) → Decidable (r a b)\n", "additional_info": "A decidable relation. See `🗟Decidable🗟🔗.././Init/Prelude.html#Decidable🔗` .\nEquations\n* 🗟DecidableRel🗟🔗.././Init/Prelude.html#DecidableRel🔗  r 🗟=🗟🔗.././Init/Prelude.html#Eq🔗  ((a b : α) → 🗟Decidable🗟🔗.././Init/Prelude.html#Decidable🔗  (r a b))\n\n", "used_premises": [], "def_path": "Init/Prelude.lean", "pos": [855, 857], "informalization": "`DecidableRel` is an abbreviation for a type of binary relations on a type `α` that can be decided, meaning for any pair `(a, b)` in `α`, it can be determined whether the relation `r a b` holds or not."}
{"full_name": "DecidableEq", "url": "Init/Prelude.html#DecidableEq", "code_src": "lean4", "ptype": "abbrev", "header": "@[inline, reducible]abbrev DecidableEq (α : Sort u) :Sort (max 1 u)", "code": "abbrev DecidableEq (α : Sort u) :=\n  (a b : α) → Decidable (Eq a b)\n", "additional_info": "Asserts that `α` has decidable equality, that is, `a = b` is decidable\nfor all `a b : α`. See `🗟Decidable🗟🔗.././Init/Prelude.html#Decidable🔗` .\nEquations\n* 🗟DecidableEq🗟🔗.././Init/Prelude.html#DecidableEq🔗  α 🗟=🗟🔗.././Init/Prelude.html#Eq🔗  ((a b : α) → 🗟Decidable🗟🔗.././Init/Prelude.html#Decidable🔗  (a 🗟=🗟🔗.././Init/Prelude.html#Eq🔗  b))\n\n", "used_premises": [], "def_path": "Init/Prelude.lean", "pos": [862, 864], "informalization": "`DecidableEq` is a type class that provides a decision procedure for equality on a type `α`, meaning it can determine whether any two elements of `α` are equal or not."}
{"full_name": "compareOfLessAndEq", "url": "Init/Data/Ord.html#compareOfLessAndEq", "code_src": "lean4", "ptype": "def", "header": "@[inline]def compareOfLessAndEq {α : Type u_1} (x : α) (y : α) [LT🔗<|PREMISE|>🔗 α] [Decidable🔗<|PREMISE|>🔗 (x < y)] [DecidableEq🔗<|PREMISE|>🔗 α] :Ordering🔗<|PREMISE|>🔗", "code": "@[inline] def compareOfLessAndEq {α} (x y : α) [LT α] [Decidable (x < y)] [DecidableEq α] : Ordering :=\n  if x < y then Ordering.lt\n  else if x = y then Ordering.eq\n  else Ordering.gt\n", "additional_info": "Equations\n* 🗟compareOfLessAndEq🗟🔗../.././Init/Data/Ord.html#compareOfLessAndEq🔗  x y 🗟=🗟🔗../.././Init/Prelude.html#Eq🔗  if x 🗟<🗟🔗../.././Init/Prelude.html#LT.lt🔗  y then 🗟Ordering.lt🗟🔗../.././Init/Data/Ord.html#Ordering.lt🔗  else if x 🗟=🗟🔗../.././Init/Prelude.html#Eq🔗  y then 🗟Ordering.eq🗟🔗../.././Init/Data/Ord.html#Ordering.eq🔗  else 🗟Ordering.gt🗟🔗../.././Init/Data/Ord.html#Ordering.gt🔗\n\n", "used_premises": [6, 14, 12, 10], "def_path": "Init/Data/Ord.lean", "pos": [90, 94], "informalization": "Function `compareOfLessAndEq` performs a comparison between two elements `x` and `y` of a type `α` by checking if `x` is less than `y`, equal to `y`, or greater than `y`, returning the corresponding `Ordering` value."}
{"full_name": "Decidable", "url": "Init/Prelude.html#Decidable", "code_src": "lean4", "ptype": "class inductive", "header": "class inductive Decidable (p : Prop ) :Type", "code": "class inductive Decidable (p : Prop) where\n  /-- Prove that `p` is decidable by supplying a proof of `¬p` -/\n  | isFalse (h : Not p) : Decidable p\n  /-- Prove that `p` is decidable by supplying a proof of `p` -/\n  | isTrue (h : p) : Decidable p\n", "additional_info": "`🗟Decidable🗟🔗.././Init/Prelude.html#Decidable🔗  p` is a data-carrying class that supplies a proof that `p` is\neither `🗟true🗟🔗.././Init/Prelude.html#Bool.true🔗`  or `🗟false🗟🔗.././Init/Prelude.html#Bool.false🔗` . It is equivalent to `🗟Bool🗟🔗.././Init/Prelude.html#Bool🔗`  (and in fact it has the\nsame code generation as `🗟Bool🗟🔗.././Init/Prelude.html#Bool🔗` ) together with a proof that the `🗟Bool🗟🔗.././Init/Prelude.html#Bool🔗`  is\ntrue iff `p` is.\n`🗟Decidable🗟🔗.././Init/Prelude.html#Decidable🔗`  instances are used to infer \"computation strategies\" for\npropositions, so that you can have the convenience of writing propositions\ninside `if` statements and executing them (which actually executes the inferred\ndecidability instance instead of the proposition, which has no code).\nIf a proposition `p` is `🗟Decidable🗟🔗.././Init/Prelude.html#Decidable🔗` , then `(by 🗟decide🗟🔗.././Init/Prelude.html#Decidable.decide🔗  : p)` will prove it by\nevaluating the decidability instance to `🗟isTrue🗟🔗.././Init/Prelude.html#Decidable.isTrue🔗  h` and returning `h`.\nBecause `🗟Decidable🗟🔗.././Init/Prelude.html#Decidable🔗`  carries data,\nwhen writing `@[simp]` lemmas which include a `🗟Decidable🗟🔗.././Init/Prelude.html#Decidable🔗`  instance on the LHS,\nit is best to use `{_ : 🗟Decidable🗟🔗.././Init/Prelude.html#Decidable🔗  p}` rather than `[Decidable p]`\nso that non-canonical instances can be found via unification rather than\ntypeclass search.\n", "used_premises": [], "def_path": "Init/Prelude.lean", "pos": [833, 838], "informalization": "Class `Decidable` represents the concept of a proposition being decidable, meaning it can be determined to be either true or false, providing a way to include propositions in computations and proofs."}
{"full_name": "IsWellOrder", "url": "Mathlib/Order/RelClasses.html#IsWellOrder", "code_src": "mathlib4", "ptype": "class", "header": "class IsWellOrder (α : Type u) (r : α → α → Prop ) extends IsTrichotomous🔗<|PREMISE|>🔗 , IsTrans🔗<|PREMISE|>🔗 , IsWellFounded🔗<|PREMISE|>🔗 :Prop", "code": "class IsWellOrder (α : Type u) (r : α → α → Prop) extends\n  IsTrichotomous α r, IsTrans α r, IsWellFounded α r : Prop\n", "additional_info": "A well order is a well-founded linear order.\n", "used_premises": [16, 17, 18], "def_path": "Mathlib/Order/RelClasses.lean", "pos": [378, 380], "informalization": "A well order is a well-founded linear order."}
{"full_name": "IsTrichotomous", "url": "Mathlib/Init/Algebra/Classes.html#IsTrichotomous", "code_src": "mathlib4", "ptype": "class", "header": "class IsTrichotomous (α : Sort u) (lt : α → α → Prop ) :Prop\n | trichotomous : ∀ (a b : α), lt a b ∨  a =  b ∨  lt b a", "code": "class IsTrichotomous (α : Sort u) (lt : α → α → Prop) : Prop where\n  trichotomous : ∀ a b, lt a b ∨ a = b ∨ lt b a\n", "additional_info": "`🗟IsTrichotomous🗟🔗../../.././Mathlib/Init/Algebra/Classes.html#IsTrichotomous🔗  X lt` means that the binary relation `lt` on `X` is trichotomous, that is,\neither `lt a b` or `a = b` or `lt b a` for any `a` and `b`.\n", "used_premises": [], "def_path": "Mathlib/Init/Algebra/Classes.lean", "pos": [263, 265], "informalization": "Class `IsTrichotomous` represents the concept of a trichotomous binary relation `lt` on a type `α`, meaning that for any two elements `a` and `b` of `α`, exactly one of the following holds: `lt a b`, `a = b`, or `lt b a`."}
{"full_name": "IsTrans", "url": "Mathlib/Init/Algebra/Classes.html#IsTrans", "code_src": "mathlib4", "ptype": "class", "header": "class IsTrans (α : Sort u) (r : α → α → Prop ) :Prop\n | trans : ∀ (a b c : α), r a b → r b c → r a c", "code": "class IsTrans (α : Sort u) (r : α → α → Prop) : Prop where\n  trans : ∀ a b c, r a b → r b c → r a c\n", "additional_info": "`🗟IsTrans🗟🔗../../.././Mathlib/Init/Algebra/Classes.html#IsTrans🔗  X r` means the binary relation `r` on `X` is transitive.\n", "used_premises": [], "def_path": "Mathlib/Init/Algebra/Classes.lean", "pos": [192, 194], "informalization": "Class `IsTrans` represents the concept of a transitive binary relation `r` on a type `α`, meaning if `r a b` and `r b c` hold, then `r a c` must also hold."}
{"full_name": "IsWellFounded", "url": "Mathlib/Order/RelClasses.html#IsWellFounded", "code_src": "mathlib4", "ptype": "class", "header": "class IsWellFounded (α : Type u) (r : α → α → Prop ) :Prop\n | wf : WellFounded🔗<|PREMISE|>🔗  r", "code": "@[mk_iff] class IsWellFounded (α : Type u) (r : α → α → Prop) : Prop where\n  /-- The relation is `WellFounded`, as a proposition. -/\n  wf : WellFounded r\n", "additional_info": "A well-founded relation. Not to be confused with `🗟IsWellOrder🗟🔗../.././Mathlib/Order/RelClasses.html#IsWellOrder🔗` .\n- IsWellFounded.wf: The relation is `🗟WellFounded🗟🔗../.././Init/WF.html#WellFounded🔗` , as a proposition.\n\n\n", "used_premises": [19], "def_path": "Mathlib/Order/RelClasses.lean", "pos": [274, 277], "informalization": "A well-founded relation. Not to be confused with `IsWellOrder`."}
{"full_name": "WellFounded", "url": "Init/WF.html#WellFounded", "code_src": "lean4", "ptype": "inductive", "header": "inductive WellFounded {α : Sort u} (r : α → α → Prop ) :Prop", "code": "inductive WellFounded {α : Sort u} (r : α → α → Prop) : Prop where\n  | intro (h : ∀ a, Acc r a) : WellFounded r\n", "additional_info": "", "used_premises": [], "def_path": "Init/WF.lean", "pos": [33, 35], "informalization": "Type `WellFounded` represents a well-founded relation on a type `α`, which means that every non-empty subset of `α` has a minimal element with respect to the relation `r`."}
{"full_name": "Zero", "url": "Mathlib/Init/ZeroOne.html#Zero", "code_src": "mathlib4", "ptype": "class", "header": "class Zero (α : Type u) :Type u\n | zero : α", "code": "class Zero.{u} (α : Type u) where\n  zero : α\n", "additional_info": "", "used_premises": [], "def_path": "Mathlib/Init/ZeroOne.lean", "pos": [12, 14], "informalization": "Class `Zero` represents the concept of a zero element."}
{"full_name": "SuccOrder", "url": "Mathlib/Order/SuccPred/Basic.html#SuccOrder", "code_src": "mathlib4", "ptype": "class", "header": "class SuccOrder (α : Type u_3) [Preorder🔗<|PREMISE|>🔗 α] :Type u_3\n | succ : α → α\n | le_succ : ∀ (a : α), a ≤  SuccOrder.succ🔗<|PREMISE|>🔗  a\n | max_of_succ_le : ∀ {a : α}, SuccOrder.succ🔗<|PREMISE|>🔗  a ≤  a → IsMax🔗<|PREMISE|>🔗  a\n | succ_le_of_lt : ∀ {a b : α}, a <  b → SuccOrder.succ🔗<|PREMISE|>🔗  a ≤  b\n | le_of_lt_succ : ∀ {a b : α}, a <  SuccOrder.succ🔗<|PREMISE|>🔗  b → a ≤  b", "code": "class SuccOrder (α : Type*) [Preorder α] where\n  /--Successor function-/\n  succ : α → α\n  /--Proof of basic ordering with respect to `succ`-/\n  le_succ : ∀ a, a ≤ succ a\n  /--Proof of interaction between `succ` and maximal element-/\n  max_of_succ_le {a} : succ a ≤ a → IsMax a\n  /--Proof that `succ` satisfies ordering invariants between `LT` and `LE`-/\n  succ_le_of_lt {a b} : a < b → succ a ≤ b\n  /--Proof that `succ` satisfies ordering invariants between `LE` and `LT`-/\n  le_of_lt_succ {a b} : a < succ b → a ≤ b\n", "additional_info": "Order equipped with a sensible successor function.\n- SuccOrder.succ: Successor function\n\n\n- SuccOrder.le_succ: Proof of basic ordering with respect to `🗟succ🗟🔗../../.././Mathlib/Order/SuccPred/Basic.html#SuccOrder.succ🔗` \n\n\n- SuccOrder.max_of_succ_le: Proof of interaction between `🗟succ🗟🔗../../.././Mathlib/Order/SuccPred/Basic.html#SuccOrder.succ🔗`  and maximal element\n\n\n- SuccOrder.succ_le_of_lt: Proof that `🗟succ🗟🔗../../.././Mathlib/Order/SuccPred/Basic.html#SuccOrder.succ🔗`  satisfies ordering invariants between `🗟LT🗟🔗../../.././Init/Prelude.html#LT🔗`  and `🗟LE🗟🔗../../.././Init/Prelude.html#LE🔗` \n\n\n- SuccOrder.le_of_lt_succ: Proof that `🗟succ🗟🔗../../.././Mathlib/Order/SuccPred/Basic.html#SuccOrder.succ🔗`  satisfies ordering invariants between `🗟LE🗟🔗../../.././Init/Prelude.html#LE🔗`  and `🗟LT🗟🔗../../.././Init/Prelude.html#LT🔗` \n\n\n", "used_premises": [4, 22, 22, 23, 22, 22], "def_path": "Mathlib/Order/SuccPred/Basic.lean", "pos": [62, 73], "informalization": "Class `SuccOrder` represents an order equipped with a sensible successor function, where the successor of an element `a` is the smallest element greater than `a`. It includes axioms that ensure the successor function correctly interacts with the order relation and that the successor of a non-maximal element is always greater than the element itself."}
{"full_name": "SuccOrder.succ", "url": "Mathlib/Order/SuccPred/Basic.html#SuccOrder", "code_src": "mathlib4", "ptype": "structure_field", "header": "structure_field SuccOrder🔗<|PREMISE|>🔗.succ : α → α", "code": "class SuccOrder (α : Type*) [Preorder α] where\n  /--Successor function-/\n  succ : α → α\n  /--Proof of basic ordering with respect to `succ`-/\n  le_succ : ∀ a, a ≤ succ a\n  /--Proof of interaction between `succ` and maximal element-/\n  max_of_succ_le {a} : succ a ≤ a → IsMax a\n  /--Proof that `succ` satisfies ordering invariants between `LT` and `LE`-/\n  succ_le_of_lt {a b} : a < b → succ a ≤ b\n  /--Proof that `succ` satisfies ordering invariants between `LE` and `LT`-/\n  le_of_lt_succ {a b} : a < succ b → a ≤ b\n", "additional_info": "Successor function\n\n", "used_premises": [21], "def_path": "Mathlib/Order/SuccPred/Basic.lean", "pos": [62, 73], "informalization": "Function `SuccOrder.succ` is a part of the `SuccOrder` class, which represents an order equipped with a successor function. The successor of an element `a` is the smallest element greater than `a`. The class includes axioms that ensure the successor function correctly interacts with the order relation and that the successor of a non-maximal element is always greater than the element itself."}
{"full_name": "IsMax", "url": "Mathlib/Order/Max.html#IsMax", "code_src": "mathlib4", "ptype": "def", "header": "def IsMax {α : Type u_1} [LE🔗<|PREMISE|>🔗 α] (a : α) :Prop", "code": "def IsMax (a : α) : Prop :=\n  ∀ ⦃b⦄, a ≤ b → b ≤ a\n", "additional_info": "`a` is a maximal element of `α` if no element is strictly greater than it. We spell it without\n`<` to avoid having to convert between `≤` and `<`. Instead, `🗟isMax_iff_forall_not_lt🗟🔗../.././Mathlib/Order/Max.html#isMax_iff_forall_not_lt🔗`  does the\nconversion.\nEquations\n* 🗟IsMax🗟🔗../.././Mathlib/Order/Max.html#IsMax🔗  a 🗟=🗟🔗../.././Init/Prelude.html#Eq🔗  ∀ ⦃b : α⦄, a 🗟≤🗟🔗../.././Init/Prelude.html#LE.le🔗  b → b 🗟≤🗟🔗../.././Init/Prelude.html#LE.le🔗  a\n\n", "used_premises": [5], "def_path": "Mathlib/Order/Max.lean", "pos": [208, 210], "informalization": "Function `IsMax` checks if an element `a` of a preordered type `α` is a maximal element, meaning there is no element strictly greater than `a`."}
{"full_name": "Ordinal.IsLimit", "url": "Mathlib/SetTheory/Ordinal/Arithmetic.html#Ordinal.IsLimit", "code_src": "mathlib4", "ptype": "def", "header": "def Ordinal.IsLimit (o : Ordinal🔗<|PREMISE|>🔗 ) :Prop", "code": "def IsLimit (o : Ordinal) : Prop :=\n  o ≠ 0 ∧ ∀ a < o, succ a < o\n", "additional_info": "A limit ordinal is an ordinal which is not zero and not a successor.\nEquations\n* 🗟Ordinal.IsLimit🗟🔗../../.././Mathlib/SetTheory/Ordinal/Arithmetic.html#Ordinal.IsLimit🔗  o 🗟=🗟🔗../../.././Init/Prelude.html#Eq🔗  (o 🗟≠🗟🔗../../.././Init/Core.html#Ne🔗  0 🗟∧🗟🔗../../.././Init/Prelude.html#And🔗  ∀ a < o, 🗟Order.succ🗟🔗../../.././Mathlib/Order/SuccPred/Basic.html#Order.succ🔗  a 🗟<🗟🔗../../.././Init/Prelude.html#LT.lt🔗  o)\n\n", "used_premises": [25], "def_path": "Mathlib/SetTheory/Ordinal/Arithmetic.lean", "pos": [237, 239], "informalization": "Function `Ordinal.IsLimit` checks if an ordinal is a limit ordinal, meaning it is neither zero nor a successor of another ordinal."}
{"full_name": "Ordinal", "url": "Mathlib/SetTheory/Ordinal/Basic.html#Ordinal", "code_src": "mathlib4", "ptype": "def", "header": "def Ordinal :Type (u + 1)", "code": "def Ordinal : Type (u + 1) :=\n  Quotient Ordinal.isEquivalent\n", "additional_info": "`Ordinal.{u}` is the type of well orders in `Type u`, up to order isomorphism.\nEquations\n* 🗟Ordinal.{u}🗟🔗../../.././Mathlib/SetTheory/Ordinal/Basic.html#Ordinal🔗  🗟=🗟🔗../../.././Init/Prelude.html#Eq🔗  🗟Quotient🗟🔗../../.././Init/Core.html#Quotient🔗  🗟Ordinal.isEquivalent🗟🔗../../.././Mathlib/SetTheory/Ordinal/Basic.html#Ordinal.isEquivalent🔗\n\n", "used_premises": [], "def_path": "Mathlib/SetTheory/Ordinal/Basic.lean", "pos": [151, 153], "informalization": "`Ordinal.{u}` is the type of well orders in `Type u`, up to order isomorphism."}
{"full_name": "Ordinal.type", "url": "Mathlib/SetTheory/Ordinal/Basic.html#Ordinal.type", "code_src": "mathlib4", "ptype": "def", "header": "def Ordinal.type {α : Type u} (r : α → α → Prop ) [wo : IsWellOrder🔗<|PREMISE|>🔗 α r] :Ordinal🔗<|PREMISE|>🔗", "code": "def type (r : α → α → Prop) [wo : IsWellOrder α r] : Ordinal :=\n  ⟦⟨α, r, wo⟩⟧\n", "additional_info": "The order type of a well order is an ordinal.\nEquations\n* 🗟Ordinal.type🗟🔗../../.././Mathlib/SetTheory/Ordinal/Basic.html#Ordinal.type🔗  r 🗟=🗟🔗../../.././Init/Prelude.html#Eq🔗  ⟦{ α := α, r := r, wo := wo }⟧\n\n", "used_premises": [15, 25], "def_path": "Mathlib/SetTheory/Ordinal/Basic.lean", "pos": [172, 174], "informalization": "Function `Ordinal.type` constructs an ordinal from a well order `r` on a type `α`."}
{"full_name": "Cardinal.ord", "url": "Mathlib/SetTheory/Ordinal/Basic.html#Cardinal.ord", "code_src": "mathlib4", "ptype": "def", "header": "def Cardinal.ord (c : Cardinal🔗<|PREMISE|>🔗 ) :Ordinal🔗<|PREMISE|>🔗", "code": "def ord (c : Cardinal) : Ordinal :=\n  let F := fun α : Type u => ⨅ r : { r // IsWellOrder α r }, @type α r.1 r.2\n  Quot.liftOn c F\n    (by\n      suffices ∀ {α β}, α ≈ β → F α ≤ F β from\n        fun α β h => (this h).antisymm (this (Setoid.symm h))\n      rintro α β ⟨f⟩\n      refine' le_ciInf_iff'.2 fun i => _\n      haveI := @RelEmbedding.isWellOrder _ _ (f ⁻¹'o i.1) _ (↑(RelIso.preimage f i.1)) i.2\n      exact\n        (ciInf_le' _\n              (Subtype.mk (f ⁻¹'o i.val)\n                (@RelEmbedding.isWellOrder _ _ _ _ (↑(RelIso.preimage f i.1)) i.2))).trans_eq\n          (Quot.sound ⟨RelIso.preimage f i.1⟩))\n", "additional_info": "The ordinal corresponding to a cardinal `c` is the least ordinal\nwhose cardinal is `c`. For the order-embedding version, see `ord.order_embedding`.\nEquations\n* 🗟Cardinal.ord🗟🔗../../.././Mathlib/SetTheory/Ordinal/Basic.html#Cardinal.ord🔗  c 🗟=🗟🔗../../.././Init/Prelude.html#Eq🔗  let F := fun (α : 🗟Type🗟🔗../../.././foundational_types.html🔗  u) => ⨅ (r : { r : α → α → 🗟Prop🗟🔗../../.././foundational_types.html🔗  // 🗟IsWellOrder🗟🔗../../.././Mathlib/Order/RelClasses.html#IsWellOrder🔗  α r }), 🗟Ordinal.type🗟🔗../../.././Mathlib/SetTheory/Ordinal/Basic.html#Ordinal.type🔗  ↑r;\n 🗟Quot.liftOn🗟🔗../../.././Init/Core.html#Quot.liftOn🔗  c F 🗟Cardinal.ord.proof_2🗟🔗../../.././Mathlib/SetTheory/Ordinal/Basic.html#Cardinal.ord.proof_2🔗\n\n", "used_premises": [28, 25], "def_path": "Mathlib/SetTheory/Ordinal/Basic.lean", "pos": [1307, 1321], "informalization": "Function `Cardinal.ord` maps a cardinal number `c` to the smallest ordinal number whose cardinality is `c`."}
{"full_name": "Cardinal", "url": "Mathlib/SetTheory/Cardinal/Basic.html#Cardinal", "code_src": "mathlib4", "ptype": "def", "header": "def Cardinal :Type (u + 1)", "code": "def Cardinal : Type (u + 1) :=\n  Quotient Cardinal.isEquivalent\n", "additional_info": "`Cardinal.{u}` is the type of cardinal numbers in `Type u`,\ndefined as the quotient of `Type u` by existence of an equivalence\n(a bijection with explicit inverse).\nEquations\n* 🗟Cardinal.{u}🗟🔗../../.././Mathlib/SetTheory/Cardinal/Basic.html#Cardinal🔗  🗟=🗟🔗../../.././Init/Prelude.html#Eq🔗  🗟Quotient🗟🔗../../.././Init/Core.html#Quotient🔗  🗟Cardinal.isEquivalent🗟🔗../../.././Mathlib/SetTheory/Cardinal/Basic.html#Cardinal.isEquivalent🔗\n\n", "used_premises": [], "def_path": "Mathlib/SetTheory/Cardinal/Basic.lean", "pos": [106, 108], "informalization": "`Cardinal.{u}` is the type of cardinal numbers in `Type u`, defined as the quotient of `Type u` by existence of an equivalence (a bijection with explicit inverse)."}
{"full_name": "Cardinal.mk", "url": "Mathlib/SetTheory/Cardinal/Basic.html#Cardinal.mk", "code_src": "mathlib4", "ptype": "def", "header": "def Cardinal.mk :Type u → Cardinal🔗<|PREMISE|>🔗", "code": "def mk : Type u → Cardinal :=\n  Quotient.mk'\n", "additional_info": "The cardinal number of a type\nEquations\n* 🗟Cardinal.mk🗟🔗../../.././Mathlib/SetTheory/Cardinal/Basic.html#Cardinal.mk🔗  🗟=🗟🔗../../.././Init/Prelude.html#Eq🔗  Quotient.mk'\n\n", "used_premises": [28], "def_path": "Mathlib/SetTheory/Cardinal/Basic.lean", "pos": [113, 115], "informalization": "Function `Cardinal.mk` maps a given type to its corresponding cardinal number, which is an equivalence class of types under the equivalence relation of having the same number of elements."}
{"full_name": "Cardinal.IsRegular", "url": "Mathlib/SetTheory/Cardinal/Cofinality.html#Cardinal.IsRegular", "code_src": "mathlib4", "ptype": "def", "header": "def Cardinal.IsRegular (c : Cardinal🔗<|PREMISE|>🔗 ) :Prop", "code": "def IsRegular (c : Cardinal) : Prop :=\n  ℵ₀ ≤ c ∧ c ≤ c.ord.cof\n", "additional_info": "A cardinal is regular if it is infinite and it equals its own cofinality.\nEquations\n* 🗟Cardinal.IsRegular🗟🔗../../.././Mathlib/SetTheory/Cardinal/Cofinality.html#Cardinal.IsRegular🔗  c 🗟=🗟🔗../../.././Init/Prelude.html#Eq🔗  (🗟Cardinal.aleph0🗟🔗../../.././Mathlib/SetTheory/Cardinal/Basic.html#Cardinal.aleph0🔗  🗟≤🗟🔗../../.././Init/Prelude.html#LE.le🔗  c 🗟∧🗟🔗../../.././Init/Prelude.html#And🔗  c 🗟≤🗟🔗../../.././Init/Prelude.html#LE.le🔗  🗟Ordinal.cof🗟🔗../../.././Mathlib/SetTheory/Cardinal/Cofinality.html#Ordinal.cof🔗  (🗟Cardinal.ord🗟🔗../../.././Mathlib/SetTheory/Ordinal/Basic.html#Cardinal.ord🔗  c))\n\n", "used_premises": [28], "def_path": "Mathlib/SetTheory/Cardinal/Cofinality.lean", "pos": [943, 945], "informalization": "Function `Cardinal.IsRegular` is a predicate that checks if a given cardinal number `c` is regular, meaning it is infinite and equals its own cofinality."}
{"full_name": "AddMonoid", "url": "Mathlib/Algebra/Group/Defs.html#AddMonoid", "code_src": "mathlib4", "ptype": "class", "header": "class AddMonoid (M : Type u) extends AddSemigroup🔗<|PREMISE|>🔗 , Zero🔗<|PREMISE|>🔗 :Type u\n | add : M → M → M\n | add_assoc : ∀ (a b c : M), a +  b +  c =  a +  (b +  c)\n | zero : M\n | zero_add : ∀ (a : M), 0 +  a =  a\n | add_zero : ∀ (a : M), a +  0 =  a\n | nsmul : ℕ  → M → M\n | nsmul_zero : ∀ (x : M), AddMonoid.nsmul🔗<|PREMISE|>🔗  0 x =  0\n | nsmul_succ : ∀ (n : ℕ ) (x : M), AddMonoid.nsmul🔗<|PREMISE|>🔗  (n +  1) x =  x +  AddMonoid.nsmul🔗<|PREMISE|>🔗  n x", "code": "class AddMonoid (M : Type u) extends AddSemigroup M, AddZeroClass M where\n  /-- Multiplication by a natural number. -/\n  protected nsmul : ℕ → M → M := nsmulRec\n  /-- Multiplication by `(0 : ℕ)` gives `0`. -/\n  protected nsmul_zero : ∀ x, nsmul 0 x = 0 := by intros; rfl\n  /-- Multiplication by `(n + 1 : ℕ)` behaves as expected. -/\n  protected nsmul_succ : ∀ (n : ℕ) (x), nsmul (n + 1) x = x + nsmul n x := by intros; rfl\n", "additional_info": "An `🗟AddMonoid🗟🔗../../.././Mathlib/Algebra/Group/Defs.html#AddMonoid🔗`  is an `🗟AddSemigroup🗟🔗../../.././Mathlib/Algebra/Group/Defs.html#AddSemigroup🔗`  with an element `0` such that `0 + a = a + 0 = a`.\n- AddMonoid.zero_add: Zero is a left neutral element for addition\n\n\n- AddMonoid.add_zero: Zero is a right neutral element for addition\n\n\n- AddMonoid.nsmul: Multiplication by a natural number.\n\n\n- AddMonoid.nsmul_zero: Multiplication by `(0 : ℕ)` gives `0`.\n\n\n- AddMonoid.nsmul_succ: Multiplication by `(n + 1 : ℕ)` behaves as expected.\n\n\n", "used_premises": [32, 20, 34, 34, 34], "def_path": "Mathlib/Algebra/Group/Defs.lean", "pos": [594, 601], "informalization": "Class `AddMonoid` represents the concept of an additive monoid. An additive monoid is a type with an associative addition operation, a zero element, and a natural number multiplication operation. The zero element satisfies the properties of being a left and right neutral element for addition, meaning adding zero to any element does not change it. Multiplying by zero results in the zero element, and multiplying by `n + 1` is equivalent to adding the element to its multiplication by `n`."}
{"full_name": "AddSemigroup", "url": "Mathlib/Algebra/Group/Defs.html#AddSemigroup", "code_src": "mathlib4", "ptype": "class", "header": "class AddSemigroup (G : Type u) extends Add🔗<|PREMISE|>🔗 :Type u\n | add : G → G → G\n | add_assoc : ∀ (a b c : G), a +  b +  c =  a +  (b +  c)", "code": "class AddSemigroup (G : Type u) extends Add G where\n  /-- Addition is associative -/\n  protected add_assoc : ∀ a b c : G, a + b + c = a + (b + c)\n", "additional_info": "An additive semigroup is a type with an associative `(+)`.\n- AddSemigroup.add_assoc: Addition is associative\n\n\n", "used_premises": [33], "def_path": "Mathlib/Algebra/Group/Defs.lean", "pos": [271, 274], "informalization": "Class `AddSemigroup` represents the concept of an additive semigroup. It can perform associative addition."}
{"full_name": "Add", "url": "Init/Prelude.html#Add", "code_src": "lean4", "ptype": "class", "header": "class Add (α : Type u) :Type u\n | add : α → α → α", "code": "class Add (α : Type u) where\n  /-- `a + b` computes the sum of `a` and `b`. See `HAdd`. -/\n  add : α → α → α\n", "additional_info": "The homogeneous version of `🗟HAdd🗟🔗.././Init/Prelude.html#HAdd🔗` : `a + b : α` where `a b : α`.\n- Add.add: `a + b` computes the sum of `a` and `b`. See `🗟HAdd🗟🔗.././Init/Prelude.html#HAdd🔗` .\n\n\n", "used_premises": [], "def_path": "Init/Prelude.lean", "pos": [1289, 1292], "informalization": "Class `Add` represents the concept of addition."}
{"full_name": "AddMonoid.nsmul", "url": "Mathlib/Algebra/Group/Defs.html#AddMonoid", "code_src": "mathlib4", "ptype": "structure_field", "header": "structure_field AddMonoid🔗<|PREMISE|>🔗.nsmul : ℕ  → M → M", "code": "class AddMonoid (M : Type u) extends AddSemigroup M, AddZeroClass M where\n  /-- Multiplication by a natural number. -/\n  protected nsmul : ℕ → M → M := nsmulRec\n  /-- Multiplication by `(0 : ℕ)` gives `0`. -/\n  protected nsmul_zero : ∀ x, nsmul 0 x = 0 := by intros; rfl\n  /-- Multiplication by `(n + 1 : ℕ)` behaves as expected. -/\n  protected nsmul_succ : ∀ (n : ℕ) (x), nsmul (n + 1) x = x + nsmul n x := by intros; rfl\n", "additional_info": "Multiplication by a natural number.\n\n", "used_premises": [31], "def_path": "Mathlib/Algebra/Group/Defs.lean", "pos": [594, 601], "informalization": "Function `AddMonoid.nsmul` takes a natural number and an element from an additive monoid, and returns the result of their multiplication."}
{"full_name": "Sub", "url": "Init/Prelude.html#Sub", "code_src": "lean4", "ptype": "class", "header": "class Sub (α : Type u) :Type u\n | sub : α → α → α", "code": "class Sub (α : Type u) where\n  /-- `a - b` computes the difference of `a` and `b`. See `HSub`. -/\n  sub : α → α → α\n", "additional_info": "The homogeneous version of `🗟HSub🗟🔗.././Init/Prelude.html#HSub🔗` : `a - b : α` where `a b : α`.\n- Sub.sub: `a - b` computes the difference of `a` and `b`. See `🗟HSub🗟🔗.././Init/Prelude.html#HSub🔗` .\n\n\n", "used_premises": [], "def_path": "Init/Prelude.lean", "pos": [1294, 1297], "informalization": "Class `Sub` represents the concept of subtraction, which is a binary operation that computes the difference between two elements of the same type. This operation is defined for homogeneous types, meaning both operands and the result are of the same type. The comment suggests that this class is related to a more general concept of subtraction (`HSub`), which might handle heterogeneous types or more complex scenarios."}
{"full_name": "Ordinal.typein", "url": "Mathlib/SetTheory/Ordinal/Basic.html#Ordinal.typein", "code_src": "mathlib4", "ptype": "def", "header": "def Ordinal.typein {α : Type u} (r : α → α → Prop ) [IsWellOrder🔗<|PREMISE|>🔗 α r] (a : α) :Ordinal🔗<|PREMISE|>🔗", "code": "def typein (r : α → α → Prop) [IsWellOrder α r] (a : α) : Ordinal :=\n  type (Subrel r { b | r b a })\n", "additional_info": "The order type of an element inside a well order. For the embedding as a principal segment, see\n`🗟typein.principalSeg🗟🔗../../.././Mathlib/SetTheory/Ordinal/Basic.html#Ordinal.typein.principalSeg🔗` .\nEquations\n* 🗟Ordinal.typein🗟🔗../../.././Mathlib/SetTheory/Ordinal/Basic.html#Ordinal.typein🔗  r a 🗟=🗟🔗../../.././Init/Prelude.html#Eq🔗  🗟Ordinal.type🗟🔗../../.././Mathlib/SetTheory/Ordinal/Basic.html#Ordinal.type🔗  (🗟Subrel🗟🔗../../.././Mathlib/Order/RelIso/Set.html#Subrel🔗  r {b : α | r b a})\n\n", "used_premises": [15, 25], "def_path": "Mathlib/SetTheory/Ordinal/Basic.lean", "pos": [187, 189], "informalization": "Function `Ordinal.typein` computes the order type of an element `a` within a well-ordered type `α`, using the relation `r` to determine the order."}
{"full_name": "Cardinal.IsStrongLimit", "url": "Mathlib/SetTheory/Cardinal/Cofinality.html#Cardinal.IsStrongLimit", "code_src": "mathlib4", "ptype": "def", "header": "def Cardinal.IsStrongLimit (c : Cardinal🔗<|PREMISE|>🔗 ) :Prop", "code": "def IsStrongLimit (c : Cardinal) : Prop :=\n  c ≠ 0 ∧ ∀ x < c, (2^x) < c\n", "additional_info": "A cardinal is a strong limit if it is not zero and it is\nclosed under powersets. Note that `ℵ₀` is a strong limit by this definition.\nEquations\n* 🗟Cardinal.IsStrongLimit🗟🔗../../.././Mathlib/SetTheory/Cardinal/Cofinality.html#Cardinal.IsStrongLimit🔗  c 🗟=🗟🔗../../.././Init/Prelude.html#Eq🔗  (c 🗟≠🗟🔗../../.././Init/Core.html#Ne🔗  0 🗟∧🗟🔗../../.././Init/Prelude.html#And🔗  ∀ x < c, 2 🗟^🗟🔗../../.././Init/Prelude.html#HPow.hPow🔗  x 🗟<🗟🔗../../.././Init/Prelude.html#LT.lt🔗  c)\n\n", "used_premises": [28], "def_path": "Mathlib/SetTheory/Cardinal/Cofinality.lean", "pos": [853, 855], "informalization": "Function `Cardinal.IsStrongLimit` checks if a given cardinal number `c` is a strong limit. A cardinal is a strong limit if it is not zero and for any cardinal `x` less than `c`, the power set of `x` (denoted as `2^x`) is also less than `c`."}
{"full_name": "Ordinal.cof", "url": "Mathlib/SetTheory/Cardinal/Cofinality.html#Ordinal.cof", "code_src": "mathlib4", "ptype": "def", "header": "def Ordinal.cof (o : Ordinal🔗<|PREMISE|>🔗 ) :Cardinal🔗<|PREMISE|>🔗", "code": "def cof (o : Ordinal.{u}) : Cardinal.{u} :=\n  o.liftOn (fun a => StrictOrder.cof a.r)\n    (by\n      rintro ⟨α, r, wo₁⟩ ⟨β, s, wo₂⟩ ⟨⟨f, hf⟩⟩\n      haveI := wo₁; haveI := wo₂\n      dsimp only\n      apply @RelIso.cof_eq _ _ _ _ ?_ ?_\n      · constructor\n        exact @fun a b => not_iff_not.2 hf\n      · dsimp only [swap]\n        exact ⟨fun _ => irrefl _⟩\n      · dsimp only [swap]\n        exact ⟨fun _ => irrefl _⟩)\n", "additional_info": "Cofinality of an ordinal. This is the smallest cardinal of a\nsubset `S` of the ordinal which is unbounded, in the sense\n`∀ a, ∃ b ∈ S, a ≤ b`. It is defined for all ordinals, but\n`🗟cof🗟🔗../../.././Mathlib/SetTheory/Cardinal/Cofinality.html#Order.cof🔗  0 = 0` and `🗟cof🗟🔗../../.././Mathlib/SetTheory/Cardinal/Cofinality.html#Order.cof🔗  (succ o) = 1`, so it is only really\ninteresting on limit ordinals (when it is an infinite cardinal).\nEquations\n* 🗟Ordinal.cof🗟🔗../../.././Mathlib/SetTheory/Cardinal/Cofinality.html#Ordinal.cof🔗  o 🗟=🗟🔗../../.././Init/Prelude.html#Eq🔗  🗟Quotient.liftOn🗟🔗../../.././Init/Core.html#Quotient.liftOn🔗  o (fun (a : 🗟WellOrder🗟🔗../../.././Mathlib/SetTheory/Ordinal/Basic.html#WellOrder🔗 ) => 🗟StrictOrder.cof🗟🔗../../.././Mathlib/SetTheory/Cardinal/Cofinality.html#StrictOrder.cof🔗  a.r) 🗟Ordinal.cof.proof_1🗟🔗../../.././Mathlib/SetTheory/Cardinal/Cofinality.html#Ordinal.cof.proof_1🔗\n\n", "used_premises": [25, 28], "def_path": "Mathlib/SetTheory/Cardinal/Cofinality.lean", "pos": [140, 153], "informalization": "Function `Ordinal.cof` computes the cofinality of an ordinal, which is the smallest cardinality of a subset of the ordinal that is unbounded in the sense that every element of the ordinal is less than or equal to some element in the subset."}
{"full_name": "ConNF.TangleData", "url": "ConNF/Fuzz/Hypotheses.html#ConNF.TangleData", "code_src": "con-nf", "ptype": "class", "header": "class ConNF.TangleData [ConNF.Params🔗<|PREMISE|>🔗 ] (α : ConNF.TypeIndex) :Type (u + 1)\n | Tangle : Type  u\n | Allowable : Type  u\n | allowableGroup : Group🔗<|PREMISE|>🔗  (ConNF.Allowable  α)\n | allowableToStructPerm : ConNF.Allowable  α →*  ConNF.StructPerm🔗<|PREMISE|>🔗  α\n | allowableAction : MulAction🔗<|PREMISE|>🔗  (ConNF.Allowable  α) (ConNF.Tangle  α)\n | support : ConNF.Tangle  α → ConNF.Support🔗<|PREMISE|>🔗  α\n | support_supports : ∀ (t : ConNF.Tangle  α),\n MulAction.Supports🔗<|PREMISE|>🔗  (ConNF.Allowable  α) (ConNF.Enumeration.carrier🔗<|PREMISE|>🔗  (ConNF.TangleData.support🔗<|PREMISE|>🔗  t).enum) t", "code": "class TangleData (α : TypeIndex) where\n  /-- The type of tangles that we assume were constructed at stage `α`.\n  Later in the recursion, we will construct this type explicitly, but for now, we will just assume\n  that it exists. -/\n  (Tangle : Type u)\n  /-- The type of allowable permutations that we assume exists on `α`-tangles. -/\n  (Allowable : Type u)\n  [allowableGroup : Group Allowable]\n  allowableToStructPerm : Allowable →* StructPerm α\n  [allowableAction : MulAction Allowable Tangle]\n  support : Tangle → Support α\n  support_supports (t : Tangle) :\n    haveI : MulAction Allowable (Address α) :=\n      MulAction.compHom _ allowableToStructPerm\n    MulAction.Supports Allowable (support t : Set (Address α)) t\n", "additional_info": "Data about the model elements at level `α`. This class asserts the existence of a type of\ntangles at level `α`, and a group of allowable permutations at level `α` that act on the\n`α`-tangles. We also stipulate that each tangle has a prescribed small support, called its\ndesignated support.\n- ConNF.TangleData.Tangle: The type of tangles that we assume were constructed at stage `α`.\nLater in the recursion, we will construct this type explicitly, but for now, we will just assume\nthat it exists.\n\n\n- ConNF.TangleData.Allowable: The type of allowable permutations that we assume exists on `α`-tangles.\n\n\n", "used_premises": [1, 40, 55, 56, 58, 68, 70, 71], "def_path": "ConNF/Fuzz/Hypotheses.lean", "pos": [33, 48], "informalization": "Class `ConNF.TangleData` represents data about the model elements at level `α` in the context of Constructive Ordinal Notation (ConNF). It asserts the existence of a type of tangles at level `α`, and a group of allowable permutations at level `α` that act on the `α`-tangles. Additionally, it stipulates that each tangle has a designated small support."}
{"full_name": "Group", "url": "Mathlib/Algebra/Group/Defs.html#Group", "code_src": "mathlib4", "ptype": "class", "header": "class Group (G : Type u) extends DivInvMonoid🔗<|PREMISE|>🔗 :Type u\n | mul : G → G → G\n | mul_assoc : ∀ (a b c : G), a *  b *  c =  a *  (b *  c)\n | one : G\n | one_mul : ∀ (a : G), 1 *  a =  a\n | mul_one : ∀ (a : G), a *  1 =  a\n | npow : ℕ  → G → G\n | npow_zero : ∀ (x : G), Monoid.npow🔗<|PREMISE|>🔗  0 x =  1\n | npow_succ : ∀ (n : ℕ ) (x : G), Monoid.npow🔗<|PREMISE|>🔗  (n +  1) x =  x *  Monoid.npow🔗<|PREMISE|>🔗  n x\n | inv : G → G\n | div : G → G → G\n | div_eq_mul_inv : ∀ (a b : G), a /  b =  a *  b⁻¹ \n | zpow : ℤ  → G → G\n | zpow_zero' : ∀ (a : G), DivInvMonoid.zpow🔗<|PREMISE|>🔗  0 a =  1\n | zpow_succ' : ∀ (n : ℕ ) (a : G), DivInvMonoid.zpow🔗<|PREMISE|>🔗  (Int.ofNat🔗<|PREMISE|>🔗  (Nat.succ🔗<|PREMISE|>🔗  n)) a =  a *  DivInvMonoid.zpow🔗<|PREMISE|>🔗  (Int.ofNat🔗<|PREMISE|>🔗  n) a\n | zpow_neg' : ∀ (n : ℕ ) (a : G), DivInvMonoid.zpow🔗<|PREMISE|>🔗  (Int.negSucc🔗<|PREMISE|>🔗  n) a =  (DivInvMonoid.zpow🔗<|PREMISE|>🔗  (↑(Nat.succ🔗<|PREMISE|>🔗  n)) a)⁻¹ \n | mul_left_inv : ∀ (a : G), a⁻¹  *  a =  1", "code": "class Group (G : Type u) extends DivInvMonoid G where\n  protected mul_left_inv : ∀ a : G, a⁻¹ * a = 1\n", "additional_info": "A `🗟Group🗟🔗../../.././Mathlib/Algebra/Group/Defs.html#Group🔗`  is a `🗟Monoid🗟🔗../../.././Mathlib/Algebra/Group/Defs.html#Monoid🔗`  with an operation `⁻¹` satisfying `a⁻¹ * a = 1`.\nThere is also a division operation `/` such that `a / b = a * b⁻¹`,\nwith a default so that `a / b = a * b⁻¹` holds by definition.\nUse `Group.ofLeftAxioms` or `Group.ofRightAxioms` to define a group structure\non a type with the minumum proof obligations.\n", "used_premises": [41, 46, 46, 46, 49, 49, 50, 53, 49, 50, 49, 54, 49, 53], "def_path": "Mathlib/Algebra/Group/Defs.lean", "pos": [1111, 1113], "informalization": "Class `Group` represents a monoid with an additional inverse operation satisfying `a⁻¹ * a = 1`, forming a fundamental algebraic structure with associative multiplication, identity element, and inverses."}
{"full_name": "DivInvMonoid", "url": "Mathlib/Algebra/Group/Defs.html#DivInvMonoid", "code_src": "mathlib4", "ptype": "class", "header": "class DivInvMonoid (G : Type u) extends Monoid🔗<|PREMISE|>🔗 , Inv🔗<|PREMISE|>🔗 , Div🔗<|PREMISE|>🔗 :Type u\n | mul : G → G → G\n | mul_assoc : ∀ (a b c : G), a *  b *  c =  a *  (b *  c)\n | one : G\n | one_mul : ∀ (a : G), 1 *  a =  a\n | mul_one : ∀ (a : G), a *  1 =  a\n | npow : ℕ  → G → G\n | npow_zero : ∀ (x : G), Monoid.npow🔗<|PREMISE|>🔗  0 x =  1\n | npow_succ : ∀ (n : ℕ ) (x : G), Monoid.npow🔗<|PREMISE|>🔗  (n +  1) x =  x *  Monoid.npow🔗<|PREMISE|>🔗  n x\n | inv : G → G\n | div : G → G → G\n | div_eq_mul_inv : ∀ (a b : G), a /  b =  a *  b⁻¹ \n | zpow : ℤ  → G → G\n | zpow_zero' : ∀ (a : G), DivInvMonoid.zpow🔗<|PREMISE|>🔗  0 a =  1\n | zpow_succ' : ∀ (n : ℕ ) (a : G), DivInvMonoid.zpow🔗<|PREMISE|>🔗  (Int.ofNat🔗<|PREMISE|>🔗  (Nat.succ🔗<|PREMISE|>🔗  n)) a =  a *  DivInvMonoid.zpow🔗<|PREMISE|>🔗  (Int.ofNat🔗<|PREMISE|>🔗  n) a\n | zpow_neg' : ∀ (n : ℕ ) (a : G), DivInvMonoid.zpow🔗<|PREMISE|>🔗  (Int.negSucc🔗<|PREMISE|>🔗  n) a =  (DivInvMonoid.zpow🔗<|PREMISE|>🔗  (↑(Nat.succ🔗<|PREMISE|>🔗  n)) a)⁻¹ ", "code": "class DivInvMonoid (G : Type u) extends Monoid G, Inv G, Div G where\n  protected div := DivInvMonoid.div'\n  /-- `a / b := a * b⁻¹` -/\n  protected div_eq_mul_inv : ∀ a b : G, a / b = a * b⁻¹ := by intros; rfl\n  /-- The power operation: `a ^ n = a * ··· * a`; `a ^ (-n) = a⁻¹ * ··· a⁻¹` (`n` times) -/\n  protected zpow : ℤ → G → G := zpowRec\n  /-- `a ^ 0 = 1` -/\n  protected zpow_zero' : ∀ a : G, zpow 0 a = 1 := by intros; rfl\n  /-- `a ^ (n + 1) = a * a ^ n` -/\n  protected zpow_succ' (n : ℕ) (a : G) : zpow (Int.ofNat n.succ) a = a * zpow (Int.ofNat n) a := by\n    intros; rfl\n  /-- `a ^ -(n + 1) = (a ^ (n + 1))⁻¹` -/\n  protected zpow_neg' (n : ℕ) (a : G) : zpow (Int.negSucc n) a = (zpow n.succ a)⁻¹ := by intros; rfl\n", "additional_info": "A `🗟DivInvMonoid🗟🔗../../.././Mathlib/Algebra/Group/Defs.html#DivInvMonoid🔗`  is a `🗟Monoid🗟🔗../../.././Mathlib/Algebra/Group/Defs.html#Monoid🔗`  with operations `/` and `⁻¹` satisfying\n`🗟div_eq_mul_inv🗟🔗../../.././Mathlib/Algebra/Group/Defs.html#div_eq_mul_inv🔗  : ∀ a b, a / b = a * b⁻¹`.\nThis deduplicates the name `🗟div_eq_mul_inv🗟🔗../../.././Mathlib/Algebra/Group/Defs.html#div_eq_mul_inv🔗` .\nThe default for `div` is such that `a / b = a * b⁻¹` holds by definition.\nAdding `div` as a field rather than defining `a / b := a * b⁻¹` allows us to\navoid certain classes of unification failures, for example:\nLet `Foo X` be a type with a `∀ X, 🗟Div🗟🔗../../.././Init/Prelude.html#Div🔗  (Foo X)` instance but no\n`∀ X, 🗟Inv🗟🔗../../.././Mathlib/Algebra/Group/Defs.html#Inv🔗  (Foo X)`, e.g. when `Foo X` is a `EuclideanDomain`. Suppose we\nalso have an instance `∀ X [Cromulent X], GroupWithZero (Foo X)`. Then the\n`(/)` coming from `GroupWithZero.div` cannot be definitionally equal to\nthe `(/)` coming from `Foo.🗟Div🗟🔗../../.././Init/Prelude.html#Div🔗` .\nIn the same way, adding a `🗟zpow🗟🔗../../.././Mathlib/Algebra/Group/Defs.html#DivInvMonoid.zpow🔗`  field makes it possible to avoid definitional failures\nin diamonds. See the definition of `🗟Monoid🗟🔗../../.././Mathlib/Algebra/Group/Defs.html#Monoid🔗`  and Note [forgetful inheritance] for more\nexplanations on this.\n- DivInvMonoid.div_eq_mul_inv: `a / b := a * b⁻¹`\n\n\n- DivInvMonoid.zpow: The power operation: `a ^ n = a * ··· * a`; `a ^ (-n) = a⁻¹ * ··· a⁻¹` (`n` times)\n\n\n- DivInvMonoid.zpow_zero': `a ^ 0 = 1`\n\n\n- DivInvMonoid.zpow_succ': `a ^ (n + 1) = a * a ^ n`\n\n\n- DivInvMonoid.zpow_neg': `a ^ -(n + 1) = (a ^ (n + 1))⁻¹`\n\n\n", "used_premises": [42, 47, 48, 46, 46, 46, 49, 49, 50, 53, 49, 50, 49, 54, 49, 53], "def_path": "Mathlib/Algebra/Group/Defs.lean", "pos": [875, 888], "informalization": "Class `DivInvMonoid` represents the concept of a monoid with additional operations: inversion (`Inv`) and division (`Div`). It extends a monoid by including the unary operation of inversion and the binary operation of division, defined in terms of multiplication and inversion, and introduces integer power operations (`zpow`), extending natural number powers to include negative integers."}
{"full_name": "Monoid", "url": "Mathlib/Algebra/Group/Defs.html#Monoid", "code_src": "mathlib4", "ptype": "class", "header": "class Monoid (M : Type u) extends Semigroup🔗<|PREMISE|>🔗 , One🔗<|PREMISE|>🔗 :Type u\n | mul : M → M → M\n | mul_assoc : ∀ (a b c : M), a *  b *  c =  a *  (b *  c)\n | one : M\n | one_mul : ∀ (a : M), 1 *  a =  a\n | mul_one : ∀ (a : M), a *  1 =  a\n | npow : ℕ  → M → M\n | npow_zero : ∀ (x : M), Monoid.npow🔗<|PREMISE|>🔗  0 x =  1\n | npow_succ : ∀ (n : ℕ ) (x : M), Monoid.npow🔗<|PREMISE|>🔗  (n +  1) x =  x *  Monoid.npow🔗<|PREMISE|>🔗  n x", "code": "class Monoid (M : Type u) extends Semigroup M, MulOneClass M where\n  /-- Raising to the power of a natural number. -/\n  protected npow : ℕ → M → M := npowRec\n  /-- Raising to the power `(0 : ℕ)` gives `1`. -/\n  protected npow_zero : ∀ x, npow 0 x = 1 := by intros; rfl\n  /-- Raising to the power `(n + 1 : ℕ)` behaves as expected. -/\n  protected npow_succ : ∀ (n : ℕ) (x), npow (n + 1) x = x * npow n x := by intros; rfl\n", "additional_info": "A `🗟Monoid🗟🔗../../.././Mathlib/Algebra/Group/Defs.html#Monoid🔗`  is a `🗟Semigroup🗟🔗../../.././Mathlib/Algebra/Group/Defs.html#Semigroup🔗`  with an element `1` such that `1 * a = a * 1 = a`.\n- Monoid.one_mul: One is a left neutral element for multiplication\n\n\n- Monoid.mul_one: One is a right neutral element for multiplication\n\n\n- Monoid.npow: Raising to the power of a natural number.\n\n\n- Monoid.npow_zero: Raising to the power `(0 : ℕ)` gives `1`.\n\n\n- Monoid.npow_succ: Raising to the power `(n + 1 : ℕ)` behaves as expected.\n\n\n", "used_premises": [43, 45, 46, 46, 46], "def_path": "Mathlib/Algebra/Group/Defs.lean", "pos": [611, 618], "informalization": "Class `Monoid` represents the concept of a monoid, which is an algebraic structure that extends a semigroup by adding a multiplicative identity element. A monoid is defined on a type `M` and includes a binary operation `mul` (often thought of as multiplication) that is associative, and an element `one` (often denoted as `1`) that acts as a neutral element for multiplication. This means that for any element `a` in `M`, the identity element `1` satisfies `1 * a = a` and `a * 1 = a`. Additionally, a monoid includes a method `npow` for raising elements to natural number powers, which is defined recursively such that `npow 0 x = 1` for any `x` in `M`, and `npow (n + 1) x = x * npow n x`. This power operation captures the repeated application of the monoid's multiplication, providing a way to express iterated multiplication succinctly. Monoids are fundamental in abstract algebra and computer science, serving as the basis for more complex algebraic structures and as models for various computational processes involving composition and aggregation."}
{"full_name": "Semigroup", "url": "Mathlib/Algebra/Group/Defs.html#Semigroup", "code_src": "mathlib4", "ptype": "class", "header": "class Semigroup (G : Type u) extends Mul🔗<|PREMISE|>🔗 :Type u\n | mul : G → G → G\n | mul_assoc : ∀ (a b c : G), a *  b *  c =  a *  (b *  c)", "code": "class Semigroup (G : Type u) extends Mul G where\n  /-- Multiplication is associative -/\n  protected mul_assoc : ∀ a b c : G, a * b * c = a * (b * c)\n", "additional_info": "A semigroup is a type with an associative `(*)`.\n- Semigroup.mul_assoc: Multiplication is associative\n\n\n", "used_premises": [44], "def_path": "Mathlib/Algebra/Group/Defs.lean", "pos": [262, 265], "informalization": "Class `Semigroup` represents the concept of a semigroup, which is a type `G` equipped with a binary operation `mul` (often thought of as multiplication) that is associative. This means that for any elements `a`, `b`, and `c` in `G`, the operation satisfies the property `(a * b) * c = a * (b * c)`. Semigroups are a fundamental algebraic structure in abstract algebra, providing a basis for more complex structures like monoids and groups by ensuring that the operation is well-behaved under composition."}
{"full_name": "Mul", "url": "Init/Prelude.html#Mul", "code_src": "lean4", "ptype": "class", "header": "class Mul (α : Type u) :Type u\n | mul : α → α → α", "code": "class Mul (α : Type u) where\n  /-- `a * b` computes the product of `a` and `b`. See `HMul`. -/\n  mul : α → α → α\n", "additional_info": "The homogeneous version of `🗟HMul🗟🔗.././Init/Prelude.html#HMul🔗` : `a * b : α` where `a b : α`.\n- Mul.mul: `a * b` computes the product of `a` and `b`. See `🗟HMul🗟🔗.././Init/Prelude.html#HMul🔗` .\n\n\n", "used_premises": [], "def_path": "Init/Prelude.lean", "pos": [1299, 1302], "informalization": "Class `Mul` represents the concept of multiplication."}
{"full_name": "One", "url": "Mathlib/Init/ZeroOne.html#One", "code_src": "mathlib4", "ptype": "class", "header": "class One (α : Type u) :Type u\n | one : α", "code": "class One (α : Type u) where\n  one : α\n", "additional_info": "", "used_premises": [], "def_path": "Mathlib/Init/ZeroOne.lean", "pos": [24, 26], "informalization": "Class `One` represents the concept of a multiplicative identity element, often denoted as `1`."}
{"full_name": "Monoid.npow", "url": "Mathlib/Algebra/Group/Defs.html#Monoid", "code_src": "mathlib4", "ptype": "structure_field", "header": "structure_field Monoid🔗<|PREMISE|>🔗.npow : ℕ  → M → M", "code": "class Monoid (M : Type u) extends Semigroup M, MulOneClass M where\n  /-- Raising to the power of a natural number. -/\n  protected npow : ℕ → M → M := npowRec\n  /-- Raising to the power `(0 : ℕ)` gives `1`. -/\n  protected npow_zero : ∀ x, npow 0 x = 1 := by intros; rfl\n  /-- Raising to the power `(n + 1 : ℕ)` behaves as expected. -/\n  protected npow_succ : ∀ (n : ℕ) (x), npow (n + 1) x = x * npow n x := by intros; rfl\n", "additional_info": "Raising to the power of a natural number.\n\n", "used_premises": [42], "def_path": "Mathlib/Algebra/Group/Defs.lean", "pos": [611, 618], "informalization": "Function `Monoid.npow` takes a natural number and an element from a monoid, returning the result of raising the element to that natural number power, essential for iterated multiplication in monoids."}
{"full_name": "Inv", "url": "Mathlib/Algebra/Group/Defs.html#Inv", "code_src": "mathlib4", "ptype": "class", "header": "class Inv (α : Type u) :Type u\n | inv : α → α", "code": "class Inv (α : Type u) where\n  /-- Invert an element of α. -/\n  inv : α → α\n", "additional_info": "Class of types that have an inversion operation.\n- Inv.inv: Invert an element of α.\n\n\n", "used_premises": [], "def_path": "Mathlib/Algebra/Group/Defs.lean", "pos": [162, 165], "informalization": "Class `Inv` represents the concept of an inversion operation, which is a unary operation that maps an element of a type `α` to another element of `α`. This operation is denoted by `inv` and is intended to represent the inverse of an element in the context of the type `α`. The specific interpretation of \"inverse\" can vary depending on the type and the algebraic structure it possesses. For example, in the context of a group, the inverse of an element `a` is an element `b` such that `a * b = b * a = 1`, where `1` is the identity element of the group and `*` is the group operation. In other contexts, such as rings or fields, the inverse might refer to the additive inverse (negation) or the multiplicative inverse (reciprocal), depending on the operation associated with the `Inv` class. This class provides a uniform way to define and work with inversion operations across different mathematical structures."}
{"full_name": "Div", "url": "Init/Prelude.html#Div", "code_src": "lean4", "ptype": "class", "header": "class Div (α : Type u) :Type u\n | div : α → α → α", "code": "class Div (α : Type u) where\n  /-- `a / b` computes the result of dividing `a` by `b`. See `HDiv`. -/\n  div : α → α → α\n", "additional_info": "The homogeneous version of `🗟HDiv🗟🔗.././Init/Prelude.html#HDiv🔗` : `a / b : α` where `a b : α`.\n- Div.div: `a / b` computes the result of dividing `a` by `b`. See `🗟HDiv🗟🔗.././Init/Prelude.html#HDiv🔗` .\n\n\n", "used_premises": [], "def_path": "Init/Prelude.lean", "pos": [1313, 1316], "informalization": "Class `Div` represents the concept of division, which is a binary operation that computes the quotient of two elements of the same type. This operation is defined for homogeneous types, meaning both operands and the result are of the same type. The comment suggests that this class is related to a more general concept of division (`HDiv`), which might handle heterogeneous types or more complex scenarios."}
{"full_name": "DivInvMonoid.zpow", "url": "Mathlib/Algebra/Group/Defs.html#DivInvMonoid", "code_src": "mathlib4", "ptype": "structure_field", "header": "structure_field DivInvMonoid🔗<|PREMISE|>🔗.zpow : ℤ  → G → G", "code": "class DivInvMonoid (G : Type u) extends Monoid G, Inv G, Div G where\n  protected div := DivInvMonoid.div'\n  /-- `a / b := a * b⁻¹` -/\n  protected div_eq_mul_inv : ∀ a b : G, a / b = a * b⁻¹ := by intros; rfl\n  /-- The power operation: `a ^ n = a * ··· * a`; `a ^ (-n) = a⁻¹ * ··· a⁻¹` (`n` times) -/\n  protected zpow : ℤ → G → G := zpowRec\n  /-- `a ^ 0 = 1` -/\n  protected zpow_zero' : ∀ a : G, zpow 0 a = 1 := by intros; rfl\n  /-- `a ^ (n + 1) = a * a ^ n` -/\n  protected zpow_succ' (n : ℕ) (a : G) : zpow (Int.ofNat n.succ) a = a * zpow (Int.ofNat n) a := by\n    intros; rfl\n  /-- `a ^ -(n + 1) = (a ^ (n + 1))⁻¹` -/\n  protected zpow_neg' (n : ℕ) (a : G) : zpow (Int.negSucc n) a = (zpow n.succ a)⁻¹ := by intros; rfl\n", "additional_info": "The power operation: `a ^ n = a * ··· * a`; `a ^ (-n) = a⁻¹ * ··· a⁻¹` (`n` times)\n\n", "used_premises": [41], "def_path": "Mathlib/Algebra/Group/Defs.lean", "pos": [875, 888], "informalization": "Function `DivInvMonoid.zpow` takes an integer and an element from a monoid with division and inversion, returning the result of raising the element to the power of the integer, handling both positive and negative exponents."}
{"full_name": "Int.ofNat", "url": "Init/Data/Int/Basic.html#Int", "code_src": "lean4", "ptype": "constructor", "header": "constructor Int🔗<|PREMISE|>🔗.ofNat: Nat🔗<|PREMISE|>🔗  → Int🔗<|PREMISE|>🔗", "code": "inductive Int : Type where\n  /-- A natural number is an integer (`0` to `∞`). -/\n  | ofNat   : Nat → Int\n  /-- The negation of the successor of a natural number is an integer\n    (`-1` to `-∞`). -/\n  | negSucc : Nat → Int\n", "additional_info": "A natural number is an integer (`0` to `∞`).\n\n", "used_premises": [51, 52, 51], "def_path": "Init/Data/Int/Basic.lean", "pos": [39, 45], "informalization": "Constructor `Int.ofNat` is a method within the `Int` inductive type that constructs an integer from a natural number. Specifically, if `n` is a natural number, `Int.ofNat n` represents the integer `n`. This constructor is used to include natural numbers within the set of integers."}
{"full_name": "Int", "url": "Init/Data/Int/Basic.html#Int", "code_src": "lean4", "ptype": "inductive", "header": "inductive Int :Type", "code": "inductive Int : Type where\n  /-- A natural number is an integer (`0` to `∞`). -/\n  | ofNat   : Nat → Int\n  /-- The negation of the successor of a natural number is an integer\n    (`-1` to `-∞`). -/\n  | negSucc : Nat → Int\n", "additional_info": "The type of integers. It is defined as an inductive type based on the\nnatural number type `🗟Nat🗟🔗../../.././Init/Prelude.html#Nat🔗`  featuring two constructors: \"a natural\nnumber is an integer\", and \"the negation of a successor of a natural\nnumber is an integer\". The former represents integers between `0`\n(inclusive) and `∞`, and the latter integers between `-∞` and `-1`\n(inclusive).\nThis type is special-cased by the compiler. The runtime has a special\nrepresentation for `🗟Int🗟🔗../../.././Init/Data/Int/Basic.html#Int🔗`  which stores \"small\" signed numbers directly,\nand larger numbers use an arbitrary precision \"bignum\" library\n(usually 🗟GMP🗟🔗https://gmplib.org/🔗 ). A \"small number\" is an integer\nthat can be encoded with 63 bits (31 bits on 32-bits architectures).\n", "used_premises": [], "def_path": "Init/Data/Int/Basic.lean", "pos": [39, 45], "informalization": "Type `Int` represents the integers, which include both natural numbers (0, 1, 2, ...) and their negative counterparts (-1, -2, -3, ...)."}
{"full_name": "Nat", "url": "Init/Prelude.html#Nat", "code_src": "lean4", "ptype": "inductive", "header": "inductive Nat :Type", "code": "inductive Nat where\n  /-- `Nat.zero`, normally written `0 : Nat`, is the smallest natural number.\n  This is one of the two constructors of `Nat`. -/\n  | zero : Nat\n  /-- The successor function on natural numbers, `succ n = n + 1`.\n  This is one of the two constructors of `Nat`. -/\n  | succ (n : Nat) : Nat\n", "additional_info": "The type of natural numbers, starting at zero. It is defined as an\ninductive type freely generated by \"zero is a natural number\" and\n\"the successor of a natural number is a natural number\".\nYou can prove a theorem `P n` about `n : 🗟Nat🗟🔗.././Init/Prelude.html#Nat🔗`  by `induction n`, which will\nexpect a proof of the theorem for `P 0`, and a proof of `P (succ i)` assuming\na proof of `P i`. The same method also works to define functions by recursion\non natural numbers: induction and recursion are two expressions of the same\noperation from Lean's point of view.\nopen 🗟Nat🗟🔗.././Init/Prelude.html#Nat🔗 \nexample (n : Nat) : n < 🗟succ🗟🔗.././Init/Prelude.html#Nat.succ🔗  n := by\n  induction n with\n  | 🗟zero🗟🔗.././Init/Prelude.html#Nat.zero🔗  =>\n    show 0 < 1\n    🗟decide🗟🔗.././Init/Prelude.html#Decidable.decide🔗 \n  | 🗟succ🗟🔗.././Init/Prelude.html#Nat.succ🔗  i ih => -- ih : i < 🗟succ🗟🔗.././Init/Prelude.html#Nat.succ🔗  i\n    show 🗟succ🗟🔗.././Init/Prelude.html#Nat.succ🔗  i < 🗟succ🗟🔗.././Init/Prelude.html#Nat.succ🔗  (succ i)\n    exact 🗟Nat.succ_lt_succ🗟🔗.././Init/Data/Nat/Basic.html#Nat.succ_lt_succ🔗  ih\n\nThis type is special-cased by both the kernel and the compiler:\n* The type of expressions contains \"`🗟Nat🗟🔗.././Init/Prelude.html#Nat🔗`  literals\" as a primitive constructor,\nand the kernel knows how to reduce zero/succ expressions to nat literals.\n* If implemented naively, this type would represent a numeral `n` in unary as a\nlinked list with `n` links, which is horribly inefficient. Instead, the\nruntime itself has a special representation for `🗟Nat🗟🔗.././Init/Prelude.html#Nat🔗`  which stores numbers up\nto 2^63 directly and larger numbers use an arbitrary precision \"bignum\"\nlibrary (usually 🗟GMP🗟🔗https://gmplib.org/🔗 ).\n\n", "used_premises": [], "def_path": "Init/Prelude.lean", "pos": [1064, 1071], "informalization": "Type `Nat` represents the natural numbers by Peano axioms. It provides a way to represent both the smallest natural number, `0`, and any other natural number through the successor function."}
{"full_name": "Nat.succ", "url": "Init/Prelude.html#Nat", "code_src": "lean4", "ptype": "constructor", "header": "constructor Nat🔗<|PREMISE|>🔗.succ: Nat🔗<|PREMISE|>🔗  → Nat🔗<|PREMISE|>🔗", "code": "inductive Nat where\n  /-- `Nat.zero`, normally written `0 : Nat`, is the smallest natural number.\n  This is one of the two constructors of `Nat`. -/\n  | zero : Nat\n  /-- The successor function on natural numbers, `succ n = n + 1`.\n  This is one of the two constructors of `Nat`. -/\n  | succ (n : Nat) : Nat\n", "additional_info": "The successor function on natural numbers, `🗟succ🗟🔗.././Init/Prelude.html#Nat.succ🔗  n = n + 1`.\nThis is one of the two constructors of `🗟Nat🗟🔗.././Init/Prelude.html#Nat🔗` .\n\n", "used_premises": [52, 52, 52], "def_path": "Init/Prelude.lean", "pos": [1064, 1071], "informalization": "Constructor `Nat.succ` is a method within the `Nat` inductive type that represents the successor function on natural numbers. This function takes a natural number `n` and returns its successor, which is `n + 1`."}
{"full_name": "Int.negSucc", "url": "Init/Data/Int/Basic.html#Int", "code_src": "lean4", "ptype": "constructor", "header": "constructor Int🔗<|PREMISE|>🔗.negSucc: Nat🔗<|PREMISE|>🔗  → Int🔗<|PREMISE|>🔗", "code": "inductive Int : Type where\n  /-- A natural number is an integer (`0` to `∞`). -/\n  | ofNat   : Nat → Int\n  /-- The negation of the successor of a natural number is an integer\n    (`-1` to `-∞`). -/\n  | negSucc : Nat → Int\n", "additional_info": "The negation of the successor of a natural number is an integer\n(`-1` to `-∞`).\n\n", "used_premises": [51, 52, 51], "def_path": "Init/Data/Int/Basic.lean", "pos": [39, 45], "informalization": "Constructor `Int.negSucc` is a method within the `Int` inductive type that constructs an integer from a natural number by representing the negation of the successor of that natural number. Specifically, if `n` is a natural number, `Int.negSucc n` represents the integer `-(n + 1)`. This constructor is used to generate the negative integers starting from `-1` and going down to `-∞`."}
{"full_name": "ConNF.StructPerm", "url": "ConNF/Structural/StructPerm.html#ConNF.StructPerm", "code_src": "con-nf", "ptype": "abbrev", "header": "@[inline, reducible]abbrev ConNF.StructPerm [ConNF.Params🔗<|PREMISE|>🔗 ] :ConNF.TypeIndex → Type u", "code": "abbrev StructPerm : TypeIndex → Type u :=\n  Tree NearLitterPerm\n", "additional_info": "A *structural permutation* on a proper type index `α` is a near-litter permutation for\neach `α`-extended index. This represents how the permutation acts along each path down the type\nlevels in the model. Note that we define structural permutations as trees of near-litter\npermutations.\nEquations\n* ConNF.StructPerm 🗟=🗟🔗../.././Init/Prelude.html#Eq🔗  🗟ConNF.Tree🗟🔗../.././ConNF/Structural/Tree.html#ConNF.Tree🔗  ConNF.NearLitterPerm\n\n", "used_premises": [1], "def_path": "ConNF/Structural/StructPerm.lean", "pos": [33, 35], "informalization": "A *structural permutation* on a proper type index `α` is a near-litter permutation for each `α`-extended index. This represents how the permutation acts along each path down the type levels in the model. Note that we define structural permutations as trees of near-litter permutations."}
{"full_name": "MulAction", "url": "Mathlib/GroupTheory/GroupAction/Defs.html#MulAction", "code_src": "mathlib4", "ptype": "class", "header": "class MulAction (α : Type u_10) (β : Type u_11) [Monoid🔗<|PREMISE|>🔗 α] extends SMul🔗<|PREMISE|>🔗 :Type (max u_10 u_11)\n | smul : α → β → β\n | one_smul : ∀ (b : β), 1 •  b =  b\n | mul_smul : ∀ (x y : α) (b : β), (x *  y) •  b =  x •  y •  b", "code": "class MulAction (α : Type*) (β : Type*) [Monoid α] extends SMul α β where\n  /-- One is the neutral element for `•` -/\n  protected one_smul : ∀ b : β, (1 : α) • b = b\n  /-- Associativity of `•` and `*` -/\n  mul_smul : ∀ (x y : α) (b : β), (x * y) • b = x • y • b\n", "additional_info": "Typeclass for multiplicative actions by monoids. This generalizes group actions.\n- MulAction.one_smul: One is the neutral element for `•`\n\n\n- MulAction.mul_smul: Associativity of `•` and `*`\n\n\n", "used_premises": [42, 57], "def_path": "Mathlib/GroupTheory/GroupAction/Defs.lean", "pos": [107, 112], "informalization": "Class `MulAction` represents the concept of a multiplicative action of a monoid `α` on a type `β`, where the action is associative with the monoid's multiplication and the identity element of the monoid acts as a neutral element for the action."}
{"full_name": "SMul", "url": "Mathlib/Algebra/Group/Defs.html#SMul", "code_src": "mathlib4", "ptype": "class", "header": "class SMul (M : Type u) (α : Type v) :Type (max u v)\n | smul : M → α → α", "code": "class SMul (M : Type u) (α : Type v) where\n  /-- `a • b` computes the product of `a` and `b`. The meaning of this notation is type-dependent,\n  but it is intended to be used for left actions. -/\n  smul : M → α → α\n", "additional_info": "Typeclass for types with a scalar multiplication operation, denoted `•` (`\\bu`)\n- SMul.smul: `a • b` computes the product of `a` and `b`. The meaning of this notation is type-dependent,\nbut it is intended to be used for left actions.\n\n\n", "used_premises": [], "def_path": "Mathlib/Algebra/Group/Defs.lean", "pos": [98, 102], "informalization": "Class `SMul` represents the concept of scalar multiplication, which is a binary operation between elements of a type `M` (the scalar) and elements of another type `α` (the target), resulting in an element of `α`. This operation is denoted by `•` (read as \"smul\") and is intended to be used for left actions, meaning the scalar `a` acts on the element `b` from the left. The specific interpretation of this operation can vary depending on the types involved, but it is commonly used in contexts such as vector spaces, where it represents the multiplication of a vector by a scalar. This class provides a uniform way to define and work with scalar multiplication across different mathematical structures."}
{"full_name": "ConNF.Support", "url": "ConNF/Structural/Support.html#ConNF.Support", "code_src": "con-nf", "ptype": "structure", "header": "structure ConNF.Support [ConNF.Params🔗<|PREMISE|>🔗 ] (α : ConNF.TypeIndex) :Type u\n | enum : ConNF.Enumeration🔗<|PREMISE|>🔗  (ConNF.Address🔗<|PREMISE|>🔗  α)\n | mem_of_mem_symmDiff' : ∀ (A : ConNF.ExtendedIndex🔗<|PREMISE|>🔗  α) (N₁ N₂ : ConNF.NearLitter) (a : ConNF.Atom),\n N₁.fst =  N₂.fst →\n a ∈  symmDiff🔗<|PREMISE|>🔗  ↑N₁ ↑N₂ →\n { path := A, value := Sum.inr🔗<|PREMISE|>🔗  N₁ } ∈  self.enum →\n { path := A, value := Sum.inr🔗<|PREMISE|>🔗  N₂ } ∈  self.enum → { path := A, value := Sum.inl🔗<|PREMISE|>🔗  a } ∈  self.enum", "code": "structure Support (α : TypeIndex) where\n  enum : Enumeration (Address α)\n  mem_of_mem_symmDiff' (A : ExtendedIndex α) (N₁ N₂ : NearLitter) (a : Atom) :\n    N₁.1 = N₂.1 → a ∈ (N₁ : Set Atom) ∆ N₂ →\n    ⟨A, inr N₁⟩ ∈ enum → ⟨A, inr N₂⟩ ∈ enum → ⟨A, inl a⟩ ∈ enum\n", "additional_info": "A *support* is a function from an initial segment of κ to the type of addresses,\nsuch that if `N₁, N₂` are near-litters near the same litter, any atoms in their symmetric difference\nare included in the enumeration.\n", "used_premises": [1, 59, 60, 61, 62, 65, 65, 67], "def_path": "ConNF/Structural/Support.lean", "pos": [121, 126], "informalization": "Structure `ConNF.Support` represents a function from an initial segment of `κ` to the type of addresses in the context of Constructive Ordinal Notation (ConNF). It ensures that for any two near-litters `N₁` and `N₂` that are near the same litter, any atoms in their symmetric difference are included in the enumeration."}
{"full_name": "ConNF.Enumeration", "url": "ConNF/Structural/Enumeration.html#ConNF.Enumeration", "code_src": "con-nf", "ptype": "structure", "header": "structure ConNF.Enumeration [ConNF.Params🔗<|PREMISE|>🔗 ] (α : Type u_1) :Type (max u u_1)\n | max : ConNF.κ\n | f : (i : ConNF.κ) → i <  self.max → α", "code": "structure Enumeration (α : Type _) where\n  max : κ\n  f : (i : κ) → i < max → α\n", "additional_info": "An *`α`-enumeration* is a function from an initial segment of κ to `α`.\n", "used_premises": [1], "def_path": "ConNF/Structural/Enumeration.lean", "pos": [16, 19], "informalization": "An `α`-enumeration is a function from an initial segment of `κ` to `α`."}
{"full_name": "ConNF.Address", "url": "ConNF/Structural/Support.html#ConNF.Address", "code_src": "con-nf", "ptype": "structure", "header": "structure ConNF.Address [ConNF.Params🔗<|PREMISE|>🔗 ] (α : ConNF.TypeIndex) :Type u\n | path : ConNF.ExtendedIndex🔗<|PREMISE|>🔗  α\n | value : ConNF.Atom ⊕  ConNF.NearLitter", "code": "structure Address (α : TypeIndex) : Type u\n    where\n  path : ExtendedIndex α\n  value : Atom ⊕ NearLitter\n", "additional_info": "A *address* is an extended type index together with an atom or a near-litter.\nThis represents an object in the base type (the atom or near-litter) together with the path\ndetailing how we descend from type `α` to type `⊥` by looking at elements of elements and so on\nin the model.\n", "used_premises": [1, 61], "def_path": "ConNF/Structural/Support.lean", "pos": [31, 35], "informalization": "Structure `ConNF.Address` represents an object in the base type (the atom or near-litter) together with the path detailing how we descend from type `α` to type `⊥` by looking at elements of elements and so on in the model."}
{"full_name": "ConNF.ExtendedIndex", "url": "ConNF/Structural/Index.html#ConNF.ExtendedIndex", "code_src": "con-nf", "ptype": "def", "header": "def ConNF.ExtendedIndex [ConNF.Params🔗<|PREMISE|>🔗 ] (α : ConNF.TypeIndex) :Type u", "code": "def ExtendedIndex (α : TypeIndex) :=\n  Quiver.Path α ⊥\n", "additional_info": "A (finite) path from the type `🗟α🗟🔗../.././ConNF/Structural/Index.html#ConNF.Level.α🔗`  to the base type.\nThis is a way that we can perceive extensionality, iteratively descending to lower\ntypes in the hierarchy until we reach the base type.\nAs `Λ` is well-ordered, there are no infinite descending paths.\nEquations\n* 🗟ConNF.ExtendedIndex🗟🔗../.././ConNF/Structural/Index.html#ConNF.ExtendedIndex🔗  α 🗟=🗟🔗../.././Init/Prelude.html#Eq🔗  🗟Quiver.Path🗟🔗../.././Mathlib/Combinatorics/Quiver/Path.html#Quiver.Path🔗  α 🗟⊥🗟🔗../.././Mathlib/Order/Notation.html#Bot.bot🔗\n\n", "used_premises": [1], "def_path": "ConNF/Structural/Index.lean", "pos": [59, 61], "informalization": "Function `ConNF.ExtendedIndex` defines a finite path from a type `α` to the base type `⊥` in the context of Constructive Ordinal Notation (ConNF). This path represents a way to understand extensionality by iteratively descending to lower types in the hierarchy until reaching the base type. Since `Λ` is well-ordered, there are no infinite descending paths."}
{"full_name": "symmDiff", "url": "Mathlib/Order/SymmDiff.html#symmDiff", "code_src": "mathlib4", "ptype": "def", "header": "def symmDiff {α : Type u_2} [Sup🔗<|PREMISE|>🔗 α] [SDiff🔗<|PREMISE|>🔗 α] (a : α) (b : α) :α", "code": "def symmDiff [Sup α] [SDiff α] (a b : α) : α :=\n  a \\ b ⊔ b \\ a\n", "additional_info": "The symmetric difference operator on a type with `⊔` and `\\` is `(A \\ B) ⊔ (B \\ A)`.\nEquations\n* 🗟symmDiff🗟🔗../.././Mathlib/Order/SymmDiff.html#symmDiff🔗  a b 🗟=🗟🔗../.././Init/Prelude.html#Eq🔗  a 🗟\\🗟🔗../.././Init/Core.html#SDiff.sdiff🔗  b 🗟⊔🗟🔗../.././Mathlib/Order/Notation.html#Sup.sup🔗  b 🗟\\🗟🔗../.././Init/Core.html#SDiff.sdiff🔗  a\n\n", "used_premises": [63, 64], "def_path": "Mathlib/Order/SymmDiff.lean", "pos": [59, 61], "informalization": "Function `symmDiff` calculates the symmetric difference between two sets `a` and `b`, which is defined as the union of the relative complements `a \\ b` and `b \\ a`."}
{"full_name": "Sup", "url": "Mathlib/Order/Notation.html#Sup", "code_src": "mathlib4", "ptype": "class", "header": "class Sup (α : Type u_1) :Type u_1\n | sup : α → α → α", "code": "class Sup (α : Type*) where\n  /-- Least upper bound (`\\lub` notation) -/\n  sup : α → α → α\n", "additional_info": "Typeclass for the `⊔` (`\\lub`) notation\n- Sup.sup: Least upper bound (`\\lub` notation)\n\n\n", "used_premises": [], "def_path": "Mathlib/Order/Notation.lean", "pos": [46, 49], "informalization": "Class `Sup` represents the concept of a least upper bound operation, often denoted as `⊔` (`\\lub`), for a type `α`."}
{"full_name": "SDiff", "url": "Init/Core.html#SDiff", "code_src": "lean4", "ptype": "class", "header": "class SDiff (α : Type u) :Type u\n | sdiff : α → α → α", "code": "class SDiff (α : Type u) where\n  /--\n  `a \\ b` is the set difference of `a` and `b`,\n  consisting of all elements in `a` that are not in `b`.\n  -/\n  sdiff : α → α → α\n", "additional_info": "Notation type class for the set difference `\\`.\n- SDiff.sdiff: `a \\ b` is the set difference of `a` and `b`,\nconsisting of all elements in `a` that are not in `b`.\n\n\n", "used_premises": [], "def_path": "Init/Core.lean", "pos": [407, 413], "informalization": "Class `SDiff` represents the concept of set difference, providing a binary operation `sdiff` that returns the elements of `a` not in `b`."}
{"full_name": "Sum.inr", "url": "Init/Core.html#Sum", "code_src": "lean4", "ptype": "constructor", "header": "constructor Sum🔗<|PREMISE|>🔗.inr: {α : Type  u} → {β : Type  v} → β → α ⊕  β", "code": "inductive Sum (α : Type u) (β : Type v) where\n  /-- Left injection into the sum type `α ⊕ β`. If `a : α` then `.inl a : α ⊕ β`. -/\n  | inl (val : α) : Sum α β\n  /-- Right injection into the sum type `α ⊕ β`. If `b : β` then `.inr b : α ⊕ β`. -/\n  | inr (val : β) : Sum α β\n", "additional_info": "Right injection into the sum type `α ⊕ β`. If `b : β` then `.🗟inr🗟🔗.././Init/Core.html#Sum.inr🔗  b : α ⊕ β`.\n\n", "used_premises": [66], "def_path": "Init/Core.lean", "pos": [129, 134], "informalization": "Constructor `Sum.inr` is a method within the `Sum` inductive type that constructs an element of the sum type `α ⊕ β` from an element of type `β`. Specifically, if `b` is an element of type `β`, then `Sum.inr b` represents the right injection of `b` into the sum type `α ⊕ β`."}
{"full_name": "Sum", "url": "Init/Core.html#Sum", "code_src": "lean4", "ptype": "inductive", "header": "inductive Sum (α : Type u) (β : Type v) :Type (max u v)", "code": "inductive Sum (α : Type u) (β : Type v) where\n  /-- Left injection into the sum type `α ⊕ β`. If `a : α` then `.inl a : α ⊕ β`. -/\n  | inl (val : α) : Sum α β\n  /-- Right injection into the sum type `α ⊕ β`. If `b : β` then `.inr b : α ⊕ β`. -/\n  | inr (val : β) : Sum α β\n", "additional_info": "`🗟Sum🗟🔗.././Init/Core.html#Sum🔗  α β`, or `α ⊕ β`, is the disjoint union of types `α` and `β`.\nAn element of `α ⊕ β` is either of the form `.🗟inl🗟🔗.././Init/Core.html#Sum.inl🔗  a` where `a : α`,\nor `.🗟inr🗟🔗.././Init/Core.html#Sum.inr🔗  b` where `b : β`.\n", "used_premises": [], "def_path": "Init/Core.lean", "pos": [129, 134], "informalization": "Type `Sum α β` represents the disjoint union of types `α` and `β`, containing elements of the form `.inl a` where `a : α`, or `.inr b` where `b : β`."}
{"full_name": "Sum.inl", "url": "Init/Core.html#Sum", "code_src": "lean4", "ptype": "constructor", "header": "constructor Sum🔗<|PREMISE|>🔗.inl: {α : Type  u} → {β : Type  v} → α → α ⊕  β", "code": "inductive Sum (α : Type u) (β : Type v) where\n  /-- Left injection into the sum type `α ⊕ β`. If `a : α` then `.inl a : α ⊕ β`. -/\n  | inl (val : α) : Sum α β\n  /-- Right injection into the sum type `α ⊕ β`. If `b : β` then `.inr b : α ⊕ β`. -/\n  | inr (val : β) : Sum α β\n", "additional_info": "Left injection into the sum type `α ⊕ β`. If `a : α` then `.🗟inl🗟🔗.././Init/Core.html#Sum.inl🔗  a : α ⊕ β`.\n\n", "used_premises": [66], "def_path": "Init/Core.lean", "pos": [129, 134], "informalization": "Function `Sum.inl` injects an element of type `α` into the left side of the sum type `α ⊕ β`."}
{"full_name": "MulAction.Supports", "url": "Mathlib/GroupTheory/GroupAction/Support.html#MulAction.Supports", "code_src": "mathlib4", "ptype": "def", "header": "def MulAction.Supports (G : Type u_1) {α : Type u_3} {β : Type u_4} [SMul🔗<|PREMISE|>🔗 G α] [SMul🔗<|PREMISE|>🔗 G β] (s : Set🔗<|PREMISE|>🔗 α) (b : β) :Prop", "code": "def Supports (s : Set α) (b : β) :=\n  ∀ g : G, (∀ ⦃a⦄, a ∈ s → g • a = a) → g • b = b\n", "additional_info": "A set `s` supports `b` if `g • b = b` whenever `g • a = a` for all `a ∈ s`.\nEquations\n* 🗟MulAction.Supports🗟🔗../../.././Mathlib/GroupTheory/GroupAction/Support.html#MulAction.Supports🔗  G s b 🗟=🗟🔗../../.././Init/Prelude.html#Eq🔗  ∀ (g : G), (∀ ⦃a : α⦄, a 🗟∈🗟🔗../../.././Init/Prelude.html#Membership.mem🔗  s → g 🗟•🗟🔗../../.././Mathlib/Algebra/Group/Defs.html#HSMul.hSMul🔗  a 🗟=🗟🔗../../.././Init/Prelude.html#Eq🔗  a) → g 🗟•🗟🔗../../.././Mathlib/Algebra/Group/Defs.html#HSMul.hSMul🔗  b 🗟=🗟🔗../../.././Init/Prelude.html#Eq🔗  b\n\n", "used_premises": [57, 57, 69], "def_path": "Mathlib/GroupTheory/GroupAction/Support.lean", "pos": [30, 32], "informalization": "Function `MulAction.Supports` checks if a set `s` supports an element `b` under the action of a monoid `G`, meaning that for any `g` in `G`, if `g` acts trivially on every element of `s`, then it also acts trivially on `b`."}
{"full_name": "Set", "url": "Mathlib/Init/Set.html#Set", "code_src": "mathlib4", "ptype": "def", "header": "def Set (α : Type u) :Type u", "code": "def Set (α : Type u) := α → Prop\n", "additional_info": "A set is a collection of elements of some type `α`.\nAlthough `🗟Set🗟🔗../.././Mathlib/Init/Set.html#Set🔗`  is defined as `α → Prop`, this is an implementation detail which should not be\nrelied on. Instead, `🗟setOf🗟🔗../.././Mathlib/Init/Set.html#setOf🔗`  and membership of a set (`∈`) should be used to convert between sets\nand predicates.\nEquations\n* 🗟Set🗟🔗../.././Mathlib/Init/Set.html#Set🔗  α 🗟=🗟🔗../.././Init/Prelude.html#Eq🔗  (α → 🗟Prop🗟🔗../.././foundational_types.html🔗 )\n\n", "used_premises": [], "def_path": "Mathlib/Init/Set.lean", "pos": [46, 47], "informalization": "Function `Set` maps a given type to a proposition, which means that for each element of that type, it determines whether that element belongs to the set. A set a collection of elements of some type α."}
{"full_name": "ConNF.Enumeration.carrier", "url": "ConNF/Structural/Enumeration.html#ConNF.Enumeration.carrier", "code_src": "con-nf", "ptype": "def", "header": "def ConNF.Enumeration.carrier [ConNF.Params🔗<|PREMISE|>🔗 ] {α : Type u_1} (E : ConNF.Enumeration🔗<|PREMISE|>🔗 α) :Set🔗<|PREMISE|>🔗 α", "code": "def Enumeration.carrier (E : Enumeration α) : Set α :=\n  { c | ∃ i, ∃ (h : i < E.max), c = E.f i h }\n", "additional_info": "Equations\n* 🗟ConNF.Enumeration.carrier🗟🔗../.././ConNF/Structural/Enumeration.html#ConNF.Enumeration.carrier🔗  E 🗟=🗟🔗../.././Init/Prelude.html#Eq🔗  {c : α | ∃ (i : ConNF.κ) (h : i 🗟<🗟🔗../.././Init/Prelude.html#LT.lt🔗  E.max), c 🗟=🗟🔗../.././Init/Prelude.html#Eq🔗  E.f i h}\n\n", "used_premises": [1, 59, 69], "def_path": "ConNF/Structural/Enumeration.lean", "pos": [20, 22], "informalization": "Function `ConNF.Enumeration.carrier` defines the carrier set of an `α`-enumeration `E`, which consists of all elements `c` of type `α` that can be expressed as `E.f i h` for some `i < E.max`."}
{"full_name": "ConNF.TangleData.support", "url": "ConNF/Fuzz/Hypotheses.html#ConNF.TangleData", "code_src": "con-nf", "ptype": "structure_field", "header": "structure_field ConNF.TangleData🔗<|PREMISE|>🔗.support : ConNF.Tangle  α → ConNF.Support🔗<|PREMISE|>🔗  α", "code": "class TangleData (α : TypeIndex) where\n  /-- The type of tangles that we assume were constructed at stage `α`.\n  Later in the recursion, we will construct this type explicitly, but for now, we will just assume\n  that it exists. -/\n  (Tangle : Type u)\n  /-- The type of allowable permutations that we assume exists on `α`-tangles. -/\n  (Allowable : Type u)\n  [allowableGroup : Group Allowable]\n  allowableToStructPerm : Allowable →* StructPerm α\n  [allowableAction : MulAction Allowable Tangle]\n  support : Tangle → Support α\n  support_supports (t : Tangle) :\n    haveI : MulAction Allowable (Address α) :=\n      MulAction.compHom _ allowableToStructPerm\n    MulAction.Supports Allowable (support t : Set (Address α)) t\n", "additional_info": "", "used_premises": [39, 58], "def_path": "ConNF/Fuzz/Hypotheses.lean", "pos": [33, 48], "informalization": "Function `ConNF.TangleData.support` maps an `α`-tangle to a function from an initial segment of `κ` to the type of addresses in the context of Constructive Ordinal Notation (ConNF). It ensures that for any two near-litters `N₁` and `N₂` that are near the same litter, any atoms in their symmetric difference are included in the enumeration."}
{"full_name": "ConNF.PositionedTangles", "url": "ConNF/Fuzz/Hypotheses.html#ConNF.PositionedTangles", "code_src": "con-nf", "ptype": "class", "header": "class ConNF.PositionedTangles [ConNF.Params🔗<|PREMISE|>🔗 ] (α : ConNF.TypeIndex) [ConNF.TangleData🔗<|PREMISE|>🔗 α] :Type u\n | pos : ConNF.Tangle  α ↪  ConNF.μ", "code": "class PositionedTangles (α : TypeIndex) [TangleData α] where\n  /-- A position function, giving each tangle a unique position `ν : μ`.\n  The existence of this injection proves that there are at most `μ` tangles at level `α`.\n  Since `μ` has a well-ordering, this induces a well-ordering on `α`-tangles: to compare two\n  tangles, simply compare their images under this map. -/\n  pos : Tangle α ↪ μ\n", "additional_info": "- ConNF.PositionedTangles.pos: A position function, giving each tangle a unique position `ν : μ`.\nThe existence of this injection proves that there are at most `μ` tangles at level `α`.\nSince `μ` has a well-ordering, this induces a well-ordering on `α`-tangles: to compare two\ntangles, simply compare their images under this map.\n\n\n", "used_premises": [1, 39], "def_path": "ConNF/Fuzz/Hypotheses.lean", "pos": [134, 140], "informalization": "Class `ConNF.PositionedTangles` represents the concept of a position function for tangles at level `α` in the context of Constructive Ordinal Notation (ConNF), which gives each tangle a unique position `ν : μ`. This injection proves that there are at most `μ` tangles at level `α`, and it induces a well-ordering on `α`-tangles."}
{"full_name": "ConNF.TypedObjects", "url": "ConNF/Fuzz/Hypotheses.html#ConNF.TypedObjects", "code_src": "con-nf", "ptype": "class", "header": "class ConNF.TypedObjects [ConNF.Params🔗<|PREMISE|>🔗 ] (α : ConNF.Λ) [ConNF.TangleData🔗<|PREMISE|>🔗 ↑α] :Type u\n | typedAtom : ConNF.Atom ↪  ConNF.Tangle  ↑α\n | typedNearLitter : ConNF.NearLitter ↪  ConNF.Tangle  ↑α\n | smul_typedNearLitter : ∀ (ρ : ConNF.Allowable  ↑α) (N : ConNF.NearLitter),\n ρ •  ConNF.typedNearLitter N =  ConNF.typedNearLitter (ConNF.Allowable.toStructPerm ρ (Quiver.Hom.toPath🔗<|PREMISE|>🔗  ⋯) •  N)", "code": "class TypedObjects where\n  /-- Encode an atom as an `α`-tangle. The resulting model element has a `⊥`-extension which\n  contains only this atom. -/\n  typedAtom : Atom ↪ Tangle α\n  /-- Encode a near-litter as an `α`-tangle. The resulting model element has a `⊥`-extension which\n  contains only this near-litter. -/\n  typedNearLitter : NearLitter ↪ Tangle α\n  smul_typedNearLitter :\n    ∀ (ρ : Allowable α) (N : NearLitter),\n    ρ • typedNearLitter N =\n    typedNearLitter ((Allowable.toStructPerm ρ) (Quiver.Hom.toPath <| bot_lt_coe α) • N)\n", "additional_info": "Allows us to encode atoms and near-litters as `α`-tangles. These maps are expected to cohere\nwith the conditions given in `BasePositions`, but this requirement is expressed later.\n- ConNF.TypedObjects.typedAtom: Encode an atom as an `α`-tangle. The resulting model element has a `⊥`-extension which\ncontains only this atom.\n\n\n- ConNF.TypedObjects.typedNearLitter: Encode a near-litter as an `α`-tangle. The resulting model element has a `⊥`-extension which\ncontains only this near-litter.\n\n\n", "used_premises": [1, 39, 74], "def_path": "ConNF/Fuzz/Hypotheses.lean", "pos": [148, 159], "informalization": "Class `ConNF.TypedObjects` allows us to encode atoms and near-litters as `α`-tangles. These maps are expected to cohere with the conditions given in `BasePositions`, but this requirement is expressed later."}
{"full_name": "Quiver.Hom.toPath", "url": "Mathlib/Combinatorics/Quiver/Path.html#Quiver.Hom.toPath", "code_src": "mathlib4", "ptype": "def", "header": "def Quiver.Hom.toPath {V : Type u_1} [Quiver🔗<|PREMISE|>🔗 V] {a : V} {b : V} (e : a ⟶ b) :Quiver.Path🔗<|PREMISE|>🔗 a b", "code": "def Hom.toPath {V} [Quiver V] {a b : V} (e : a ⟶ b) : Path a b :=\n  Path.nil.cons e\n", "additional_info": "An arrow viewed as a path of length one.\nEquations\n* 🗟Quiver.Hom.toPath🗟🔗../../.././Mathlib/Combinatorics/Quiver/Path.html#Quiver.Hom.toPath🔗  e 🗟=🗟🔗../../.././Init/Prelude.html#Eq🔗  🗟Quiver.Path.cons🗟🔗../../.././Mathlib/Combinatorics/Quiver/Path.html#Quiver.Path.cons🔗  Quiver.Path.nil e\n\n", "used_premises": [75, 76], "def_path": "Mathlib/Combinatorics/Quiver/Path.lean", "pos": [33, 35], "informalization": "Function `Quiver.Hom.toPath` converts a single arrow in a quiver into a path of length one."}
{"full_name": "Quiver", "url": "Mathlib/Combinatorics/Quiver/Basic.html#Quiver", "code_src": "mathlib4", "ptype": "class", "header": "class Quiver (V : Type u) :Type (max u v)\n | Hom : V → V → Sort  v", "code": "class Quiver (V : Type u) where\n  /-- The type of edges/arrows/morphisms between a given source and target. -/\n  Hom : V → V → Sort v\n", "additional_info": "A quiver `G` on a type `V` of vertices assigns to every pair `a b : V` of vertices\na type `a ⟶ b` of arrows from `a` to `b`.\nFor graphs with no repeated edges, one can use `Quiver.{0} V`, which ensures\n`a ⟶ b : Prop`. For multigraphs, one can use `Quiver.{v+1} V`, which ensures\n`a ⟶ b : Type v`.\nBecause `Category` will later extend this class, we call the field `🗟Hom🗟🔗../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom🔗` .\nExcept when constructing instances, you should rarely see this, and use the `⟶` notation instead.\n- Quiver.Hom: The type of edges/arrows/morphisms between a given source and target.\n\n\n", "used_premises": [], "def_path": "Mathlib/Combinatorics/Quiver/Basic.lean", "pos": [45, 48], "informalization": "A `Quiver` on a type `V` of vertices assigns to every pair `a b : V` of vertices a type `a ⟶ b` of arrows from `a` to `b`."}
{"full_name": "Quiver.Path", "url": "Mathlib/Combinatorics/Quiver/Path.html#Quiver.Path", "code_src": "mathlib4", "ptype": "inductive", "header": "inductive Quiver.Path {V : Type u} [Quiver🔗<|PREMISE|>🔗 V] (a : V) :V → Sort (max (u + 1) v)", "code": "inductive Path {V : Type u} [Quiver.{v} V] (a : V) : V → Sort max (u + 1) v\n  | nil : Path a a\n  | cons : ∀ {b c : V}, Path a b → (b ⟶ c) → Path a c\n", "additional_info": "`🗟Path🗟🔗../../.././Mathlib/Combinatorics/Quiver/Path.html#Quiver.Path🔗  a b` is the type of paths from `a` to `b` through the arrows of `G`.\n", "used_premises": [75], "def_path": "Mathlib/Combinatorics/Quiver/Path.lean", "pos": [24, 27], "informalization": "Type `Quiver.Path` represents the type of paths between two vertices in a quiver, defined inductively as either a trivial path (`nil`) or a path extended by an arrow (`cons`)."}
{"full_name": "ConNF.cloud", "url": "ConNF/NewTangle/Cloud.html#ConNF.cloud", "code_src": "con-nf", "ptype": "def", "header": "def ConNF.cloud [ConNF.Params🔗<|PREMISE|>🔗 ] {γ : ConNF.TypeIndex} [ConNF.TangleData🔗<|PREMISE|>🔗 γ] [ConNF.PositionedTangles🔗<|PREMISE|>🔗 γ] {β : ConNF.Λ} [ConNF.TangleData🔗<|PREMISE|>🔗 ↑β] [ConNF.PositionedTangles🔗<|PREMISE|>🔗 ↑β] [ConNF.TypedObjects🔗<|PREMISE|>🔗 β] (hγβ : γ ≠ ↑β) (s : Set🔗<|PREMISE|>🔗 (ConNF.Tangle γ)) :Set🔗<|PREMISE|>🔗 (ConNF.Tangle ↑β)", "code": "def cloud (s : Set (Tangle γ)) : Set (Tangle β) :=\n  typedNearLitter '' ⋃ t ∈ s, localCardinal (fuzz hγβ t)\n", "additional_info": "The cloud map. We map each tangle to all typed near-litters near the `fuzz`ed tangle, and take\nthe union over all tangles in the input.\nEquations\n* 🗟ConNF.cloud🗟🔗../.././ConNF/NewTangle/Cloud.html#ConNF.cloud🔗  hγβ s 🗟=🗟🔗../.././Init/Prelude.html#Eq🔗  ⇑ConNF.typedNearLitter 🗟''🗟🔗../.././Mathlib/Init/Set.html#Set.image🔗  ⋃ t ∈ s, 🗟ConNF.localCardinal🗟🔗../.././ConNF/BaseType/NearLitter.html#ConNF.localCardinal🔗  (🗟ConNF.fuzz🗟🔗../.././ConNF/Fuzz/Construction.html#ConNF.fuzz🔗  hγβ t)\n\n", "used_premises": [1, 39, 72, 39, 72, 73, 69, 69], "def_path": "ConNF/NewTangle/Cloud.lean", "pos": [50, 52], "informalization": "Function `ConNF.cloud` maps each tangle to all typed near-litters near the `fuzz`ed tangle, and takes the union over all tangles in the input."}
{"full_name": "ConNF.fuzz", "url": "ConNF/Fuzz/Construction.html#ConNF.fuzz", "code_src": "con-nf", "ptype": "noncomputable def", "header": "noncomputable def ConNF.fuzz [ConNF.Params🔗<|PREMISE|>🔗 ] {β : ConNF.TypeIndex} {γ : ConNF.Λ} [ConNF.TangleData🔗<|PREMISE|>🔗 β] [ConNF.PositionedTangles🔗<|PREMISE|>🔗 β] [ConNF.TangleData🔗<|PREMISE|>🔗 ↑γ] [ConNF.PositionedTangles🔗<|PREMISE|>🔗 ↑γ] [ConNF.TypedObjects🔗<|PREMISE|>🔗 γ] (hβγ : β ≠ ↑γ) (t : ConNF.Tangle β) :ConNF.Litter", "code": "noncomputable def fuzz (t : Tangle β) : Litter :=\n  ⟨chooseWf (fuzzDeny γ) mk_fuzzDeny t, β, γ, hβγ⟩\n", "additional_info": "The `🗟fuzz🗟🔗../.././ConNF/Fuzz/Construction.html#ConNF.fuzz🔗`  map for a particular pair of type indices.\nIn tangled type theory, a given model element has extensions at each level below it.\nWe have a \"preferred\" extension, and must find a way to compute the other extensions from that\ninformation. In order to do this, we need to be able to convert arbitrary model elements into\n\"junk\" at other levels, which can then be clearly interpreted as a \"non-preferred\" extension.\nThe `🗟fuzz🗟🔗../.././ConNF/Fuzz/Construction.html#ConNF.fuzz🔗`  maps perform this task. They are parametrised by a pair of type indices, representing\nthe source type level and target type level. At each pair of levels, the `🗟fuzz🗟🔗../.././ConNF/Fuzz/Construction.html#ConNF.fuzz🔗`  map is an injection\nfrom tangles to litters. An arbitrary litter can only be the image of a `🗟fuzz🗟🔗../.././ConNF/Fuzz/Construction.html#ConNF.fuzz🔗`  map defined at a\nsingle pair of type levels.\nTreating the output of a `🗟fuzz🗟🔗../.././ConNF/Fuzz/Construction.html#ConNF.fuzz🔗`  map as a typed near-litter, its pos is always greater than\nthe pos of the input to the function. This ensures a well-foundedness condition that we use\nin many places later.\nEquations\n* 🗟ConNF.fuzz🗟🔗../.././ConNF/Fuzz/Construction.html#ConNF.fuzz🔗  hβγ t 🗟=🗟🔗../.././Init/Prelude.html#Eq🔗  { ν := 🗟ConNF.chooseWf🗟🔗../.././ConNF/Fuzz/Construction.html#ConNF.chooseWf🔗  (🗟ConNF.fuzzDeny🗟🔗../.././ConNF/Fuzz/Construction.html#ConNF.fuzzDeny🔗  γ) ⋯ t, β := β, γ := γ, β_ne_γ := hβγ }\n\n", "used_premises": [1, 39, 72, 39, 72, 73], "def_path": "ConNF/Fuzz/Construction.lean", "pos": [182, 184], "informalization": "Function `ConNF.fuzz` is a noncomputable function defined in the context of Constructive Ordinal Notation (ConNF) in Lean 4. It takes as input a tangle `t` of type `β` and returns a `Litter` object. The `Litter` object is defined as a 4-tuple consisting of a `Wf` object, a type index `β`, a `Λ` object `γ`, and a proof that `β` is not equal to `γ`. The `Wf` object is chosen using the `chooseWf` function, which selects an element from a nonempty set. The `chooseWf` function is applied to the set `fuzzDeny γ`, which is defined using the `mk_fuzzDeny` function. The `mk_fuzzDeny` function takes a tangle `t` of type `β` and returns a `Wf` object. The `Litter` object is then constructed using the chosen `Wf` object, the type index `β`, the `Λ` object `γ`, and the proof that `β` is not equal to `γ`."}
{"full_name": "ConNF.cloud_empty", "url": "ConNF/NewTangle/Cloud.html#ConNF.cloud_empty", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.cloud_empty [ConNF.Params🔗<|PREMISE|>🔗 ] {γ : ConNF.TypeIndex} [ConNF.TangleData🔗<|PREMISE|>🔗 γ] [ConNF.PositionedTangles🔗<|PREMISE|>🔗 γ] {β : ConNF.Λ} [ConNF.TangleData🔗<|PREMISE|>🔗 ↑β] [ConNF.PositionedTangles🔗<|PREMISE|>🔗 ↑β] [ConNF.TypedObjects🔗<|PREMISE|>🔗 β] {hγβ : γ ≠ ↑β} :ConNF.cloud🔗<|PREMISE|>🔗 hγβ ∅ = ∅", "code": "theorem cloud_empty : cloud hγβ (∅ : Set (Tangle γ)) = ∅ := by\n  simp only [cloud, mem_empty_iff_false, iUnion_of_empty, iUnion_empty, image_empty]\n", "additional_info": "", "used_premises": [1, 39, 72, 39, 72, 73, 77], "def_path": "ConNF/NewTangle/Cloud.lean", "pos": [67, 69], "informalization": "Function `ConNF.cloud` maps each tangle to all typed near-litters near the `fuzz`ed tangle, and takes the union over all tangles in the input. This theorem states that if the input set of tangles is empty, then the output set of near-litters is also empty."}
{"full_name": "ConNF.cloud_singleton", "url": "ConNF/NewTangle/Cloud.html#ConNF.cloud_singleton", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.cloud_singleton [ConNF.Params🔗<|PREMISE|>🔗 ] {γ : ConNF.TypeIndex} [ConNF.TangleData🔗<|PREMISE|>🔗 γ] [ConNF.PositionedTangles🔗<|PREMISE|>🔗 γ] {β : ConNF.Λ} [ConNF.TangleData🔗<|PREMISE|>🔗 ↑β] [ConNF.PositionedTangles🔗<|PREMISE|>🔗 ↑β] [ConNF.TypedObjects🔗<|PREMISE|>🔗 β] {hγβ : γ ≠ ↑β} (t : ConNF.Tangle γ) :ConNF.cloud🔗<|PREMISE|>🔗 hγβ {t} = ⇑ConNF.typedNearLitter '' ConNF.localCardinal🔗<|PREMISE|>🔗 (ConNF.fuzz🔗<|PREMISE|>🔗 hγβ t)", "code": "theorem cloud_singleton (t : Tangle γ) :\n    cloud hγβ {t} = typedNearLitter '' localCardinal (fuzz hγβ t) := by\n  simp only [cloud, mem_singleton_iff, iUnion_iUnion_eq_left]\n", "additional_info": "", "used_premises": [1, 39, 72, 39, 72, 73, 77, 81, 78], "def_path": "ConNF/NewTangle/Cloud.lean", "pos": [71, 74], "informalization": "In the context of Constructive Ordinal Notation (ConNF), the function `ConNF.cloud` maps each tangle to all typed near-litters near the `fuzz`ed tangle, and takes the union over all tangles in the input. The function `ConNF.localCardinal` defines the local cardinal of a given litter `L` in the context of Constructive Ordinal Notation (ConNF). The local cardinal of a litter `L` is defined as the set of all near-litters `N` such that the first component of `N` is equal to `L`. In other words, the local cardinal of a litter `L` consists of all near-litters that have `L` as their first component. The function `ConNF.fuzz` is a noncomputable function defined in the context of Constructive Ordinal Notation (ConNF) in Lean 4. It takes as input a tangle `t` of type `β` and returns a `Litter` object. The `Litter` object is defined as a 4-tuple consisting of a `Wf` object, a type index `β`, a `Λ` object `γ`, and a proof that `β` is not equal to `γ`. The `Wf` object is chosen using the `chooseWf` function, which selects an element from a nonempty set. The `chooseWf` function is applied to the set `fuzzDeny γ`, which is defined using the `mk_fuzzDeny` function. The `mk_fuzzDeny` function takes a tangle `t` of type `β` and returns a `Wf` object. The `Litter` object is then constructed using the chosen `Wf` object, the type index `β`, the `Λ` object `γ`, and the proof that `β` is not equal to `γ`."}
{"full_name": "ConNF.localCardinal", "url": "ConNF/BaseType/NearLitter.html#ConNF.localCardinal", "code_src": "con-nf", "ptype": "def", "header": "def ConNF.localCardinal [ConNF.Params🔗<|PREMISE|>🔗 ] (L : ConNF.Litter) :Set🔗<|PREMISE|>🔗 ConNF.NearLitter", "code": "def localCardinal (L : Litter) : Set NearLitter :=\n  {N : NearLitter | N.1 = L}\n", "additional_info": "The *local cardinal* of a litter is the set of all near-litters to that litter.\nEquations\n* 🗟ConNF.localCardinal🗟🔗../.././ConNF/BaseType/NearLitter.html#ConNF.localCardinal🔗  L 🗟=🗟🔗../.././Init/Prelude.html#Eq🔗  {N : ConNF.NearLitter | N.fst 🗟=🗟🔗../.././Init/Prelude.html#Eq🔗  L}\n\n", "used_premises": [1, 69], "def_path": "ConNF/BaseType/NearLitter.lean", "pos": [184, 186], "informalization": "Function `ConNF.localCardinal` defines the local cardinal of a given litter `L` in the context of Constructive Ordinal Notation (ConNF). The local cardinal of a litter `L` is defined as the set of all near-litters `N` such that the first component of `N` is equal to `L`. In other words, the local cardinal of a litter `L` consists of all near-litters that have `L` as their first component."}
{"full_name": "Set.Nonempty.cloud", "url": "ConNF/NewTangle/Cloud.html#Set.Nonempty.cloud", "code_src": "con-nf", "ptype": "theorem", "header": "theorem Set.Nonempty.cloud [ConNF.Params🔗<|PREMISE|>🔗 ] {γ : ConNF.TypeIndex} [ConNF.TangleData🔗<|PREMISE|>🔗 γ] [ConNF.PositionedTangles🔗<|PREMISE|>🔗 γ] {β : ConNF.Λ} [ConNF.TangleData🔗<|PREMISE|>🔗 ↑β] [ConNF.PositionedTangles🔗<|PREMISE|>🔗 ↑β] [ConNF.TypedObjects🔗<|PREMISE|>🔗 β] {hγβ : γ ≠ ↑β} {s : Set🔗<|PREMISE|>🔗 (ConNF.Tangle γ)} (h : Set.Nonempty🔗<|PREMISE|>🔗 s) :Set.Nonempty🔗<|PREMISE|>🔗 (ConNF.cloud🔗<|PREMISE|>🔗 hγβ s)", "code": "theorem Set.Nonempty.cloud (h : s.Nonempty) : (cloud hγβ s).Nonempty := by\n  refine (nonempty_iUnion.2 ?_).image _\n  refine ⟨h.choose, ⟨(fuzz hγβ h.choose).toNearLitter, ?_⟩⟩\n  simp only [mem_iUnion, mem_localCardinal, Litter.toNearLitter_fst, exists_prop, and_true]\n  exact h.choose_spec\n", "additional_info": "", "used_premises": [1, 39, 72, 39, 72, 73, 69, 83, 83, 77], "def_path": "ConNF/NewTangle/Cloud.lean", "pos": [77, 82], "informalization": "In the context of Constructive Ordinal Notation (ConNF), the function `ConNF.cloud` maps each tangle to all typed near-litters near the `fuzz`ed tangle, and takes the union over all tangles in the input. The theorem `Set.Nonempty.cloud` asserts that if `s` is a non-empty set of `γ`-tangles, then the set obtained by applying `ConNF.cloud` to `s` is also non-empty."}
{"full_name": "Set.Nonempty", "url": "Mathlib/Init/Set.html#Set.Nonempty", "code_src": "mathlib4", "ptype": "def", "header": "def Set.Nonempty {α : Type u_1} (s : Set🔗<|PREMISE|>🔗 α) :Prop", "code": "protected def Nonempty (s : Set α) : Prop :=\n  ∃ x, x ∈ s\n", "additional_info": "The property `s.🗟Nonempty🗟🔗../.././Init/Prelude.html#Nonempty🔗`  expresses the fact that the set `s` is not empty. It should be used\nin theorem assumptions instead of `∃ x, x ∈ s` or `s ≠ ∅` as it gives access to a nice API thanks\nto the dot notation.\nEquations\n* 🗟Set.Nonempty🗟🔗../.././Mathlib/Init/Set.html#Set.Nonempty🔗  s 🗟=🗟🔗../.././Init/Prelude.html#Eq🔗  ∃ (x : α), x 🗟∈🗟🔗../.././Init/Prelude.html#Membership.mem🔗  s\n\n", "used_premises": [69], "def_path": "Mathlib/Init/Set.lean", "pos": [217, 219], "informalization": "Function `Set.Nonempty` is a predicate that checks if a given set `s` of type `α` contains at least one element, providing a convenient API for theorem assumptions."}
{"full_name": "ConNF.cloud_eq_empty", "url": "ConNF/NewTangle/Cloud.html#ConNF.cloud_eq_empty", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.cloud_eq_empty [ConNF.Params🔗<|PREMISE|>🔗 ] {γ : ConNF.TypeIndex} [ConNF.TangleData🔗<|PREMISE|>🔗 γ] [ConNF.PositionedTangles🔗<|PREMISE|>🔗 γ] {β : ConNF.Λ} [ConNF.TangleData🔗<|PREMISE|>🔗 ↑β] [ConNF.PositionedTangles🔗<|PREMISE|>🔗 ↑β] [ConNF.TypedObjects🔗<|PREMISE|>🔗 β] {s : Set🔗<|PREMISE|>🔗 (ConNF.Tangle γ)} (hγβ : γ ≠ ↑β) :ConNF.cloud🔗<|PREMISE|>🔗 hγβ s = ∅ ↔ s = ∅", "code": "theorem cloud_eq_empty (hγβ : γ ≠ β) : cloud hγβ s = ∅ ↔ s = ∅ := by\n  refine' ⟨fun h => not_nonempty_iff_eq_empty.1 fun hs => hs.cloud.ne_empty h, _⟩\n  rintro rfl\n  exact cloud_empty\n", "additional_info": "", "used_premises": [1, 39, 72, 39, 72, 73, 69, 77], "def_path": "ConNF/NewTangle/Cloud.lean", "pos": [84, 88], "informalization": "In the context of Constructive Ordinal Notation (ConNF), the function `ConNF.cloud` maps each tangle to all typed near-litters near the `fuzz`ed tangle, and takes the union over all tangles in the input. The theorem `ConNF.cloud_eq_empty` states that the `ConNF.cloud` of a set of tangles is empty if and only if the set of tangles itself is empty."}
{"full_name": "ConNF.cloud_nonempty", "url": "ConNF/NewTangle/Cloud.html#ConNF.cloud_nonempty", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.cloud_nonempty [ConNF.Params🔗<|PREMISE|>🔗 ] {γ : ConNF.TypeIndex} [ConNF.TangleData🔗<|PREMISE|>🔗 γ] [ConNF.PositionedTangles🔗<|PREMISE|>🔗 γ] {β : ConNF.Λ} [ConNF.TangleData🔗<|PREMISE|>🔗 ↑β] [ConNF.PositionedTangles🔗<|PREMISE|>🔗 ↑β] [ConNF.TypedObjects🔗<|PREMISE|>🔗 β] {s : Set🔗<|PREMISE|>🔗 (ConNF.Tangle γ)} (hγβ : γ ≠ ↑β) :Set.Nonempty🔗<|PREMISE|>🔗 (ConNF.cloud🔗<|PREMISE|>🔗 hγβ s) ↔ Set.Nonempty🔗<|PREMISE|>🔗 s", "code": "theorem cloud_nonempty (hγβ : γ ≠ β) : (cloud hγβ s).Nonempty ↔ s.Nonempty := by\n  simp_rw [nonempty_iff_ne_empty, Ne.def, cloud_eq_empty]\n", "additional_info": "", "used_premises": [1, 39, 72, 39, 72, 73, 69, 83, 77, 83], "def_path": "ConNF/NewTangle/Cloud.lean", "pos": [90, 92], "informalization": "In the context of Constructive Ordinal Notation (ConNF), the function `ConNF.cloud` maps each tangle to all typed near-litters near the `fuzz`ed tangle, and takes the union over all tangles in the input. The theorem `ConNF.cloud_nonempty` asserts that the resulting set is nonempty if and only if the input set is nonempty."}
{"full_name": "ConNF.subset_cloud", "url": "ConNF/NewTangle/Cloud.html#ConNF.subset_cloud", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.subset_cloud [ConNF.Params🔗<|PREMISE|>🔗 ] {γ : ConNF.TypeIndex} [ConNF.TangleData🔗<|PREMISE|>🔗 γ] [ConNF.PositionedTangles🔗<|PREMISE|>🔗 γ] {β : ConNF.Λ} [ConNF.TangleData🔗<|PREMISE|>🔗 ↑β] [ConNF.PositionedTangles🔗<|PREMISE|>🔗 ↑β] [ConNF.TypedObjects🔗<|PREMISE|>🔗 β] {hγβ : γ ≠ ↑β} {s : Set🔗<|PREMISE|>🔗 (ConNF.Tangle γ)} {t : ConNF.Tangle γ} (ht : t ∈ s) :⇑ConNF.typedNearLitter '' ConNF.localCardinal🔗<|PREMISE|>🔗 (ConNF.fuzz🔗<|PREMISE|>🔗 hγβ t) ⊆ ConNF.cloud🔗<|PREMISE|>🔗 hγβ s", "code": "theorem subset_cloud (ht : t ∈ s) :\n    typedNearLitter '' localCardinal (fuzz hγβ t) ⊆ cloud hγβ s :=\n  image_subset _ <| subset_iUnion₂ (s := fun t' _ => localCardinal (fuzz hγβ t')) t ht\n", "additional_info": "", "used_premises": [1, 39, 72, 39, 72, 73, 69, 81, 78, 77], "def_path": "ConNF/NewTangle/Cloud.lean", "pos": [93, 96], "informalization": "In the context of Constructive Ordinal Notation (ConNF) in Lean 4, the theorem `ConNF.subset_cloud` asserts that for any tangle `t` of type `γ` that belongs to a set `s` of tangles of type `γ`, the set of all typed near-litters near the `fuzz`ed tangle `t` is a subset of the `cloud` of `s`."}
{"full_name": "ConNF.μ_le_mk_cloud", "url": "ConNF/NewTangle/Cloud.html#ConNF.μ_le_mk_cloud", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.μ_le_mk_cloud [ConNF.Params🔗<|PREMISE|>🔗 ] {γ : ConNF.TypeIndex} [ConNF.TangleData🔗<|PREMISE|>🔗 γ] [ConNF.PositionedTangles🔗<|PREMISE|>🔗 γ] {β : ConNF.Λ} [ConNF.TangleData🔗<|PREMISE|>🔗 ↑β] [ConNF.PositionedTangles🔗<|PREMISE|>🔗 ↑β] [ConNF.TypedObjects🔗<|PREMISE|>🔗 β] {hγβ : γ ≠ ↑β} {s : Set🔗<|PREMISE|>🔗 (ConNF.Tangle γ)} :Set.Nonempty🔗<|PREMISE|>🔗 s → Cardinal.mk🔗<|PREMISE|>🔗 ConNF.μ ≤ Cardinal.mk🔗<|PREMISE|>🔗 ↑(ConNF.cloud🔗<|PREMISE|>🔗 hγβ s)", "code": "theorem μ_le_mk_cloud : s.Nonempty → #μ ≤ #(cloud hγβ s) := by\n  rintro ⟨t, ht⟩\n  refine' (Cardinal.mk_le_mk_of_subset <| subset_cloud ht).trans_eq' _\n  rw [Cardinal.mk_image_eq, mk_localCardinal]\n  exact typedNearLitter.inj'\n", "additional_info": "", "used_premises": [1, 39, 72, 39, 72, 73, 69, 83, 29, 29, 77], "def_path": "ConNF/NewTangle/Cloud.lean", "pos": [97, 102], "informalization": "In the context of Constructive Ordinal Notation (ConNF), the theorem `ConNF.μ_le_mk_cloud` asserts that for any non-empty set `s` of `γ`-tangles, the cardinality of `μ` is less than or equal to the cardinality of the set of all `β`-typed near-litters near the `fuzz`ed tangles in `s`."}
{"full_name": "ConNF.cloud_injective", "url": "ConNF/NewTangle/Cloud.html#ConNF.cloud_injective", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.cloud_injective [ConNF.Params🔗<|PREMISE|>🔗 ] {γ : ConNF.TypeIndex} [ConNF.TangleData🔗<|PREMISE|>🔗 γ] [ConNF.PositionedTangles🔗<|PREMISE|>🔗 γ] {β : ConNF.Λ} [ConNF.TangleData🔗<|PREMISE|>🔗 ↑β] [ConNF.PositionedTangles🔗<|PREMISE|>🔗 ↑β] [ConNF.TypedObjects🔗<|PREMISE|>🔗 β] {hγβ : γ ≠ ↑β} :Function.Injective🔗<|PREMISE|>🔗 (ConNF.cloud🔗<|PREMISE|>🔗 hγβ)", "code": "theorem cloud_injective : Injective (cloud hγβ) :=\n  typedNearLitter.injective.image_injective.comp <|\n    Pairwise.biUnion_injective (fun _ _ h => localCardinal_disjoint <| (fuzz_injective _).ne h)\n      fun _ => localCardinal_nonempty _\n", "additional_info": "", "used_premises": [1, 39, 72, 39, 72, 73, 89, 77], "def_path": "ConNF/NewTangle/Cloud.lean", "pos": [103, 107], "informalization": "In the context of Constructive Ordinal Notation (ConNF), the theorem `ConNF.cloud_injective` asserts that the function `ConNF.cloud`, which maps each tangle to all typed near-litters near the `fuzz`ed tangle, and takes the union over all tangles in the input, is injective."}
{"full_name": "Function.Injective", "url": "Mathlib/Init/Function.html#Function.Injective", "code_src": "mathlib4", "ptype": "def", "header": "def Function.Injective {α : Sort u₁} {β : Sort u₂} (f : α → β) :Prop", "code": "def Injective (f : α → β) : Prop :=\n  ∀ ⦃a₁ a₂⦄, f a₁ = f a₂ → a₁ = a₂\n", "additional_info": "A function `f : α → β` is called injective if `f x = f y` implies `x = y`.\nEquations\n* 🗟Function.Injective🗟🔗../.././Mathlib/Init/Function.html#Function.Injective🔗  f 🗟=🗟🔗../.././Init/Prelude.html#Eq🔗  ∀ ⦃a₁ a₂ : α⦄, f a₁ 🗟=🗟🔗../.././Init/Prelude.html#Eq🔗  f a₂ → a₁ 🗟=🗟🔗../.././Init/Prelude.html#Eq🔗  a₂\n\n", "used_premises": [], "def_path": "Mathlib/Init/Function.lean", "pos": [115, 117], "informalization": "Function `Function.Injective` checks if a function `f` from `α` to `β` is injective, meaning `f a₁ = f a₂` implies `a₁ = a₂` for all `a₁, a₂` in `α`."}
{"full_name": "ConNF.cloud_disjoint_range", "url": "ConNF/NewTangle/Cloud.html#ConNF.cloud_disjoint_range", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.cloud_disjoint_range [ConNF.Params🔗<|PREMISE|>🔗 ] {γ : ConNF.TypeIndex} [ConNF.TangleData🔗<|PREMISE|>🔗 γ] [ConNF.PositionedTangles🔗<|PREMISE|>🔗 γ] {β : ConNF.Λ} [ConNF.TangleData🔗<|PREMISE|>🔗 ↑β] [ConNF.PositionedTangles🔗<|PREMISE|>🔗 ↑β] [ConNF.TypedObjects🔗<|PREMISE|>🔗 β] {hγβ : γ ≠ ↑β} {δ : ConNF.TypeIndex} [ConNF.TangleData🔗<|PREMISE|>🔗 δ] [ConNF.PositionedTangles🔗<|PREMISE|>🔗 δ] {hδβ : δ ≠ ↑β} (c : Set🔗<|PREMISE|>🔗 (ConNF.Tangle γ)) (d : Set🔗<|PREMISE|>🔗 (ConNF.Tangle δ)) (hc : Set.Nonempty🔗<|PREMISE|>🔗 c) (h : ConNF.cloud🔗<|PREMISE|>🔗 hγβ c = ConNF.cloud🔗<|PREMISE|>🔗 hδβ d) :γ = δ", "code": "theorem cloud_disjoint_range {hδβ} (c : Set (Tangle γ)) (d : Set (Tangle δ)) (hc : c.Nonempty)\n    (h : cloud hγβ c = cloud hδβ d) : γ = δ := by\n  obtain ⟨b, hb⟩ := hc\n  have := (subset_iUnion₂ b hb).trans (typedNearLitter.injective.image_injective h).subset\n  obtain ⟨i, -, hi⟩ := mem_iUnion₂.1 (this (fuzz _ b).toNearLitter_mem_localCardinal)\n  exact fuzz_congr_β hi\n", "additional_info": "", "used_premises": [1, 39, 72, 39, 72, 73, 39, 72, 69, 69, 83, 77, 77], "def_path": "ConNF/NewTangle/Cloud.lean", "pos": [110, 116], "informalization": "In the context of Constructive Ordinal Notation (ConNF), the theorem `ConNF.cloud_disjoint_range` asserts that for any two different types of tangles `γ` and `δ`, and any non-empty set of `γ`-tangles `c` and any set of `δ`-tangles `d`, if the `ConNF.cloud` of `c` equals the `ConNF.cloud` of `d`, then `γ` must equal `δ`."}
{"full_name": "ConNF.wellFounded_pos", "url": "ConNF/NewTangle/Cloud.html#ConNF.wellFounded_pos", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.wellFounded_pos [ConNF.Params🔗<|PREMISE|>🔗 ] {γ : ConNF.TypeIndex} [ConNF.TangleData🔗<|PREMISE|>🔗 γ] [ConNF.PositionedTangles🔗<|PREMISE|>🔗 γ] :WellFounded🔗<|PREMISE|>🔗 fun (a b : ConNF.Tangle γ) => ConNF.pos a < ConNF.pos b", "code": "theorem wellFounded_pos : WellFounded fun a b : Tangle γ => pos a < pos b :=\n  InvImage.wf _ IsWellFounded.wf\n", "additional_info": "", "used_premises": [1, 39, 72, 19], "def_path": "ConNF/NewTangle/Cloud.lean", "pos": [125, 127], "informalization": "In the context of Constructive Ordinal Notation (ConNF), the theorem `ConNF.wellFounded_pos` asserts that the relation defined by comparing the positions of tangles is well-founded. This means that every non-empty set of tangles has a minimal element with respect to this relation."}
{"full_name": "ConNF.minTangle_mem", "url": "ConNF/NewTangle/Cloud.html#ConNF.minTangle_mem", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.minTangle_mem [ConNF.Params🔗<|PREMISE|>🔗 ] {γ : ConNF.TypeIndex} [ConNF.TangleData🔗<|PREMISE|>🔗 γ] [ConNF.PositionedTangles🔗<|PREMISE|>🔗 γ] (s : Set🔗<|PREMISE|>🔗 (ConNF.Tangle γ)) (hs : Set.Nonempty🔗<|PREMISE|>🔗 s) :ConNF.minTangle🔗<|PREMISE|>🔗 s hs ∈ s", "code": "theorem minTangle_mem (s : Set (Tangle γ)) (hs : s.Nonempty) : minTangle s hs ∈ s :=\n  WellFounded.min_mem _ s hs\n", "additional_info": "", "used_premises": [1, 39, 72, 69, 83, 93], "def_path": "ConNF/NewTangle/Cloud.lean", "pos": [132, 134], "informalization": "Given a nonempty set of tangles at level `γ` in the context of Constructive Ordinal Notation (ConNF), `ConNF.minTangle_mem` asserts that the tangle with the smallest position among all tangles in the set is indeed a member of that set."}
{"full_name": "ConNF.minTangle", "url": "ConNF/NewTangle/Cloud.html#ConNF.minTangle", "code_src": "con-nf", "ptype": "noncomputable def", "header": "noncomputable def ConNF.minTangle [ConNF.Params🔗<|PREMISE|>🔗 ] {γ : ConNF.TypeIndex} [ConNF.TangleData🔗<|PREMISE|>🔗 γ] [ConNF.PositionedTangles🔗<|PREMISE|>🔗 γ] (s : Set🔗<|PREMISE|>🔗 (ConNF.Tangle γ)) (hs : Set.Nonempty🔗<|PREMISE|>🔗 s) :ConNF.Tangle γ", "code": "noncomputable def minTangle (s : Set (Tangle γ)) (hs : s.Nonempty) : Tangle γ :=\n  wellFounded_pos.min s hs\n", "additional_info": "The minimum tangle of a nonempty set of tangles.\nEquations\n* 🗟ConNF.minTangle🗟🔗../.././ConNF/NewTangle/Cloud.html#ConNF.minTangle🔗  s hs 🗟=🗟🔗../.././Init/Prelude.html#Eq🔗  🗟WellFounded.min🗟🔗../.././Mathlib/Order/WellFounded.html#WellFounded.min🔗  ⋯ s hs\n\n", "used_premises": [1, 39, 72, 69, 83], "def_path": "ConNF/NewTangle/Cloud.lean", "pos": [129, 131], "informalization": "Function `ConNF.minTangle` is a noncomputable function that, given a nonempty set of tangles at level `γ` in the context of Constructive Ordinal Notation (ConNF), returns the tangle with the smallest position among all tangles in the set."}
{"full_name": "ConNF.minTangle_le", "url": "ConNF/NewTangle/Cloud.html#ConNF.minTangle_le", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.minTangle_le [ConNF.Params🔗<|PREMISE|>🔗 ] {γ : ConNF.TypeIndex} [ConNF.TangleData🔗<|PREMISE|>🔗 γ] [ConNF.PositionedTangles🔗<|PREMISE|>🔗 γ] (s : Set🔗<|PREMISE|>🔗 (ConNF.Tangle γ)) (hs : Set.Nonempty🔗<|PREMISE|>🔗 s) {t : ConNF.Tangle γ} (ht : t ∈ s) :ConNF.pos (ConNF.minTangle🔗<|PREMISE|>🔗 s hs) ≤ ConNF.pos t", "code": "theorem minTangle_le (s : Set (Tangle γ)) (hs : s.Nonempty) {t : Tangle γ} (ht : t ∈ s) :\n    pos (minTangle s hs) ≤ pos t :=\n  not_lt.1 <| wellFounded_pos.not_lt_min s hs ht\n", "additional_info": "", "used_premises": [1, 39, 72, 69, 83, 93], "def_path": "ConNF/NewTangle/Cloud.lean", "pos": [135, 138], "informalization": "In the context of Constructive Ordinal Notation (ConNF), the theorem `ConNF.minTangle_le` asserts that for any nonempty set of tangles at level `γ`, the position of the tangle with the smallest position is less than or equal to the position of any other tangle in the set."}
{"full_name": "ConNF.invImage_codeMinMap_wf", "url": "ConNF/NewTangle/Cloud.html#ConNF.invImage_codeMinMap_wf", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.invImage_codeMinMap_wf [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.TangleDataLt] [ConNF.PositionedTanglesLt] :WellFounded🔗<|PREMISE|>🔗 (InvImage🔗<|PREMISE|>🔗 (fun (x x_1 : ConNF.μ) => x < x_1) ConNF.codeMinMap)", "code": "theorem invImage_codeMinMap_wf : WellFounded (InvImage (· < ·) (codeMinMap : NonemptyCode → μ)) :=\n  InvImage.wf codeMinMap IsWellFounded.wf\n", "additional_info": "The pullback `<` relation on codes is well-founded.", "used_premises": [1, 19, 96], "def_path": "ConNF/NewTangle/Cloud.lean", "pos": [158, 160], "informalization": "The theorem `ConNF.invImage_codeMinMap_wf` states that the inverse image of the `<` relation on codes under the function `ConNF.codeMinMap` is well-founded. This means that every non-empty set of codes has a minimal element with respect to this relation."}
{"full_name": "InvImage", "url": "Init/Core.html#InvImage", "code_src": "lean4", "ptype": "def", "header": "def InvImage {α : Sort u} {β : Sort v} (r : β → β → Prop ) (f : α → β) :α → α → Prop", "code": "def InvImage {α : Sort u} {β : Sort v} (r : β → β → Prop) (f : α → β) : α → α → Prop :=\n  fun a₁ a₂ => r (f a₁) (f a₂)\n", "additional_info": "The inverse image of `🗟r🗟🔗.././Init/Core.html#Setoid.r🔗  : β → β → Prop` by a function `α → β` is the relation\n`s : α → α → Prop` defined by `s a b = 🗟r🗟🔗.././Init/Core.html#Setoid.r🔗  (f a) (f b)`.\nEquations\n* 🗟InvImage🗟🔗.././Init/Core.html#InvImage🔗  r f a₁ a₂ 🗟=🗟🔗.././Init/Prelude.html#Eq🔗  r (f a₁) (f a₂)\n\n", "used_premises": [], "def_path": "Init/Core.lean", "pos": [1082, 1084], "informalization": "`InvImage` is a function that takes a relation `r : β → β → Prop` and a function `f : α → β`, and returns a new relation `s : α → α → Prop` such that `s a₁ a₂` holds if and only if `r (f a₁) (f a₂)` holds. In other words, `s` is the inverse image of `r` under `f`."}
{"full_name": "ConNF.extension_self", "url": "ConNF/NewTangle/Cloud.html#ConNF.extension_self", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.extension_self [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.TangleDataLt] [ConNF.PositionedTanglesLt] [ConNF.TypedObjectsLt] {γ : ConNF.Λ} [ConNF.LtLevel🔗<|PREMISE|>🔗 ↑γ] (s : Set🔗<|PREMISE|>🔗 (ConNF.Tangle ↑γ)) :ConNF.extension🔗<|PREMISE|>🔗 s γ = s", "code": "theorem extension_self {γ : Λ} [LtLevel γ] (s : Set (Tangle γ)) : extension s γ = s :=\n  dif_pos rfl\n", "additional_info": "", "used_premises": [1, 98, 69, 99], "def_path": "ConNF/NewTangle/Cloud.lean", "pos": [171, 173], "informalization": "Function `ConNF.extension` maps a set of `β`-tangles to a set of `γ`-tangles, where `β` and `γ` are type indices in the context of Constructive Ordinal Notation (ConNF). If `β` equals `γ`, the function is the identity. Otherwise, it uses the `ConNF.cloud` function to map the set of `β`-tangles to a set of `γ`-tangles. The theorem `ConNF.extension_self` states that when `β` equals `γ`, the function `ConNF.extension` is the identity, meaning it maps the set of `β`-tangles to itself."}
{"full_name": "ConNF.LtLevel", "url": "ConNF/Structural/Index.html#ConNF.LtLevel", "code_src": "con-nf", "ptype": "class", "header": "class ConNF.LtLevel [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] (β : ConNF.TypeIndex) :Prop\n | elim : β <  ↑ConNF.α", "code": "class LtLevel (β : TypeIndex) : Prop where\n  elim : β < α\n", "additional_info": "The type index `β` is less than our current level.\n", "used_premises": [1], "def_path": "ConNF/Structural/Index.lean", "pos": [33, 35], "informalization": "The `ConNF.LtLevel` class in Lean 4 represents the condition that a type index `β` is less than the current level `α` in the context of Constructive Ordinal Notation (ConNF)."}
{"full_name": "ConNF.extension", "url": "ConNF/NewTangle/Cloud.html#ConNF.extension", "code_src": "con-nf", "ptype": "def", "header": "def ConNF.extension [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.TangleDataLt] [ConNF.PositionedTanglesLt] [ConNF.TypedObjectsLt] {β : ConNF.TypeIndex} [ConNF.LtLevel🔗<|PREMISE|>🔗 β] (s : Set🔗<|PREMISE|>🔗 (ConNF.Tangle β)) (γ : ConNF.Λ) [ConNF.LtLevel🔗<|PREMISE|>🔗 ↑γ] :Set🔗<|PREMISE|>🔗 (ConNF.Tangle ↑γ)", "code": "def extension (s : Set (Tangle β)) (γ : Λ) [LtLevel γ] : Set (Tangle γ) :=\n  if hβγ : β = γ then cast (by subst hβγ; rfl) s else cloud hβγ s\n", "additional_info": "The `🗟cloud🗟🔗../.././ConNF/NewTangle/Cloud.html#ConNF.cloud🔗`  map, phrased as a function on sets of `γ`-tangles, but if `γ = β`, this is the\nidentity function.\nEquations\n* 🗟ConNF.extension🗟🔗../.././ConNF/NewTangle/Cloud.html#ConNF.extension🔗  s γ 🗟=🗟🔗../.././Init/Prelude.html#Eq🔗  if hβγ : β 🗟=🗟🔗../.././Init/Prelude.html#Eq🔗  ↑γ then 🗟cast🗟🔗../.././Init/Prelude.html#cast🔗  ⋯ s else 🗟ConNF.cloud🗟🔗../.././ConNF/NewTangle/Cloud.html#ConNF.cloud🔗  hβγ s\n\n", "used_premises": [1, 98, 69, 98, 69], "def_path": "ConNF/NewTangle/Cloud.lean", "pos": [167, 169], "informalization": "`ConNF.extension` is a function that maps a set of `β`-tangles to a set of `γ`-tangles, where `β` and `γ` are type indices in the context of Constructive Ordinal Notation (ConNF). If `β` equals `γ`, the function is the identity. Otherwise, it uses the `ConNF.cloud` function to map the set of `β`-tangles to a set of `γ`-tangles."}
{"full_name": "ConNF.cloudCode_eq", "url": "ConNF/NewTangle/Cloud.html#ConNF.cloudCode_eq", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.cloudCode_eq [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.TangleDataLt] [ConNF.PositionedTanglesLt] [ConNF.TypedObjectsLt] (β : ConNF.Λ) [ConNF.LtLevel🔗<|PREMISE|>🔗 ↑β] (c : ConNF.Code) (hcβ : c.β = ↑β) :ConNF.cloudCode🔗<|PREMISE|>🔗 β c = c", "code": "theorem cloudCode_eq (hcβ : c.1 = β) : cloudCode β c = c := by\n  rw [cloudCode, extension_eq _ _ hcβ]\n  ext : 1\n  · exact hcβ.symm\n  · simp only [cast_heq]\n", "additional_info": "", "used_premises": [1, 98, 101], "def_path": "ConNF/NewTangle/Cloud.lean", "pos": [194, 199], "informalization": "In the context of Constructive Ordinal Notation (ConNF) in Lean 4, the `ConNF.cloudCode` function takes a type index `β` and a `ConNF.Code` object `c`, and returns a new `ConNF.Code` object. If the level of `c` matches `β`, then `ConNF.cloudCode` is the identity function. This function is defined in such a way that the first component of the returned `ConNF.Code` object is defeq to `β`."}
{"full_name": "ConNF.cloudCode", "url": "ConNF/NewTangle/Cloud.html#ConNF.cloudCode", "code_src": "con-nf", "ptype": "def", "header": "def ConNF.cloudCode [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.TangleDataLt] [ConNF.PositionedTanglesLt] [ConNF.TypedObjectsLt] (β : ConNF.Λ) [ConNF.LtLevel🔗<|PREMISE|>🔗 ↑β] (c : ConNF.Code) :ConNF.Code", "code": "def cloudCode (c : Code) : Code :=\n  mk β (extension c.members β)\n", "additional_info": "The `🗟cloud🗟🔗../.././ConNF/NewTangle/Cloud.html#ConNF.cloud🔗`  map, phrased as a function on `α`-codes, but if the code's level matches `β`,\nthis is the identity function. This is written in a weird way in order to make `(cloudCode β c).1`\ndefeq to `β`.\nEquations\n* 🗟ConNF.cloudCode🗟🔗../.././ConNF/NewTangle/Cloud.html#ConNF.cloudCode🔗  β c 🗟=🗟🔗../.././Init/Prelude.html#Eq🔗  🗟ConNF.Code.mk🗟🔗../.././ConNF/NewTangle/Code.html#ConNF.Code.mk🔗  (↑β) (🗟ConNF.extension🗟🔗../.././ConNF/NewTangle/Cloud.html#ConNF.extension🔗  c.members β)\n\n", "used_premises": [1, 98], "def_path": "ConNF/NewTangle/Cloud.lean", "pos": [191, 193], "informalization": "`ConNF.cloudCode` is a function defined in the context of Constructive Ordinal Notation (ConNF) in Lean 4. It takes a type index `β` and a `ConNF.Code` object `c`, and returns a new `ConNF.Code` object. If the level of `c` matches `β`, then `ConNF.cloudCode` is the identity function. This function is defined in such a way that the first component of the returned `ConNF.Code` object is defeq to `β`."}
{"full_name": "ConNF.fst_cloudCode", "url": "ConNF/NewTangle/Cloud.html#ConNF.fst_cloudCode", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.fst_cloudCode [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.TangleDataLt] [ConNF.PositionedTanglesLt] [ConNF.TypedObjectsLt] (β : ConNF.Λ) [ConNF.LtLevel🔗<|PREMISE|>🔗 ↑β] (c : ConNF.Code) :(ConNF.cloudCode🔗<|PREMISE|>🔗 β c).β = ↑β", "code": "theorem fst_cloudCode : (cloudCode β c).1 = β :=\n  rfl\n", "additional_info": "", "used_premises": [1, 98, 101], "def_path": "ConNF/NewTangle/Cloud.lean", "pos": [204, 206], "informalization": "In the context of Constructive Ordinal Notation (ConNF) in Lean 4, the function `ConNF.cloudCode` takes a type index `β` and a `ConNF.Code` object `c`, and returns a new `ConNF.Code` object. If the level of `c` matches `β`, then `ConNF.cloudCode` is the identity function. This function is defined in such a way that the first component of the returned `ConNF.Code` object is defeq to `β`."}
{"full_name": "ConNF.cloudCode_mk_eq", "url": "ConNF/NewTangle/Cloud.html#ConNF.cloudCode_mk_eq", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.cloudCode_mk_eq [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.TangleDataLt] [ConNF.PositionedTanglesLt] [ConNF.TypedObjectsLt] (β : ConNF.Λ) [ConNF.LtLevel🔗<|PREMISE|>🔗 ↑β] (s : Set🔗<|PREMISE|>🔗 (ConNF.Tangle ↑β)) :ConNF.cloudCode🔗<|PREMISE|>🔗 β (ConNF.Code.mk🔗<|PREMISE|>🔗 (↑β) s) = ConNF.Code.mk🔗<|PREMISE|>🔗 (↑β) s", "code": "theorem cloudCode_mk_eq (s) : cloudCode β (mk β s) = mk β s := by\n  rw [cloudCode_eq]\n  rfl\n", "additional_info": "", "used_premises": [1, 98, 69, 101, 104, 104], "def_path": "ConNF/NewTangle/Cloud.lean", "pos": [214, 217], "informalization": "In the context of Constructive Ordinal Notation (ConNF), the function `ConNF.cloudCode` takes a type index `β` and a `ConNF.Code` object `c`, and returns a new `ConNF.Code` object. If the level of `c` matches `β`, then `ConNF.cloudCode` is the identity function. This function is defined in such a way that the first component of the returned `ConNF.Code` object is defeq to `β`."}
{"full_name": "ConNF.Code.mk", "url": "ConNF/NewTangle/Code.html#ConNF.Code", "code_src": "con-nf", "ptype": "structure_mk", "header": "structure_mk ConNF.Code🔗<|PREMISE|>🔗.mk  [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.TangleDataLt] :Type u\n | β : ConNF.TypeIndex\n | inst : ConNF.LtLevel🔗<|PREMISE|>🔗  self.β\n | members : Set🔗<|PREMISE|>🔗  (ConNF.Tangle  self.β)", "code": "structure Code : Type u where\n  (β : TypeIndex)\n  [inst : LtLevel β]\n  (members : Set (Tangle β))\n", "additional_info": "", "used_premises": [105, 1, 98, 69], "def_path": "ConNF/NewTangle/Code.lean", "pos": [23, 27], "informalization": "Structure `ConNF.Code` represents a type index `β` less than the current level `α` in the context of Constructive Ordinal Notation (ConNF), along with a set of tangles of type `β`."}
{"full_name": "ConNF.Code", "url": "ConNF/NewTangle/Code.html#ConNF.Code", "code_src": "con-nf", "ptype": "structure", "header": "structure ConNF.Code [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.TangleDataLt] :Type u\n | β : ConNF.TypeIndex\n | inst : ConNF.LtLevel🔗<|PREMISE|>🔗  self.β\n | members : Set🔗<|PREMISE|>🔗  (ConNF.Tangle  self.β)", "code": "structure Code : Type u where\n  (β : TypeIndex)\n  [inst : LtLevel β]\n  (members : Set (Tangle β))\n", "additional_info": "An `α` code is a type index `🗟β🗟🔗../.././ConNF/NewTangle/Code.html#ConNF.Code.β🔗  < α` together with a set of tangles of type `🗟β🗟🔗../.././ConNF/NewTangle/Code.html#ConNF.Code.β🔗` .\n", "used_premises": [1, 98, 69], "def_path": "ConNF/NewTangle/Code.lean", "pos": [23, 27], "informalization": "Structure `ConNF.Code` represents a type index `β` less than the current level `α` in the context of Constructive Ordinal Notation (ConNF), along with a set of tangles of type `β`."}
{"full_name": "ConNF.cloudCode_isEmpty", "url": "ConNF/NewTangle/Cloud.html#ConNF.cloudCode_isEmpty", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.cloudCode_isEmpty [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.TangleDataLt] [ConNF.PositionedTanglesLt] [ConNF.TypedObjectsLt] {β : ConNF.Λ} [ConNF.LtLevel🔗<|PREMISE|>🔗 ↑β] {c : ConNF.Code} :ConNF.Code.IsEmpty🔗<|PREMISE|>🔗 (ConNF.cloudCode🔗<|PREMISE|>🔗 β c) ↔ ConNF.Code.IsEmpty🔗<|PREMISE|>🔗 c", "code": "theorem cloudCode_isEmpty : (cloudCode β c).IsEmpty ↔ c.IsEmpty := by\n  obtain ⟨γ, s⟩ := c\n  by_cases h : γ = β\n  · rw [cloudCode_eq]\n    exact h\n  · rw [cloudCode_ne]\n    exact cloud_eq_empty h\n", "additional_info": "", "used_premises": [1, 98, 107, 101, 107], "def_path": "ConNF/NewTangle/Cloud.lean", "pos": [225, 232], "informalization": "Function `ConNF.cloudCode` is defined in the context of Constructive Ordinal Notation (ConNF) in Lean 4. It takes a type index `β` and a `ConNF.Code` object `c`, and returns a new `ConNF.Code` object. The theorem `ConNF.cloudCode_isEmpty` states that the new `ConNF.Code` object returned by `ConNF.cloudCode` is empty if and only if the original `ConNF.Code` object `c` is empty."}
{"full_name": "ConNF.Code.IsEmpty", "url": "ConNF/NewTangle/Code.html#ConNF.Code.IsEmpty", "code_src": "con-nf", "ptype": "def", "header": "def ConNF.Code.IsEmpty [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.TangleDataLt] (c : ConNF.Code) :Prop", "code": "protected def IsEmpty (c : Code) : Prop :=\n  c.members = ∅\n", "additional_info": "A code is empty if it has no element.\nEquations\n* 🗟ConNF.Code.IsEmpty🗟🔗../.././ConNF/NewTangle/Code.html#ConNF.Code.IsEmpty🔗  c 🗟=🗟🔗../.././Init/Prelude.html#Eq🔗  (c.members 🗟=🗟🔗../.././Init/Prelude.html#Eq🔗  🗟∅🗟🔗../.././Init/Core.html#EmptyCollection.emptyCollection🔗 )\n\n", "used_premises": [1], "def_path": "ConNF/NewTangle/Code.lean", "pos": [43, 45], "informalization": "Function `ConNF.Code.IsEmpty` checks if a `ConNF.Code` object is empty, meaning it contains no elements."}
{"full_name": "ConNF.cloudCode_nonempty", "url": "ConNF/NewTangle/Cloud.html#ConNF.cloudCode_nonempty", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.cloudCode_nonempty [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.TangleDataLt] [ConNF.PositionedTanglesLt] [ConNF.TypedObjectsLt] {β : ConNF.Λ} [ConNF.LtLevel🔗<|PREMISE|>🔗 ↑β] {c : ConNF.Code} :Set.Nonempty🔗<|PREMISE|>🔗 (ConNF.cloudCode🔗<|PREMISE|>🔗 β c).members ↔ Set.Nonempty🔗<|PREMISE|>🔗 c.members", "code": "theorem cloudCode_nonempty : (cloudCode β c).members.Nonempty ↔ c.members.Nonempty := by\n  simp_rw [nonempty_iff_ne_empty]; exact cloudCode_isEmpty.not\n", "additional_info": "", "used_premises": [1, 98, 83, 101, 83], "def_path": "ConNF/NewTangle/Cloud.lean", "pos": [234, 236], "informalization": "Function `ConNF.cloudCode` in the context of Constructive Ordinal Notation (ConNF) in Lean 4 takes a type index `β` and a `ConNF.Code` object `c`, and returns a new `ConNF.Code` object. The theorem `ConNF.cloudCode_nonempty` states that the set of members of the returned `ConNF.Code` object is nonempty if and only if the set of members of the original `ConNF.Code` object `c` is nonempty."}
{"full_name": "ConNF.Code.IsEmpty.cloudCode", "url": "ConNF/NewTangle/Cloud.html#ConNF.Code.IsEmpty.cloudCode", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.Code.IsEmpty.cloudCode [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.TangleDataLt] [ConNF.PositionedTanglesLt] [ConNF.TypedObjectsLt] {β : ConNF.Λ} [ConNF.LtLevel🔗<|PREMISE|>🔗 ↑β] {c : ConNF.Code} :ConNF.Code.IsEmpty🔗<|PREMISE|>🔗 c → ConNF.Code.IsEmpty🔗<|PREMISE|>🔗 (ConNF.cloudCode🔗<|PREMISE|>🔗 β c)", "code": "alias ⟨_, Code.IsEmpty.cloudCode⟩ := cloudCode_isEmpty\n", "additional_info": "**Alias** of the reverse direction of `🗟ConNF.cloudCode_isEmpty🗟🔗../.././ConNF/NewTangle/Cloud.html#ConNF.cloudCode_isEmpty🔗` .", "used_premises": [1, 98, 107, 107, 101], "def_path": "ConNF/NewTangle/Cloud.lean", "pos": [237, 238], "informalization": "Function `ConNF.Code.IsEmpty.cloudCode` is a theorem in the context of Constructive Ordinal Notation (ConNF) in Lean 4. It states that if a `ConNF.Code` object `c` is empty, then applying the `ConNF.cloudCode` function to `c` with a type index `β` that is less than the current level will also result in an empty `ConNF.Code` object."}
{"full_name": "ConNF.cloudCode_injOn", "url": "ConNF/NewTangle/Cloud.html#ConNF.cloudCode_injOn", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.cloudCode_injOn [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.TangleDataLt] [ConNF.PositionedTanglesLt] [ConNF.TypedObjectsLt] {β : ConNF.Λ} [ConNF.LtLevel🔗<|PREMISE|>🔗 ↑β] :Set.InjOn🔗<|PREMISE|>🔗 (ConNF.cloudCode🔗<|PREMISE|>🔗 β) {c : ConNF.Code | c.β ≠ ↑β ∧ Set.Nonempty🔗<|PREMISE|>🔗 c.members}", "code": "theorem cloudCode_injOn : {c : Code | c.1 ≠ β ∧ c.members.Nonempty}.InjOn (cloudCode β) := by\n  rintro ⟨γ, s⟩ ⟨hγβ, hs⟩ ⟨δ, t⟩ ⟨hδβ, ht⟩ h\n  rw [cloudCode_ne _ _ hγβ, cloudCode_ne _ _ hδβ] at h\n  have := (congr_arg_heq Code.members h).eq\n  obtain rfl := cloud_disjoint_range _ _ hs this\n  dsimp only at this\n  rw [cloud_injective this]\n", "additional_info": "", "used_premises": [1, 98, 111, 101, 83], "def_path": "ConNF/NewTangle/Cloud.lean", "pos": [239, 246], "informalization": "The theorem `ConNF.cloudCode_injOn` states that the function `ConNF.cloudCode` is injective when restricted to the set of `ConNF.Code` objects `c` such that the level of `c` is not equal to `β` and the set of members of `c` is nonempty."}
{"full_name": "Set.InjOn", "url": "Mathlib/Data/Set/Defs.html#Set.InjOn", "code_src": "mathlib4", "ptype": "def", "header": "def Set.InjOn {α : Type u} {β : Type v} (f : α → β) (s : Set🔗<|PREMISE|>🔗 α) :Prop", "code": "def InjOn (f : α → β) (s : Set α) : Prop :=\n  ∀ ⦃x₁ : α⦄, x₁ ∈ s → ∀ ⦃x₂ : α⦄, x₂ ∈ s → f x₁ = f x₂ → x₁ = x₂\n", "additional_info": "`f` is injective on `a` if the restriction of `f` to `a` is injective.\nEquations\n* 🗟Set.InjOn🗟🔗../../.././Mathlib/Data/Set/Defs.html#Set.InjOn🔗  f s 🗟=🗟🔗../../.././Init/Prelude.html#Eq🔗  ∀ ⦃x₁ : α⦄, x₁ 🗟∈🗟🔗../../.././Init/Prelude.html#Membership.mem🔗  s → ∀ ⦃x₂ : α⦄, x₂ 🗟∈🗟🔗../../.././Init/Prelude.html#Membership.mem🔗  s → f x₁ 🗟=🗟🔗../../.././Init/Prelude.html#Eq🔗  f x₂ → x₁ 🗟=🗟🔗../../.././Init/Prelude.html#Eq🔗  x₂\n\n", "used_premises": [69], "def_path": "Mathlib/Data/Set/Defs.lean", "pos": [289, 291], "informalization": "Function `Set.InjOn` checks if a function `f` is injective when restricted to a set `s`, meaning that for any `x₁, x₂` in `s`, `f(x₁) = f(x₂)` implies `x₁ = x₂`."}
{"full_name": "ConNF.μ_le_mk_cloudCode", "url": "ConNF/NewTangle/Cloud.html#ConNF.μ_le_mk_cloudCode", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.μ_le_mk_cloudCode [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.TangleDataLt] [ConNF.PositionedTanglesLt] [ConNF.TypedObjectsLt] {β : ConNF.Λ} [ConNF.LtLevel🔗<|PREMISE|>🔗 ↑β] (c : ConNF.Code) (hcβ : c.β ≠ ↑β) :Set.Nonempty🔗<|PREMISE|>🔗 c.members → Cardinal.mk🔗<|PREMISE|>🔗 ConNF.μ ≤ Cardinal.mk🔗<|PREMISE|>🔗 ↑(ConNF.cloudCode🔗<|PREMISE|>🔗 β c).members", "code": "theorem μ_le_mk_cloudCode (c : Code) (hcβ : c.1 ≠ β) :\n    c.members.Nonempty → #μ ≤ #(cloudCode β c).members := by\n  rw [cloudCode_ne β c hcβ]\n  exact μ_le_mk_cloud (hγβ := hcβ)\n", "additional_info": "", "used_premises": [1, 98, 83, 29, 29, 101], "def_path": "ConNF/NewTangle/Cloud.lean", "pos": [247, 251], "informalization": "This theorem states that, given a `ConNF.Code` object `c` with a level different from `β`, and assuming `c` has at least one member, the cardinality of `ConNF.μ` (the type of all `ConNF.Code` objects) is less than or equal to the cardinality of the members of the `ConNF.Code` object obtained by applying the `ConNF.cloudCode` function to `β` and `c`. The `ConNF.cloudCode` function is defined in such a way that it returns a `ConNF.Code` object with a level equal to `β`, and its members are a subset of the members of `c`. The assumption `Set.Nonempty c.members` ensures that `c` has at least one member, which is necessary for the inequality to hold. The `ConNF.Params` class provides the foundation for the Constructive Ordinal Notation (ConNF) system in Lean 4."}
{"full_name": "ConNF.cloudRel_iff", "url": "ConNF/NewTangle/Cloud.html#ConNF.cloudRel_iff", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.cloudRel_iff [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.TangleDataLt] [ConNF.PositionedTanglesLt] [ConNF.TypedObjectsLt] (c : ConNF.Code) :∀ (a : ConNF.Code), c ↝₀ a ↔ ∃ (β : ConNF.Λ) (inst : ConNF.LtLevel🔗<|PREMISE|>🔗 ↑β), c.β ≠ ↑β ∧ a = ConNF.cloudCode🔗<|PREMISE|>🔗 β c", "code": "@[mk_iff]\n", "additional_info": "", "used_premises": [1, 98, 101], "def_path": "ConNF/NewTangle/Cloud.lean", "pos": [265, 266], "informalization": "`ConNF.cloudRel_iff` is a theorem in the context of Constructive Ordinal Notation (ConNF) in Lean 4. It states that for any two `ConNF.Code` objects `c` and `a`, the relation `c ↝₀ a` holds if and only if there exists a type index `β` such that `c.β` is not equal to `β`, and `a` is equal to the result of applying `ConNF.cloudCode` to `β` and `c`."}
{"full_name": "ConNF.cloudRel_subsingleton", "url": "ConNF/NewTangle/Cloud.html#ConNF.cloudRel_subsingleton", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.cloudRel_subsingleton [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.TangleDataLt] [ConNF.PositionedTanglesLt] [ConNF.TypedObjectsLt] {c : ConNF.Code} (hc : Set.Nonempty🔗<|PREMISE|>🔗 c.members) :Set.Subsingleton🔗<|PREMISE|>🔗 {d : ConNF.Code | d ↝₀ c}", "code": "theorem cloudRel_subsingleton (hc : c.members.Nonempty) : {d : Code | d ↝₀ c}.Subsingleton := by\n  intro d hd e he\n  simp only [cloudRel_iff] at hd he\n  obtain ⟨β, hβ, hdβ, rfl⟩ := hd\n  obtain ⟨γ, hγ, heγ, h⟩ := he\n  have := ((Code.ext_iff _ _).1 h).1\n  simp only [fst_cloudCode, coe_inj] at this\n  subst this\n  refine' cloudCode_injOn ⟨hdβ, cloudCode_nonempty.1 hc⟩ _ h\n  rw [h] at hc\n  exact ⟨heγ, cloudCode_nonempty.1 hc⟩\n", "additional_info": "", "used_premises": [1, 83, 115], "def_path": "ConNF/NewTangle/Cloud.lean", "pos": [271, 282], "informalization": "In the context of Constructive Ordinal Notation (ConNF), the theorem `ConNF.cloudRel_subsingleton` asserts that the set of all `ConNF.Code` objects that are related to a given `ConNF.Code` object `c` by the `ConNF.cloudRel` relation is a `Set.Subsingleton`. This means that there is at most one `ConNF.Code` object that is related to `c` by the `ConNF.cloudRel` relation."}
{"full_name": "Set.Subsingleton", "url": "Mathlib/Data/Set/Basic.html#Set.Subsingleton", "code_src": "mathlib4", "ptype": "def", "header": "def Set.Subsingleton {α : Type u} (s : Set🔗<|PREMISE|>🔗 α) :Prop", "code": "protected def Subsingleton (s : Set α) : Prop :=\n  ∀ ⦃x⦄ (_ : x ∈ s) ⦃y⦄ (_ : y ∈ s), x = y\n", "additional_info": "A set `s` is a `🗟Subsingleton🗟🔗../../.././Init/Core.html#Subsingleton🔗`  if it has at most one element.\nEquations\n* 🗟Set.Subsingleton🗟🔗../../.././Mathlib/Data/Set/Basic.html#Set.Subsingleton🔗  s 🗟=🗟🔗../../.././Init/Prelude.html#Eq🔗  ∀ ⦃x : α⦄, x 🗟∈🗟🔗../../.././Init/Prelude.html#Membership.mem🔗  s → ∀ ⦃y : α⦄, y 🗟∈🗟🔗../../.././Init/Prelude.html#Membership.mem🔗  s → x 🗟=🗟🔗../../.././Init/Prelude.html#Eq🔗  y\n\n", "used_premises": [69], "def_path": "Mathlib/Data/Set/Basic.lean", "pos": [2336, 2338], "informalization": "A set is a `Subsingleton` if it contains at most one element."}
{"full_name": "ConNF.cloudRel_cloudCode", "url": "ConNF/NewTangle/Cloud.html#ConNF.cloudRel_cloudCode", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.cloudRel_cloudCode [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.TangleDataLt] [ConNF.PositionedTanglesLt] [ConNF.TypedObjectsLt] (β : ConNF.Λ) [ConNF.LtLevel🔗<|PREMISE|>🔗 ↑β] {c : ConNF.Code} {d : ConNF.Code} (hd : Set.Nonempty🔗<|PREMISE|>🔗 d.members) (hdβ : d.β ≠ ↑β) :c ↝₀ ConNF.cloudCode🔗<|PREMISE|>🔗 β d ↔ c = d", "code": "theorem cloudRel_cloudCode (hd : d.members.Nonempty) (hdβ : d.1 ≠ β) :\n    c ↝₀ cloudCode β d ↔ c = d := by\n  refine'\n    ⟨fun h => cloudRel_subsingleton (by rwa [cloudCode_nonempty]) h <| CloudRel.intro _ hdβ, _⟩\n  rintro rfl\n  exact ⟨_, hdβ⟩\n", "additional_info": "", "used_premises": [1, 98, 83, 101], "def_path": "ConNF/NewTangle/Cloud.lean", "pos": [283, 289], "informalization": "Function `ConNF.cloudRel_cloudCode` is a theorem in the context of Constructive Ordinal Notation (ConNF) in Lean 4. It states that given a type index `β` and two `ConNF.Code` objects `c` and `d`, if `d` is nonempty and its level does not match `β`, then `c` is related to `ConNF.cloudCode β d` by the `ConNF.cloudRel` relation if and only if `c` is equal to `d`."}
{"full_name": "ConNF.CloudRel.nonempty_iff", "url": "ConNF/NewTangle/Cloud.html#ConNF.CloudRel.nonempty_iff", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.CloudRel.nonempty_iff [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.TangleDataLt] [ConNF.PositionedTanglesLt] [ConNF.TypedObjectsLt] {c : ConNF.Code} {d : ConNF.Code} :c ↝₀ d → (Set.Nonempty🔗<|PREMISE|>🔗 c.members ↔ Set.Nonempty🔗<|PREMISE|>🔗 d.members)", "code": "theorem CloudRel.nonempty_iff : c ↝₀ d → (c.members.Nonempty ↔ d.members.Nonempty) := by\n  rintro ⟨β, hcβ⟩\n  exact cloudCode_nonempty.symm\n", "additional_info": "", "used_premises": [1, 83, 83], "def_path": "ConNF/NewTangle/Cloud.lean", "pos": [290, 293], "informalization": "The theorem `ConNF.CloudRel.nonempty_iff` states that for any two codes `c` and `d` in the context of Constructive Ordinal Notation (ConNF), if there is a relation `c ↝₀ d` between them, then the set of members of `c` is nonempty if and only if the set of members of `d` is nonempty."}
{"full_name": "ConNF.cloudRelEmptyEmpty", "url": "ConNF/NewTangle/Cloud.html#ConNF.cloudRelEmptyEmpty", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.cloudRelEmptyEmpty [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.TangleDataLt] [ConNF.PositionedTanglesLt] [ConNF.TypedObjectsLt] (γ : ConNF.TypeIndex) [ConNF.LtLevel🔗<|PREMISE|>🔗 γ] (β : ConNF.Λ) [ConNF.LtLevel🔗<|PREMISE|>🔗 ↑β] (hγβ : γ ≠ ↑β) :ConNF.Code.mk🔗<|PREMISE|>🔗 γ ∅ ↝₀ ConNF.Code.mk🔗<|PREMISE|>🔗 ↑β ∅", "code": "theorem cloudRelEmptyEmpty (hγβ : γ ≠ β) : mk γ ∅ ↝₀ mk β ∅ :=\n  (cloudRel_iff _ _).2\n    ⟨β, inferInstance, hγβ, by\n      ext : 1\n      · rfl\n      · refine heq_of_eq ?_\n        simp only [snd_cloudCode _ (mk γ ∅) hγβ, cloud_empty]⟩\n", "additional_info": "", "used_premises": [1, 98, 98, 104, 104], "def_path": "ConNF/NewTangle/Cloud.lean", "pos": [294, 301], "informalization": "Given a set of parameters for Constructive Ordinal Notation, and assuming that a type index `γ` is less than the current level `α`, and another type index `β` is also less than `α`, and `γ` is not equal to `β`, the theorem `ConNF.cloudRelEmptyEmpty` proves that if there is a tangle of type `β` and `γ` with an empty set of tangles, then there is a tangle of type `β` with an empty set of tangles, with the condition that `γ` is not equal to `β`."}
{"full_name": "ConNF.eq_of_cloudCode", "url": "ConNF/NewTangle/Cloud.html#ConNF.eq_of_cloudCode", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.eq_of_cloudCode [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.TangleDataLt] [ConNF.PositionedTanglesLt] [ConNF.TypedObjectsLt] {c : ConNF.Code} {d : ConNF.Code} {β : ConNF.Λ} {γ : ConNF.Λ} [ConNF.LtLevel🔗<|PREMISE|>🔗 ↑β] [ConNF.LtLevel🔗<|PREMISE|>🔗 ↑γ] (hc : Set.Nonempty🔗<|PREMISE|>🔗 c.members) (hcβ : c.β ≠ ↑β) (hdγ : d.β ≠ ↑γ) (h : ConNF.cloudCode🔗<|PREMISE|>🔗 β c = ConNF.cloudCode🔗<|PREMISE|>🔗 γ d) :c = d", "code": "theorem eq_of_cloudCode {β γ : Λ} [LtLevel β] [LtLevel γ]\n    (hc : c.members.Nonempty) (hcβ : c.1 ≠ β) (hdγ : d.1 ≠ γ)\n    (h : cloudCode β c = cloudCode γ d) : c = d := by\n  refine cloudRel_subsingleton (by rwa [cloudCode_nonempty]) (CloudRel.intro _ hcβ) ?_\n  rw [h]\n  exact CloudRel.intro _ hdγ\n", "additional_info": "", "used_premises": [1, 98, 98, 83, 101, 101], "def_path": "ConNF/NewTangle/Cloud.lean", "pos": [302, 308], "informalization": "Given a type index β less than the current level and a code object c of a higher level, if c is not equal to β, then the cloud code operation ConNF.cloudCode β c will return a new code object that is not equal to the original code object c. However, if we apply the same cloud code operation to another code object d of the same level but not equal to β, and the resulting code objects are the same, then the original code objects c and d must also be equal. This theorem formalizes this property in the context of Constructive Ordinal Notation (ConNF) in Lean 4."}
{"full_name": "ConNF.cloudRel_coe_coe", "url": "ConNF/NewTangle/Cloud.html#ConNF.cloudRel_coe_coe", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.cloudRel_coe_coe [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.TangleDataLt] [ConNF.PositionedTanglesLt] [ConNF.TypedObjectsLt] {c : ConNF.NonemptyCode} {d : ConNF.NonemptyCode} :↑c ↝₀ ↑d ↔ c ↝ d", "code": "theorem cloudRel_coe_coe {c d : NonemptyCode} : (c : Code) ↝₀ d ↔ c ↝ d := by\n  rw [cloudRel_iff, cloudRel'_iff]\n  aesop\n", "additional_info": "", "used_premises": [1], "def_path": "ConNF/NewTangle/Cloud.lean", "pos": [319, 322], "informalization": "In the context of Constructive Ordinal Notation (ConNF), the theorem `ConNF.cloudRel_coe_coe` states that for any two nonempty codes `c` and `d`, the relation `c ↝ d` holds if and only if the relation `↑c ↝₀ ↑d` holds, where `↑c` and `↑d` are the coercions of `c` and `d` to their respective types in the context of ConNF."}
{"full_name": "ConNF.cloud_subrelation", "url": "ConNF/NewTangle/Cloud.html#ConNF.cloud_subrelation", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.cloud_subrelation [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.TangleDataLt] [ConNF.PositionedTanglesLt] [ConNF.TypedObjectsLt] :Subrelation🔗<|PREMISE|>🔗 (fun (x x_1 : ConNF.NonemptyCode) => x ↝ x_1) (InvImage🔗<|PREMISE|>🔗 (fun (x x_1 : ConNF.μ) => x < x_1) ConNF.codeMinMap)", "code": "theorem cloud_subrelation : Subrelation (· ↝ ·) (InvImage (· < ·) (codeMinMap : NonemptyCode → μ))\n  | c, _, CloudRel'.intro β hc => codeMinMap_lt_codeMinMap_cloudCode β c hc\n", "additional_info": "", "used_premises": [1, 122, 96], "def_path": "ConNF/NewTangle/Cloud.lean", "pos": [323, 325], "informalization": "The theorem `ConNF.cloud_subrelation` states that the relation `↝` on `ConNF.NonemptyCode` is a subrelation of the inverse image of the relation `<` on `ConNF.μ` under the function `ConNF.codeMinMap`. This means that if `x ↝ y` holds, then `ConNF.codeMinMap x < ConNF.codeMinMap y` also holds."}
{"full_name": "Subrelation", "url": "Init/Core.html#Subrelation", "code_src": "lean4", "ptype": "def", "header": "def Subrelation {α : Sort u} (q : α → α → Prop ) (r : α → α → Prop ) :Prop", "code": "def Subrelation {α : Sort u} (q r : α → α → Prop) :=\n  ∀ {x y}, q x y → r x y\n", "additional_info": "`🗟Subrelation🗟🔗.././Init/Core.html#Subrelation🔗  q 🗟r🗟🔗.././Init/Core.html#Setoid.r🔗`  means that `q ⊆ 🗟r🗟🔗.././Init/Core.html#Setoid.r🔗`  or `∀ x y, q x y → 🗟r🗟🔗.././Init/Core.html#Setoid.r🔗  x y`.\nIt is the analogue of the subset relation on relations.\nEquations\n* 🗟Subrelation🗟🔗.././Init/Core.html#Subrelation🔗  q r 🗟=🗟🔗.././Init/Prelude.html#Eq🔗  ∀ {x y : α}, q x y → r x y\n\n", "used_premises": [], "def_path": "Init/Core.lean", "pos": [1075, 1077], "informalization": "Function `Subrelation` checks if a relation `q` is a subrelation of another relation `r`, meaning that `q` is always true whenever `r` is true."}
{"full_name": "ConNF.cloudRel'_wellFounded", "url": "ConNF/NewTangle/Cloud.html#ConNF.cloudRel'_wellFounded", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.cloudRel'_wellFounded [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.TangleDataLt] [ConNF.PositionedTanglesLt] [ConNF.TypedObjectsLt] :WellFounded🔗<|PREMISE|>🔗 fun (x x_1 : ConNF.NonemptyCode) => x ↝ x_1", "code": "theorem cloudRel'_wellFounded : WellFounded ((· ↝ ·) : _ → NonemptyCode → Prop) :=\n  cloud_subrelation.wf invImage_codeMinMap_wf\n", "additional_info": "There are only finitely many iterated images under any inverse `🗟cloud🗟🔗../.././ConNF/NewTangle/Cloud.html#ConNF.cloud🔗`  map.", "used_premises": [1, 19], "def_path": "ConNF/NewTangle/Cloud.lean", "pos": [327, 329], "informalization": "The theorem `ConNF.cloudRel'_wellFounded` in Lean 4 establishes that the relation `↝` defined on `ConNF.NonemptyCode` is well-founded. This means that every nonempty set of `ConNF.NonemptyCode` objects has a minimal element with respect to the relation `↝`. The relation `↝` is defined in terms of the `cloud` map, which is a key part of the ConNF (Constructive Notation For Numbers) system, used to express and manipulate natural numbers. The theorem's proof indicates that the iterated images under the `cloud` map (and its inverse) can be shown to be finite, thus ensuring the well-foundedness of the relation `↝`."}
{"full_name": "ConNF.cloudRel'_subsingleton", "url": "ConNF/NewTangle/Cloud.html#ConNF.cloudRel'_subsingleton", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.cloudRel'_subsingleton [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.TangleDataLt] [ConNF.PositionedTanglesLt] [ConNF.TypedObjectsLt] (c : ConNF.NonemptyCode) :Set.Subsingleton🔗<|PREMISE|>🔗 {d : ConNF.NonemptyCode | d ↝ c}", "code": "theorem cloudRel'_subsingleton (c : NonemptyCode) :\n    {d : NonemptyCode | d ↝ c}.Subsingleton := by\n  intro d hd e he\n  simp only [Ne.def, cloudRel'_iff, mem_setOf_eq] at hd he\n  obtain ⟨β, hβ, hdβ, rfl⟩ := hd\n  obtain ⟨γ, hγ, heγ, h⟩ := he\n  rw [Subtype.ext_iff] at h\n  have := ((Code.ext_iff _ _).1 h).1\n  simp only [Subtype.coe_mk, fst_cloudCode, coe_eq_coe] at this\n  subst this\n  exact Subtype.coe_injective (cloudCode_injOn ⟨hdβ, d.2⟩ ⟨heγ, e.2⟩ h)\n", "additional_info": "There is at most one inverse under an `🗟cloud🗟🔗../.././ConNF/NewTangle/Cloud.html#ConNF.cloud🔗`  map. This corresponds to the fact that there is\nonly one code which is related (on the left) to any given code under the `🗟cloud🗟🔗../.././ConNF/NewTangle/Cloud.html#ConNF.cloud🔗`  map relation.", "used_premises": [1, 115], "def_path": "ConNF/NewTangle/Cloud.lean", "pos": [335, 346], "informalization": "In the context of Constructive Ordinal Notation (ConNF), the theorem `ConNF.cloudRel'_subsingleton` states that for any given nonempty code `c`, there is at most one nonempty code `d` such that `d` is related to `c` under the `cloud` map relation."}
{"full_name": "ConNF.Code.ext_iff", "url": "ConNF/NewTangle/Code.html#ConNF.Code.ext_iff", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.Code.ext_iff :∀ {inst : ConNF.Params🔗<|PREMISE|>🔗 } {inst_1 : ConNF.Level} {inst_2 : ConNF.TangleDataLt} (x y : ConNF.Code), x = y ↔ x.β = y.β ∧ HEq🔗<|PREMISE|>🔗 x.members y.members", "code": "@[ext]\n", "additional_info": "", "used_premises": [1, 126], "def_path": "ConNF/NewTangle/Code.lean", "pos": [22, 23], "informalization": "The theorem `ConNF.Code.ext_iff` states that two `ConNF.Code` objects are equal if and only if their `β` components are equal and their `members` components are equal up to heterogeneous equality (`HEq`)."}
{"full_name": "HEq", "url": "Init/Prelude.html#HEq", "code_src": "lean4", "ptype": "inductive", "header": "inductive HEq {α : Sort u} :α → {β : Sort u} → β → Prop", "code": "inductive HEq : {α : Sort u} → α → {β : Sort u} → β → Prop where\n  /-- Reflexivity of heterogeneous equality. -/\n  | refl (a : α) : HEq a a\n", "additional_info": "Heterogeneous equality. `🗟HEq🗟🔗.././Init/Prelude.html#HEq🔗  a b` asserts that `a` and `b` have the same\ntype, and casting `a` across the equality yields `b`, and vice versa.\nYou should avoid using this type if you can. Heterogeneous equality does not\nhave all the same properties as `🗟Eq🗟🔗.././Init/Prelude.html#Eq🔗` , because the assumption that the types of\n`a` and `b` are equal is often too weak to prove theorems of interest. One\nimportant non-theorem is the analogue of `🗟congr🗟🔗.././Init/Prelude.html#congr🔗` : If `🗟HEq🗟🔗.././Init/Prelude.html#HEq🔗  f g` and `🗟HEq🗟🔗.././Init/Prelude.html#HEq🔗  x y`\nand `f x` and `g y` are well typed it does not follow that `🗟HEq🗟🔗.././Init/Prelude.html#HEq🔗  (f x) (g y)`.\n(This does follow if you have `f = g` instead.) However if `a` and `b` have\nthe same type then `a = b` and `🗟HEq🗟🔗.././Init/Prelude.html#HEq🔗  a b` are equivalent.\n", "used_premises": [], "def_path": "Init/Prelude.lean", "pos": [455, 458], "informalization": "Type `HEq` represents the concept of heterogeneous equality, which states that two objects of different types are considered equal if they have the same structure and properties, despite their types being different."}
{"full_name": "ConNF.Code.ext", "url": "ConNF/NewTangle/Code.html#ConNF.Code.ext", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.Code.ext :∀ {inst : ConNF.Params🔗<|PREMISE|>🔗 } {inst_1 : ConNF.Level} {inst_2 : ConNF.TangleDataLt} (x y : ConNF.Code), x.β = y.β → HEq🔗<|PREMISE|>🔗 x.members y.members → x = y", "code": "@[ext]\n", "additional_info": "", "used_premises": [1, 126], "def_path": "ConNF/NewTangle/Code.lean", "pos": [22, 23], "informalization": "In the context of Constructive Ordinal Notation (ConNF), the theorem `ConNF.Code.ext` states that two `ConNF.Code` objects are equal if their `β` components are equal and their `members` components are equal up to heterogeneous equality (`HEq`)."}
{"full_name": "ConNF.Code.IsEmpty.eq", "url": "ConNF/NewTangle/Code.html#ConNF.Code.IsEmpty.eq", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.Code.IsEmpty.eq [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.TangleDataLt] {c : ConNF.Code} :ConNF.Code.IsEmpty🔗<|PREMISE|>🔗 c → c.members = ∅", "code": "protected theorem IsEmpty.eq : c.IsEmpty → c.members = ∅ :=\n  id\n", "additional_info": "", "used_premises": [1, 107], "def_path": "ConNF/NewTangle/Code.lean", "pos": [46, 48], "informalization": "Function `ConNF.Code.IsEmpty.eq` is a theorem in Lean 4 that states that if a `ConNF.Code` object `c` is empty, then the set of members of `c` is equal to the empty set."}
{"full_name": "ConNF.Code.isEmpty_mk", "url": "ConNF/NewTangle/Code.html#ConNF.Code.isEmpty_mk", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.Code.isEmpty_mk [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.TangleDataLt] {β : ConNF.Λ} [ConNF.LtLevel🔗<|PREMISE|>🔗 ↑β] {s : Set🔗<|PREMISE|>🔗 (ConNF.Tangle ↑β)} :ConNF.Code.IsEmpty🔗<|PREMISE|>🔗 (ConNF.Code.mk🔗<|PREMISE|>🔗 (↑β) s) ↔ s = ∅", "code": "theorem isEmpty_mk : (mk β s).IsEmpty ↔ s = ∅ :=\n  Iff.rfl\n", "additional_info": "", "used_premises": [1, 98, 69, 107, 104], "def_path": "ConNF/NewTangle/Code.lean", "pos": [50, 52], "informalization": "The theorem `ConNF.Code.isEmpty_mk` states that a `ConNF.Code` object is empty if and only if the set of tangles it contains is empty."}
{"full_name": "ConNF.Code.mk_inj", "url": "ConNF/NewTangle/Code.html#ConNF.Code.mk_inj", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.Code.mk_inj [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.TangleDataLt] {β : ConNF.Λ} [ConNF.LtLevel🔗<|PREMISE|>🔗 ↑β] {s : Set🔗<|PREMISE|>🔗 (ConNF.Tangle ↑β)} {t : Set🔗<|PREMISE|>🔗 (ConNF.Tangle ↑β)} :ConNF.Code.mk🔗<|PREMISE|>🔗 (↑β) s = ConNF.Code.mk🔗<|PREMISE|>🔗 (↑β) t ↔ s = t", "code": "theorem mk_inj : mk β s = mk β t ↔ s = t :=\n  by simp only [mk.injEq, heq_eq_eq, true_and]\n", "additional_info": "", "used_premises": [1, 98, 69, 69, 104, 104], "def_path": "ConNF/NewTangle/Code.lean", "pos": [54, 56], "informalization": "The theorem `ConNF.Code.mk_inj` states that for two sets of tangles `s` and `t` of the same type index `β` less than the current level `α` in the context of Constructive Ordinal Notation (ConNF), the codes `ConNF.Code.mk (↑β) s` and `ConNF.Code.mk (↑β) t` are equal if and only if the sets `s` and `t` are equal."}
{"full_name": "ConNF.SemiallowablePerm.mul_apply", "url": "ConNF/NewTangle/NewAllowable.html#ConNF.SemiallowablePerm.mul_apply", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.SemiallowablePerm.mul_apply [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.TangleDataLt] (β : ConNF.TypeIndex) [ConNF.LtLevel🔗<|PREMISE|>🔗 β] (ρ : ConNF.SemiallowablePerm) (ρ' : ConNF.SemiallowablePerm) :(ρ * ρ') β = ρ β * ρ' β", "code": "theorem mul_apply (ρ ρ' : SemiallowablePerm) :\n    (ρ * ρ') β = ρ β * ρ' β :=\n  rfl\n", "additional_info": "", "used_premises": [1, 98], "def_path": "ConNF/NewTangle/NewAllowable.lean", "pos": [48, 51], "informalization": "The `ConNF.SemiallowablePerm.mul_apply` theorem states that the application of the product of two semiallowable permutations `ρ` and `ρ'` to a type index `β` is equal to the product of the applications of `ρ` and `ρ'` to `β`."}
{"full_name": "ConNF.SemiallowablePerm.inv_apply", "url": "ConNF/NewTangle/NewAllowable.html#ConNF.SemiallowablePerm.inv_apply", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.SemiallowablePerm.inv_apply [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.TangleDataLt] (β : ConNF.TypeIndex) [ConNF.LtLevel🔗<|PREMISE|>🔗 β] (ρ : ConNF.SemiallowablePerm) :ρ⁻¹ β = (ρ β)⁻¹", "code": "theorem inv_apply :\n    ρ⁻¹ β = (ρ β)⁻¹ :=\n  rfl\n", "additional_info": "", "used_premises": [1, 98], "def_path": "ConNF/NewTangle/NewAllowable.lean", "pos": [53, 56], "informalization": "The theorem `ConNF.SemiallowablePerm.inv_apply` states that for any semiallowable permutation `ρ` and any type index `β` less than the current level, the inverse of `ρ` applied to `β` is equal to the inverse of `ρ` applied to `β`."}
{"full_name": "ConNF.SemiallowablePerm.pathTop_toPath_comp", "url": "ConNF/NewTangle/NewAllowable.html#ConNF.SemiallowablePerm.pathTop_toPath_comp", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.SemiallowablePerm.pathTop_toPath_comp {V : Type u_2} [Quiver🔗<|PREMISE|>🔗 V] {x : V} {y : V} {z : V} (e : x ⟶ y) (p : Quiver.Path🔗<|PREMISE|>🔗 y z) :ConNF.SemiallowablePerm.pathTop🔗<|PREMISE|>🔗 (Quiver.Path.comp🔗<|PREMISE|>🔗 (Quiver.Hom.toPath🔗<|PREMISE|>🔗 e) p) = y", "code": "theorem pathTop_toPath_comp {x y z : V} (e : x ⟶ y) (p : Quiver.Path y z) :\n    pathTop ((e.toPath).comp p) = y := by\n  induction p with\n  | nil => rfl\n  | cons p f ih =>\n    cases p with\n    | nil => rfl\n    | cons p g => exact ih\n", "additional_info": "", "used_premises": [75, 76, 134, 135, 74], "def_path": "ConNF/NewTangle/NewAllowable.lean", "pos": [75, 83], "informalization": "Function `ConNF.SemiallowablePerm.pathTop` takes a path in a quiver from vertex `x` to vertex `y` and returns the second vertex in the path if the path is nonempty, or `y` if the path is empty. Function `Quiver.Path.comp` composes two paths in a quiver. Given a path from vertex `a` to vertex `b` and a path from vertex `b` to vertex `c`, it returns a path from vertex `a` to vertex `c`. Function `Quiver.Hom.toPath` converts a single arrow in a quiver into a path of length one. The theorem `ConNF.SemiallowablePerm.pathTop_toPath_comp` states that if `e` is an arrow from vertex `x` to vertex `y`, and `p` is a path from vertex `y` to vertex `z`, then `ConNF.SemiallowablePerm.pathTop (Quiver.Path.comp (Quiver.Hom.toPath e) p) = y`."}
{"full_name": "ConNF.SemiallowablePerm.pathTop", "url": "ConNF/NewTangle/NewAllowable.html#ConNF.SemiallowablePerm.pathTop", "code_src": "con-nf", "ptype": "def", "header": "def ConNF.SemiallowablePerm.pathTop {V : Type u_1} [Quiver🔗<|PREMISE|>🔗 V] {x : V} {y : V} :Quiver.Path🔗<|PREMISE|>🔗 x y → V", "code": "def pathTop {x y : V} : Quiver.Path x y → V\n| Quiver.Path.cons Quiver.Path.nil e => y\n| Quiver.Path.cons (Quiver.Path.cons p e) _ => pathTop (Quiver.Path.cons p e)\n| Quiver.Path.nil => y\n", "additional_info": "If the path is nonempty, extract the second element of the path.\nThis requires induction over paths because paths in quivers are expressed with their `cons`\noperation at the end, not the start.\nEquations\n* 🗟ConNF.SemiallowablePerm.pathTop🗟🔗../.././ConNF/NewTangle/NewAllowable.html#ConNF.SemiallowablePerm.pathTop🔗  (🗟Quiver.Path.cons🗟🔗../.././Mathlib/Combinatorics/Quiver/Path.html#Quiver.Path.cons🔗  Quiver.Path.nil e) 🗟=🗟🔗../.././Init/Prelude.html#Eq🔗  y\n* 🗟ConNF.SemiallowablePerm.pathTop🗟🔗../.././ConNF/NewTangle/NewAllowable.html#ConNF.SemiallowablePerm.pathTop🔗  (🗟Quiver.Path.cons🗟🔗../.././Mathlib/Combinatorics/Quiver/Path.html#Quiver.Path.cons🔗  (🗟Quiver.Path.cons🗟🔗../.././Mathlib/Combinatorics/Quiver/Path.html#Quiver.Path.cons🔗  p e) a) 🗟=🗟🔗../.././Init/Prelude.html#Eq🔗  🗟ConNF.SemiallowablePerm.pathTop🗟🔗../.././ConNF/NewTangle/NewAllowable.html#ConNF.SemiallowablePerm.pathTop🔗  (🗟Quiver.Path.cons🗟🔗../.././Mathlib/Combinatorics/Quiver/Path.html#Quiver.Path.cons🔗  p e)\n* 🗟ConNF.SemiallowablePerm.pathTop🗟🔗../.././ConNF/NewTangle/NewAllowable.html#ConNF.SemiallowablePerm.pathTop🔗  Quiver.Path.nil 🗟=🗟🔗../.././Init/Prelude.html#Eq🔗  x\n\n", "used_premises": [75, 76], "def_path": "ConNF/NewTangle/NewAllowable.lean", "pos": [70, 74], "informalization": "Function `ConNF.SemiallowablePerm.pathTop` takes a path in a quiver from vertex `x` to vertex `y` and returns the second vertex in the path if the path is nonempty, or `y` if the path is empty."}
{"full_name": "Quiver.Path.comp", "url": "Mathlib/Combinatorics/Quiver/Path.html#Quiver.Path.comp", "code_src": "mathlib4", "ptype": "def", "header": "def Quiver.Path.comp {V : Type u} [Quiver🔗<|PREMISE|>🔗 V] {a : V} {b : V} {c : V} :Quiver.Path🔗<|PREMISE|>🔗 a b → Quiver.Path🔗<|PREMISE|>🔗 b c → Quiver.Path🔗<|PREMISE|>🔗 a c", "code": "def comp {a b : V} : ∀ {c}, Path a b → Path b c → Path a c\n  | _, p, nil => p\n  | _, p, cons q e => (p.comp q).cons e\n", "additional_info": "Composition of paths.\nEquations\n* 🗟Quiver.Path.comp🗟🔗../../.././Mathlib/Combinatorics/Quiver/Path.html#Quiver.Path.comp🔗  x Quiver.Path.nil 🗟=🗟🔗../../.././Init/Prelude.html#Eq🔗  x\n* 🗟Quiver.Path.comp🗟🔗../../.././Mathlib/Combinatorics/Quiver/Path.html#Quiver.Path.comp🔗  x (🗟Quiver.Path.cons🗟🔗../../.././Mathlib/Combinatorics/Quiver/Path.html#Quiver.Path.cons🔗  q e) 🗟=🗟🔗../../.././Init/Prelude.html#Eq🔗  🗟Quiver.Path.cons🗟🔗../../.././Mathlib/Combinatorics/Quiver/Path.html#Quiver.Path.cons🔗  (🗟Quiver.Path.comp🗟🔗../../.././Mathlib/Combinatorics/Quiver/Path.html#Quiver.Path.comp🔗  x q) e\n\n", "used_premises": [75, 76, 76, 76], "def_path": "Mathlib/Combinatorics/Quiver/Path.lean", "pos": [87, 90], "informalization": "Function `Quiver.Path.comp` composes two paths in a quiver. Given a path from vertex `a` to vertex `b` and a path from vertex `b` to vertex `c`, it returns a path from vertex `a` to vertex `c`."}
{"full_name": "ConNF.SemiallowablePerm.pathTop_pathTail", "url": "ConNF/NewTangle/NewAllowable.html#ConNF.SemiallowablePerm.pathTop_pathTail", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.SemiallowablePerm.pathTop_pathTail {V : Type u_2} [Quiver🔗<|PREMISE|>🔗 V] {x : V} {y : V} (p : Quiver.Path🔗<|PREMISE|>🔗 x y) (h : Quiver.Path.length🔗<|PREMISE|>🔗 p ≠ 0) :Quiver.Path.comp🔗<|PREMISE|>🔗 (Quiver.Hom.toPath🔗<|PREMISE|>🔗 (ConNF.SemiallowablePerm.pathTop_hom🔗<|PREMISE|>🔗 p h)) (ConNF.SemiallowablePerm.pathTail🔗<|PREMISE|>🔗 p) = p", "code": "theorem pathTop_pathTail {x y : V} (p : Quiver.Path x y) (h : p.length ≠ 0) :\n    (Quiver.Hom.toPath (pathTop_hom p h)).comp (pathTail p) = p := by\n  induction p with\n  | nil => cases h rfl\n  | cons p e ih =>\n    cases p with\n    | nil => rfl\n    | cons p e => simp_rw [← ih (by simp)]; rfl\n", "additional_info": "We can remove the first morphism from a path and compose it back to form the original path.", "used_premises": [75, 76, 137, 135, 74, 138, 139], "def_path": "ConNF/NewTangle/NewAllowable.lean", "pos": [104, 112], "informalization": "The theorem `ConNF.SemiallowablePerm.pathTop_pathTail` states that given a path `p` from vertex `x` to vertex `y` in a quiver, if the length of `p` is not zero (meaning `p` is not a trivial path), then we can remove the first morphism from `p` and compose it back to form the original path `p`."}
{"full_name": "Quiver.Path.length", "url": "Mathlib/Combinatorics/Quiver/Path.html#Quiver.Path.length", "code_src": "mathlib4", "ptype": "def", "header": "def Quiver.Path.length {V : Type u} [Quiver🔗<|PREMISE|>🔗 V] {a : V} {b : V} :Quiver.Path🔗<|PREMISE|>🔗 a b → ℕ", "code": "def length {a : V} : ∀ {b : V}, Path a b → ℕ\n  | _, nil => 0\n  | _, cons p _ => p.length + 1\n", "additional_info": "The length of a path is the number of arrows it uses.\nEquations\n* 🗟Quiver.Path.length🗟🔗../../.././Mathlib/Combinatorics/Quiver/Path.html#Quiver.Path.length🔗  Quiver.Path.nil 🗟=🗟🔗../../.././Init/Prelude.html#Eq🔗  0\n* 🗟Quiver.Path.length🗟🔗../../.././Mathlib/Combinatorics/Quiver/Path.html#Quiver.Path.length🔗  (🗟Quiver.Path.cons🗟🔗../../.././Mathlib/Combinatorics/Quiver/Path.html#Quiver.Path.cons🔗  p a_1) 🗟=🗟🔗../../.././Init/Prelude.html#Eq🔗  🗟Quiver.Path.length🗟🔗../../.././Mathlib/Combinatorics/Quiver/Path.html#Quiver.Path.length🔗  p 🗟+🗟🔗../../.././Init/Prelude.html#HAdd.hAdd🔗  1\n\n", "used_premises": [75, 76], "def_path": "Mathlib/Combinatorics/Quiver/Path.lean", "pos": [62, 65], "informalization": "Function `Quiver.Path.length` calculates the length of a path in a quiver, which is defined as the number of arrows in the path. For a trivial path (`nil`), the length is 0, and for a path extended by an arrow (`cons`), the length is the length of the previous path plus 1."}
{"full_name": "ConNF.SemiallowablePerm.pathTop_hom", "url": "ConNF/NewTangle/NewAllowable.html#ConNF.SemiallowablePerm.pathTop_hom", "code_src": "con-nf", "ptype": "def", "header": "def ConNF.SemiallowablePerm.pathTop_hom {V : Type u_1} [Quiver🔗<|PREMISE|>🔗 V] {x : V} {y : V} (p : Quiver.Path🔗<|PREMISE|>🔗 x y) (h : Quiver.Path.length🔗<|PREMISE|>🔗 p ≠ 0) :x ⟶ ConNF.SemiallowablePerm.pathTop🔗<|PREMISE|>🔗 p", "code": "def pathTop_hom {x y : V} (p : Quiver.Path x y) (h : p.length ≠ 0) : x ⟶ pathTop p :=\n  Quiver.Path.rec\n    (fun h => (h rfl).elim)\n    (fun {y z} p e ih _ => Quiver.Path.rec\n      (motive := fun {y} p =>\n        (e : y ⟶ z) →\n        (ih : Quiver.Path.length p ≠ 0 → (x ⟶ pathTop p)) →\n        x ⟶ pathTop (Quiver.Path.cons p e))\n      (fun e _ => e)\n      (fun {v w} p _ _ _ ih => ih (by simp))\n      p e ih)\n    p h\n", "additional_info": "Equations\n* One or more equations did not get rendered due to their size.\n\n", "used_premises": [75, 76, 137, 134], "def_path": "ConNF/NewTangle/NewAllowable.lean", "pos": [84, 96], "informalization": "Function `ConNF.SemiallowablePerm.pathTop_hom` takes a path in a quiver from vertex `x` to vertex `y` and returns the second vertex in the path if the path is nonempty, or `y` if the path is empty."}
{"full_name": "ConNF.SemiallowablePerm.pathTail", "url": "ConNF/NewTangle/NewAllowable.html#ConNF.SemiallowablePerm.pathTail", "code_src": "con-nf", "ptype": "def", "header": "def ConNF.SemiallowablePerm.pathTail {V : Type u_1} [Quiver🔗<|PREMISE|>🔗 V] {x : V} {y : V} (p : Quiver.Path🔗<|PREMISE|>🔗 x y) :Quiver.Path🔗<|PREMISE|>🔗 (ConNF.SemiallowablePerm.pathTop🔗<|PREMISE|>🔗 p) y", "code": "def pathTail {x : V} : {y : V} → (p : Quiver.Path x y) → Quiver.Path (pathTop p) y\n| _, Quiver.Path.cons Quiver.Path.nil _ => Quiver.Path.nil\n| _, Quiver.Path.cons (Quiver.Path.cons p e) f => (pathTail (Quiver.Path.cons p e)).cons f\n| _, Quiver.Path.nil => Quiver.Path.nil\n", "additional_info": "Extract the portion of the path after the first morphism.\nEquations\n* 🗟ConNF.SemiallowablePerm.pathTail🗟🔗../.././ConNF/NewTangle/NewAllowable.html#ConNF.SemiallowablePerm.pathTail🔗  (🗟Quiver.Path.cons🗟🔗../.././Mathlib/Combinatorics/Quiver/Path.html#Quiver.Path.cons🔗  Quiver.Path.nil e) 🗟=🗟🔗../.././Init/Prelude.html#Eq🔗  Quiver.Path.nil\n* 🗟ConNF.SemiallowablePerm.pathTail🗟🔗../.././ConNF/NewTangle/NewAllowable.html#ConNF.SemiallowablePerm.pathTail🔗  (🗟Quiver.Path.cons🗟🔗../.././Mathlib/Combinatorics/Quiver/Path.html#Quiver.Path.cons🔗  (🗟Quiver.Path.cons🗟🔗../.././Mathlib/Combinatorics/Quiver/Path.html#Quiver.Path.cons🔗  p e) a) 🗟=🗟🔗../.././Init/Prelude.html#Eq🔗  🗟Quiver.Path.cons🗟🔗../.././Mathlib/Combinatorics/Quiver/Path.html#Quiver.Path.cons🔗  (🗟ConNF.SemiallowablePerm.pathTail🗟🔗../.././ConNF/NewTangle/NewAllowable.html#ConNF.SemiallowablePerm.pathTail🔗  (🗟Quiver.Path.cons🗟🔗../.././Mathlib/Combinatorics/Quiver/Path.html#Quiver.Path.cons🔗  p e)) a\n* 🗟ConNF.SemiallowablePerm.pathTail🗟🔗../.././ConNF/NewTangle/NewAllowable.html#ConNF.SemiallowablePerm.pathTail🔗  Quiver.Path.nil 🗟=🗟🔗../.././Init/Prelude.html#Eq🔗  Quiver.Path.nil\n\n", "used_premises": [75, 76, 76, 134], "def_path": "ConNF/NewTangle/NewAllowable.lean", "pos": [98, 102], "informalization": "Function `ConNF.SemiallowablePerm.pathTail` takes a path in a quiver from vertex `x` to vertex `y` and returns the portion of the path after the first morphism."}
{"full_name": "ConNF.SemiallowablePerm.toStructPerm'_one", "url": "ConNF/NewTangle/NewAllowable.html#ConNF.SemiallowablePerm.toStructPerm'_one", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.SemiallowablePerm.toStructPerm'_one [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.TangleDataLt] :ConNF.SemiallowablePerm.toStructPerm'🔗<|PREMISE|>🔗 1 = 1", "code": "theorem toStructPerm'_one : (toStructPerm' 1 : StructPerm α) = 1 := by\n  funext A\n  rw [toStructPerm', one_apply, map_one]\n  rfl\n", "additional_info": "", "used_premises": [1, 141], "def_path": "ConNF/NewTangle/NewAllowable.lean", "pos": [128, 132], "informalization": "The theorem `ConNF.SemiallowablePerm.toStructPerm'_one` states that the function `ConNF.SemiallowablePerm.toStructPerm'`, which converts a semi-allowable permutation to a structural permutation in the context of Constructive Ordinal Notation (ConNF), maps the identity permutation to itself."}
{"full_name": "ConNF.SemiallowablePerm.toStructPerm'", "url": "ConNF/NewTangle/NewAllowable.html#ConNF.SemiallowablePerm.toStructPerm'", "code_src": "con-nf", "ptype": "def", "header": "def ConNF.SemiallowablePerm.toStructPerm' [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.TangleDataLt] (ρ : ConNF.SemiallowablePerm) :ConNF.StructPerm🔗<|PREMISE|>🔗 ↑ConNF.α", "code": "def toStructPerm' (ρ : SemiallowablePerm) : StructPerm α :=\n  fun A => Allowable.toStructPerm (ρ (pathTop A)) (pathTail A)\n", "additional_info": "Convert a semi-allowable permutation to a structural permutation.\nTo work out the `A`-derivative, we extract the first morphism in the path `A` and use it to\ndetermine which of the `β`-allowable permutations in `ρ` we will use.\nEquations\n* 🗟ConNF.SemiallowablePerm.toStructPerm'🗟🔗../.././ConNF/NewTangle/NewAllowable.html#ConNF.SemiallowablePerm.toStructPerm'🔗  ρ A 🗟=🗟🔗../.././Init/Prelude.html#Eq🔗  ConNF.Allowable.toStructPerm (ρ (🗟ConNF.SemiallowablePerm.pathTop🗟🔗../.././ConNF/NewTangle/NewAllowable.html#ConNF.SemiallowablePerm.pathTop🔗  A)) (🗟ConNF.SemiallowablePerm.pathTail🗟🔗../.././ConNF/NewTangle/NewAllowable.html#ConNF.SemiallowablePerm.pathTail🔗  A)\n\n", "used_premises": [1, 55], "def_path": "ConNF/NewTangle/NewAllowable.lean", "pos": [125, 127], "informalization": "Function `ConNF.SemiallowablePerm.toStructPerm'` converts a semi-allowable permutation to a structural permutation in the context of Constructive Ordinal Notation (ConNF). It takes a semi-allowable permutation `ρ` and converts it into a tree of near-litter permutations, which represents how the permutation acts along each path down the type levels in the model."}
{"full_name": "ConNF.SemiallowablePerm.toStructPerm_smul", "url": "ConNF/NewTangle/NewAllowable.html#ConNF.SemiallowablePerm.toStructPerm_smul", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.SemiallowablePerm.toStructPerm_smul [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.TangleDataLt] {X : Type u_1} [MulAction🔗<|PREMISE|>🔗 (ConNF.StructPerm🔗<|PREMISE|>🔗 ↑ConNF.α) X] (ρ : ConNF.SemiallowablePerm) (x : X) :ρ • x = ConNF.SemiallowablePerm.toStructPerm ρ • x", "code": "theorem toStructPerm_smul (ρ : SemiallowablePerm) (x : X) :\n    ρ • x = SemiallowablePerm.toStructPerm ρ • x :=\n  rfl\n", "additional_info": "", "used_premises": [1, 56, 55], "def_path": "ConNF/NewTangle/NewAllowable.lean", "pos": [160, 163], "informalization": "The theorem `ConNF.SemiallowablePerm.toStructPerm_smul` states that the action of a semiallowable permutation `ρ` on an element `x` of a type `X` with a multiplicative action by structural permutations is equal to the action of the corresponding structural permutation `ConNF.SemiallowablePerm.toStructPerm ρ` on `x`."}
{"full_name": "ConNF.SemiallowablePerm.β_smul", "url": "ConNF/NewTangle/NewAllowable.html#ConNF.SemiallowablePerm.β_smul", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.SemiallowablePerm.β_smul [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.TangleDataLt] (ρ : ConNF.SemiallowablePerm) (c : ConNF.Code) :(ρ • c).β = c.β", "code": "theorem β_smul : (ρ • c).β = c.β :=\n  rfl\n", "additional_info": "", "used_premises": [1], "def_path": "ConNF/NewTangle/NewAllowable.lean", "pos": [175, 177], "informalization": "The theorem `ConNF.SemiallowablePerm.β_smul` states that for any semiallowable permutation `ρ` and any code `c`, the `β` value of `ρ` acting on `c` is equal to the `β` value of `c`."}
{"full_name": "ConNF.SemiallowablePerm.coe_smul", "url": "ConNF/NewTangle/NewAllowable.html#ConNF.SemiallowablePerm.coe_smul", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.SemiallowablePerm.coe_smul [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.TangleDataLt] (ρ : ConNF.SemiallowablePerm) (c : ConNF.NonemptyCode) :↑(ρ • c) = ρ • ↑c", "code": "theorem coe_smul (c : NonemptyCode) : (↑(ρ • c) : Code) = ρ • (c : Code) :=\n  rfl\n", "additional_info": "", "used_premises": [1], "def_path": "ConNF/NewTangle/NewAllowable.lean", "pos": [191, 193], "informalization": "The theorem `ConNF.SemiallowablePerm.coe_smul` states that for any semiallowable permutation `ρ` and any nonempty code `c`, the action of `ρ` on `c` (denoted as `ρ • c`) is equal to the action of `ρ` on the underlying value of `c` (denoted as `ρ • ↑c`)."}
{"full_name": "ConNF.isAllowable_one", "url": "ConNF/NewTangle/NewAllowable.html#ConNF.isAllowable_one", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.isAllowable_one [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.TangleDataLt] [ConNF.PositionedTanglesLt] [ConNF.TypedObjectsLt] :ConNF.SemiallowablePerm.IsAllowable🔗<|PREMISE|>🔗 1", "code": "theorem isAllowable_one : (1 : SemiallowablePerm).IsAllowable := by\n  intro\n  simp only [ne_eq, SemiallowablePerm.one_apply, map_one, Tree.one_apply, one_smul, implies_true]\n", "additional_info": "", "used_premises": [1, 146], "def_path": "ConNF/NewTangle/NewAllowable.lean", "pos": [209, 212], "informalization": "The theorem `ConNF.isAllowable_one` states that the semiallowable permutation `1` is allowable in the context of Constructive Ordinal Notation (ConNF). A semiallowable permutation is allowable if its one-step derivatives commute with the `fuzz` maps, which are functions used in the construction of the natural numbers in ConNF. This property ensures that the permutation `1` behaves consistently with the `fuzz` maps across different levels of the ConNF hierarchy."}
{"full_name": "ConNF.SemiallowablePerm.IsAllowable", "url": "ConNF/NewTangle/NewAllowable.html#ConNF.SemiallowablePerm.IsAllowable", "code_src": "con-nf", "ptype": "def", "header": "def ConNF.SemiallowablePerm.IsAllowable [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.TangleDataLt] [ConNF.PositionedTanglesLt] [ConNF.TypedObjectsLt] (ρ : ConNF.SemiallowablePerm) :Prop", "code": "def SemiallowablePerm.IsAllowable (ρ : SemiallowablePerm) : Prop :=\n  ∀ ⦃β : TypeIndex⦄ [LtLevel β] ⦃γ : Λ⦄ [LtLevel γ] (hβγ : β ≠ γ) (t : Tangle β),\n  Allowable.toStructPerm (ρ γ) (Quiver.Hom.toPath <| bot_lt_coe _) • fuzz hβγ t = fuzz hβγ (ρ β • t)\n", "additional_info": "We say that a semiallowable permutation is allowable if its one-step derivatives commute with\nthe `fuzz` maps.\nEquations\n* One or more equations did not get rendered due to their size.\n\n", "used_premises": [1], "def_path": "ConNF/NewTangle/NewAllowable.lean", "pos": [203, 206], "informalization": "Function `ConNF.SemiallowablePerm.IsAllowable` checks if a semiallowable permutation `ρ` in the context of Constructive Ordinal Notation (ConNF) is allowable. A semiallowable permutation is allowable if its one-step derivatives commute with the `fuzz` maps, which are functions used in the construction of the natural numbers in ConNF. This property ensures that the permutation `ρ` behaves consistently with the `fuzz` maps across different levels of the ConNF hierarchy."}
{"full_name": "ConNF.isAllowable_inv", "url": "ConNF/NewTangle/NewAllowable.html#ConNF.isAllowable_inv", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.isAllowable_inv [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.TangleDataLt] [ConNF.PositionedTanglesLt] [ConNF.TypedObjectsLt] {ρ : ConNF.SemiallowablePerm} (h : ConNF.SemiallowablePerm.IsAllowable🔗<|PREMISE|>🔗 ρ) :ConNF.SemiallowablePerm.IsAllowable🔗<|PREMISE|>🔗 ρ⁻¹", "code": "theorem isAllowable_inv (h : ρ.IsAllowable) : ρ⁻¹.IsAllowable := by\n  intros β _ γ _ hβγ t\n  have := h hβγ (ρ⁻¹ β • t)\n  simp only [SemiallowablePerm.inv_apply, smul_inv_smul] at this\n  rw [← this]\n  simp only [SemiallowablePerm.inv_apply, map_inv, Tree.inv_apply, inv_smul_smul]\n", "additional_info": "", "used_premises": [1, 146, 146], "def_path": "ConNF/NewTangle/NewAllowable.lean", "pos": [213, 219], "informalization": "Given a semiallowable permutation `ρ` in the context of Constructive Ordinal Notation (ConNF), if `ρ` is allowable, then its inverse `ρ⁻¹` is also allowable."}
{"full_name": "ConNF.isAllowable_mul", "url": "ConNF/NewTangle/NewAllowable.html#ConNF.isAllowable_mul", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.isAllowable_mul [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.TangleDataLt] [ConNF.PositionedTanglesLt] [ConNF.TypedObjectsLt] {ρ : ConNF.SemiallowablePerm} {ρ' : ConNF.SemiallowablePerm} (h : ConNF.SemiallowablePerm.IsAllowable🔗<|PREMISE|>🔗 ρ) (h' : ConNF.SemiallowablePerm.IsAllowable🔗<|PREMISE|>🔗 ρ') :ConNF.SemiallowablePerm.IsAllowable🔗<|PREMISE|>🔗 (ρ * ρ')", "code": "theorem isAllowable_mul (h : ρ.IsAllowable) (h' : ρ'.IsAllowable) : (ρ * ρ').IsAllowable := by\n  intros β _ γ _ hβγ t\n  simp only [SemiallowablePerm.mul_apply, map_mul, Tree.mul_apply, mul_smul]\n  rw [h' hβγ t, h hβγ (ρ' β • t)]\n", "additional_info": "", "used_premises": [1, 146, 146, 146], "def_path": "ConNF/NewTangle/NewAllowable.lean", "pos": [220, 224], "informalization": "Function `ConNF.isAllowable_mul` proves that the product of two allowable semiallowable permutations in the context of Constructive Ordinal Notation (ConNF) is also allowable. A semiallowable permutation is allowable if its one-step derivatives commute with the `fuzz` maps, which are functions used in the construction of the natural numbers in ConNF. This property ensures that the permutations behave consistently with the `fuzz` maps across different levels of the ConNF hierarchy."}
{"full_name": "ConNF.isAllowable_div", "url": "ConNF/NewTangle/NewAllowable.html#ConNF.isAllowable_div", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.isAllowable_div [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.TangleDataLt] [ConNF.PositionedTanglesLt] [ConNF.TypedObjectsLt] {ρ : ConNF.SemiallowablePerm} {ρ' : ConNF.SemiallowablePerm} (h : ConNF.SemiallowablePerm.IsAllowable🔗<|PREMISE|>🔗 ρ) (h' : ConNF.SemiallowablePerm.IsAllowable🔗<|PREMISE|>🔗 ρ') :ConNF.SemiallowablePerm.IsAllowable🔗<|PREMISE|>🔗 (ρ / ρ')", "code": "theorem isAllowable_div (h : ρ.IsAllowable) (h' : ρ'.IsAllowable) : (ρ / ρ').IsAllowable := by\n  rw [div_eq_mul_inv]\n  exact isAllowable_mul h (isAllowable_inv h')\n", "additional_info": "", "used_premises": [1, 146, 146, 146], "def_path": "ConNF/NewTangle/NewAllowable.lean", "pos": [225, 228], "informalization": "Function `ConNF.SemiallowablePerm.IsAllowable` checks if a semiallowable permutation `ρ` in the context of Constructive Ordinal Notation (ConNF) is allowable. A semiallowable permutation is allowable if its one-step derivatives commute with the `fuzz` maps, which are functions used in the construction of the natural numbers in ConNF. This property ensures that the permutation `ρ` behaves consistently with the `fuzz` maps across different levels of the ConNF hierarchy. The theorem `ConNF.isAllowable_div` states that if `ρ` and `ρ'` are both allowable semiallowable permutations, then their quotient `ρ / ρ'` is also allowable."}
{"full_name": "ConNF.isAllowable_pow", "url": "ConNF/NewTangle/NewAllowable.html#ConNF.isAllowable_pow", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.isAllowable_pow [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.TangleDataLt] [ConNF.PositionedTanglesLt] [ConNF.TypedObjectsLt] {ρ : ConNF.SemiallowablePerm} (h : ConNF.SemiallowablePerm.IsAllowable🔗<|PREMISE|>🔗 ρ) (n : ℕ ) :ConNF.SemiallowablePerm.IsAllowable🔗<|PREMISE|>🔗 (ρ ^ n)", "code": "theorem isAllowable_pow (h : ρ.IsAllowable) (n : ℕ) : (ρ ^ n).IsAllowable := by\n  induction n with\n  | zero =>\n    rw [pow_zero]\n    exact isAllowable_one\n  | succ n ih =>\n    rw [pow_succ]\n    exact isAllowable_mul h ih\n", "additional_info": "", "used_premises": [1, 146, 146], "def_path": "ConNF/NewTangle/NewAllowable.lean", "pos": [229, 237], "informalization": "The theorem `ConNF.isAllowable_pow` states that if `ρ` is an allowable semiallowable permutation in the context of Constructive Ordinal Notation (ConNF), then any power of `ρ` is also allowable."}
{"full_name": "ConNF.isAllowable_zpow", "url": "ConNF/NewTangle/NewAllowable.html#ConNF.isAllowable_zpow", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.isAllowable_zpow [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.TangleDataLt] [ConNF.PositionedTanglesLt] [ConNF.TypedObjectsLt] {ρ : ConNF.SemiallowablePerm} (h : ConNF.SemiallowablePerm.IsAllowable🔗<|PREMISE|>🔗 ρ) (n : ℤ ) :ConNF.SemiallowablePerm.IsAllowable🔗<|PREMISE|>🔗 (ρ ^ n)", "code": "theorem isAllowable_zpow (h : ρ.IsAllowable) (n : ℤ) : (ρ ^ n).IsAllowable := by\n  cases n with\n  | ofNat n =>\n    rw [Int.ofNat_eq_coe, zpow_coe_nat]\n    exact isAllowable_pow h n\n  | negSucc n =>\n    rw [zpow_negSucc]\n    exact isAllowable_inv (isAllowable_pow h (n + 1))\n", "additional_info": "", "used_premises": [1, 146, 146], "def_path": "ConNF/NewTangle/NewAllowable.lean", "pos": [238, 246], "informalization": "The theorem `ConNF.isAllowable_zpow` states that if `ρ` is an allowable semiallowable permutation in the context of Constructive Ordinal Notation (ConNF), then `ρ` raised to any integer power `n` is also an allowable semiallowable permutation."}
{"full_name": "ConNF.NewAllowable.coe_one", "url": "ConNF/NewTangle/NewAllowable.html#ConNF.NewAllowable.coe_one", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.NewAllowable.coe_one [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.TangleDataLt] [ConNF.PositionedTanglesLt] [ConNF.TypedObjectsLt] :↑1 = 1", "code": "theorem coe_one : ((1 : NewAllowable) : SemiallowablePerm) = 1 :=\n  rfl\n", "additional_info": "", "used_premises": [1], "def_path": "ConNF/NewTangle/NewAllowable.lean", "pos": [281, 283], "informalization": "In the context of Constructive Ordinal Notation (ConNF), the theorem `ConNF.NewAllowable.coe_one` states that the natural number 1, when coerced into the type `ConNF.NewAllowable`, is equal to 1. This theorem is marked as `simp` in Lean, indicating that it can be used as a simplification rule."}
{"full_name": "ConNF.NewAllowable.coe_inv", "url": "ConNF/NewTangle/NewAllowable.html#ConNF.NewAllowable.coe_inv", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.NewAllowable.coe_inv [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.TangleDataLt] [ConNF.PositionedTanglesLt] [ConNF.TypedObjectsLt] (ρ : ConNF.NewAllowable) :↑ρ⁻¹ = (↑ρ)⁻¹", "code": "theorem coe_inv (ρ : NewAllowable) : ↑(ρ⁻¹) = (ρ : SemiallowablePerm)⁻¹ :=\n  rfl\n", "additional_info": "", "used_premises": [1], "def_path": "ConNF/NewTangle/NewAllowable.lean", "pos": [285, 287], "informalization": "The theorem `ConNF.NewAllowable.coe_inv` states that the inverse of a `ConNF.NewAllowable` object, when coerced to a real number, is equal to the inverse of the real number obtained by coercing the `ConNF.NewAllowable` object."}
{"full_name": "ConNF.NewAllowable.coe_mul", "url": "ConNF/NewTangle/NewAllowable.html#ConNF.NewAllowable.coe_mul", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.NewAllowable.coe_mul [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.TangleDataLt] [ConNF.PositionedTanglesLt] [ConNF.TypedObjectsLt] (ρ : ConNF.NewAllowable) (ρ' : ConNF.NewAllowable) :↑(ρ * ρ') = ↑ρ * ↑ρ'", "code": "theorem coe_mul (ρ ρ' : NewAllowable) : ↑(ρ * ρ') = (ρ : SemiallowablePerm) * ρ' :=\n  rfl\n", "additional_info": "", "used_premises": [1], "def_path": "ConNF/NewTangle/NewAllowable.lean", "pos": [289, 291], "informalization": "In the context of Constructive Ordinal Notation (ConNF), the theorem `ConNF.NewAllowable.coe_mul` states that the natural number representation of the product of two `ConNF.NewAllowable` objects is equal to the product of their natural number representations."}
{"full_name": "ConNF.NewAllowable.coe_div", "url": "ConNF/NewTangle/NewAllowable.html#ConNF.NewAllowable.coe_div", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.NewAllowable.coe_div [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.TangleDataLt] [ConNF.PositionedTanglesLt] [ConNF.TypedObjectsLt] (ρ : ConNF.NewAllowable) (ρ' : ConNF.NewAllowable) :↑(ρ / ρ') = ↑ρ / ↑ρ'", "code": "theorem coe_div (ρ ρ' : NewAllowable) : ↑(ρ / ρ') = (ρ : SemiallowablePerm) / ρ' :=\n  rfl\n", "additional_info": "", "used_premises": [1], "def_path": "ConNF/NewTangle/NewAllowable.lean", "pos": [293, 295], "informalization": "The theorem `ConNF.NewAllowable.coe_div` states that the natural number representation of the division of two `ConNF.NewAllowable` objects is equal to the division of their natural number representations."}
{"full_name": "ConNF.NewAllowable.coe_pow", "url": "ConNF/NewTangle/NewAllowable.html#ConNF.NewAllowable.coe_pow", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.NewAllowable.coe_pow [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.TangleDataLt] [ConNF.PositionedTanglesLt] [ConNF.TypedObjectsLt] (ρ : ConNF.NewAllowable) (n : ℕ ) :↑(ρ ^ n) = ↑ρ ^ n", "code": "theorem coe_pow (ρ : NewAllowable) (n : ℕ) : ↑(ρ ^ n) = (ρ : SemiallowablePerm) ^ n :=\n  rfl\n", "additional_info": "", "used_premises": [1], "def_path": "ConNF/NewTangle/NewAllowable.lean", "pos": [297, 299], "informalization": "The theorem `ConNF.NewAllowable.coe_pow` states that for any `ConNF.NewAllowable` object `ρ` and any natural number `n`, the `n`th power of `ρ` (denoted as `ρ ^ n`) is equal to the `n`th power of the underlying value of `ρ` (denoted as `↑ρ ^ n`)."}
{"full_name": "ConNF.NewAllowable.coe_zpow", "url": "ConNF/NewTangle/NewAllowable.html#ConNF.NewAllowable.coe_zpow", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.NewAllowable.coe_zpow [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.TangleDataLt] [ConNF.PositionedTanglesLt] [ConNF.TypedObjectsLt] (ρ : ConNF.NewAllowable) (n : ℤ ) :↑(ρ ^ n) = ↑ρ ^ n", "code": "theorem coe_zpow (ρ : NewAllowable) (n : ℤ) : ↑(ρ ^ n) = (ρ : SemiallowablePerm) ^ n :=\n  rfl\n", "additional_info": "", "used_premises": [1], "def_path": "ConNF/NewTangle/NewAllowable.lean", "pos": [301, 303], "informalization": "The theorem `ConNF.NewAllowable.coe_zpow` states that for any `ConNF.NewAllowable` object `ρ` and any integer `n`, the natural number representation of `ρ` raised to the power `n` is equal to the natural number representation of `ρ` raised to the power `n`."}
{"full_name": "ConNF.NewAllowable.coeHom_apply", "url": "ConNF/NewTangle/NewAllowable.html#ConNF.NewAllowable.coeHom_apply", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.NewAllowable.coeHom_apply [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.TangleDataLt] [ConNF.PositionedTanglesLt] [ConNF.TypedObjectsLt] (self : { ρ : ConNF.SemiallowablePerm // ConNF.SemiallowablePerm.IsAllowable🔗<|PREMISE|>🔗 ρ }) :ConNF.NewAllowable.coeHom self = ↑self", "code": "@[simps]\n", "additional_info": "", "used_premises": [1, 146], "def_path": "ConNF/NewTangle/NewAllowable.lean", "pos": [315, 316], "informalization": "Function `ConNF.NewAllowable.coeHom_apply` is a simplification theorem in the context of Constructive Ordinal Notation (ConNF) in Lean 4. It states that for a semiallowable permutation `ρ` that is allowable (i.e., its one-step derivatives commute with the `fuzz` maps), the function `ConNF.NewAllowable.coeHom` applied to `ρ` simply returns `ρ` itself."}
{"full_name": "ConNF.NewAllowable.coe_smul", "url": "ConNF/NewTangle/NewAllowable.html#ConNF.NewAllowable.coe_smul", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.NewAllowable.coe_smul [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.TangleDataLt] [ConNF.PositionedTanglesLt] [ConNF.TypedObjectsLt] {X : Type u_1} [MulAction🔗<|PREMISE|>🔗 ConNF.SemiallowablePerm X] (ρ : ConNF.NewAllowable) (x : X) :↑ρ • x = ρ • x", "code": "theorem coe_smul (ρ : NewAllowable) (x : X) : (ρ : SemiallowablePerm) • x = ρ • x :=\n  rfl\n", "additional_info": "", "used_premises": [1, 56], "def_path": "ConNF/NewTangle/NewAllowable.lean", "pos": [334, 336], "informalization": "The theorem `ConNF.NewAllowable.coe_smul` is a simplication lemma in Lean 4. It states that for any `ConNF.NewAllowable` object `ρ` and any type `X` with a `MulAction` of `ConNF.SemiallowablePerm` on `X`, the action of `ρ` on `x : X` is the same whether `ρ` is considered as an element of `ConNF.NewAllowable` or as an element of `ConNF.SemiallowablePerm`."}
{"full_name": "ConNF.NewAllowable.β_smul", "url": "ConNF/NewTangle/NewAllowable.html#ConNF.NewAllowable.β_smul", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.NewAllowable.β_smul [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.TangleDataLt] [ConNF.PositionedTanglesLt] [ConNF.TypedObjectsLt] (ρ : ConNF.NewAllowable) (c : ConNF.Code) :(ρ • c).β = c.β", "code": "theorem β_smul (ρ : NewAllowable) (c : Code) : (ρ • c).β = c.β :=\n  rfl\n", "additional_info": "", "used_premises": [1], "def_path": "ConNF/NewTangle/NewAllowable.lean", "pos": [347, 349], "informalization": "The theorem `ConNF.NewAllowable.β_smul` states that for any `ConNF.NewAllowable` object `ρ` and any `ConNF.Code` object `c`, the `β` component of the `ConNF.Code` object `(ρ • c)` is equal to the `β` component of `c`."}
{"full_name": "ConNF.NewAllowable.smul_cloudCode", "url": "ConNF/NewTangle/NewAllowable.html#ConNF.NewAllowable.smul_cloudCode", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NewAllowable.smul_cloudCode [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.TangleDataLt] {γ : ConNF.Λ} [ConNF.LtLevel🔗<|PREMISE|>🔗 ↑γ] [ConNF.PositionedTanglesLt] [ConNF.TypedObjectsLt] {c : ConNF.Code} (ρ : ConNF.NewAllowable) (hc : c.β ≠ ↑γ) :ρ • ConNF.cloudCode🔗<|PREMISE|>🔗 γ c = ConNF.cloudCode🔗<|PREMISE|>🔗 γ (ρ • c)", "code": "theorem smul_cloudCode (ρ : NewAllowable) (hc : c.1 ≠ γ) :\n    ρ • cloudCode γ c = cloudCode γ (ρ • c) := by\n  simp only [cloudCode_ne γ c hc, smul_mk, cloudCode_ne γ (ρ • c) hc, β_smul, members_smul, mk_inj]\n  rw [smul_cloud]\n", "additional_info": "Allowable permutations commute with the `cloudCode` map.", "used_premises": [1, 98, 101, 101], "def_path": "ConNF/NewTangle/NewAllowable.lean", "pos": [385, 389], "informalization": "Function `ConNF.NewAllowable.smul_cloudCode` proves that allowable permutations commute with the `cloudCode` map in the context of Constructive Ordinal Notation (ConNF)."}
{"full_name": "ConNF.CloudRel.smul", "url": "ConNF/NewTangle/NewAllowable.html#ConNF.CloudRel.smul", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.CloudRel.smul [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.TangleDataLt] [ConNF.PositionedTanglesLt] [ConNF.TypedObjectsLt] {ρ : ConNF.NewAllowable} {c : ConNF.Code} {d : ConNF.Code} :c ↝₀ d → ρ • c ↝₀ ρ • d", "code": "theorem CloudRel.smul : c ↝₀ d → ρ • c ↝₀ ρ • d := by\n  rintro ⟨γ, hγ⟩\n  exact (cloudRel_iff _ _).2 ⟨_, inferInstance, hγ, ρ.smul_cloudCode hγ⟩\n", "additional_info": "", "used_premises": [1], "def_path": "ConNF/NewTangle/NewAllowable.lean", "pos": [392, 395], "informalization": "In the context of Constructive Ordinal Notation (ConNF), the theorem `ConNF.CloudRel.smul` states that if there is a relation `c ↝₀ d` between two codes `c` and `d`, then there is also a relation `ρ • c ↝₀ ρ • d` between the codes obtained by multiplying `c` and `d` by a new allowable `ρ`."}
{"full_name": "ConNF.smul_cloudRel", "url": "ConNF/NewTangle/NewAllowable.html#ConNF.smul_cloudRel", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.smul_cloudRel [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.TangleDataLt] [ConNF.PositionedTanglesLt] [ConNF.TypedObjectsLt] {ρ : ConNF.NewAllowable} {c : ConNF.Code} {d : ConNF.Code} :ρ • c ↝₀ ρ • d ↔ c ↝₀ d", "code": "theorem smul_cloudRel : ρ • c ↝₀ ρ • d ↔ c ↝₀ d := by\n  refine ⟨fun h => ?_, CloudRel.smul⟩\n  rw [← inv_smul_smul ρ c, ← inv_smul_smul ρ d]\n  exact h.smul\n", "additional_info": "", "used_premises": [1], "def_path": "ConNF/NewTangle/NewAllowable.lean", "pos": [397, 401], "informalization": "In the context of Constructive Ordinal Notation (ConNF), the theorem `ConNF.smul_cloudRel` states that for any `ConNF.NewAllowable` object `ρ` and any two `ConNF.Code` objects `c` and `d`, the relation `ρ • c ↝₀ ρ • d` holds if and only if the relation `c ↝₀ d` holds. This theorem simplifies the manipulation of the `ConNF.smul` operation on `ConNF.Code` objects."}
{"full_name": "ConNF.Code.isEven_smul_nonempty", "url": "ConNF/NewTangle/NewAllowable.html#ConNF.Code.isEven_smul_nonempty", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.Code.isEven_smul_nonempty [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.TangleDataLt] [ConNF.PositionedTanglesLt] [ConNF.TypedObjectsLt] {ρ : ConNF.NewAllowable} (c : ConNF.NonemptyCode) :ConNF.Code.IsEven🔗<|PREMISE|>🔗 (ρ • ↑c) ↔ ConNF.Code.IsEven🔗<|PREMISE|>🔗 ↑c", "code": "theorem isEven_smul_nonempty : ∀ c : NonemptyCode, (ρ • c.val).IsEven ↔ c.val.IsEven\n  | ⟨c, hc⟩ => by\n    simp_rw [Code.isEven_iff]\n    constructor <;> intro h d hd\n    · have := hd.nonempty_iff.2 hc\n      have _ : ⟨d, this⟩ ↝ ⟨c, hc⟩ := cloudRel_coe_coe.1 hd\n      exact Code.not_isEven.1 fun H =>\n        (h _ hd.smul).not_isEven <| (isEven_smul_nonempty ⟨d, this⟩).2 H\n    · rw [← smul_inv_smul ρ d] at hd ⊢\n      rw [smul_cloudRel] at hd\n      have := hd.nonempty_iff.2 hc\n      have _ : ⟨_, this⟩ ↝ ⟨c, hc⟩ := cloudRel_coe_coe.1 hd\n      exact Code.not_isEven.1 fun H =>\n        (h _ hd).not_isEven <| (isEven_smul_nonempty ⟨_, this⟩).1 H\ntermination_by c => c\n", "additional_info": "", "used_premises": [1, 165, 165], "def_path": "ConNF/NewTangle/NewAllowable.lean", "pos": [404, 419], "informalization": "The theorem `ConNF.Code.isEven_smul_nonempty` states that for a nonempty code `c` in the context of Constructive Ordinal Notation (ConNF), the code `ρ • c` is even if and only if `c` is even."}
{"full_name": "ConNF.Code.IsEven", "url": "ConNF/NewTangle/CodeEquiv.html#ConNF.Code.IsEven", "code_src": "con-nf", "ptype": "inductive", "header": "inductive ConNF.Code.IsEven [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.TangleDataLt] [ConNF.TypedObjectsLt] [ConNF.PositionedTanglesLt] :ConNF.Code → Prop", "code": "  inductive IsEven : Code → Prop\n    | intro : ∀ c, (∀ d, d ↝₀ c → IsOdd d) → IsEven c\n", "additional_info": "A code is even iff it only leads to odd codes.\n", "used_premises": [1], "def_path": "ConNF/NewTangle/CodeEquiv.lean", "pos": [58, 60], "informalization": "Type `ConNF.Code.IsEven` represents a property of codes in the context of Constructive Ordinal Notation (ConNF), where a code is considered even if it only leads to odd codes."}
{"full_name": "ConNF.Code.isEven_smul", "url": "ConNF/NewTangle/NewAllowable.html#ConNF.Code.isEven_smul", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.Code.isEven_smul [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.TangleDataLt] [ConNF.PositionedTanglesLt] [ConNF.TypedObjectsLt] {ρ : ConNF.NewAllowable} {c : ConNF.Code} :ConNF.Code.IsEven🔗<|PREMISE|>🔗 (ρ • c) ↔ ConNF.Code.IsEven🔗<|PREMISE|>🔗 c", "code": "theorem isEven_smul : (ρ • c).IsEven ↔ c.IsEven := by\n  obtain (h | h) := c.members.eq_empty_or_nonempty\n  · rw [IsEmpty.isEven_iff h, IsEmpty.isEven_iff]\n    · rfl\n    simpa [Code.IsEmpty]\n  · exact isEven_smul_nonempty ⟨c, h⟩\n", "additional_info": "", "used_premises": [1, 165, 165], "def_path": "ConNF/NewTangle/NewAllowable.lean", "pos": [421, 427], "informalization": "In the context of Constructive Ordinal Notation (ConNF), a code is considered even if it only leads to odd codes. The theorem `ConNF.Code.isEven_smul` states that the property of being an even code is preserved under the operation of multiplying a code by a new allowable term."}
{"full_name": "ConNF.Code.isOdd_smul", "url": "ConNF/NewTangle/NewAllowable.html#ConNF.Code.isOdd_smul", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.Code.isOdd_smul [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.TangleDataLt] [ConNF.PositionedTanglesLt] [ConNF.TypedObjectsLt] {ρ : ConNF.NewAllowable} {c : ConNF.Code} :ConNF.Code.IsOdd🔗<|PREMISE|>🔗 (ρ • c) ↔ ConNF.Code.IsOdd🔗<|PREMISE|>🔗 c", "code": "theorem isOdd_smul : (ρ • c).IsOdd ↔ c.IsOdd := by simp_rw [← Code.not_isEven, isEven_smul]\n", "additional_info": "", "used_premises": [1, 168, 168], "def_path": "ConNF/NewTangle/NewAllowable.lean", "pos": [429, 430], "informalization": "In the context of Constructive Ordinal Notation (ConNF), a `ConNF.Code` is said to be `IsOdd` if it leads to some `ConNF.Code` that is `IsEven`. This property is defined inductively, stating that a code `c` is odd if there exists an even code `d` such that `d` leads to `c`. The theorem `ConNF.Code.isOdd_smul` states that for any `ConNF.NewAllowable` `ρ` and `ConNF.Code` `c`, the `ConNF.Code` `ρ • c` is `IsOdd` if and only if `c` is `IsOdd`."}
{"full_name": "ConNF.Code.IsOdd", "url": "ConNF/NewTangle/CodeEquiv.html#ConNF.Code.IsOdd", "code_src": "con-nf", "ptype": "inductive", "header": "inductive ConNF.Code.IsOdd [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.TangleDataLt] [ConNF.TypedObjectsLt] [ConNF.PositionedTanglesLt] :ConNF.Code → Prop", "code": "  inductive IsOdd : Code → Prop\n    | intro : ∀ c d, d ↝₀ c → IsEven d → IsOdd c\n", "additional_info": "A code is odd iff it leads to some even code.\n", "used_premises": [1], "def_path": "ConNF/NewTangle/CodeEquiv.lean", "pos": [63, 65], "informalization": "In the context of Constructive Ordinal Notation (ConNF), a `ConNF.Code` is said to be `IsOdd` if it leads to some `ConNF.Code` that is `IsEven`. This property is defined inductively, stating that a code `c` is odd if there exists an even code `d` such that `d` leads to `c`."}
{"full_name": "ConNF.Code.isEven.smul", "url": "ConNF/NewTangle/NewAllowable.html#ConNF.Code.isEven.smul", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.Code.isEven.smul [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.TangleDataLt] [ConNF.PositionedTanglesLt] [ConNF.TypedObjectsLt] {ρ : ConNF.NewAllowable} {c : ConNF.Code} :ConNF.Code.IsEven🔗<|PREMISE|>🔗 c → ConNF.Code.IsEven🔗<|PREMISE|>🔗 (ρ • c)", "code": "alias ⟨_, isEven.smul⟩ := isEven_smul\n", "additional_info": "**Alias** of the reverse direction of `🗟ConNF.Code.isEven_smul🗟🔗../.././ConNF/NewTangle/NewAllowable.html#ConNF.Code.isEven_smul🔗` .", "used_premises": [1, 165, 165], "def_path": "ConNF/NewTangle/NewAllowable.lean", "pos": [431, 432], "informalization": "`ConNF.Code.isEven.smul` is a theorem that states that if a code `c` is even, then the result of applying the `smul` operation (which scales a code by a factor) to `c` with a new allowable `ρ` will also result in an even code. This is derived from the fact that applying `smul` to an even code will not change its parity, as `smul` only scales the code and does not change its property of being even."}
{"full_name": "ConNF.Code.isOdd.smul", "url": "ConNF/NewTangle/NewAllowable.html#ConNF.Code.isOdd.smul", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.Code.isOdd.smul [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.TangleDataLt] [ConNF.PositionedTanglesLt] [ConNF.TypedObjectsLt] {ρ : ConNF.NewAllowable} {c : ConNF.Code} :ConNF.Code.IsOdd🔗<|PREMISE|>🔗 c → ConNF.Code.IsOdd🔗<|PREMISE|>🔗 (ρ • c)", "code": "alias ⟨_, isOdd.smul⟩ := isOdd_smul\n", "additional_info": "**Alias** of the reverse direction of `🗟ConNF.Code.isOdd_smul🗟🔗../.././ConNF/NewTangle/NewAllowable.html#ConNF.Code.isOdd_smul🔗` .", "used_premises": [1, 168, 168], "def_path": "ConNF/NewTangle/NewAllowable.lean", "pos": [433, 434], "informalization": "The statement represents that if a `ConNF.Code` is `IsOdd`, then when it is scaled by a `ConNF.NewAllowable` (denoted as `ρ • c`), the resulting code is also `IsOdd`. This is an important property in understanding the behavior of Constructive Ordinal Notation (ConNF) codes under multiplication."}
{"full_name": "ConNF.Code.isEven_iff", "url": "ConNF/NewTangle/CodeEquiv.html#ConNF.Code.isEven_iff", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.Code.isEven_iff [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.TangleDataLt] [ConNF.TypedObjectsLt] [ConNF.PositionedTanglesLt] :∀ (a : ConNF.Code), ConNF.Code.IsEven🔗<|PREMISE|>🔗 a ↔ ∀ (d : ConNF.Code), d ↝₀ a → ConNF.Code.IsOdd🔗<|PREMISE|>🔗 d", "code": "  @[mk_iff]\n", "additional_info": "", "used_premises": [1, 165, 168], "def_path": "ConNF/NewTangle/CodeEquiv.lean", "pos": [57, 58], "informalization": "In the context of Constructive Ordinal Notation (ConNF), a code is considered even if it only leads to odd codes. The theorem `ConNF.Code.isEven_iff` states that a code `a` is even if and only if every code `d` that leads to `a` is odd."}
{"full_name": "ConNF.Code.isOdd_iff", "url": "ConNF/NewTangle/CodeEquiv.html#ConNF.Code.isOdd_iff", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.Code.isOdd_iff [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.TangleDataLt] [ConNF.TypedObjectsLt] [ConNF.PositionedTanglesLt] :∀ (a : ConNF.Code), ConNF.Code.IsOdd🔗<|PREMISE|>🔗 a ↔ ∃ (d : ConNF.Code), d ↝₀ a ∧ ConNF.Code.IsEven🔗<|PREMISE|>🔗 d", "code": "  @[mk_iff]\n", "additional_info": "", "used_premises": [1, 168, 165], "def_path": "ConNF/NewTangle/CodeEquiv.lean", "pos": [62, 63], "informalization": "In the context of Constructive Ordinal Notation (ConNF), a `ConNF.Code` is said to be `IsOdd` if it leads to some `ConNF.Code` that is `IsEven`. This theorem states that a code `a` is odd if and only if there exists an even code `d` such that `d` leads to `a`."}
{"full_name": "ConNF.Code.isEven_of_forall_not", "url": "ConNF/NewTangle/CodeEquiv.html#ConNF.Code.isEven_of_forall_not", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.Code.isEven_of_forall_not [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.TangleDataLt] [ConNF.TypedObjectsLt] [ConNF.PositionedTanglesLt] {c : ConNF.Code} (h : ∀ (d : ConNF.Code), ¬ d ↝₀ c) :ConNF.Code.IsEven🔗<|PREMISE|>🔗 c", "code": "theorem isEven_of_forall_not (h : ∀ d, ¬d ↝₀ c) : IsEven c :=\n  (isEven_iff c).2 fun _ hd => (h _ hd).elim\n", "additional_info": "", "used_premises": [1, 165], "def_path": "ConNF/NewTangle/CodeEquiv.lean", "pos": [67, 69], "informalization": "In the context of Constructive Ordinal Notation (ConNF), a code is considered even if it only leads to odd codes. The theorem `ConNF.Code.isEven_of_forall_not` states that if for every code `d`, `d` does not lead to `c`, then `c` is an even code."}
{"full_name": "ConNF.Code.isEven_of_eq_bot", "url": "ConNF/NewTangle/CodeEquiv.html#ConNF.Code.isEven_of_eq_bot", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.Code.isEven_of_eq_bot [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.TangleDataLt] [ConNF.TypedObjectsLt] [ConNF.PositionedTanglesLt] (c : ConNF.Code) (hc : c.β = ⊥ ) :ConNF.Code.IsEven🔗<|PREMISE|>🔗 c", "code": "theorem isEven_of_eq_bot (c : Code) (hc : c.1 = ⊥) : c.IsEven :=\n  isEven_of_forall_not <| by rintro d ⟨β, -⟩; exact coe_ne_bot hc\n", "additional_info": "", "used_premises": [1, 165], "def_path": "ConNF/NewTangle/CodeEquiv.lean", "pos": [71, 73], "informalization": "The theorem `ConNF.Code.isEven_of_eq_bot` states that if a ConNF code `c` satisfies `c.β = ⊥`, then `c` is an even code."}
{"full_name": "ConNF.Code.isEven_bot", "url": "ConNF/NewTangle/CodeEquiv.html#ConNF.Code.isEven_bot", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.Code.isEven_bot [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.TangleDataLt] [ConNF.TypedObjectsLt] [ConNF.PositionedTanglesLt] (s : Set🔗<|PREMISE|>🔗 ConNF.Atom) :ConNF.Code.IsEven🔗<|PREMISE|>🔗 (ConNF.Code.mk🔗<|PREMISE|>🔗 ⊥ s)", "code": "theorem isEven_bot (s : Set Atom) : IsEven (mk ⊥ s : Code) :=\n  isEven_of_eq_bot _ rfl\n", "additional_info": "", "used_premises": [1, 69, 165, 104], "def_path": "ConNF/NewTangle/CodeEquiv.lean", "pos": [75, 77], "informalization": "In the context of Constructive Ordinal Notation (ConNF), a code is considered even if it only leads to odd codes. The theorem `ConNF.Code.isEven_bot` states that the code `ConNF.Code.mk ⊥ s` is even, where `⊥` represents the bottom element in the ConNF hierarchy and `s` is a set of atoms."}
{"full_name": "ConNF.Code.not_isOdd_bot", "url": "ConNF/NewTangle/CodeEquiv.html#ConNF.Code.not_isOdd_bot", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.Code.not_isOdd_bot [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.TangleDataLt] [ConNF.TypedObjectsLt] [ConNF.PositionedTanglesLt] (s : Set🔗<|PREMISE|>🔗 ConNF.Atom) :¬ ConNF.Code.IsOdd🔗<|PREMISE|>🔗 (ConNF.Code.mk🔗<|PREMISE|>🔗 ⊥ s)", "code": "theorem not_isOdd_bot (s : Set Atom) : ¬IsOdd (mk ⊥ s : Code) := by\n  simp_rw [isOdd_iff, cloudRel_iff]\n  rintro ⟨d, ⟨γ, _, h⟩, _⟩\n  exact bot_ne_coe (congr_arg Code.β h.2)\n", "additional_info": "", "used_premises": [1, 69, 168, 104], "def_path": "ConNF/NewTangle/CodeEquiv.lean", "pos": [78, 82], "informalization": "In the context of Constructive Ordinal Notation (ConNF), a `ConNF.Code` is said to be `IsOdd` if it leads to some `ConNF.Code` that is `IsEven`. This property is defined inductively, stating that a code `c` is odd if there exists an even code `d` such that `d` leads to `c`. The theorem `ConNF.Code.not_isOdd_bot` states that the bottom code `ConNF.Code.mk ⊥ s` is not `IsOdd`."}
{"full_name": "ConNF.Code.IsEmpty.isEven_iff", "url": "ConNF/NewTangle/CodeEquiv.html#ConNF.Code.IsEmpty.isEven_iff", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.Code.IsEmpty.isEven_iff [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.TangleDataLt] [ConNF.TypedObjectsLt] [ConNF.PositionedTanglesLt] {c : ConNF.Code} (hc : ConNF.Code.IsEmpty🔗<|PREMISE|>🔗 c) :ConNF.Code.IsEven🔗<|PREMISE|>🔗 c ↔ c.β = ⊥", "code": "theorem IsEmpty.isEven_iff (hc : c.IsEmpty) : IsEven c ↔ (c.1 : TypeIndex) = ⊥ := by\n  refine ⟨?_, isEven_of_eq_bot _⟩\n  intro h\n  obtain ⟨_ | (β : Λ), s⟩ := c\n  · rfl\n  · simp [Code.IsEmpty] at hc\n    cases hc\n    have := not_isOdd_bot ∅ ((isEven_iff _).1 h ⟨⊥, ∅⟩ ?_)\n    · cases this\n    convert CloudRel.intro β _\n    · aesop\n    · simp only [ne_eq, Subtype.mk.injEq, WithBot.bot_ne_coe, not_false_eq_true]\n", "additional_info": "An empty code is even iff its extension is `⊥`.", "used_premises": [1, 107, 165], "def_path": "ConNF/NewTangle/CodeEquiv.lean", "pos": [85, 97], "informalization": "In the context of Constructive Ordinal Notation (ConNF), a code is considered even if it only leads to odd codes. This theorem states that an empty code is even if and only if its extension is `⊥`."}
{"full_name": "ConNF.Code.IsEmpty.isOdd_iff", "url": "ConNF/NewTangle/CodeEquiv.html#ConNF.Code.IsEmpty.isOdd_iff", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.Code.IsEmpty.isOdd_iff [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.TangleDataLt] [ConNF.TypedObjectsLt] [ConNF.PositionedTanglesLt] {c : ConNF.Code} (hc : ConNF.Code.IsEmpty🔗<|PREMISE|>🔗 c) :ConNF.Code.IsOdd🔗<|PREMISE|>🔗 c ↔ c.β ≠ ⊥", "code": "theorem IsEmpty.isOdd_iff (hc : c.IsEmpty) : IsOdd c ↔ (c.1 : TypeIndex) ≠ ⊥ := by\n  obtain ⟨β, s⟩ := c\n  refine' ⟨_, fun h => (isOdd_iff _).2 ⟨mk ⊥ ∅, _, isEven_bot _⟩⟩\n  · rintro h (rfl : β = _)\n    exact not_isOdd_bot _ h\n  · lift β to Λ using h\n    refine (cloudRel_iff _ _).2 ⟨β, inferInstance, ?_⟩\n    simp only [ne_eq, bot_ne_coe, not_false_eq_true, cloudCode_mk_ne, cloud_empty, mk.injEq,\n      heq_eq_eq, true_and]\n    exact hc\n", "additional_info": "", "used_premises": [1, 107, 168], "def_path": "ConNF/NewTangle/CodeEquiv.lean", "pos": [99, 109], "informalization": "In the context of Constructive Ordinal Notation (ConNF), a `ConNF.Code` object is said to be `IsOdd` if it leads to some `ConNF.Code` that is `IsEven`. This property is defined inductively, stating that a code `c` is odd if there exists an even code `d` such that `d` leads to `c`. The theorem `ConNF.Code.IsEmpty.isOdd_iff` states that for an empty `ConNF.Code` object `c`, `c` is `IsOdd` if and only if `c.β ≠ ⊥`."}
{"full_name": "ConNF.Code.isEven_empty_iff", "url": "ConNF/NewTangle/CodeEquiv.html#ConNF.Code.isEven_empty_iff", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.Code.isEven_empty_iff [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] {β : ConNF.TypeIndex} [ConNF.LtLevel🔗<|PREMISE|>🔗 β] [ConNF.TangleDataLt] [ConNF.TypedObjectsLt] [ConNF.PositionedTanglesLt] :ConNF.Code.IsEven🔗<|PREMISE|>🔗 (ConNF.Code.mk🔗<|PREMISE|>🔗 β ∅ ) ↔ β = ⊥", "code": "theorem isEven_empty_iff : IsEven (mk β ∅) ↔ (β : TypeIndex) = ⊥ :=\n  IsEmpty.isEven_iff rfl\n", "additional_info": "", "used_premises": [1, 98, 165, 104], "def_path": "ConNF/NewTangle/CodeEquiv.lean", "pos": [111, 113], "informalization": "Function `ConNF.Code.isEven_empty_iff` is a theorem in Lean 4 that states that a code is even (in the context of Constructive Ordinal Notation) if and only if the index type `β` is equal to the bottom element `⊥`. The theorem's proof is a direct consequence of the definition of evenness for codes, which depends on the index type `β` being less than the current level `α`, and the empty set being interpreted in the context of tangles as the smallest possible tangle, which corresponds to the bottom element of the type index. The empty set does not itself contribute to the evenness of the code, hence the condition `β = ⊥` arises."}
{"full_name": "ConNF.Code.isOdd_empty_iff", "url": "ConNF/NewTangle/CodeEquiv.html#ConNF.Code.isOdd_empty_iff", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.Code.isOdd_empty_iff [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] {β : ConNF.TypeIndex} [ConNF.LtLevel🔗<|PREMISE|>🔗 β] [ConNF.TangleDataLt] [ConNF.TypedObjectsLt] [ConNF.PositionedTanglesLt] :ConNF.Code.IsOdd🔗<|PREMISE|>🔗 (ConNF.Code.mk🔗<|PREMISE|>🔗 β ∅ ) ↔ β ≠ ⊥", "code": "theorem isOdd_empty_iff : IsOdd (mk β ∅) ↔ (β : TypeIndex) ≠ ⊥ :=\n  IsEmpty.isOdd_iff rfl\n", "additional_info": "", "used_premises": [1, 98, 168, 104], "def_path": "ConNF/NewTangle/CodeEquiv.lean", "pos": [115, 117], "informalization": "In the context of Constructive Ordinal Notation (ConNF), a `ConNF.Code` is said to be `IsOdd` if it leads to some `ConNF.Code` that is `IsEven`. This property is defined inductively, stating that a code `c` is odd if there exists an even code `d` such that `d` leads to `c`. The theorem `ConNF.Code.isOdd_empty_iff` states that a `ConNF.Code.mk` with an empty set of tangles is `IsOdd` if and only if its type index `β` is not equal to `⊥`."}
{"full_name": "ConNF.Code.not_isOdd", "url": "ConNF/NewTangle/CodeEquiv.html#ConNF.Code.not_isOdd", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.Code.not_isOdd [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.TangleDataLt] [ConNF.TypedObjectsLt] [ConNF.PositionedTanglesLt] {c : ConNF.Code} :¬ ConNF.Code.IsOdd🔗<|PREMISE|>🔗 c ↔ ConNF.Code.IsEven🔗<|PREMISE|>🔗 c", "code": "theorem not_isOdd : ¬c.IsOdd ↔ c.IsEven := by\n  obtain hc | hc := c.members.eq_empty_or_nonempty\n  · rw [IsEmpty.isOdd_iff hc, IsEmpty.isEven_iff hc, Classical.not_not]\n  · exact not_isOdd_nonempty ⟨c, hc⟩\n", "additional_info": "A code is not odd iff it is even.", "used_premises": [1, 168, 165], "def_path": "ConNF/NewTangle/CodeEquiv.lean", "pos": [135, 139], "informalization": "A code in the context of Constructive Ordinal Notation (ConNF) is not odd if and only if it is even."}
{"full_name": "ConNF.Code.not_isEven", "url": "ConNF/NewTangle/CodeEquiv.html#ConNF.Code.not_isEven", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.Code.not_isEven [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.TangleDataLt] [ConNF.TypedObjectsLt] [ConNF.PositionedTanglesLt] {c : ConNF.Code} :¬ ConNF.Code.IsEven🔗<|PREMISE|>🔗 c ↔ ConNF.Code.IsOdd🔗<|PREMISE|>🔗 c", "code": "theorem not_isEven : ¬c.IsEven ↔ c.IsOdd :=\n  not_isOdd.symm.not_left\n", "additional_info": "A code is not even iff it is odd.", "used_premises": [1, 165, 168], "def_path": "ConNF/NewTangle/CodeEquiv.lean", "pos": [142, 144], "informalization": "A code in the context of Constructive Ordinal Notation (ConNF) is not even if and only if it is odd."}
{"full_name": "ConNF.Code.IsEven.not_isOdd", "url": "ConNF/NewTangle/CodeEquiv.html#ConNF.Code.IsEven.not_isOdd", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.Code.IsEven.not_isOdd [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.TangleDataLt] [ConNF.TypedObjectsLt] [ConNF.PositionedTanglesLt] {c : ConNF.Code} :ConNF.Code.IsEven🔗<|PREMISE|>🔗 c → ¬ ConNF.Code.IsOdd🔗<|PREMISE|>🔗 c", "code": "alias ⟨_, IsEven.not_isOdd⟩ := not_isOdd\n", "additional_info": "**Alias** of the reverse direction of `🗟ConNF.Code.not_isOdd🗟🔗../.././ConNF/NewTangle/CodeEquiv.html#ConNF.Code.not_isOdd🔗` .\n\nA code is not odd iff it is even.", "used_premises": [1, 165, 168], "def_path": "ConNF/NewTangle/CodeEquiv.lean", "pos": [145, 146], "informalization": "The theorem `ConNF.Code.IsEven.not_isOdd` is an alias of the reverse direction of `ConNF.Code.not_isOdd`. It states that if a code is even, then it is not odd."}
{"full_name": "ConNF.Code.IsOdd.not_isEven", "url": "ConNF/NewTangle/CodeEquiv.html#ConNF.Code.IsOdd.not_isEven", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.Code.IsOdd.not_isEven [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.TangleDataLt] [ConNF.TypedObjectsLt] [ConNF.PositionedTanglesLt] {c : ConNF.Code} :ConNF.Code.IsOdd🔗<|PREMISE|>🔗 c → ¬ ConNF.Code.IsEven🔗<|PREMISE|>🔗 c", "code": "alias ⟨_, IsOdd.not_isEven⟩ := not_isEven\n", "additional_info": "**Alias** of the reverse direction of `🗟ConNF.Code.not_isEven🗟🔗../.././ConNF/NewTangle/CodeEquiv.html#ConNF.Code.not_isEven🔗` .\n\nA code is not even iff it is odd.", "used_premises": [1, 168, 165], "def_path": "ConNF/NewTangle/CodeEquiv.lean", "pos": [147, 148], "informalization": "In the context of Constructive Ordinal Notation (ConNF), a `ConNF.Code` is said to be `IsOdd` if it leads to some `ConNF.Code` that is `IsEven`. This property is defined inductively, stating that a code `c` is odd if there exists an even code `d` such that `d` leads to `c`. A code is not even iff it is odd."}
{"full_name": "ConNF.Code.isEven_or_isOdd", "url": "ConNF/NewTangle/CodeEquiv.html#ConNF.Code.isEven_or_isOdd", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.Code.isEven_or_isOdd [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.TangleDataLt] [ConNF.TypedObjectsLt] [ConNF.PositionedTanglesLt] (c : ConNF.Code) :ConNF.Code.IsEven🔗<|PREMISE|>🔗 c ∨ ConNF.Code.IsOdd🔗<|PREMISE|>🔗 c", "code": "theorem isEven_or_isOdd (c : Code) : c.IsEven ∨ c.IsOdd := by\n  rw [← not_isEven]\n  exact em _\n", "additional_info": "Any code is even or odd.", "used_premises": [1, 165, 168], "def_path": "ConNF/NewTangle/CodeEquiv.lean", "pos": [150, 153], "informalization": "In the context of Constructive Ordinal Notation (ConNF), any code can be classified as either even or odd. This theorem, `ConNF.Code.isEven_or_isOdd`, asserts that for any given `ConNF.Code`, it either satisfies the property of being even or odd, according to the inductive definition provided in the `ConNF.Code.IsEven` and `ConNF.Code.IsOdd` types. This categorization is crucial for understanding the structure of the natural numbers and their representation in the ConNF system."}
{"full_name": "ConNF.CloudRel.isOdd", "url": "ConNF/NewTangle/CodeEquiv.html#ConNF.CloudRel.isOdd", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.CloudRel.isOdd [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.TangleDataLt] [ConNF.TypedObjectsLt] [ConNF.PositionedTanglesLt] {c : ConNF.Code} {d : ConNF.Code} (hc : ConNF.Code.IsEven🔗<|PREMISE|>🔗 c) (h : c ↝₀ d) :ConNF.Code.IsOdd🔗<|PREMISE|>🔗 d", "code": "protected theorem ConNF.CloudRel.isOdd (hc : c.IsEven) (h : c ↝₀ d) : d.IsOdd :=\n  (isOdd_iff d).2 ⟨_, h, hc⟩\n", "additional_info": "", "used_premises": [1, 165, 168], "def_path": "ConNF/NewTangle/CodeEquiv.lean", "pos": [154, 156], "informalization": "In the context of Constructive Ordinal Notation (ConNF), if `c` is an even code and `c` leads to `d`, then `d` is an odd code."}
{"full_name": "ConNF.Code.IsEven.cloudCode", "url": "ConNF/NewTangle/CodeEquiv.html#ConNF.Code.IsEven.cloudCode", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.Code.IsEven.cloudCode [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] {γ : ConNF.Λ} [ConNF.LtLevel🔗<|PREMISE|>🔗 ↑γ] [ConNF.TangleDataLt] [ConNF.TypedObjectsLt] [ConNF.PositionedTanglesLt] {c : ConNF.Code} (hc : ConNF.Code.IsEven🔗<|PREMISE|>🔗 c) (hcγ : c.β ≠ ↑γ) :ConNF.Code.IsOdd🔗<|PREMISE|>🔗 (ConNF.cloudCode🔗<|PREMISE|>🔗 γ c)", "code": "protected theorem IsEven.cloudCode (hc : c.IsEven) (hcγ : c.1 ≠ γ) : (cloudCode γ c).IsOdd :=\n  (CloudRel.intro _ hcγ).isOdd hc\n", "additional_info": "", "used_premises": [1, 98, 165, 168, 101], "def_path": "ConNF/NewTangle/CodeEquiv.lean", "pos": [157, 159], "informalization": "The theorem `ConNF.Code.IsEven.cloudCode` is a theorem in the Lean proof assistant that is used in the context of Constructive Ordinal Notation (ConNF). It states that given a code `c` which is even and a type index `γ`, if `c`'s level does not match `γ`, then the code `ConNF.cloudCode γ c` is odd. This theorem is proved by leveraging the definitions and properties of ConNF, such as the `ConNF.Code.IsEven` and `ConNF.Code.IsOdd` classes, and the `ConNF.cloudCode` function, which is defined to adjust the first component of a `ConNF.Code` object to match a given type index."}
{"full_name": "ConNF.Code.IsOdd.cloudCode", "url": "ConNF/NewTangle/CodeEquiv.html#ConNF.Code.IsOdd.cloudCode", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.Code.IsOdd.cloudCode [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] {γ : ConNF.Λ} [ConNF.LtLevel🔗<|PREMISE|>🔗 ↑γ] [ConNF.TangleDataLt] [ConNF.TypedObjectsLt] [ConNF.PositionedTanglesLt] {c : ConNF.Code} (hc : ConNF.Code.IsOdd🔗<|PREMISE|>🔗 c) (hc' : Set.Nonempty🔗<|PREMISE|>🔗 c.members) (hcγ : c.β ≠ ↑γ) :ConNF.Code.IsEven🔗<|PREMISE|>🔗 (ConNF.cloudCode🔗<|PREMISE|>🔗 γ c)", "code": "protected theorem IsOdd.cloudCode (hc : c.IsOdd) (hc' : c.members.Nonempty) (hcγ : c.1 ≠ γ) :\n    (cloudCode γ c).IsEven :=\n  (isEven_iff _).2 fun d hd => by rwa [(cloudRel_cloudCode _ hc' hcγ).1 hd]\n", "additional_info": "", "used_premises": [1, 98, 168, 83, 165, 101], "def_path": "ConNF/NewTangle/CodeEquiv.lean", "pos": [160, 163], "informalization": "The given Lean 4 object is a theorem named `ConNF.Code.IsOdd.cloudCode`, which is a function defined in the context of Constructive Ordinal Notation (ConNF). This function takes a type index `β` and a `ConNF.Code` object `c`, and returns a new `ConNF.Code` object. The theorem states that if `c` is an odd `ConNF.Code` object with a nonempty set of members and `c.β` is not equal to `γ`, then the `ConNF.Code` returned by `ConNF.cloudCode γ c` is even."}
{"full_name": "ConNF.Code.IsEven.cloudCode_ne", "url": "ConNF/NewTangle/CodeEquiv.html#ConNF.Code.IsEven.cloudCode_ne", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.Code.IsEven.cloudCode_ne [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] {γ : ConNF.Λ} [ConNF.LtLevel🔗<|PREMISE|>🔗 ↑γ] [ConNF.TangleDataLt] [ConNF.TypedObjectsLt] [ConNF.PositionedTanglesLt] {c : ConNF.Code} {d : ConNF.Code} (hc : ConNF.Code.IsEven🔗<|PREMISE|>🔗 c) (hd : ConNF.Code.IsEven🔗<|PREMISE|>🔗 d) (hcγ : c.β ≠ ↑γ) :ConNF.cloudCode🔗<|PREMISE|>🔗 γ c ≠ d", "code": "protected theorem IsEven.cloudCode_ne (hc : c.IsEven) (hd : d.IsEven) (hcγ : c.1 ≠ γ) :\n    cloudCode γ c ≠ d := by rintro rfl; exact hd.not_isOdd (hc.cloudCode hcγ)\n", "additional_info": "", "used_premises": [1, 98, 165, 165, 101], "def_path": "ConNF/NewTangle/CodeEquiv.lean", "pos": [164, 166], "informalization": "Given a type index `γ` and two even codes `c` and `d`, the theorem states that if the level of code `c` does not match `γ`, then `ConNF.cloudCode γ c` (which returns a new code where the `β` component is defeq to `γ`, while leaving the other components unchanged) is not equal to `d`. The `ConNF.Code.IsEven` typeclass ensures that `c` and `d` only lead to odd codes. The `ConNF.Params`, `ConNF.Level`, `ConNF.TangleDataLt`, `ConNF.TypedObjectsLt`, and `ConNF.PositionedTanglesLt` classes provide the necessary type-level and order-theoretic relationships required for the proof."}
{"full_name": "ConNF.Code.cloudCode_ne_bot", "url": "ConNF/NewTangle/CodeEquiv.html#ConNF.Code.cloudCode_ne_bot", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.Code.cloudCode_ne_bot [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] {γ : ConNF.Λ} [ConNF.LtLevel🔗<|PREMISE|>🔗 ↑γ] [ConNF.TangleDataLt] [ConNF.TypedObjectsLt] [ConNF.PositionedTanglesLt] {c : ConNF.Code} {s : Set🔗<|PREMISE|>🔗 (ConNF.Tangle ⊥ )} :ConNF.cloudCode🔗<|PREMISE|>🔗 γ c ≠ ConNF.Code.mk🔗<|PREMISE|>🔗 ⊥ s", "code": "theorem cloudCode_ne_bot {s} : cloudCode γ c ≠ mk ⊥ s :=\n  ne_of_apply_ne Code.β coe_ne_bot\n", "additional_info": "", "used_premises": [1, 98, 69, 101, 104], "def_path": "ConNF/NewTangle/CodeEquiv.lean", "pos": [167, 169], "informalization": "The theorem `ConNF.Code.cloudCode_ne_bot` asserts that given a type level index γ less than the current level α, and a Code object c, the operation `ConNF.cloudCode γ c` does not result in a Code object that is equal to `ConNF.Code.mk ⊥ s`, where `s` is a set of tangles at level ⊥. The conclusion is that the operation `ConNF.cloudCode γ c` yields a distinct Code object, which has a level of γ, and its tangles are not all at the lowest level ⊥."}
{"full_name": "ConNF.Code.cloudCode_ne_singleton", "url": "ConNF/NewTangle/CodeEquiv.html#ConNF.Code.cloudCode_ne_singleton", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.Code.cloudCode_ne_singleton [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] {β : ConNF.TypeIndex} [ConNF.LtLevel🔗<|PREMISE|>🔗 β] {γ : ConNF.Λ} [ConNF.LtLevel🔗<|PREMISE|>🔗 ↑γ] [ConNF.TangleDataLt] [ConNF.TypedObjectsLt] [ConNF.PositionedTanglesLt] {c : ConNF.Code} {t : ConNF.Tangle β} (hcβ : c.β ≠ β) :ConNF.cloudCode🔗<|PREMISE|>🔗 γ c ≠ ConNF.Code.mk🔗<|PREMISE|>🔗 β {t}", "code": "theorem cloudCode_ne_singleton {t} (hcβ : c.1 ≠ β) : cloudCode γ c ≠ mk β {t} := by\n  intro h\n  rw [cloudCode, Code.ext_iff] at h\n  simp only [ne_eq] at h\n  obtain ⟨rfl, h⟩ := h\n  refine' (Cardinal.one_lt_aleph0.trans_le\n    (Params.κ_isRegular.aleph0_le.trans Params.κ_lt_μ.le)).not_le _\n  rw [← Cardinal.mk_singleton t, ← h.eq]\n  refine' μ_le_mk_cloudCode c hcβ ((cloudCode_nonempty (β := γ)).1 _)\n  rw [cloudCode, eq_of_heq h]\n  simp only [singleton_nonempty]\n", "additional_info": "The cloud map cannot produce a singleton code.", "used_premises": [1, 98, 98, 101, 104], "def_path": "ConNF/NewTangle/CodeEquiv.lean", "pos": [171, 182], "informalization": "In the context of Constructive Ordinal Notation (ConNF), the `ConNF.Code.cloudCode` function takes a type index `β` and a `ConNF.Code` object `c`, and returns a new `ConNF.Code` object. If the level of `c` matches `β`, then `ConNF.cloudCode` is the identity function. This function is defined in such a way that the first component of the returned `ConNF.Code` object is defeq to `β`. The theorem `ConNF.Code.cloudCode_ne_singleton` states that if `c.β` is not equal to `β`, then `ConNF.cloudCode γ c` cannot be a singleton code."}
{"full_name": "ConNF.Code.isEven_singleton", "url": "ConNF/NewTangle/CodeEquiv.html#ConNF.Code.isEven_singleton", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.Code.isEven_singleton [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] {β : ConNF.TypeIndex} [ConNF.LtLevel🔗<|PREMISE|>🔗 β] [ConNF.TangleDataLt] [ConNF.TypedObjectsLt] [ConNF.PositionedTanglesLt] (t : ConNF.Tangle β) :ConNF.Code.IsEven🔗<|PREMISE|>🔗 (ConNF.Code.mk🔗<|PREMISE|>🔗 β {t})", "code": "theorem isEven_singleton (t) : (mk β {t}).IsEven := by\n  refine' isEven_of_forall_not fun c hc => _\n  obtain ⟨γ, _, h⟩ := (cloudRel_iff _ _).1 hc\n  have := congr_arg Code.β h.2\n  cases this\n  exact cloudCode_ne_singleton h.1 h.2.symm\n", "additional_info": "Singleton codes are even.", "used_premises": [1, 98, 165, 104], "def_path": "ConNF/NewTangle/CodeEquiv.lean", "pos": [185, 191], "informalization": "In the context of Constructive Ordinal Notation (ConNF), a code is considered even if it only leads to odd codes. This theorem states that a singleton code, which consists of a single tangle, is an even code."}
{"full_name": "ConNF.Code.Equiv.rfl", "url": "ConNF/NewTangle/CodeEquiv.html#ConNF.Code.Equiv.rfl", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.Code.Equiv.rfl [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.TangleDataLt] [ConNF.TypedObjectsLt] [ConNF.PositionedTanglesLt] {c : ConNF.Code} :c ≡ c", "code": "protected theorem rfl : c ≡ c :=\n  refl _\n", "additional_info": "", "used_premises": [1], "def_path": "ConNF/NewTangle/CodeEquiv.lean", "pos": [214, 216], "informalization": "`ConNF.Code.Equiv.rfl` is a reflexivity theorem in the context of Constructive Ordinal Notation (ConNF) in Lean 4. It states that for any `ConNF.Code` object `c`, `c` is equivalent to itself (`c ≡ c`)."}
{"full_name": "ConNF.Code.Equiv.of_eq", "url": "ConNF/NewTangle/CodeEquiv.html#ConNF.Code.Equiv.of_eq", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.Code.Equiv.of_eq [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.TangleDataLt] [ConNF.TypedObjectsLt] [ConNF.PositionedTanglesLt] {c : ConNF.Code} {d : ConNF.Code} :c = d → c ≡ d", "code": "theorem of_eq : c = d → c ≡ d := by rintro rfl; rfl\n", "additional_info": "", "used_premises": [1], "def_path": "ConNF/NewTangle/CodeEquiv.lean", "pos": [217, 218], "informalization": "Function `ConNF.Code.Equiv.of_eq` is a theorem in the Constructive Ordinal Notation (ConNF) library in Lean 4. It states that if two ConNF codes `c` and `d` are equal, then they are equivalent, denoted as `c ≡ d`."}
{"full_name": "ConNF.Code.Equiv.symm", "url": "ConNF/NewTangle/CodeEquiv.html#ConNF.Code.Equiv.symm", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.Code.Equiv.symm [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.TangleDataLt] [ConNF.TypedObjectsLt] [ConNF.PositionedTanglesLt] :Symmetric🔗<|PREMISE|>🔗 fun (x x_1 : ConNF.Code) => x ≡ x_1", "code": "theorem symm : Symmetric ((· ≡ ·) : Code → Code → Prop)\n  | _, _, refl _ => refl _\n  | _, _, cloud_left c β hc hcβ => cloud_right c β hc hcβ\n  | _, _, cloud_right c β hc hcβ => cloud_left c β hc hcβ\n  | _, _, cloud_cloud c hc β hcβ γ hcγ => cloud_cloud c hc γ hcγ β hcβ\n", "additional_info": "", "used_premises": [1, 196], "def_path": "ConNF/NewTangle/CodeEquiv.lean", "pos": [219, 224], "informalization": "Function `Symmetric` checks if a given binary relation `r` on a type `β` is symmetric, meaning if `r x y` holds, then `r y x` must also hold. The theorem `ConNF.Code.Equiv.symm` states that the equivalence relation `≡` on `ConNF.Code` is symmetric."}
{"full_name": "Symmetric", "url": "Mathlib/Init/Logic.html#Symmetric", "code_src": "mathlib4", "ptype": "def", "header": "def Symmetric {β : Sort v} (r : β → β → Prop ) :Prop", "code": "def Symmetric := ∀ ⦃x y⦄, x ≺ y → y ≺ x\n", "additional_info": "A relation is symmetric if `x ≺ y` implies `y ≺ x`.\nEquations\n* 🗟Symmetric🗟🔗../.././Mathlib/Init/Logic.html#Symmetric🔗  r 🗟=🗟🔗../.././Init/Prelude.html#Eq🔗  ∀ ⦃x y : β⦄, r x y → r y x\n\n", "used_premises": [], "def_path": "Mathlib/Init/Logic.lean", "pos": [462, 463], "informalization": "Function `Symmetric` is a predicate that checks if a given binary relation `r` on a type `β` is symmetric, meaning if `r x y` holds, then `r y x` must also hold."}
{"full_name": "ConNF.Code.Equiv.empty_empty", "url": "ConNF/NewTangle/CodeEquiv.html#ConNF.Code.Equiv.empty_empty", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.Code.Equiv.empty_empty [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.TangleDataLt] [ConNF.TypedObjectsLt] [ConNF.PositionedTanglesLt] (β : ConNF.TypeIndex) (γ : ConNF.TypeIndex) [ConNF.LtLevel🔗<|PREMISE|>🔗 β] [ConNF.LtLevel🔗<|PREMISE|>🔗 γ] :ConNF.Code.mk🔗<|PREMISE|>🔗 β ∅ ≡ ConNF.Code.mk🔗<|PREMISE|>🔗 γ ∅", "code": "theorem empty_empty : ∀ (β γ : TypeIndex), [LtLevel β] → [LtLevel γ] → (⟨β, ∅⟩ : Code) ≡ ⟨γ, ∅⟩\n  | ⊥, ⊥, _, _ => Equiv.rfl\n  | ⊥, (γ : Λ), _, hγ => by\n    convert cloud_right _ (isEven_bot _) γ bot_ne_coe\n    simp only [ne_eq, bot_ne_coe, not_false_eq_true, snd_cloudCode, cloud_empty]\n  | (β : Λ), ⊥, hβ, _ => by\n    convert cloud_left _ (isEven_bot _) β bot_ne_coe\n    simp only [ne_eq, bot_ne_coe, not_false_eq_true, snd_cloudCode, cloud_empty]\n  | (β : Λ), (γ : Λ), hβ, hγ => by\n    convert cloud_cloud _ (isEven_bot ∅) β bot_ne_coe γ bot_ne_coe <;>\n    · simp only [ne_eq, bot_ne_coe, not_false_eq_true, snd_cloudCode]\n      rw [cloud_empty]\n", "additional_info": "All empty codes are equivalent.", "used_premises": [1, 98, 98, 104, 104], "def_path": "ConNF/NewTangle/CodeEquiv.lean", "pos": [229, 241], "informalization": "All empty codes are equivalent in the context of Constructive Ordinal Notation (ConNF)."}
{"full_name": "ConNF.Code.IsEmpty.equiv", "url": "ConNF/NewTangle/CodeEquiv.html#ConNF.Code.IsEmpty.equiv", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.Code.IsEmpty.equiv [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.TangleDataLt] [ConNF.TypedObjectsLt] [ConNF.PositionedTanglesLt] {c : ConNF.Code} {d : ConNF.Code} (hc : ConNF.Code.IsEmpty🔗<|PREMISE|>🔗 c) (hd : ConNF.Code.IsEmpty🔗<|PREMISE|>🔗 d) :c ≡ d", "code": "protected theorem ConNF.Code.IsEmpty.equiv (hc : c.IsEmpty) (hd : d.IsEmpty) : c ≡ d := by\n  obtain ⟨γ, c⟩ := c\n  obtain ⟨δ, d⟩ := d\n  change c = ∅ at hc\n  change d = ∅ at hd\n  subst hc\n  subst hd\n  exact empty_empty _ _\n", "additional_info": "", "used_premises": [1, 107, 107], "def_path": "ConNF/NewTangle/CodeEquiv.lean", "pos": [242, 250], "informalization": "Function `ConNF.Code.IsEmpty.equiv` proves that if two `ConNF.Code` objects `c` and `d` are both empty (`ConNF.Code.IsEmpty c` and `ConNF.Code.IsEmpty d`), then they are equivalent (`c ≡ d`)."}
{"full_name": "ConNF.Code.Equiv.equiv_equivalence", "url": "ConNF/NewTangle/CodeEquiv.html#ConNF.Code.Equiv.equiv_equivalence", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.Code.Equiv.equiv_equivalence [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.TangleDataLt] [ConNF.TypedObjectsLt] [ConNF.PositionedTanglesLt] :Equivalence🔗<|PREMISE|>🔗 fun (x x_1 : ConNF.Code) => x ≡ x_1", "code": "theorem equiv_equivalence : Equivalence ((· ≡ ·) : Code → Code → Prop) :=\n  ⟨refl, fun {_ _} h => symm h, fun {_ _ _} h₁ h₂ => trans h₁ h₂⟩\n", "additional_info": "Code equivalence is an equivalence relation.", "used_premises": [1, 200], "def_path": "ConNF/NewTangle/CodeEquiv.lean", "pos": [289, 291], "informalization": "The theorem `ConNF.Code.Equiv.equiv_equivalence` states that the equivalence relation `≡` on `ConNF.Code` is indeed an equivalence relation, meaning it is reflexive, symmetric, and transitive."}
{"full_name": "Equivalence", "url": "Init/Core.html#Equivalence", "code_src": "lean4", "ptype": "structure", "header": "structure Equivalence {α : Sort u} (r : α → α → Prop ) :Prop\n | refl : ∀ (x : α), r x x\n | symm : ∀ {x y : α}, r x y → r y x\n | trans : ∀ {x y z : α}, r x y → r y z → r x z", "code": "structure Equivalence {α : Sort u} (r : α → α → Prop) : Prop where\n  /-- An equivalence relation is reflexive: `x ~ x` -/\n  refl  : ∀ x, r x x\n  /-- An equivalence relation is symmetric: `x ~ y` implies `y ~ x` -/\n  symm  : ∀ {x y}, r x y → r y x\n  /-- An equivalence relation is transitive: `x ~ y` and `y ~ z` implies `x ~ z` -/\n  trans : ∀ {x y z}, r x y → r y z → r x z\n", "additional_info": "An equivalence relation `~ : α → α → Prop` is a relation that is:\n* reflexive: `x ~ x`\n* symmetric: `x ~ y` implies `y ~ x`\n* transitive: `x ~ y` and `y ~ z` implies `x ~ z`\n\nEquality is an equivalence relation, and equivalence relations share many of\nthe properties of equality. In particular, `🗟Quot🗟🔗.././Init/Prelude.html#Quot🔗  α 🗟r🗟🔗.././Init/Core.html#Setoid.r🔗`  is most well behaved\nwhen `🗟r🗟🔗.././Init/Core.html#Setoid.r🔗`  is an equivalence relation, and in this case we use `🗟Quotient🗟🔗.././Init/Core.html#Quotient🔗`  instead.\n- Equivalence.refl: An equivalence relation is reflexive: `x ~ x`\n\n\n- Equivalence.symm: An equivalence relation is symmetric: `x ~ y` implies `y ~ x`\n\n\n- Equivalence.trans: An equivalence relation is transitive: `x ~ y` and `y ~ z` implies `x ~ z`\n\n\n", "used_premises": [], "def_path": "Init/Core.lean", "pos": [1059, 1066], "informalization": "An equivalence relation `~ : α → α → Prop` is a relation that is reflexive (`x ~ x`), symmetric (`x ~ y` implies `y ~ x`), and transitive (`x ~ y` and `y ~ z` implies `x ~ z`). Equality is an equivalence relation, and equivalence relations share many of the properties of equality. In particular, `Quot  α r` is most well behaved when `r` is an equivalence relation, and in this case we use `Quotient` instead."}
{"full_name": "ConNF.Code.extension_eq_of_singleton_equiv_singleton", "url": "ConNF/NewTangle/CodeEquiv.html#ConNF.Code.extension_eq_of_singleton_equiv_singleton", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.Code.extension_eq_of_singleton_equiv_singleton [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] {β : ConNF.TypeIndex} [ConNF.LtLevel🔗<|PREMISE|>🔗 β] [ConNF.TangleDataLt] [ConNF.TypedObjectsLt] [ConNF.PositionedTanglesLt] {γ : ConNF.TypeIndex} [ConNF.LtLevel🔗<|PREMISE|>🔗 γ] {a : ConNF.Tangle β} {b : ConNF.Tangle γ} (h : ConNF.Code.mk🔗<|PREMISE|>🔗 β {a} ≡ ConNF.Code.mk🔗<|PREMISE|>🔗 γ {b}) :β = γ", "code": "theorem extension_eq_of_singleton_equiv_singleton {γ : TypeIndex} [LtLevel γ]\n    {a : Tangle β} {b : Tangle γ}\n    (h : (⟨β, {a}⟩ : Code) ≡ ⟨γ, {b}⟩) : β = γ := by\n  obtain h | ⟨ε, _, hc, hβε, hA⟩ := Equiv.singleton_iff.1 h\n  · exact ((Code.ext_iff _ _).1 h).1\n  · exfalso\n    refine cloudCode_ne_singleton ?_ hA.symm\n    cases congr_arg Code.β hA\n    exact hβε\n", "additional_info": "", "used_premises": [1, 98, 98, 104, 104], "def_path": "ConNF/NewTangle/CodeEquiv.lean", "pos": [361, 370], "informalization": "The theorem states that given two codes `a` and `b` of type indices `β` and `γ` respectively, where `a` is a singleton set and `b` is also a singleton set, and these codes are equivalent under the equivalence relation defined by the `ConNF.Params` class, then the types `β` and `γ` must be equal. This is a key property that underpins the use of ConNF in the context of Constructive Ordinal Notation."}
{"full_name": "ConNF.Code.equiv_bot_subsingleton", "url": "ConNF/NewTangle/CodeEquiv.html#ConNF.Code.equiv_bot_subsingleton", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.Code.equiv_bot_subsingleton [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.TangleDataLt] [ConNF.TypedObjectsLt] [ConNF.PositionedTanglesLt] {c : ConNF.Code} (d : ConNF.Code) (e : ConNF.Code) (hdc : d ≡ c) (hec : e ≡ c) (hd : d.β = ⊥ ) (he : e.β = ⊥ ) :d = e", "code": "theorem equiv_bot_subsingleton (d e : Code)\n    (hdc : d ≡ c) (hec : e ≡ c) (hd : d.1 = ⊥) (he : e.1 = ⊥) : d = e :=\n  (hdc.trans hec.symm).unique (hd.trans he.symm)\n", "additional_info": "", "used_premises": [1], "def_path": "ConNF/NewTangle/CodeEquiv.lean", "pos": [406, 409], "informalization": "The theorem `ConNF.Code.equiv_bot_subsingleton` states that if two ConNF codes `d` and `e` are equivalent to the same code `c`, and both `d.β` and `e.β` are equal to `⊥`, then `d` must be equal to `e`."}
{"full_name": "ConNF.Extensions.ext", "url": "ConNF/NewTangle/NewTangle.html#ConNF.Extensions.ext", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.Extensions.ext [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.TangleDataLt] {e₁ : ConNF.Extensions} {e₂ : ConNF.Extensions} (h : ∀ (β : ConNF.Λ) [inst : ConNF.LtLevel🔗<|PREMISE|>🔗 ↑β], e₁ β = e₂ β) :e₁ = e₂", "code": "theorem Extensions.ext {e₁ e₂ : Extensions} (h : ∀ β : Λ, [LtLevel β] → e₁ β = e₂ β) : e₁ = e₂ :=\n  funext (fun β => funext (fun _ => h β))\n", "additional_info": "", "used_premises": [1, 98], "def_path": "ConNF/NewTangle/NewTangle.lean", "pos": [39, 41], "informalization": "The `ConNF.Extensions.ext` theorem in Lean 4 is a proof that two `ConNF.Extensions` objects are equal if and only if their values are equal for all types `β` that are less than the current level `α` in the context of Constructive Ordinal Notation (ConNF)."}
{"full_name": "ConNF.Semitangle.Preference.base_heq_base", "url": "ConNF/NewTangle/NewTangle.html#ConNF.Semitangle.Preference.base_heq_base", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.Semitangle.Preference.base_heq_base [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.TangleDataLt] [ConNF.PositionedTanglesLt] [ConNF.TypedObjectsLt] {m₁ : ConNF.Extensions} {m₂ : ConNF.Extensions} {s₁ : Set🔗<|PREMISE|>🔗 (ConNF.Tangle ⊥ )} {s₂ : Set🔗<|PREMISE|>🔗 (ConNF.Tangle ⊥ )} {h₁ : ∀ (γ : ConNF.Λ) [inst : ConNF.LtLevel🔗<|PREMISE|>🔗 ↑γ], ConNF.cloud🔗<|PREMISE|>🔗 ⋯ s₁ = m₁ γ} {h₂ : ∀ (γ : ConNF.Λ) [inst : ConNF.LtLevel🔗<|PREMISE|>🔗 ↑γ], ConNF.cloud🔗<|PREMISE|>🔗 ⋯ s₂ = m₂ γ} (hm : m₁ = m₂) (hs : s₁ = s₂) :HEq🔗<|PREMISE|>🔗 (ConNF.Semitangle.Preference.base🔗<|PREMISE|>🔗 s₁ h₁) (ConNF.Semitangle.Preference.base🔗<|PREMISE|>🔗 s₂ h₂)", "code": "theorem Preference.base_heq_base {m₁ m₂ : Extensions} {s₁ s₂ h₁ h₂} (hm : m₁ = m₂)\n    (hs : s₁ = s₂) :\n    HEq (Preference.base s₁ h₁ : Preference m₁) (Preference.base s₂ h₂ : Preference m₂) := by\n  cases hm\n  cases hs\n  rfl\n", "additional_info": "", "used_premises": [1, 69, 69, 98, 77, 98, 77, 126, 205, 205], "def_path": "ConNF/NewTangle/NewTangle.lean", "pos": [64, 70], "informalization": "This theorem states that the Base preference constructor for semitangles is equality-preserving with respect to the set of tangles and the extension function. This means that if two Base preference constructors have the same set of tangles and the same extension function, they are considered equal."}
{"full_name": "ConNF.Semitangle.Preference.base", "url": "ConNF/NewTangle/NewTangle.html#ConNF.Semitangle.Preference", "code_src": "con-nf", "ptype": "constructor", "header": "constructor ConNF.Semitangle.Preference🔗<|PREMISE|>🔗.base: [inst : ConNF.Params🔗<|PREMISE|>🔗 ] →\n [inst_1 : ConNF.Level] →\n [inst_2 : ConNF.TangleDataLt] →\n [inst_3 : ConNF.PositionedTanglesLt] →\n [inst_4 : ConNF.TypedObjectsLt] →\n {members : ConNF.Extensions} →\n (atoms : Set🔗<|PREMISE|>🔗  (ConNF.Tangle  ⊥ )) →\n (∀ (γ : ConNF.Λ) [inst_5 : ConNF.LtLevel🔗<|PREMISE|>🔗  ↑γ], ConNF.cloud🔗<|PREMISE|>🔗  ⋯ atoms =  members γ) →\n ConNF.Semitangle.Preference🔗<|PREMISE|>🔗  members", "code": "inductive Preference (members : Extensions)\n  | base (atoms : Set (Tangle ⊥)) :\n    (∀ (γ : Λ), [LtLevel γ] → cloud bot_ne_coe atoms = members γ) → Preference members\n  | proper (β : Λ) [LtLevel β] :\n    (mk β (members β) : Code).IsEven →\n    (∀ (γ : Λ) [LtLevel γ] (hβγ : (β : TypeIndex) ≠ γ), cloud hβγ (members β) = members γ) →\n    Preference members\n", "additional_info": "", "used_premises": [206, 1, 69, 98, 77, 206], "def_path": "ConNF/NewTangle/NewTangle.lean", "pos": [49, 56], "informalization": "Function `ConNF.Semitangle.Preference.base` is a constructor for the type `ConNF.Semitangle.Preference`, which represents the preferred extension of a semitangle, along with coherence conditions relating each extension of the semitangle. Each non-preferred extension can be obtained by applying the `ConNF.cloud` map to the preferred extension. This constructor is used to define the base case of the preference, where the preferred extension is directly given by the `ConNF.cloud` map applied to a set of tangles."}
{"full_name": "ConNF.Semitangle.Preference", "url": "ConNF/NewTangle/NewTangle.html#ConNF.Semitangle.Preference", "code_src": "con-nf", "ptype": "inductive", "header": "inductive ConNF.Semitangle.Preference [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.TangleDataLt] [ConNF.PositionedTanglesLt] [ConNF.TypedObjectsLt] (members : ConNF.Extensions) :Type u", "code": "inductive Preference (members : Extensions)\n  | base (atoms : Set (Tangle ⊥)) :\n    (∀ (γ : Λ), [LtLevel γ] → cloud bot_ne_coe atoms = members γ) → Preference members\n  | proper (β : Λ) [LtLevel β] :\n    (mk β (members β) : Code).IsEven →\n    (∀ (γ : Λ) [LtLevel γ] (hβγ : (β : TypeIndex) ≠ γ), cloud hβγ (members β) = members γ) →\n    Preference members\n", "additional_info": "Keeps track of the preferred extension of a semitangle, along with coherence conditions\nrelating each extension of the semitangle. In particular, each non-preferred extension can be\nobtained by applying the `cloud` map to the preferred extension.\n", "used_premises": [1], "def_path": "ConNF/NewTangle/NewTangle.lean", "pos": [49, 56], "informalization": "Type `Preference` represents the preferred extension of a semitangle, along with coherence conditions relating each extension of the semitangle. Each non-preferred extension can be obtained by applying the `cloud` map to the preferred extension."}
{"full_name": "ConNF.Semitangle.reprCode_base", "url": "ConNF/NewTangle/NewTangle.html#ConNF.Semitangle.reprCode_base", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.Semitangle.reprCode_base [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.TangleDataLt] [ConNF.PositionedTanglesLt] [ConNF.TypedObjectsLt] (exts : ConNF.Extensions) (atoms : Set🔗<|PREMISE|>🔗 (ConNF.Tangle ⊥ )) (hA : ∀ (γ : ConNF.Λ) [inst : ConNF.LtLevel🔗<|PREMISE|>🔗 ↑γ], ConNF.cloud🔗<|PREMISE|>🔗 ⋯ atoms = exts γ) :ConNF.Semitangle.reprCode🔗<|PREMISE|>🔗 { members := exts, pref := ConNF.Semitangle.Preference.base🔗<|PREMISE|>🔗 atoms hA } = ConNF.Code.mk🔗<|PREMISE|>🔗 ⊥ atoms", "code": "theorem reprCode_base (exts : Extensions) (atoms hA) :\n    reprCode ⟨exts, Preference.base atoms hA⟩ = ⟨⊥, atoms⟩ :=\n  rfl\n", "additional_info": "", "used_premises": [1, 69, 98, 77, 208, 205, 104], "def_path": "ConNF/NewTangle/NewTangle.lean", "pos": [99, 102], "informalization": "In the context of Constructive Ordinal Notation (ConNF), the function `ConNF.Semitangle.reprCode` computes the even code associated to a semitangle. The theorem `ConNF.Semitangle.reprCode_base` provides a base case for this computation, where the preferred extension of the semitangle is directly given by the `ConNF.cloud` map applied to a set of tangles."}
{"full_name": "ConNF.Semitangle.reprCode", "url": "ConNF/NewTangle/NewTangle.html#ConNF.Semitangle.reprCode", "code_src": "con-nf", "ptype": "def", "header": "def ConNF.Semitangle.reprCode [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.TangleDataLt] [ConNF.PositionedTanglesLt] [ConNF.TypedObjectsLt] :ConNF.Semitangle → ConNF.Code", "code": "def reprCode : Semitangle → Code\n  | ⟨_, Preference.base atoms _⟩ => ⟨⊥, atoms⟩\n  | ⟨exts, Preference.proper β _ _⟩ => ⟨β, exts β⟩\n", "additional_info": "The even code associated to a semitangle.\nEquations\n* One or more equations did not get rendered due to their size.\n\n", "used_premises": [1], "def_path": "ConNF/NewTangle/NewTangle.lean", "pos": [94, 97], "informalization": "Function `ConNF.Semitangle.reprCode` computes the even code associated to a semitangle in the context of Constructive Ordinal Notation (ConNF)."}
{"full_name": "ConNF.Semitangle.reprCodeSpec", "url": "ConNF/NewTangle/NewTangle.html#ConNF.Semitangle.reprCodeSpec", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.Semitangle.reprCodeSpec [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.TangleDataLt] [ConNF.PositionedTanglesLt] [ConNF.TypedObjectsLt] (t : ConNF.Semitangle) :ConNF.Code.IsEven🔗<|PREMISE|>🔗 (ConNF.Semitangle.reprCode🔗<|PREMISE|>🔗 t)", "code": "theorem reprCodeSpec : ∀ t : Semitangle, (reprCode t : Code).IsEven\n  | ⟨_, Preference.proper _ rep _⟩ => rep\n  | ⟨_, Preference.base _ _⟩ => isEven_bot _\n", "additional_info": "", "used_premises": [1, 165, 208], "def_path": "ConNF/NewTangle/NewTangle.lean", "pos": [108, 111], "informalization": "The theorem `ConNF.Semitangle.reprCodeSpec` states that the even code associated to a semitangle in the context of Constructive Ordinal Notation (ConNF) is indeed even."}
{"full_name": "ConNF.Semitangle.reprCode_members_ne", "url": "ConNF/NewTangle/NewTangle.html#ConNF.Semitangle.reprCode_members_ne", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.Semitangle.reprCode_members_ne [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.TangleDataLt] [ConNF.PositionedTanglesLt] [ConNF.TypedObjectsLt] (t : ConNF.Semitangle) (γ : ConNF.Λ) [ConNF.LtLevel🔗<|PREMISE|>🔗 ↑γ] :(ConNF.Semitangle.reprCode🔗<|PREMISE|>🔗 t).β ≠ ↑γ → (ConNF.cloudCode🔗<|PREMISE|>🔗 γ (ConNF.Semitangle.reprCode🔗<|PREMISE|>🔗 t)).members = t.members γ", "code": "theorem reprCode_members_ne :\n    ∀ (t : Semitangle) (γ : Λ) [LtLevel γ] (_ : (reprCode t : Code).1 ≠ γ),\n      (cloudCode γ (reprCode t)).members = t.members γ\n  | ⟨exts, Preference.proper β rep hA⟩, γ, _, hcγ => by\n      rw [snd_cloudCode]\n      exact hA _ hcγ\n  | ⟨_, Preference.base _ hA⟩, γ, _, _ => hA _\n", "additional_info": "", "used_premises": [1, 98, 208, 101, 208], "def_path": "ConNF/NewTangle/NewTangle.lean", "pos": [112, 119], "informalization": "Function `ConNF.Semitangle.reprCode_members_ne` is a theorem in the context of Constructive Ordinal Notation (ConNF) in Lean 4. It states that for a semitangle `t` and a type index `γ` less than the current level, if the first component of the even code `ConNF.Semitangle.reprCode t` is not equal to `γ`, then the members of the cloud code `ConNF.cloudCode γ (ConNF.Semitangle.reprCode t)` are equal to the members of `t` at `γ`."}
{"full_name": "ConNF.Semitangle.ext_core", "url": "ConNF/NewTangle/NewTangle.html#ConNF.Semitangle.ext_core", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.Semitangle.ext_core [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.TangleDataLt] [ConNF.PositionedTanglesLt] [ConNF.TypedObjectsLt] (t₁ : ConNF.Semitangle) (t₂ : ConNF.Semitangle) :Nonempty🔗<|PREMISE|>🔗 ((γ : ConNF.Λ) ×' ConNF.LtLevel🔗<|PREMISE|>🔗 ↑γ) → t₁.members = t₂.members → t₁ = t₂", "code": "theorem ext_core (t₁ t₂ : Semitangle) : Nonempty ((γ : Λ) ×' LtLevel γ) →\n    t₁.members = t₂.members → t₁ = t₂ := by\n  obtain ⟨xs, hxs⟩ := t₁\n  obtain ⟨ys, hys⟩ := t₂\n  rintro ⟨γ, _⟩ rfl\n  simp only [mk.injEq, heq_eq_eq, true_and]\n  obtain ⟨atoms₁, hA₁⟩ | ⟨β, even₁, hA₁⟩ := hxs <;>\n  obtain ⟨atoms₂, hA₂⟩ | ⟨γ, even₂, hA₂⟩ := hys\n  · simp_rw [cloud_injective ((hA₁ γ).trans (hA₂ _).symm)]\n  · cases (isEven_bot atoms₁).cloudCode_ne even₂ (bot_ne_coe (a := γ))\n      (Code.ext _ _ rfl (heq_of_eq (hA₁ γ)))\n  · cases (isEven_bot atoms₂).cloudCode_ne even₁ (bot_ne_coe (a := β))\n      (Code.ext _ _ rfl (heq_of_eq (hA₂ β)))\n  · simp only [Preference.proper.injEq]\n    refine not_ne_iff.1 fun hβγ =>\n      even₂.cloudCode_ne even₁ (WithBot.coe_injective.ne hβγ.symm) <|\n        Code.ext _ _ rfl (heq_of_eq ?_)\n    rw [snd_cloudCode]\n    exact hA₂ β fun h => hβγ.symm (WithBot.coe_injective h)\n", "additional_info": "One form of extensionality: If there is a proper type index `γ < α`, then two semitangles\nwith the same elements have the same preference.\nRemark: This formulation of extensionality holds only for types larger than type zero, since\nit doesn't take into account any `⊥`-extension.", "used_premises": [1, 212, 98], "def_path": "ConNF/NewTangle/NewTangle.lean", "pos": [125, 144], "informalization": "The theorem `ConNF.Semitangle.ext_core` is a form of extensionality for semitangles in the context of Constructive Ordinal Notation (ConNF). It states that if there exists a proper type index `γ` less than the current level `α`, and two semitangles have the same members, then the two semitangles are equal."}
{"full_name": "Nonempty", "url": "Init/Prelude.html#Nonempty", "code_src": "lean4", "ptype": "class inductive", "header": "class inductive Nonempty (α : Sort u) :Prop", "code": "class inductive Nonempty (α : Sort u) : Prop where\n  /-- If `val : α`, then `α` is nonempty. -/\n  | intro (val : α) : Nonempty α\n", "additional_info": "`🗟Nonempty🗟🔗.././Init/Prelude.html#Nonempty🔗  α` is a typeclass that says that `α` is not an empty type,\nthat is, there exists an element in the type. It differs from `🗟Inhabited🗟🔗.././Init/Prelude.html#Inhabited🔗  α`\nin that `🗟Nonempty🗟🔗.././Init/Prelude.html#Nonempty🔗  α` is a `Prop`, which means that it does not actually carry\nan element of `α`, only a proof that *there exists* such an element.\nGiven `🗟Nonempty🗟🔗.././Init/Prelude.html#Nonempty🔗  α`, you can construct an element of `α` *nonconstructively*\nusing `🗟Classical.choice🗟🔗.././Init/Prelude.html#Classical.choice🔗` .\n", "used_premises": [], "def_path": "Init/Prelude.lean", "pos": [703, 706], "informalization": "Class `Nonempty` represents the proposition that a type `α` is not empty, meaning there exists at least one element of type `α`, without providing a specific instance."}
{"full_name": "ConNF.Semitangle.ext", "url": "ConNF/NewTangle/NewTangle.html#ConNF.Semitangle.ext", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.Semitangle.ext [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.TangleDataLt] {γ : ConNF.Λ} [ConNF.LtLevel🔗<|PREMISE|>🔗 ↑γ] [ConNF.PositionedTanglesLt] [ConNF.TypedObjectsLt] (t₁ : ConNF.Semitangle) (t₂ : ConNF.Semitangle) (h : t₁.members γ = t₂.members γ) :t₁ = t₂", "code": "theorem ext (t₁ t₂ : Semitangle) (h : t₁.members γ = t₂.members γ) : t₁ = t₂ := by\n  obtain ⟨xs, hxs⟩ := t₁\n  obtain ⟨ys, hys⟩ := t₂\n  dsimp only at h\n  refine ext_code ?_\n  obtain ⟨atoms₁, hA₁⟩ | ⟨β, even₁, hA₁⟩ := hxs <;> obtain ⟨atoms₂, hA₂⟩ | ⟨δ, even₂, hA₂⟩ := hys\n  · refine (Code.Equiv.cloud_right _ (Code.isEven_bot _) γ bot_ne_coe).trans ?_\n    simp only [ne_eq, bot_ne_coe, not_false_eq_true, cloudCode_mk_ne, reprCode_base,\n      Equiv.bot_right_iff, Code.mk.injEq, coe_ne_bot, false_and, coe_inj, exists_and_left,\n      exists_eq_left', heq_eq_eq, false_or]\n    rw [hA₁ γ, h, ← hA₂ γ]\n    exact ⟨inferInstance, rfl⟩\n  · simp only [reprCode_base, Subtype.coe_mk, reprCode_proper]\n    obtain rfl | hδγ := eq_or_ne δ γ\n    · simp only [coe_ne_bot, isEmpty_mk, ne_eq, coe_inj, Equiv.bot_left_iff, Code.mk.injEq,\n        bot_ne_coe, false_and, exists_and_left, exists_eq_left', heq_eq_eq, false_or] at *\n      rw [← h, ← hA₁ δ]\n      exact ⟨inferInstance, rfl⟩\n    · refine (Code.Equiv.cloud_right _ (Code.isEven_bot _) γ bot_ne_coe).trans ?_\n      simp only [ne_eq, bot_ne_coe, not_false_eq_true, cloudCode_mk_ne]\n      rw [hA₁ γ, h, ← hA₂ γ (WithBot.coe_injective.ne hδγ), ← cloudCode_mk_ne]\n      exact Code.Equiv.cloud_left _ even₂ γ (WithBot.coe_injective.ne hδγ)\n  · simp only [reprCode_proper, Subtype.coe_mk, reprCode_base]\n    obtain rfl | hβγ := eq_or_ne β γ\n    · dsimp only [mem_Iio, Ne.def, SetCoe.forall] at *\n      rw [h, ← hA₂ β]\n      exact Code.Equiv.cloud_left _ (Code.isEven_bot _) _ bot_ne_coe\n    · refine (Code.Equiv.cloud_right _ even₁ γ <| WithBot.coe_injective.ne hβγ).trans ?_\n      dsimp only [mem_Iio, Ne.def, SetCoe.forall] at *\n      refine (Code.Equiv.of_eq <| cloudCode_mk_ne _ _ (WithBot.coe_injective.ne hβγ) (xs β)).trans ?_\n      rw [hA₁ γ (WithBot.coe_injective.ne hβγ), h, ← hA₂ γ]\n      exact Code.Equiv.cloud_left _ (Code.isEven_bot _) γ bot_ne_coe\n  · simp only [reprCode_proper, Subtype.coe_mk]\n    obtain rfl | hβγ := eq_or_ne β γ\n    · obtain rfl | hδβ := eq_or_ne δ β\n      · rw [h]\n      · have := cloudCode_ne β (Code.mk δ (ys δ)) (WithBot.coe_injective.ne hδβ)\n        dsimp only [mem_Iio, Ne.def, SetCoe.forall] at *\n        rw [h, ← hA₂ _ (WithBot.coe_injective.ne hδβ), ← this]\n        exact Code.Equiv.cloud_left _ even₂ _ (WithBot.coe_injective.ne hδβ)\n    obtain rfl | hδγ := eq_or_ne δ γ\n    · have := cloudCode_ne δ (Code.mk β (xs β)) (WithBot.coe_injective.ne hβγ)\n      dsimp only [mem_Iio, Ne.def, SetCoe.forall] at *\n      simp_rw [← h, ← hA₁ _ (WithBot.coe_injective.ne hβγ), ← this]\n      exact Code.Equiv.cloud_right _ even₁ _ (WithBot.coe_injective.ne hβγ)\n    refine' (Code.Equiv.cloud_right _ even₁ γ <| WithBot.coe_injective.ne hβγ).trans _\n    have := cloudCode_ne γ (Code.mk (↑δ) (ys δ)) (WithBot.coe_injective.ne hδγ)\n    dsimp only [mem_Iio, Ne.def, SetCoe.forall] at *\n    rw [cloudCode_ne]\n    rw [hA₁ γ (WithBot.coe_injective.ne hβγ), h, ← hA₂ γ (WithBot.coe_injective.ne hδγ)]\n    rw [← this]\n    exact Code.Equiv.cloud_left _ even₂ γ (WithBot.coe_injective.ne hδγ)\n", "additional_info": "Extensionality in tangled type theory. Two semitangles are equal if their\n`β`-extensions are equal for *any* choice of `γ < α`.\nTODO: This proof can be golfed quite a bit just by cleaning up the `simp` calls.", "used_premises": [1, 98], "def_path": "ConNF/NewTangle/NewTangle.lean", "pos": [199, 251], "informalization": "The theorem `ConNF.Semitangle.ext` is a proof of extensionality for semitangles in the context of Constructive Ordinal Notation (ConNF). It states that two semitangles are equal if their `β`-extensions are equal for any choice of `γ < α`."}
{"full_name": "ConNF.Semitangle.ext_zero", "url": "ConNF/NewTangle/NewTangle.html#ConNF.Semitangle.ext_zero", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.Semitangle.ext_zero [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.TangleDataLt] [ConNF.PositionedTanglesLt] [ConNF.TypedObjectsLt] (t₁ : ConNF.Semitangle) (t₂ : ConNF.Semitangle) (α_zero : IsMin🔗<|PREMISE|>🔗 ConNF.α) (h : ConNF.Semitangle.Preference.atoms🔗<|PREMISE|>🔗 t₁.pref = ConNF.Semitangle.Preference.atoms🔗<|PREMISE|>🔗 t₂.pref) :t₁ = t₂", "code": "theorem ext_zero (t₁ t₂ : Semitangle) (α_zero : IsMin α) (h : t₁.pref.atoms = t₂.pref.atoms) :\n    t₁ = t₂ := by\n  obtain ⟨xs, ⟨atoms₁, hA₁⟩ | ⟨γ, _, _⟩⟩ := t₁\n  swap\n  · cases α_zero.not_lt (show γ < α from WithBot.coe_lt_coe.mp LtLevel.elim)\n  obtain ⟨ys, ⟨atoms₂, hA₂⟩ | ⟨γ, _, _⟩⟩ := t₂\n  swap\n  · cases α_zero.not_lt (show γ < α from WithBot.coe_lt_coe.mp LtLevel.elim)\n  subst h\n  suffices xs = ys by\n    subst this\n    rfl\n  ext β : 1\n  cases α_zero.not_lt (show β < α from WithBot.coe_lt_coe.mp LtLevel.elim)\n", "additional_info": "Extensionality at the lowest level of tangled type theory.\nAt type 0, all semitangles have a `⊥`-extension.\nTherefore, the extensionality principle in this case applies to the `⊥`-extensions.", "used_premises": [1, 215, 216, 216], "def_path": "ConNF/NewTangle/NewTangle.lean", "pos": [255, 269], "informalization": "In the context of Constructive Ordinal Notation (ConNF), the theorem `ConNF.Semitangle.ext_zero` establishes an extensionality principle for semitangles at the lowest level of tangled type theory, specifically at type 0. At this level, all semitangles have a `⊥`-extension, and the extensionality principle applies to these `⊥`-extensions."}
{"full_name": "IsMin", "url": "Mathlib/Order/Max.html#IsMin", "code_src": "mathlib4", "ptype": "def", "header": "def IsMin {α : Type u_1} [LE🔗<|PREMISE|>🔗 α] (a : α) :Prop", "code": "def IsMin (a : α) : Prop :=\n  ∀ ⦃b⦄, b ≤ a → a ≤ b\n", "additional_info": "`a` is a minimal element of `α` if no element is strictly less than it. We spell it without `<`\nto avoid having to convert between `≤` and `<`. Instead, `🗟isMin_iff_forall_not_lt🗟🔗../.././Mathlib/Order/Max.html#isMin_iff_forall_not_lt🔗`  does the\nconversion.\nEquations\n* 🗟IsMin🗟🔗../.././Mathlib/Order/Max.html#IsMin🔗  a 🗟=🗟🔗../.././Init/Prelude.html#Eq🔗  ∀ ⦃b : α⦄, b 🗟≤🗟🔗../.././Init/Prelude.html#LE.le🔗  a → a 🗟≤🗟🔗../.././Init/Prelude.html#LE.le🔗  b\n\n", "used_premises": [5], "def_path": "Mathlib/Order/Max.lean", "pos": [201, 203], "informalization": "The function `IsMin` checks if an element `a` of a preordered type `α` is a minimal element, meaning there is no element `b` such that `b < a`."}
{"full_name": "ConNF.Semitangle.Preference.atoms", "url": "ConNF/NewTangle/NewTangle.html#ConNF.Semitangle.Preference.atoms", "code_src": "con-nf", "ptype": "def", "header": "def ConNF.Semitangle.Preference.atoms [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.TangleDataLt] [ConNF.PositionedTanglesLt] [ConNF.TypedObjectsLt] {members : ConNF.Extensions} :ConNF.Semitangle.Preference🔗<|PREMISE|>🔗 members → Set🔗<|PREMISE|>🔗 ConNF.Atom", "code": "def Preference.atoms : Preference members → Set Atom\n  | Preference.base atoms _ => (atoms : Set (Tangle ⊥))\n  | Preference.proper _ _ _ => ∅\n", "additional_info": "The `⊥`-extension associated with a given semitangle extension.\nEquations\n* 🗟ConNF.Semitangle.Preference.atoms🗟🔗../.././ConNF/NewTangle/NewTangle.html#ConNF.Semitangle.Preference.atoms🔗  x 🗟=🗟🔗../.././Init/Prelude.html#Eq🔗  match x with\n | 🗟ConNF.Semitangle.Preference.base🗟🔗../.././ConNF/NewTangle/NewTangle.html#ConNF.Semitangle.Preference.base🔗  atoms a => atoms\n | 🗟ConNF.Semitangle.Preference.proper🗟🔗../.././ConNF/NewTangle/NewTangle.html#ConNF.Semitangle.Preference.proper🔗  β a a_1 => 🗟∅🗟🔗../.././Init/Core.html#EmptyCollection.emptyCollection🔗\n\n", "used_premises": [1, 206, 69], "def_path": "ConNF/NewTangle/NewTangle.lean", "pos": [60, 63], "informalization": "Function `ConNF.Semitangle.Preference.atoms` returns the set of `⊥`-extensions associated with a given semitangle extension."}
{"full_name": "ConNF.Semitangle.exts_intro", "url": "ConNF/NewTangle/NewTangle.html#ConNF.Semitangle.exts_intro", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.Semitangle.exts_intro [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.TangleDataLt] {β : ConNF.TypeIndex} [ConNF.LtLevel🔗<|PREMISE|>🔗 β] [ConNF.PositionedTanglesLt] [ConNF.TypedObjectsLt] (s : Set🔗<|PREMISE|>🔗 (ConNF.Tangle β)) (heven : ConNF.Code.IsEven🔗<|PREMISE|>🔗 (ConNF.Code.mk🔗<|PREMISE|>🔗 β s)) :(ConNF.Semitangle.intro🔗<|PREMISE|>🔗 s heven).members = ConNF.extension🔗<|PREMISE|>🔗 s", "code": "theorem exts_intro (s : Set (Tangle β)) (heven : IsEven (Code.mk β s)) :\n    (intro s heven).members = extension s :=\n  rfl\n", "additional_info": "", "used_premises": [1, 98, 69, 165, 104, 218, 99], "def_path": "ConNF/NewTangle/NewTangle.lean", "pos": [287, 290], "informalization": "The `ConNF.Semitangle.exts_intro` theorem in Lean 4 states that the members of a semitangle constructed from an even code are equal to the extension of the set of tangles used to construct the semitangle."}
{"full_name": "ConNF.Semitangle.intro", "url": "ConNF/NewTangle/NewTangle.html#ConNF.Semitangle.intro", "code_src": "con-nf", "ptype": "def", "header": "def ConNF.Semitangle.intro [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.TangleDataLt] [ConNF.PositionedTanglesLt] [ConNF.TypedObjectsLt] {β : ConNF.TypeIndex} [inst : ConNF.LtLevel🔗<|PREMISE|>🔗 β] (s : Set🔗<|PREMISE|>🔗 (ConNF.Tangle β)) (heven : ConNF.Code.IsEven🔗<|PREMISE|>🔗 (ConNF.Code.mk🔗<|PREMISE|>🔗 β s)) :ConNF.Semitangle", "code": "def intro {β : TypeIndex} [inst : LtLevel β] (s : Set (Tangle β))\n    (heven : (Code.mk β s).IsEven) : Semitangle :=\n  ⟨extension s,\n    match β, inst, s, heven with\n    | ⊥, _, s, _ => Preference.base s fun β => rfl\n    | (γ : Λ), _, s, heven =>\n      Preference.proper γ\n        (by\n          convert heven\n          exact extension_self s)\n        fun δ _ hδ => by\n          rw [extension_ne s δ]\n          congr\n          exact congr_arg _ (extension_self s)⟩\n", "additional_info": "Construct a semitangle from an even code.\nEquations\n* One or more equations did not get rendered due to their size.\n\n", "used_premises": [1, 98, 69, 165, 104], "def_path": "ConNF/NewTangle/NewTangle.lean", "pos": [271, 285], "informalization": "Function `ConNF.Semitangle.intro` is used to construct a semitangle from an even code in the context of Constructive Ordinal Notation (ConNF). It takes a set of tangles of type `β` and a proof that the corresponding code is even, and returns a semitangle."}
{"full_name": "ConNF.NewAllowable.members_smul'", "url": "ConNF/NewTangle/NewTangle.html#ConNF.NewAllowable.members_smul'", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.NewAllowable.members_smul' [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.TangleDataLt] [ConNF.PositionedTanglesLt] [ConNF.TypedObjectsLt] (ρ : ConNF.NewAllowable) (t : ConNF.Semitangle) :(ρ • t).members = ρ • t.members", "code": "theorem members_smul' (ρ : NewAllowable) (t : Semitangle) : (ρ • t).members = ρ • t.members :=\n  rfl\n", "additional_info": "", "used_premises": [1], "def_path": "ConNF/NewTangle/NewTangle.lean", "pos": [357, 359], "informalization": "The theorem `ConNF.NewAllowable.members_smul'` states that for any `ConNF.NewAllowable` object `ρ` and any `ConNF.Semitangle` object `t`, the members of the semitangle `(ρ • t)` is equal to `ρ • t.members`, where `ρ • t.members` denotes the scalar multiplication of the members of `t` by `ρ`."}
{"full_name": "ConNF.Code.Equiv.supports", "url": "ConNF/NewTangle/NewTangle.html#ConNF.Code.Equiv.supports", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.Code.Equiv.supports [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.TangleDataLt] [ConNF.PositionedTanglesLt] [ConNF.TypedObjectsLt] {c : ConNF.Code} {d : ConNF.Code} {S : Set🔗<|PREMISE|>🔗 (ConNF.Address🔗<|PREMISE|>🔗 ↑ConNF.α)} (hcd : c ≡ d) (hS : MulAction.Supports🔗<|PREMISE|>🔗 ConNF.NewAllowable S c) :MulAction.Supports🔗<|PREMISE|>🔗 ConNF.NewAllowable S d", "code": "protected theorem Code.Equiv.supports (hcd : c ≡ d) (hS : Supports NewAllowable S c) :\n    Supports NewAllowable S d := fun ρ h => by\n  have h₁ := hcd.smul (ρ := ρ)\n  have h₂ := (Code.Equiv.of_eq <| hS ρ h).trans hcd\n  exact (h₁.symm.trans h₂).unique rfl\n", "additional_info": "If a set of addresses supports a code, it supports all equivalent codes.", "used_premises": [1, 69, 60, 68, 68], "def_path": "ConNF/NewTangle/NewTangle.lean", "pos": [410, 415], "informalization": "The theorem `ConNF.Code.Equiv.supports` states that if a set of addresses supports a code `c`, then it also supports any code `d` that is equivalent to `c`. In the context of Constructive Ordinal Notation (ConNF), this means that if a set of addresses is sufficient to determine the behavior of one code, it is also sufficient to determine the behavior of any equivalent code."}
{"full_name": "ConNF.Code.Equiv.supports_iff", "url": "ConNF/NewTangle/NewTangle.html#ConNF.Code.Equiv.supports_iff", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.Code.Equiv.supports_iff [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.TangleDataLt] [ConNF.PositionedTanglesLt] [ConNF.TypedObjectsLt] {c : ConNF.Code} {d : ConNF.Code} {S : Set🔗<|PREMISE|>🔗 (ConNF.Address🔗<|PREMISE|>🔗 ↑ConNF.α)} (hcd : c ≡ d) :MulAction.Supports🔗<|PREMISE|>🔗 ConNF.NewAllowable S c ↔ MulAction.Supports🔗<|PREMISE|>🔗 ConNF.NewAllowable S d", "code": "theorem Code.Equiv.supports_iff (hcd : c ≡ d) :\n    Supports NewAllowable S c ↔ Supports NewAllowable S d :=\n  ⟨hcd.supports, hcd.symm.supports⟩\n", "additional_info": "", "used_premises": [1, 69, 60, 68, 68], "def_path": "ConNF/NewTangle/NewTangle.lean", "pos": [416, 419], "informalization": "The theorem `ConNF.Code.Equiv.supports_iff` states that if two ConNF codes `c` and `d` are equivalent (denoted by `c ≡ d`), then the set `S` supports `c` under the action of `ConNF.NewAllowable` if and only if `S` supports `d` under the same action."}
{"full_name": "ConNF.Code.Equiv.supported_iff", "url": "ConNF/NewTangle/NewTangle.html#ConNF.Code.Equiv.supported_iff", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.Code.Equiv.supported_iff [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.TangleDataLt] [ConNF.PositionedTanglesLt] [ConNF.TypedObjectsLt] {c : ConNF.Code} {d : ConNF.Code} (hcd : c ≡ d) :(∃ (S : ConNF.Support🔗<|PREMISE|>🔗 ↑ConNF.α), MulAction.Supports🔗<|PREMISE|>🔗 ConNF.NewAllowable (ConNF.Enumeration.carrier🔗<|PREMISE|>🔗 S.enum) c) ↔ ∃ (S : ConNF.Support🔗<|PREMISE|>🔗 ↑ConNF.α), MulAction.Supports🔗<|PREMISE|>🔗 ConNF.NewAllowable (ConNF.Enumeration.carrier🔗<|PREMISE|>🔗 S.enum) d", "code": "theorem Code.Equiv.supported_iff (hcd : c ≡ d) :\n    (∃ S : Support α, MulAction.Supports NewAllowable (S : Set (Address α)) c) ↔\n    ∃ S : Support α, MulAction.Supports NewAllowable (S : Set (Address α)) d := by\n  constructor <;> rintro ⟨S, hS⟩\n  · exact ⟨S, hcd.supports hS⟩\n  · exact ⟨S, hcd.symm.supports hS⟩\n", "additional_info": "If two codes are equivalent, one is supported if and only if the other is.", "used_premises": [1, 58, 68, 70, 58, 68, 70], "def_path": "ConNF/NewTangle/NewTangle.lean", "pos": [421, 427], "informalization": "The theorem `ConNF.Code.Equiv.supported_iff` states that if two codes `c` and `d` are equivalent (denoted by `c ≡ d`), then there exists a support for `c` if and only if there exists a support for `d`. This means that the property of being supported is preserved under equivalence of codes."}
{"full_name": "ConNF.NewAllowable.smul_address", "url": "ConNF/NewTangle/NewTangle.html#ConNF.NewAllowable.smul_address", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NewAllowable.smul_address [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.TangleDataLt] [ConNF.PositionedTanglesLt] [ConNF.TypedObjectsLt] {ρ : ConNF.NewAllowable} {c : ConNF.Address🔗<|PREMISE|>🔗 ↑ConNF.α} :ρ • c = { path := c.path, value := ConNF.NewAllowable.toStructPerm ρ c.path • c.value }", "code": "theorem NewAllowable.smul_address {ρ : NewAllowable} {c : Address α} :\n    ρ • c = ⟨c.path, NewAllowable.toStructPerm ρ c.path • c.value⟩ :=\n  rfl\n", "additional_info": "", "used_premises": [1, 60], "def_path": "ConNF/NewTangle/NewTangle.lean", "pos": [441, 444], "informalization": "In the context of Constructive Ordinal Notation (ConNF), `ConNF.NewAllowable.smul_address` is a theorem that defines the action of a `ConNF.NewAllowable` object on a `ConNF.Address` object. Specifically, it states that when a `ConNF.NewAllowable` object `ρ` acts on a `ConNF.Address` object `c`, the resulting `ConNF.Address` object has the same path as `c`, but its value is obtained by applying the permutation `ConNF.NewAllowable.toStructPerm ρ c.path` to the value of `c`."}
{"full_name": "ConNF.NewAllowable.smul_address_eq_iff", "url": "ConNF/NewTangle/NewTangle.html#ConNF.NewAllowable.smul_address_eq_iff", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.NewAllowable.smul_address_eq_iff [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.TangleDataLt] [ConNF.PositionedTanglesLt] [ConNF.TypedObjectsLt] {ρ : ConNF.NewAllowable} {c : ConNF.Address🔗<|PREMISE|>🔗 ↑ConNF.α} :ρ • c = c ↔ ConNF.NewAllowable.toStructPerm ρ c.path • c.value = c.value", "code": "theorem NewAllowable.smul_address_eq_iff {ρ : NewAllowable} {c : Address α} :\n    ρ • c = c ↔ NewAllowable.toStructPerm ρ c.path • c.value = c.value :=\n  StructPerm.smul_address_eq_iff\n", "additional_info": "", "used_premises": [1, 60], "def_path": "ConNF/NewTangle/NewTangle.lean", "pos": [446, 449], "informalization": "In the context of Constructive Ordinal Notation (ConNF), the theorem `ConNF.NewAllowable.smul_address_eq_iff` states that for an element `ρ` of the type `ConNF.NewAllowable` and an element `c` of the type `ConNF.Address ↑ConNF.α`, the condition `ρ • c = c` is equivalent to the condition `ConNF.NewAllowable.toStructPerm ρ c.path • c.value = c.value`. This theorem is marked as `@[simp]`, indicating that it should be used as a simplification rule in further proofs."}
{"full_name": "ConNF.NewAllowable.smul_address_eq_smul_iff", "url": "ConNF/NewTangle/NewTangle.html#ConNF.NewAllowable.smul_address_eq_smul_iff", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.NewAllowable.smul_address_eq_smul_iff [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.TangleDataLt] [ConNF.PositionedTanglesLt] [ConNF.TypedObjectsLt] {ρ : ConNF.NewAllowable} {ρ' : ConNF.NewAllowable} {c : ConNF.Address🔗<|PREMISE|>🔗 ↑ConNF.α} :ρ • c = ρ' • c ↔ ConNF.NewAllowable.toStructPerm ρ c.path • c.value = ConNF.NewAllowable.toStructPerm ρ' c.path • c.value", "code": "theorem NewAllowable.smul_address_eq_smul_iff\n    {ρ ρ' : NewAllowable} {c : Address α} :\n    ρ • c = ρ' • c ↔\n    NewAllowable.toStructPerm ρ c.path • c.value =\n      NewAllowable.toStructPerm ρ' c.path • c.value :=\n  StructPerm.smul_address_eq_smul_iff\n", "additional_info": "", "used_premises": [1, 60], "def_path": "ConNF/NewTangle/NewTangle.lean", "pos": [451, 457], "informalization": "The theorem `ConNF.NewAllowable.smul_address_eq_smul_iff` states that for two `ConNF.NewAllowable` objects `ρ` and `ρ'` and a `ConNF.Address` object `c`, the equation `ρ • c = ρ' • c` holds if and only if the permutation of `c`'s value by `ρ` is equal to the permutation of `c`'s value by `ρ'`."}
{"full_name": "ConNF.NewAllowable.coe_smul_newTangle", "url": "ConNF/NewTangle/NewTangle.html#ConNF.NewAllowable.coe_smul_newTangle", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.NewAllowable.coe_smul_newTangle [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.TangleDataLt] [ConNF.PositionedTanglesLt] [ConNF.TypedObjectsLt] (ρ : ConNF.NewAllowable) (t : ConNF.NewTangle) :ρ • ↑t = ρ • ↑t", "code": "theorem coe_smul_newTangle (ρ : NewAllowable) (t : NewTangle) :\n    ((ρ • t) : Semitangle) = ρ • (t : Semitangle) :=\n  rfl\n", "additional_info": "", "used_premises": [1], "def_path": "ConNF/NewTangle/NewTangle.lean", "pos": [506, 509], "informalization": "The theorem `ConNF.NewAllowable.coe_smul_newTangle` states that the scalar multiplication of a `ConNF.NewAllowable` object `ρ` with a `ConNF.NewTangle` object `t` is equal to the scalar multiplication of `ρ` with the underlying `ConNF.Tangle` object of `t`."}
{"full_name": "ConNF.Enumeration.ext", "url": "ConNF/Structural/Enumeration.html#ConNF.Enumeration.ext", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.Enumeration.ext :∀ {inst : ConNF.Params🔗<|PREMISE|>🔗 } {α : Type u_1} (x y : ConNF.Enumeration🔗<|PREMISE|>🔗 α), x.max = y.max → HEq🔗<|PREMISE|>🔗 x.f y.f → x = y", "code": "@[ext]\n", "additional_info": "", "used_premises": [1, 59, 126], "def_path": "ConNF/Structural/Enumeration.lean", "pos": [15, 16], "informalization": "In the context of Constructive Ordinal Notation (ConNF), an `α`-enumeration is a function from an initial segment of `κ` to `α`. The theorem `ConNF.Enumeration.ext` states that two `α`-enumerations `x` and `y` are equal if their maximum values (`x.max` and `y.max`) are equal and their functions (`x.f` and `y.f`) are heterogeneously equal (`HEq`)."}
{"full_name": "ConNF.Enumeration.ext_iff", "url": "ConNF/Structural/Enumeration.html#ConNF.Enumeration.ext_iff", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.Enumeration.ext_iff :∀ {inst : ConNF.Params🔗<|PREMISE|>🔗 } {α : Type u_1} (x y : ConNF.Enumeration🔗<|PREMISE|>🔗 α), x = y ↔ x.max = y.max ∧ HEq🔗<|PREMISE|>🔗 x.f y.f", "code": "@[ext]\n", "additional_info": "", "used_premises": [1, 59, 126], "def_path": "ConNF/Structural/Enumeration.lean", "pos": [15, 16], "informalization": "The theorem `ConNF.Enumeration.ext_iff` states that two `α`-enumerations `x` and `y` are equal if and only if their maximum values `x.max` and `y.max` are equal and the functions `x.f` and `y.f` are heterogeneously equal (`HEq`)."}
{"full_name": "ConNF.Enumeration.mem_carrier_iff", "url": "ConNF/Structural/Enumeration.html#ConNF.Enumeration.mem_carrier_iff", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.Enumeration.mem_carrier_iff [ConNF.Params🔗<|PREMISE|>🔗 ] {α : Type u_1} (x : α) (E : ConNF.Enumeration🔗<|PREMISE|>🔗 α) :x ∈ ConNF.Enumeration.carrier🔗<|PREMISE|>🔗 E ↔ ∃ (i : ConNF.κ) (h : i < E.max), x = E.f i h", "code": "theorem Enumeration.mem_carrier_iff (x : α) (E : Enumeration α) :\n    x ∈ E.carrier ↔ ∃ i, ∃ (h : i < E.max), x = E.f i h :=\n  Iff.rfl\n", "additional_info": "", "used_premises": [1, 59, 70], "def_path": "ConNF/Structural/Enumeration.lean", "pos": [29, 32], "informalization": "The theorem `ConNF.Enumeration.mem_carrier_iff` states that an element `x` is in the carrier set of an `α`-enumeration `E` if and only if there exists an index `i` less than `E.max` such that `x` is equal to `E.f i h`, where `h` is a proof that `i` is less than `E.max`."}
{"full_name": "ConNF.Enumeration.mem_iff", "url": "ConNF/Structural/Enumeration.html#ConNF.Enumeration.mem_iff", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.Enumeration.mem_iff [ConNF.Params🔗<|PREMISE|>🔗 ] {α : Type u_1} (c : α) (E : ConNF.Enumeration🔗<|PREMISE|>🔗 α) :c ∈ E ↔ ∃ (i : ConNF.κ) (h : i < E.max), c = E.f i h", "code": "theorem Enumeration.mem_iff (c : α) (E : Enumeration α) :\n    c ∈ E ↔ ∃ i, ∃ (h : i < E.max), c = E.f i h :=\n  Iff.rfl\n", "additional_info": "", "used_premises": [1, 59], "def_path": "ConNF/Structural/Enumeration.lean", "pos": [33, 36], "informalization": "The theorem `ConNF.Enumeration.mem_iff` states that an element `c` is a member of an enumeration `E` if and only if there exists an index `i` less than the maximum index of `E` such that `c` is equal to the value of `E` at `i`."}
{"full_name": "ConNF.Enumeration.f_mem", "url": "ConNF/Structural/Enumeration.html#ConNF.Enumeration.f_mem", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.Enumeration.f_mem [ConNF.Params🔗<|PREMISE|>🔗 ] {α : Type u_1} (E : ConNF.Enumeration🔗<|PREMISE|>🔗 α) (i : ConNF.κ) (hi : i < E.max) :E.f i hi ∈ E", "code": "theorem Enumeration.f_mem (E : Enumeration α) (i : κ) (hi : i < E.max) :\n    E.f i hi ∈ E :=\n  ⟨i, hi, rfl⟩\n", "additional_info": "", "used_premises": [1, 59], "def_path": "ConNF/Structural/Enumeration.lean", "pos": [37, 40], "informalization": "The theorem `ConNF.Enumeration.f_mem` states that for any `α`-enumeration `E` and any `i` less than `E.max`, the value `E.f i hi` (where `hi` is a proof that `i < E.max`) is an element of `E`."}
{"full_name": "ConNF.Enumeration.carrier_small", "url": "ConNF/Structural/Enumeration.html#ConNF.Enumeration.carrier_small", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.Enumeration.carrier_small [ConNF.Params🔗<|PREMISE|>🔗 ] {α : Type u} (E : ConNF.Enumeration🔗<|PREMISE|>🔗 α) :ConNF.Small🔗<|PREMISE|>🔗 (ConNF.Enumeration.carrier🔗<|PREMISE|>🔗 E)", "code": "theorem Enumeration.carrier_small (E : Enumeration α) : Small E.carrier := by\n  refine lt_of_le_of_lt (b := #(Set.Iio E.max)) ?_ (card_typein_lt (· < ·) E.max Params.κ_ord.symm)\n  refine mk_le_of_surjective (f := fun x => ⟨E.f x x.prop, x, x.prop, rfl⟩) ?_\n  rintro ⟨_, i, h, rfl⟩\n  exact ⟨⟨i, h⟩, rfl⟩\n", "additional_info": "", "used_premises": [1, 59, 233, 70], "def_path": "ConNF/Structural/Enumeration.lean", "pos": [41, 46], "informalization": "The theorem `ConNF.Enumeration.carrier_small` states that the carrier set of an `α`-enumeration `E`, which consists of all elements `c` of type `α` that can be expressed as `E.f i h` for some `i < E.max`, has a cardinality strictly less than the cardinality of the type `ConNF.κ` in the context of Constructive Ordinal Notation (ConNF)."}
{"full_name": "ConNF.Small", "url": "ConNF/BaseType/Small.html#ConNF.Small", "code_src": "con-nf", "ptype": "def", "header": "def ConNF.Small [ConNF.Params🔗<|PREMISE|>🔗 ] {α : Type u} (s : Set🔗<|PREMISE|>🔗 α) :Prop", "code": "def Small (s : Set α) : Prop :=\n  #s < #κ\n", "additional_info": "A set is small if its cardinality is strictly less than `κ`.\nEquations\n* 🗟ConNF.Small🗟🔗../.././ConNF/BaseType/Small.html#ConNF.Small🔗  s 🗟=🗟🔗../.././Init/Prelude.html#Eq🔗  (🗟Cardinal.mk🗟🔗../.././Mathlib/SetTheory/Cardinal/Basic.html#Cardinal.mk🔗  ↑s 🗟<🗟🔗../.././Init/Prelude.html#LT.lt🔗  🗟Cardinal.mk🗟🔗../.././Mathlib/SetTheory/Cardinal/Basic.html#Cardinal.mk🔗  ConNF.κ)\n\n", "used_premises": [1, 69], "def_path": "ConNF/BaseType/Small.lean", "pos": [25, 27], "informalization": "Function `ConNF.Small` is a predicate that checks if the cardinality of a given set `s` is strictly less than the cardinality of the type `ConNF.κ` in the context of Constructive Ordinal Notation (ConNF)."}
{"full_name": "ConNF.Enumeration.small", "url": "ConNF/Structural/Enumeration.html#ConNF.Enumeration.small", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.Enumeration.small [ConNF.Params🔗<|PREMISE|>🔗 ] {α : Type u} (E : ConNF.Enumeration🔗<|PREMISE|>🔗 α) :ConNF.Small🔗<|PREMISE|>🔗 (ConNF.Enumeration.carrier🔗<|PREMISE|>🔗 E)", "code": "theorem Enumeration.small (E : Enumeration α) : Small (E : Set α) :=\n  E.carrier_small\n", "additional_info": "", "used_premises": [1, 59, 233, 70], "def_path": "ConNF/Structural/Enumeration.lean", "pos": [47, 49], "informalization": "Function `ConNF.Enumeration.small` proves that the carrier set of an `α`-enumeration `E` is strictly smaller than the type `ConNF.κ` in the context of Constructive Ordinal Notation (ConNF)."}
{"full_name": "ConNF.funMap_injective", "url": "ConNF/Structural/Enumeration.html#ConNF.funMap_injective", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.funMap_injective {α : Type u_1} {β : Type u_1} [LinearOrder🔗<|PREMISE|>🔗 β] [IsWellOrder🔗<|PREMISE|>🔗 β fun (x x_1 : β) => x < x_1] :Function.Injective🔗<|PREMISE|>🔗 (ConNF.funMap🔗<|PREMISE|>🔗 α β)", "code": "theorem funMap_injective {α β : Type _} [LinearOrder β] [IsWellOrder β (· < ·)] :\n    Function.Injective (funMap α β) := by\n  intro f g h\n  simp only [funMap, Prod.mk.injEq, Subtype.mk.injEq] at h\n  suffices : ∀ y : β, ∀ x : α, f x = y → g x = y\n  · ext x : 1\n    rw [this]\n    rfl\n  intro y\n  refine IsWellFounded.induction (· < ·) (C := fun y => ∀ x : α, f x = y → g x = y) y ?_\n  clear y\n  rintro y ih x rfl\n  obtain ⟨y, h₁⟩ : f x ∈ Set.range g\n  · rw [← h.1]\n    exact ⟨x, rfl⟩\n  rw [← h₁]\n  obtain (h₂ | h₂ | h₂) := lt_trichotomy (g x) (g y)\n  · obtain ⟨z, h₃⟩ : g x ∈ Set.range f\n    · rw [h.1]\n      exact ⟨x, rfl⟩\n    rw [h₁, ← h₃] at h₂\n    have h₄ := ih (f z) h₂ z rfl\n    have := congr_fun₂ h.2 z x\n    simp only [InvImage, h₂, eq_iff_iff, true_iff] at this\n    rw [h₄, h₃] at this\n    cases lt_irrefl _ this\n  · exact h₂\n  · have := congr_fun₂ h.2 y x\n    simp only [InvImage, eq_iff_iff] at this\n    rw [← this] at h₂\n    have := ih (f y) h₂ y rfl\n    have := h₂.trans_eq (h₁.symm.trans this)\n    cases lt_irrefl _ this\n", "additional_info": "", "used_premises": [2, 15, 89, 236], "def_path": "ConNF/Structural/Enumeration.lean", "pos": [60, 93], "informalization": "The theorem `ConNF.funMap_injective` states that the function `ConNF.funMap`, which maps a function `f` from `α` to `β` to a pair consisting of the range of `f` and the inverse image of the less-than relation on `β` under `f`, is injective."}
{"full_name": "ConNF.funMap", "url": "ConNF/Structural/Enumeration.html#ConNF.funMap", "code_src": "con-nf", "ptype": "def", "header": "def ConNF.funMap (α : Type u_1) (β : Type u_1) [LT🔗<|PREMISE|>🔗 β] (f : α → β) :{ E : Set🔗<|PREMISE|>🔗 β // Cardinal.mk🔗<|PREMISE|>🔗 ↑E ≤ Cardinal.mk🔗<|PREMISE|>🔗 α } × (α → α → Prop )", "code": "def funMap (α β : Type _) [LT β] (f : α → β) :\n    { E : Set β // #E ≤ #α } × (α → α → Prop) :=\n  ⟨⟨Set.range f, mk_range_le⟩, InvImage (· < ·) f⟩\n", "additional_info": "Equations\n* 🗟ConNF.funMap🗟🔗../.././ConNF/Structural/Enumeration.html#ConNF.funMap🔗  α β f 🗟=🗟🔗../.././Init/Prelude.html#Eq🔗  ({ val := 🗟Set.range🗟🔗../.././Mathlib/Data/Set/Defs.html#Set.range🔗  f, property := ⋯ }, 🗟InvImage🗟🔗../.././Init/Core.html#InvImage🔗  (fun (x x_1 : β) => x 🗟<🗟🔗../.././Init/Prelude.html#LT.lt🔗  x_1) f)\n\n", "used_premises": [6, 69, 29, 29], "def_path": "ConNF/Structural/Enumeration.lean", "pos": [56, 59], "informalization": "Function `ConNF.funMap` takes a type `α`, a type `β` with a less-than relation, and a function `f` from `α` to `β`. It returns a pair consisting of a subset of `β` (the range of `f`) and a relation on `α` (the inverse image of the less-than relation on `β` under `f`)."}
{"full_name": "ConNF.mk_fun_le", "url": "ConNF/Structural/Enumeration.html#ConNF.mk_fun_le", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.mk_fun_le {α : Type u} {β : Type u} :Cardinal.mk🔗<|PREMISE|>🔗 (α → β) ≤ Cardinal.mk🔗<|PREMISE|>🔗 ({ E : Set🔗<|PREMISE|>🔗 β // Cardinal.mk🔗<|PREMISE|>🔗 ↑E ≤ Cardinal.mk🔗<|PREMISE|>🔗 α } × (α → α → Prop ))", "code": "theorem mk_fun_le {α β : Type u} :\n    #(α → β) ≤ #({ E : Set β // #E ≤ #α } × (α → α → Prop)) := by\n  classical\n  obtain ⟨r, hr⟩ := IsWellOrder.subtype_nonempty (σ := β)\n  let _ := linearOrderOfSTO r\n  exact ⟨⟨funMap α β, funMap_injective⟩⟩\n", "additional_info": "", "used_premises": [29, 29, 69, 29, 29], "def_path": "ConNF/Structural/Enumeration.lean", "pos": [94, 100], "informalization": "The cardinality of the set of functions from α to β is less than or equal to the product of the cardinality of the set of subsets of β whose cardinality is less than or equal to the cardinality of α, and the set of binary relations on α."}
{"full_name": "ConNF.pow_le_of_isStrongLimit'", "url": "ConNF/Structural/Enumeration.html#ConNF.pow_le_of_isStrongLimit'", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.pow_le_of_isStrongLimit' {α : Type u} {β : Type u} [Infinite🔗<|PREMISE|>🔗 α] [Infinite🔗<|PREMISE|>🔗 β] (h₁ : Cardinal.IsStrongLimit🔗<|PREMISE|>🔗 (Cardinal.mk🔗<|PREMISE|>🔗 β)) (h₂ : Cardinal.mk🔗<|PREMISE|>🔗 α < Ordinal.cof🔗<|PREMISE|>🔗 (Cardinal.ord🔗<|PREMISE|>🔗 (Cardinal.mk🔗<|PREMISE|>🔗 β))) :Cardinal.mk🔗<|PREMISE|>🔗 β ^ Cardinal.mk🔗<|PREMISE|>🔗 α ≤ Cardinal.mk🔗<|PREMISE|>🔗 β", "code": "theorem pow_le_of_isStrongLimit' {α β : Type u} [Infinite α] [Infinite β]\n    (h₁ : IsStrongLimit #β) (h₂ : #α < (#β).ord.cof) : #β ^ #α ≤ #β := by\n  refine le_trans mk_fun_le ?_\n  simp only [mk_prod, Cardinal.lift_id, mk_pi, mk_fintype, Fintype.card_prop, Nat.cast_ofNat,\n    prod_const, Cardinal.lift_id', lift_two]\n  have h₃ : #{ E : Set β // #E ≤ #α } ≤ #β\n  · rw [← mk_subset_mk_lt_cof h₁.2]\n    refine ⟨⟨fun E => ⟨E, E.prop.trans_lt h₂⟩, ?_⟩⟩\n    intro E F h\n    simp only [Subtype.mk.injEq] at h\n    exact Subtype.coe_injective h\n  have h₄ : (2 ^ #α) ^ #α ≤ #β\n  · rw [← power_mul, mul_eq_self (Cardinal.infinite_iff.mp inferInstance)]\n    refine (h₁.2 _ ?_).le\n    exact h₂.trans_le (cof_ord_le #β)\n  refine le_trans (mul_le_max _ _) ?_\n  simp only [ge_iff_le, le_max_iff, max_le_iff, le_aleph0_iff_subtype_countable, h₃, h₄, and_self,\n    aleph0_le_mk]\n", "additional_info": "", "used_premises": [239, 239, 37, 29, 29, 38, 27, 29, 29, 29, 29], "def_path": "ConNF/Structural/Enumeration.lean", "pos": [101, 119], "informalization": "The theorem `ConNF.pow_le_of_isStrongLimit'` states that for any two infinite types `α` and `β`, if `β` is a strong limit cardinal and the cardinality of `α` is less than the cofinality of the ordinal corresponding to the cardinality of `β`, then the cardinality of `β` raised to the power of the cardinality of `α` is less than or equal to the cardinality of `β`."}
{"full_name": "Infinite", "url": "Mathlib/Data/Finite/Defs.html#Infinite", "code_src": "mathlib4", "ptype": "class", "header": "class Infinite (α : Sort u_3) :Prop\n | not_finite : ¬ Finite🔗<|PREMISE|>🔗  α", "code": "class Infinite (α : Sort*) : Prop where\n  /-- assertion that `α` is `¬Finite`-/\n  not_finite : ¬Finite α\n", "additional_info": "A type is said to be infinite if it is not finite. Note that `🗟Infinite🗟🔗../../.././Mathlib/Data/Finite/Defs.html#Infinite🔗  α` is equivalent to\n`🗟IsEmpty🗟🔗../../.././Mathlib/Logic/IsEmpty.html#IsEmpty🔗  (Fintype α)` or `🗟IsEmpty🗟🔗../../.././Mathlib/Logic/IsEmpty.html#IsEmpty🔗  (Finite α)`.\n- Infinite.not_finite: assertion that `α` is `¬Finite`\n\n\n", "used_premises": [240], "def_path": "Mathlib/Data/Finite/Defs.lean", "pos": [116, 119], "informalization": "Class `Infinite` represents the proposition that a type `α` is infinite, meaning it does not have a finite number of elements and cannot be bijectively mapped to any finite set `Fin n`."}
{"full_name": "Finite", "url": "Mathlib/Data/Finite/Defs.html#Finite", "code_src": "mathlib4", "ptype": "class inductive", "header": "class inductive Finite (α : Sort u_1) :Prop", "code": "class inductive Finite (α : Sort*) : Prop\n  | intro {n : ℕ} : α ≃ Fin n → Finite _\n", "additional_info": "A type is `🗟Finite🗟🔗../../.././Mathlib/Data/Finite/Defs.html#Finite🔗`  if it is in bijective correspondence to some `🗟Fin🗟🔗../../.././Init/Prelude.html#Fin🔗  n`.\nThis is similar to `Fintype`, but `🗟Finite🗟🔗../../.././Mathlib/Data/Finite/Defs.html#Finite🔗`  is a proposition rather than data.\nA particular benefit to this is that `🗟Finite🗟🔗../../.././Mathlib/Data/Finite/Defs.html#Finite🔗`  instances are definitionally equal to one another\n(due to proof irrelevance) rather than being merely propositionally equal,\nand, furthermore, `🗟Finite🗟🔗../../.././Mathlib/Data/Finite/Defs.html#Finite🔗`  instances generally avoid the need for `🗟Decidable🗟🔗../../.././Init/Prelude.html#Decidable🔗`  instances.\nOne other notable difference is that `🗟Finite🗟🔗../../.././Mathlib/Data/Finite/Defs.html#Finite🔗`  allows there to be `🗟Finite🗟🔗../../.././Mathlib/Data/Finite/Defs.html#Finite🔗  p` instances\nfor all `p : Prop`, which is not allowed by `Fintype` due to universe constraints.\nAn application of this is that `🗟Finite🗟🔗../../.././Mathlib/Data/Finite/Defs.html#Finite🔗  (x ∈ s → β x)` follows from the general instance for pi\ntypes, assuming `[∀ x, 🗟Finite🗟🔗../../.././Mathlib/Data/Finite/Defs.html#Finite🔗  (β x)]`.\nImplementation note: this is a reason `🗟Finite🗟🔗../../.././Mathlib/Data/Finite/Defs.html#Finite🔗  α` is not defined as `🗟Nonempty🗟🔗../../.././Init/Prelude.html#Nonempty🔗  (Fintype α)`.\nEvery `Fintype` instance provides a `🗟Finite🗟🔗../../.././Mathlib/Data/Finite/Defs.html#Finite🔗`  instance via `Finite.of_fintype`.\nConversely, one can noncomputably create a `Fintype` instance from a `🗟Finite🗟🔗../../.././Mathlib/Data/Finite/Defs.html#Finite🔗`  instance\nvia `Fintype.ofFinite`. In a proof one might write\n  have := Fintype.ofFinite α\n\nto obtain such an instance.\nDo not write noncomputable `Fintype` instances; instead write `🗟Finite🗟🔗../../.././Mathlib/Data/Finite/Defs.html#Finite🔗`  instances\nand use this `Fintype.ofFinite` interface.\nThe `Fintype` instances should be relied upon to be computable for evaluation purposes.\nTheorems should use `🗟Finite🗟🔗../../.././Mathlib/Data/Finite/Defs.html#Finite🔗`  instead of `Fintype`, unless definitions in the theorem statement\nrequire `Fintype`.\nDefinitions should prefer `🗟Finite🗟🔗../../.././Mathlib/Data/Finite/Defs.html#Finite🔗`  as well, unless it is important that the definitions\nare meant to be computable in the reduction or `#eval` sense.\n", "used_premises": [], "def_path": "Mathlib/Data/Finite/Defs.lean", "pos": [80, 82], "informalization": "Class `Finite` represents the proposition that a type `α` is finite, meaning it has a finite number of elements, and can be bijectively mapped to a finite set `Fin n` for some natural number `n`."}
{"full_name": "ConNF.pow_le_of_isStrongLimit", "url": "ConNF/Structural/Enumeration.html#ConNF.pow_le_of_isStrongLimit", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.pow_le_of_isStrongLimit {κ : Cardinal🔗<|PREMISE|>🔗 } {μ : Cardinal🔗<|PREMISE|>🔗 } (h₁ : Cardinal.IsStrongLimit🔗<|PREMISE|>🔗 μ) (h₂ : κ < Ordinal.cof🔗<|PREMISE|>🔗 (Cardinal.ord🔗<|PREMISE|>🔗 μ)) :μ ^ κ ≤ μ", "code": "theorem pow_le_of_isStrongLimit {κ μ : Cardinal.{u}} (h₁ : IsStrongLimit μ) (h₂ : κ < μ.ord.cof) :\n    μ ^ κ ≤ μ := by\n  by_cases h : κ < ℵ₀\n  · exact pow_le h₁.isLimit.aleph0_le h\n  · revert h₁ h₂ h\n    refine inductionOn₂ κ μ ?_\n    intro α β h₁ h₂ h\n    have := Cardinal.infinite_iff.mpr (le_of_not_lt h)\n    have := Cardinal.infinite_iff.mpr h₁.isLimit.aleph0_le\n    exact pow_le_of_isStrongLimit' h₁ h₂\n", "additional_info": "", "used_premises": [28, 28, 37, 38, 27], "def_path": "ConNF/Structural/Enumeration.lean", "pos": [120, 130], "informalization": "If `μ` is a strong limit cardinal and `κ` is less than the cofinality of `μ`, then `μ ^ κ ≤ μ`."}
{"full_name": "ConNF.mk_enumeration", "url": "ConNF/Structural/Enumeration.html#ConNF.mk_enumeration", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.mk_enumeration [ConNF.Params🔗<|PREMISE|>🔗 ] {α : Type u} (mk_α : Cardinal.mk🔗<|PREMISE|>🔗 α = Cardinal.mk🔗<|PREMISE|>🔗 ConNF.μ) :Cardinal.mk🔗<|PREMISE|>🔗 (ConNF.Enumeration🔗<|PREMISE|>🔗 α) = Cardinal.mk🔗<|PREMISE|>🔗 ConNF.μ", "code": "theorem mk_enumeration (mk_α : #α = #μ) : #(Enumeration α) = #μ := by\n  refine le_antisymm ?_ ?_\n  · rw [Cardinal.mk_congr enumerationEquiv]\n    simp only [mk_sigma, mk_pi, mk_α, prod_const, Cardinal.lift_id]\n    refine le_trans (sum_le_sum _ (fun _ => #μ) ?_) ?_\n    · intro i\n      refine pow_le_of_isStrongLimit Params.μ_isStrongLimit ?_\n      refine lt_of_lt_of_le ?_ Params.κ_le_μ_ord_cof\n      exact card_typein_lt (· < ·) i Params.κ_ord.symm\n    · simp only [sum_const, Cardinal.lift_id, mul_mk_eq_max, ge_iff_le, max_le_iff, le_refl,\n        and_true]\n      exact Params.κ_lt_μ.le\n  · rw [← mk_α]\n    refine ⟨⟨fun x => ⟨1, fun _ _ => x⟩, ?_⟩⟩\n    intro a₁ a₂ h\n    simp only [Enumeration.mk.injEq, heq_eq_eq, true_and] at h\n    exact congr_fun₂ h 0 κ_zero_lt_one\n", "additional_info": "Given that `#α = #μ`, there are exactly `μ` Enumerations.", "used_premises": [1, 29, 29, 29, 59, 29], "def_path": "ConNF/Structural/Enumeration.lean", "pos": [133, 150], "informalization": "The theorem `ConNF.mk_enumeration` states that if the cardinality of a type `α` is equal to the cardinality of `μ`, then the number of `α`-enumerations, which are functions from an initial segment of `κ` to `α`, is also equal to the cardinality of `μ`."}
{"full_name": "ConNF.Enumeration.image_max", "url": "ConNF/Structural/Enumeration.html#ConNF.Enumeration.image_max", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.Enumeration.image_max [ConNF.Params🔗<|PREMISE|>🔗 ] {α : Type u_1} {β : Type u_2} (E : ConNF.Enumeration🔗<|PREMISE|>🔗 α) (f : α → β) :(ConNF.Enumeration.image🔗<|PREMISE|>🔗 E f).max = E.max", "code": "theorem image_max (E : Enumeration α) (f : α → β) :\n    (E.image f).max = E.max :=\n  rfl\n", "additional_info": "", "used_premises": [1, 59, 244], "def_path": "ConNF/Structural/Enumeration.lean", "pos": [158, 161], "informalization": "The function `ConNF.Enumeration.image` transforms an `α`-enumeration `E` into a `β`-enumeration by applying a function `f : α → β` to each element in the range of `E`. The maximum value of the resulting `β`-enumeration is equal to the maximum value of the original `α`-enumeration."}
{"full_name": "ConNF.Enumeration.image", "url": "ConNF/Structural/Enumeration.html#ConNF.Enumeration.image", "code_src": "con-nf", "ptype": "def", "header": "def ConNF.Enumeration.image [ConNF.Params🔗<|PREMISE|>🔗 ] {α : Type u_1} {β : Type u_2} (E : ConNF.Enumeration🔗<|PREMISE|>🔗 α) (f : α → β) :ConNF.Enumeration🔗<|PREMISE|>🔗 β", "code": "def image (E : Enumeration α) (f : α → β) : Enumeration β where\n  max := E.max\n  f i hi := f (E.f i hi)\n", "additional_info": "Equations\n* 🗟ConNF.Enumeration.image🗟🔗../.././ConNF/Structural/Enumeration.html#ConNF.Enumeration.image🔗  E f 🗟=🗟🔗../.././Init/Prelude.html#Eq🔗  { max := E.max, f := fun (i : ConNF.κ) (hi : i 🗟<🗟🔗../.././Init/Prelude.html#LT.lt🔗  E.max) => f (E.f i hi) }\n\n", "used_premises": [1, 59, 59], "def_path": "ConNF/Structural/Enumeration.lean", "pos": [153, 156], "informalization": "Function `ConNF.Enumeration.image` transforms an `α`-enumeration `E` into a `β`-enumeration by applying a function `f : α → β` to each element in the range of `E`."}
{"full_name": "ConNF.Enumeration.image_f", "url": "ConNF/Structural/Enumeration.html#ConNF.Enumeration.image_f", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.Enumeration.image_f [ConNF.Params🔗<|PREMISE|>🔗 ] {α : Type u_1} {β : Type u_2} (E : ConNF.Enumeration🔗<|PREMISE|>🔗 α) (f : α → β) (i : ConNF.κ) (hi : i < E.max) :(ConNF.Enumeration.image🔗<|PREMISE|>🔗 E f).f i hi = f (E.f i hi)", "code": "theorem image_f (E : Enumeration α) (f : α → β) (i : κ) (hi : i < E.max) :\n    (E.image f).f i hi = f (E.f i hi) :=\n  rfl\n", "additional_info": "", "used_premises": [1, 59, 244], "def_path": "ConNF/Structural/Enumeration.lean", "pos": [163, 166], "informalization": "The function `ConNF.Enumeration.image` transforms an `α`-enumeration `E` into a `β`-enumeration by applying a function `f : α → β` to each element in the range of `E`. The theorem `ConNF.Enumeration.image_f` states that for any `α`-enumeration `E`, any function `f : α → β`, and any `i < E.max`, the `i`-th element of the `β`-enumeration `ConNF.Enumeration.image E f` is equal to `f` applied to the `i`-th element of `E`."}
{"full_name": "ConNF.Enumeration.image_carrier", "url": "ConNF/Structural/Enumeration.html#ConNF.Enumeration.image_carrier", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.Enumeration.image_carrier [ConNF.Params🔗<|PREMISE|>🔗 ] {α : Type u_1} {β : Type u_2} (E : ConNF.Enumeration🔗<|PREMISE|>🔗 α) (f : α → β) :ConNF.Enumeration.carrier🔗<|PREMISE|>🔗 (ConNF.Enumeration.image🔗<|PREMISE|>🔗 E f) = f '' ConNF.Enumeration.carrier🔗<|PREMISE|>🔗 E", "code": "theorem image_carrier (E : Enumeration α) (f : α → β) :\n    (E.image f).carrier = f '' E.carrier := by\n  ext x : 1\n  constructor\n  · rintro ⟨i, hi, h⟩\n    exact ⟨_, ⟨i, hi, rfl⟩, h.symm⟩\n  · rintro ⟨_, ⟨i, hi, rfl⟩, h⟩\n    exact ⟨i, hi, h.symm⟩\n", "additional_info": "", "used_premises": [1, 59, 70, 244, 70], "def_path": "ConNF/Structural/Enumeration.lean", "pos": [168, 176], "informalization": "Function `ConNF.Enumeration.image_carrier` states that the carrier set of the image of an `α`-enumeration `E` under a function `f : α → β` is equal to the image of the carrier set of `E` under `f`."}
{"full_name": "ConNF.Enumeration.image_coe", "url": "ConNF/Structural/Enumeration.html#ConNF.Enumeration.image_coe", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.Enumeration.image_coe [ConNF.Params🔗<|PREMISE|>🔗 ] {α : Type u_1} {β : Type u_2} (E : ConNF.Enumeration🔗<|PREMISE|>🔗 α) (f : α → β) :ConNF.Enumeration.carrier🔗<|PREMISE|>🔗 (ConNF.Enumeration.image🔗<|PREMISE|>🔗 E f) = f '' ConNF.Enumeration.carrier🔗<|PREMISE|>🔗 E", "code": "theorem image_coe (E : Enumeration α) (f : α → β) :\n    (E.image f : Enumeration β) = f '' (E : Set α) :=\n  image_carrier E f\n", "additional_info": "", "used_premises": [1, 59, 70, 244, 70], "def_path": "ConNF/Structural/Enumeration.lean", "pos": [178, 181], "informalization": "The theorem `ConNF.Enumeration.image_coe` states that the carrier set of the image of an `α`-enumeration `E` under a function `f : α → β` is equal to the image of the carrier set of `E` under `f`."}
{"full_name": "ConNF.Enumeration.apply_mem_image", "url": "ConNF/Structural/Enumeration.html#ConNF.Enumeration.apply_mem_image", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.Enumeration.apply_mem_image [ConNF.Params🔗<|PREMISE|>🔗 ] {α : Type u_1} {β : Type u_2} {E : ConNF.Enumeration🔗<|PREMISE|>🔗 α} {x : α} (h : x ∈ E) (f : α → β) :f x ∈ ConNF.Enumeration.image🔗<|PREMISE|>🔗 E f", "code": "theorem apply_mem_image {E : Enumeration α} {x : α} (h : x ∈ E) (f : α → β) : f x ∈ E.image f := by\n  obtain ⟨i, hi, rfl⟩ := h\n  exact ⟨i, hi, rfl⟩\n", "additional_info": "", "used_premises": [1, 59, 244], "def_path": "ConNF/Structural/Enumeration.lean", "pos": [182, 185], "informalization": "The theorem `ConNF.Enumeration.apply_mem_image` states that if `x` is an element of an `α`-enumeration `E` and `f` is a function from `α` to `β`, then `f x` is an element of the `β`-enumeration obtained by applying `f` to each element in the range of `E`."}
{"full_name": "ConNF.Enumeration.apply_eq_of_image_eq", "url": "ConNF/Structural/Enumeration.html#ConNF.Enumeration.apply_eq_of_image_eq", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.Enumeration.apply_eq_of_image_eq [ConNF.Params🔗<|PREMISE|>🔗 ] {α : Type u_1} {E : ConNF.Enumeration🔗<|PREMISE|>🔗 α} (f : α → α) (hE : ConNF.Enumeration.image🔗<|PREMISE|>🔗 E f = E) {x : α} (hx : x ∈ E) :f x = x", "code": "theorem apply_eq_of_image_eq {E : Enumeration α} (f : α → α)\n    (hE : E.image f = E) {x : α} (hx : x ∈ E) : f x = x := by\n  obtain ⟨i, hi, rfl⟩ := hx\n  have := image_f E f i hi\n  conv at this => lhs; simp only [hE]\n  exact this.symm\n", "additional_info": "", "used_premises": [1, 59, 244], "def_path": "ConNF/Structural/Enumeration.lean", "pos": [186, 192], "informalization": "Given an `α`-enumeration `E` and a function `f : α → α`, if the image of `E` under `f` is equal to `E`, and `x` is an element of `E`, then `f x = x`."}
{"full_name": "ConNF.Enumeration.smul_max", "url": "ConNF/Structural/Enumeration.html#ConNF.Enumeration.smul_max", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.Enumeration.smul_max [ConNF.Params🔗<|PREMISE|>🔗 ] {α : Type u_2} {G : Type u_1} [SMul🔗<|PREMISE|>🔗 G α] (g : G) (E : ConNF.Enumeration🔗<|PREMISE|>🔗 α) :(g • E).max = E.max", "code": "theorem smul_max {G : Type _} [SMul G α] (g : G) (E : Enumeration α) :\n    (g • E).max = E.max :=\n  rfl\n", "additional_info": "", "used_premises": [1, 57, 59], "def_path": "ConNF/Structural/Enumeration.lean", "pos": [197, 200], "informalization": "The theorem `ConNF.Enumeration.smul_max` states that for an enumeration `E` of type `α` and a scalar `g` of type `G`, the maximum value of the enumeration `g • E` is equal to the maximum value of the original enumeration `E`."}
{"full_name": "ConNF.Enumeration.smul_f", "url": "ConNF/Structural/Enumeration.html#ConNF.Enumeration.smul_f", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.Enumeration.smul_f [ConNF.Params🔗<|PREMISE|>🔗 ] {α : Type u_2} {G : Type u_1} [SMul🔗<|PREMISE|>🔗 G α] (g : G) (E : ConNF.Enumeration🔗<|PREMISE|>🔗 α) (i : ConNF.κ) (hi : i < E.max) :(g • E).f i hi = g • E.f i hi", "code": "theorem smul_f {G : Type _} [SMul G α]\n    (g : G) (E : Enumeration α) (i : κ) (hi : i < E.max) :\n    (g • E).f i hi = g • E.f i hi :=\n  rfl\n", "additional_info": "", "used_premises": [1, 57, 59], "def_path": "ConNF/Structural/Enumeration.lean", "pos": [202, 206], "informalization": "The theorem `ConNF.Enumeration.smul_f` states that for an `α`-enumeration `E` and an element `g` of a group `G` that acts on `α`, the `i`-th element of the enumeration `g • E` is equal to `g` acting on the `i`-th element of `E`."}
{"full_name": "ConNF.Enumeration.smul_mem_smul", "url": "ConNF/Structural/Enumeration.html#ConNF.Enumeration.smul_mem_smul", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.Enumeration.smul_mem_smul [ConNF.Params🔗<|PREMISE|>🔗 ] {α : Type u_2} {G : Type u_1} [SMul🔗<|PREMISE|>🔗 G α] {E : ConNF.Enumeration🔗<|PREMISE|>🔗 α} {x : α} (h : x ∈ E) (g : G) :g • x ∈ g • E", "code": "theorem smul_mem_smul {G : Type _} [SMul G α]\n    {E : Enumeration α} {x : α} (h : x ∈ E) (g : G) : g • x ∈ g • E :=\n  apply_mem_image h _\n", "additional_info": "", "used_premises": [1, 57, 59], "def_path": "ConNF/Structural/Enumeration.lean", "pos": [217, 220], "informalization": "The theorem `ConNF.Enumeration.smul_mem_smul` is a member of the `ConNF.Enumeration` class in Lean 4. The `ConNF Params` class defines a set of parameters that are used in the context of Constructive Ordinal Notation (ConNF) for constructing natural numbers. The `SMul` class represents the concept of scalar multiplication, and an `α`-enumeration is a function from an initial segment of `κ` to `α`. This theorem states that if `x` is a member of the enumeration `E` and `g` is an element of a group `G` that acts on `α`, then `g • x` is a member of `g • E`."}
{"full_name": "ConNF.Enumeration.smul_eq_of_smul_eq", "url": "ConNF/Structural/Enumeration.html#ConNF.Enumeration.smul_eq_of_smul_eq", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.Enumeration.smul_eq_of_smul_eq [ConNF.Params🔗<|PREMISE|>🔗 ] {α : Type u_2} {G : Type u_1} [SMul🔗<|PREMISE|>🔗 G α] {g : G} {E : ConNF.Enumeration🔗<|PREMISE|>🔗 α} (hE : g • E = E) {x : α} (hx : x ∈ E) :g • x = x", "code": "theorem smul_eq_of_smul_eq {G : Type _} [SMul G α] {g : G} {E : Enumeration α}\n    (hE : g • E = E) {x : α} (hx : x ∈ E) : g • x = x :=\n  apply_eq_of_image_eq _ hE hx\n", "additional_info": "", "used_premises": [1, 57, 59], "def_path": "ConNF/Structural/Enumeration.lean", "pos": [221, 224], "informalization": "The theorem `ConNF.Enumeration.smul_eq_of_smul_eq` states that if `E` is an `α`-enumeration and `g • E = E`, then for any `x` in the range of `E`, `g • x = x`."}
{"full_name": "ConNF.Enumeration.add_max", "url": "ConNF/Structural/Enumeration.html#ConNF.Enumeration.add_max", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.Enumeration.add_max [ConNF.Params🔗<|PREMISE|>🔗 ] {α : Type u_1} {E : ConNF.Enumeration🔗<|PREMISE|>🔗 α} {F : ConNF.Enumeration🔗<|PREMISE|>🔗 α} :(E + F).max = E.max + F.max", "code": "theorem add_max {E F : Enumeration α} : (E + F).max = E.max + F.max :=\n  rfl\n", "additional_info": "", "used_premises": [1, 59, 59], "def_path": "ConNF/Structural/Enumeration.lean", "pos": [257, 259], "informalization": "Function `ConNF.Enumeration.add_max` states that the maximum value of the sum of two enumerations `E` and `F` is equal to the sum of their maximum values."}
{"full_name": "ConNF.Enumeration.add_coe", "url": "ConNF/Structural/Enumeration.html#ConNF.Enumeration.add_coe", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.Enumeration.add_coe [ConNF.Params🔗<|PREMISE|>🔗 ] {α : Type u_1} (E : ConNF.Enumeration🔗<|PREMISE|>🔗 α) (F : ConNF.Enumeration🔗<|PREMISE|>🔗 α) :ConNF.Enumeration.carrier🔗<|PREMISE|>🔗 (E + F) = ConNF.Enumeration.carrier🔗<|PREMISE|>🔗 E ∪ ConNF.Enumeration.carrier🔗<|PREMISE|>🔗 F", "code": "theorem add_coe (E F : Enumeration α) :\n    (E + F : Set α) = (E : Set _) ∪ F := by\n  ext c\n  simp only [mem_carrier_iff, Set.mem_union]\n  constructor\n  · rintro ⟨i, hi, rfl⟩\n    by_cases hi' : i < E.max\n    · refine Or.inl ⟨i, hi', ?_⟩\n      rw [add_f_left]\n    · refine Or.inr ⟨i - E.max, κ_sub_lt hi (not_lt.mp hi'), ?_⟩\n      rw [add_f_right]\n      exact not_lt.mp hi'\n  · rintro (⟨i, hi, rfl⟩ | ⟨i, hi, rfl⟩)\n    · refine ⟨i, hi.trans_le (κ_le_self_add _ _), ?_⟩\n      rw [add_f_left]\n    · refine ⟨E.max + i, add_lt_add_left hi E.max, ?_⟩\n      rw [add_f_right_add]\n", "additional_info": "", "used_premises": [1, 59, 59, 70, 70, 70], "def_path": "ConNF/Structural/Enumeration.lean", "pos": [274, 291], "informalization": "The theorem `ConNF.Enumeration.add_coe` states that the carrier set of the sum of two `α`-enumerations `E` and `F` is the union of the carrier sets of `E` and `F`."}
{"full_name": "ConNF.Enumeration.mem_add_iff", "url": "ConNF/Structural/Enumeration.html#ConNF.Enumeration.mem_add_iff", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.Enumeration.mem_add_iff [ConNF.Params🔗<|PREMISE|>🔗 ] {α : Type u_1} (E : ConNF.Enumeration🔗<|PREMISE|>🔗 α) (F : ConNF.Enumeration🔗<|PREMISE|>🔗 α) (x : α) :x ∈ E + F ↔ x ∈ E ∨ x ∈ F", "code": "theorem mem_add_iff (E F : Enumeration α) (x : α) :\n    x ∈ E + F ↔ x ∈ E ∨ x ∈ F := by\n  change x ∈ (E + F : Set α) ↔ _\n  rw [add_coe]\n  rfl\n", "additional_info": "", "used_premises": [1, 59, 59], "def_path": "ConNF/Structural/Enumeration.lean", "pos": [293, 298], "informalization": "In the context of Constructive Ordinal Notation (ConNF), an `α`-enumeration is a function from an initial segment of `κ` to `α`. The theorem `ConNF.Enumeration.mem_add_iff` states that for two `α`-enumerations `E` and `F`, an element `x` is in the sum of `E` and `F` if and only if `x` is in `E` or `x` is in `F`."}
{"full_name": "ConNF.Enumeration.smul_add", "url": "ConNF/Structural/Enumeration.html#ConNF.Enumeration.smul_add", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.Enumeration.smul_add [ConNF.Params🔗<|PREMISE|>🔗 ] {α : Type u_2} {G : Type u_1} [SMul🔗<|PREMISE|>🔗 G α] {g : G} (E : ConNF.Enumeration🔗<|PREMISE|>🔗 α) (F : ConNF.Enumeration🔗<|PREMISE|>🔗 α) :g • (E + F) = g • E + g • F", "code": "theorem smul_add {G : Type _} [SMul G α] {g : G} (E F : Enumeration α) :\n    g • (E + F) = g • E + g • F := by\n  ext\n  · rfl\n  rw [heq_iff_eq]\n  ext i hi : 2\n  by_cases hi' : i < E.max\n  · rw [smul_f, add_f_left (show i < (g • E).max from hi'), add_f_left hi', smul_f]\n  · rw [smul_f, add_f_right hi (show (g • E).max ≤ i from le_of_not_lt hi'),\n      add_f_right (show i < (g • E + g • F).max from hi)\n        (show (g • E).max ≤ i from le_of_not_lt hi'), smul_f]\n    rfl\n", "additional_info": "", "used_premises": [1, 57, 59, 59], "def_path": "ConNF/Structural/Enumeration.lean", "pos": [300, 312], "informalization": "In the context of Constructive Ordinal Notation (ConNF), an `α`-enumeration is a function from an initial segment of `κ` to `α`. Given two `α`-enumerations `E` and `F`, and a scalar `g`, the theorem `smul_add` states that the scalar multiplication of the sum of `E` and `F` by `g` is equal to the sum of the scalar multiplication of `E` by `g` and the scalar multiplication of `F` by `g`."}
{"full_name": "ConNF.Enumeration.le_iff", "url": "ConNF/Structural/Enumeration.html#ConNF.Enumeration.le_iff", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.Enumeration.le_iff [ConNF.Params🔗<|PREMISE|>🔗 ] {α : Type u_1} (E : ConNF.Enumeration🔗<|PREMISE|>🔗 α) (F : ConNF.Enumeration🔗<|PREMISE|>🔗 α) :E ≤ F ↔ E.max ≤ F.max ∧ ∀ (i : ConNF.κ) (hE : i < E.max) (hF : i < F.max), E.f i hE = F.f i hF", "code": "theorem le_iff (E F : Enumeration α) :\n    E ≤ F ↔ E.max ≤ F.max ∧ ∀ (i : κ) (hE : i < E.max) (hF : i < F.max), E.f i hE = F.f i hF :=\n  Iff.rfl\n", "additional_info": "", "used_premises": [1, 59, 59], "def_path": "ConNF/Structural/Enumeration.lean", "pos": [319, 322], "informalization": "In the context of Constructive Ordinal Notation (ConNF), an `α`-enumeration is a function from an initial segment of `κ` to `α`. The theorem `ConNF.Enumeration.le_iff` states that for two `α`-enumerations `E` and `F`, `E ≤ F` if and only if `E.max ≤ F.max` and for all `i < E.max` and `i < F.max`, `E.f i = F.f i`."}
{"full_name": "ConNF.Enumeration.lt_iff", "url": "ConNF/Structural/Enumeration.html#ConNF.Enumeration.lt_iff", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.Enumeration.lt_iff [ConNF.Params🔗<|PREMISE|>🔗 ] {α : Type u_1} (E : ConNF.Enumeration🔗<|PREMISE|>🔗 α) (F : ConNF.Enumeration🔗<|PREMISE|>🔗 α) :E < F ↔ E.max < F.max ∧ ∀ (i : ConNF.κ) (hE : i < E.max) (hF : i < F.max), E.f i hE = F.f i hF", "code": "theorem lt_iff (E F : Enumeration α) :\n    E < F ↔ E.max < F.max ∧ ∀ (i : κ) (hE : i < E.max) (hF : i < F.max), E.f i hE = F.f i hF :=\n  Iff.rfl\n", "additional_info": "", "used_premises": [1, 59, 59], "def_path": "ConNF/Structural/Enumeration.lean", "pos": [323, 326], "informalization": "In the context of Constructive Ordinal Notation (ConNF), an `α`-enumeration is a function from an initial segment of `κ` to `α`. Given two `α`-enumerations `E` and `F`, `E < F` if and only if `E.max < F.max` and for all `i` less than both `E.max` and `F.max`, `E.f i = F.f i`."}
{"full_name": "ConNF.Enumeration.image_le_image", "url": "ConNF/Structural/Enumeration.html#ConNF.Enumeration.image_le_image", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.Enumeration.image_le_image [ConNF.Params🔗<|PREMISE|>🔗 ] {α : Type u_1} {β : Type u_2} {E : ConNF.Enumeration🔗<|PREMISE|>🔗 α} {F : ConNF.Enumeration🔗<|PREMISE|>🔗 α} (h : E ≤ F) (f : α → β) :ConNF.Enumeration.image🔗<|PREMISE|>🔗 E f ≤ ConNF.Enumeration.image🔗<|PREMISE|>🔗 F f", "code": "theorem image_le_image {E F : Enumeration α} (h : E ≤ F) (f : α → β) : E.image f ≤ F.image f := by\n  constructor\n  · exact h.1\n  · intro i hE hF\n    rw [image_f, image_f, h.2]\n", "additional_info": "", "used_premises": [1, 59, 59, 244, 244], "def_path": "ConNF/Structural/Enumeration.lean", "pos": [346, 351], "informalization": "Function `ConNF.Enumeration.image` transforms an `α`-enumeration `E` into a `β`-enumeration by applying a function `f : α → β` to each element in the range of `E`. The theorem `ConNF.Enumeration.image_le_image` states that if an `α`-enumeration `E` is less than or equal to another `α`-enumeration `F`, then the `β`-enumeration obtained by applying `f` to `E` is also less than or equal to the `β`-enumeration obtained by applying `f` to `F`."}
{"full_name": "ConNF.Enumeration.smul_le_smul", "url": "ConNF/Structural/Enumeration.html#ConNF.Enumeration.smul_le_smul", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.Enumeration.smul_le_smul [ConNF.Params🔗<|PREMISE|>🔗 ] {α : Type u_2} {G : Type u_1} [SMul🔗<|PREMISE|>🔗 G α] {E : ConNF.Enumeration🔗<|PREMISE|>🔗 α} {F : ConNF.Enumeration🔗<|PREMISE|>🔗 α} (h : E ≤ F) (g : G) :g • E ≤ g • F", "code": "theorem smul_le_smul {G : Type _} [SMul G α] {E F : Enumeration α} (h : E ≤ F) (g : G) :\n    g • E ≤ g • F :=\n  image_le_image h (g • ·)\n", "additional_info": "", "used_premises": [1, 57, 59, 59], "def_path": "ConNF/Structural/Enumeration.lean", "pos": [352, 355], "informalization": "The theorem `ConNF.Enumeration.smul_le_smul` states that if `E` and `F` are `α`-enumerations and `E ≤ F`, then for any scalar `g`, the scalar multiplication of `E` by `g` is less than or equal to the scalar multiplication of `F` by `g`."}
{"full_name": "ConNF.Enumeration.le_add", "url": "ConNF/Structural/Enumeration.html#ConNF.Enumeration.le_add", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.Enumeration.le_add [ConNF.Params🔗<|PREMISE|>🔗 ] {α : Type u_1} (E : ConNF.Enumeration🔗<|PREMISE|>🔗 α) (F : ConNF.Enumeration🔗<|PREMISE|>🔗 α) :E ≤ E + F", "code": "theorem le_add (E F : Enumeration α) : E ≤ E + F := by\n  constructor\n  · simp only [add_max, le_add_iff_nonneg_right]\n    exact κ_pos _\n  · intro i hE hF\n    rw [add_f_left]\n", "additional_info": "", "used_premises": [1, 59, 59], "def_path": "ConNF/Structural/Enumeration.lean", "pos": [356, 362], "informalization": "The theorem `ConNF.Enumeration.le_add` states that for any two `α`-enumerations `E` and `F`, the enumeration `E` is less than or equal to the sum of `E` and `F`."}
{"full_name": "ConNF.Enumeration.ord_lt_of_small", "url": "ConNF/Structural/Enumeration.html#ConNF.Enumeration.ord_lt_of_small", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.Enumeration.ord_lt_of_small [ConNF.Params🔗<|PREMISE|>🔗 ] {α : Type u} {s : Set🔗<|PREMISE|>🔗 α} (hs : ConNF.Small🔗<|PREMISE|>🔗 s) [LinearOrder🔗<|PREMISE|>🔗 ↑s] [IsWellOrder🔗<|PREMISE|>🔗 ↑s fun (x x_1 : ↑s) => x < x_1] :(Ordinal.type🔗<|PREMISE|>🔗 fun (x x_1 : ↑s) => x < x_1) < Ordinal.type🔗<|PREMISE|>🔗 fun (x x_1 : ConNF.κ) => x < x_1", "code": "theorem ord_lt_of_small {s : Set α} (hs : Small s) [LinearOrder s] [IsWellOrder s (· < ·)] :\n    type ((· < ·) : s → s → Prop) < type ((· < ·) : κ → κ → Prop) := by\n  by_contra! h\n  have := card_le_card h\n  simp only [card_type] at this\n  exact hs.not_le this\n", "additional_info": "", "used_premises": [1, 69, 233, 2, 15, 26, 26], "def_path": "ConNF/Structural/Enumeration.lean", "pos": [366, 372], "informalization": "The theorem states that, given a set `s` that is strictly smaller than the cardinality of `ConNF.κ` (the type that represents the ordinal numbers in Constructive Ordinal Notation), and `s` is endowed with a linear order and a well-order, the ordinal number corresponding to this well-ordered set is strictly less than the ordinal type of `ConNF.κ`. This theorem is crucial for establishing the well-ordered structure of the natural numbers within the ConNF framework."}
{"full_name": "ConNF.Enumeration.ofSet'_coe", "url": "ConNF/Structural/Enumeration.html#ConNF.Enumeration.ofSet'_coe", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.Enumeration.ofSet'_coe [ConNF.Params🔗<|PREMISE|>🔗 ] {α : Type u} (s : Set🔗<|PREMISE|>🔗 α) (hs : ConNF.Small🔗<|PREMISE|>🔗 s) [LinearOrder🔗<|PREMISE|>🔗 ↑s] [IsWellOrder🔗<|PREMISE|>🔗 ↑s fun (x x_1 : ↑s) => x < x_1] :ConNF.Enumeration.carrier🔗<|PREMISE|>🔗 (ConNF.Enumeration.ofSet'🔗<|PREMISE|>🔗 s hs) = s", "code": "theorem ofSet'_coe (s : Set α) (hs : Small s) [LinearOrder s] [IsWellOrder s (· < ·)] :\n    (ofSet' s hs : Set α) = s := by\n  ext x\n  rw [ofSet', mem_carrier_iff]\n  constructor\n  · rintro ⟨i, hi, rfl⟩\n    exact Subtype.coe_prop _\n  · rintro hx\n    refine ⟨enum ((· < ·) : κ → κ → Prop) (typein ((· < ·) : s → s → Prop) ⟨x, hx⟩) ?_, ?_, ?_⟩\n    · exact (typein_lt_type _ _).trans (ord_lt_of_small hs)\n    · rw [enum_lt_enum (r := ((· < ·) : κ → κ → Prop))]\n      exact typein_lt_type _ _\n    · simp only [typein_enum, enum_typein]\n", "additional_info": "", "used_premises": [1, 69, 233, 2, 15, 70, 265], "def_path": "ConNF/Structural/Enumeration.lean", "pos": [385, 398], "informalization": "Function `ConNF.Enumeration.ofSet'` constructs an `α`-enumeration from a given set `s` of elements of type `α`, provided that `s` is small (i.e., its cardinality is strictly less than the cardinality of the type `ConNF.κ` in the context of Constructive Ordinal Notation (ConNF)), and that `s` is linearly ordered and well-ordered. The `α`-enumeration is represented by a function that maps an initial segment of `ConNF.κ` to `α`. The theorem `ConNF.Enumeration.ofSet'_coe` states that the carrier set of the `α`-enumeration constructed by `ConNF.Enumeration.ofSet'` is equal to the original set `s`."}
{"full_name": "ConNF.Enumeration.ofSet'", "url": "ConNF/Structural/Enumeration.html#ConNF.Enumeration.ofSet'", "code_src": "con-nf", "ptype": "def", "header": "def ConNF.Enumeration.ofSet' [ConNF.Params🔗<|PREMISE|>🔗 ] {α : Type u} (s : Set🔗<|PREMISE|>🔗 α) (hs : ConNF.Small🔗<|PREMISE|>🔗 s) [LinearOrder🔗<|PREMISE|>🔗 ↑s] [IsWellOrder🔗<|PREMISE|>🔗 ↑s fun (x x_1 : ↑s) => x < x_1] :ConNF.Enumeration🔗<|PREMISE|>🔗 α", "code": "def ofSet' (s : Set α) (hs : Small s) [LinearOrder s] [IsWellOrder s (· < ·)] : Enumeration α where\n  max := enum (· < ·) (type ((· < ·) : s → s → Prop)) (ord_lt_of_small hs)\n  f i hi := (enum ((· < ·) : s → s → Prop) (typein ((· < ·) : κ → κ → Prop) i)\n    (typein_lt_type_of_small hs hi) : s)\n", "additional_info": "Equations\n* One or more equations did not get rendered due to their size.\n\n", "used_premises": [1, 69, 233, 2, 15, 59], "def_path": "ConNF/Structural/Enumeration.lean", "pos": [379, 383], "informalization": "Function `ConNF.Enumeration.ofSet'` constructs an `α`-enumeration from a given set `s` of elements of type `α`, provided that `s` is small (i.e., its cardinality is strictly less than the cardinality of the type `ConNF.κ` in the context of Constructive Ordinal Notation (ConNF)), and that `s` is linearly ordered and well-ordered. The `α`-enumeration is represented by a function that maps an initial segment of `ConNF.κ` to `α`."}
{"full_name": "ConNF.Enumeration.ofSet_coe", "url": "ConNF/Structural/Enumeration.html#ConNF.Enumeration.ofSet_coe", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.Enumeration.ofSet_coe [ConNF.Params🔗<|PREMISE|>🔗 ] {α : Type u} (s : Set🔗<|PREMISE|>🔗 α) (hs : ConNF.Small🔗<|PREMISE|>🔗 s) :ConNF.Enumeration.carrier🔗<|PREMISE|>🔗 (ConNF.Enumeration.ofSet🔗<|PREMISE|>🔗 s hs) = s", "code": "theorem ofSet_coe (s : Set α) (hs : Small s) :\n    (ofSet s hs : Set α) = s :=\n  letI := (IsWellOrder.subtype_nonempty (σ := s)).some.prop\n  letI := linearOrderOfSTO (IsWellOrder.subtype_nonempty (σ := s)).some.val\n  ofSet'_coe s hs\n", "additional_info": "", "used_premises": [1, 69, 233, 70, 267], "def_path": "ConNF/Structural/Enumeration.lean", "pos": [405, 410], "informalization": "The theorem `ConNF.Enumeration.ofSet_coe` states that for any set `s` whose cardinality is strictly less than the cardinality of `ConNF.κ`, the carrier set of the `α`-enumeration `ConNF.Enumeration.ofSet s hs` is equal to `s`."}
{"full_name": "ConNF.Enumeration.ofSet", "url": "ConNF/Structural/Enumeration.html#ConNF.Enumeration.ofSet", "code_src": "con-nf", "ptype": "def", "header": "def ConNF.Enumeration.ofSet [ConNF.Params🔗<|PREMISE|>🔗 ] {α : Type u} (s : Set🔗<|PREMISE|>🔗 α) (hs : ConNF.Small🔗<|PREMISE|>🔗 s) :ConNF.Enumeration🔗<|PREMISE|>🔗 α", "code": "def ofSet (s : Set α) (hs : Small s) : Enumeration α :=\n  letI := (IsWellOrder.subtype_nonempty (σ := s)).some.prop\n  letI := linearOrderOfSTO (IsWellOrder.subtype_nonempty (σ := s)).some.val\n  ofSet' s hs\n", "additional_info": "Equations\n* 🗟ConNF.Enumeration.ofSet🗟🔗../.././ConNF/Structural/Enumeration.html#ConNF.Enumeration.ofSet🔗  s hs 🗟=🗟🔗../.././Init/Prelude.html#Eq🔗  🗟ConNF.Enumeration.ofSet'🗟🔗../.././ConNF/Structural/Enumeration.html#ConNF.Enumeration.ofSet'🔗  s hs\n\n", "used_premises": [1, 69, 233, 59], "def_path": "ConNF/Structural/Enumeration.lean", "pos": [399, 403], "informalization": "Function `ConNF.Enumeration.ofSet` takes a set `s` and a proof that the cardinality of `s` is strictly less than the cardinality of `ConNF.κ`, and returns an `α`-enumeration, which is a function from an initial segment of `ConNF.κ` to `α`."}
{"full_name": "ConNF.Enumeration.mem_ofSet_iff", "url": "ConNF/Structural/Enumeration.html#ConNF.Enumeration.mem_ofSet_iff", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.Enumeration.mem_ofSet_iff [ConNF.Params🔗<|PREMISE|>🔗 ] {α : Type u} (s : Set🔗<|PREMISE|>🔗 α) (hs : ConNF.Small🔗<|PREMISE|>🔗 s) (x : α) :x ∈ ConNF.Enumeration.ofSet🔗<|PREMISE|>🔗 s hs ↔ x ∈ s", "code": "theorem mem_ofSet_iff (s : Set α) (hs : Small s) (x : α) :\n    x ∈ ofSet s hs ↔ x ∈ s := by\n  change x ∈ (ofSet s hs : Set α) ↔ x ∈ s\n  rw [ofSet_coe]\n", "additional_info": "", "used_premises": [1, 69, 233, 267], "def_path": "ConNF/Structural/Enumeration.lean", "pos": [412, 416], "informalization": "The theorem `ConNF.Enumeration.mem_ofSet_iff` states that for any set `s` whose cardinality is strictly less than the cardinality of `ConNF.κ`, and any element `x` of type `α`, `x` belongs to the enumeration of `s` if and only if `x` belongs to `s`."}
{"full_name": "ConNF.Enumeration.chooseIndex_lt", "url": "ConNF/Structural/Enumeration.html#ConNF.Enumeration.chooseIndex_lt", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.Enumeration.chooseIndex_lt [ConNF.Params🔗<|PREMISE|>🔗 ] {α : Type u_1} {E : ConNF.Enumeration🔗<|PREMISE|>🔗 α} {p : α → Prop } (h : ∃ (i : ConNF.κ) (h : i < E.max), p (E.f i h)) :ConNF.Enumeration.chooseIndex🔗<|PREMISE|>🔗 E p h < E.max", "code": "theorem chooseIndex_lt {E : Enumeration α} {p : α → Prop}\n    (h : ∃ i : κ, ∃ h : i < E.max, p (E.f i h)) : E.chooseIndex p h < E.max :=\n  h.choose_spec.choose\n", "additional_info": "", "used_premises": [1, 59, 270], "def_path": "ConNF/Structural/Enumeration.lean", "pos": [421, 424], "informalization": "Function `ConNF.Enumeration.chooseIndex` takes an enumeration `E` of type `α`, a predicate `p` on `α`, and a proof `h` that there exists an index `i < E.max` such that `p (E.f i h)`. It returns the smallest such index `i`. The theorem `ConNF.Enumeration.chooseIndex_lt` proves that this index `i` is indeed less than `E.max`."}
{"full_name": "ConNF.Enumeration.chooseIndex", "url": "ConNF/Structural/Enumeration.html#ConNF.Enumeration.chooseIndex", "code_src": "con-nf", "ptype": "def", "header": "def ConNF.Enumeration.chooseIndex [ConNF.Params🔗<|PREMISE|>🔗 ] {α : Type u_1} (E : ConNF.Enumeration🔗<|PREMISE|>🔗 α) (p : α → Prop ) (h : ∃ (i : ConNF.κ) (h : i < E.max), p (E.f i h)) :ConNF.κ", "code": "def chooseIndex (E : Enumeration α) (p : α → Prop)\n    (h : ∃ i : κ, ∃ h : i < E.max, p (E.f i h)) : κ :=\n  h.choose\n", "additional_info": "Equations\n* 🗟ConNF.Enumeration.chooseIndex🗟🔗../.././ConNF/Structural/Enumeration.html#ConNF.Enumeration.chooseIndex🔗  E p h 🗟=🗟🔗../.././Init/Prelude.html#Eq🔗  🗟Exists.choose🗟🔗../.././Init/Classical.html#Exists.choose🔗  h\n\n", "used_premises": [1, 59], "def_path": "ConNF/Structural/Enumeration.lean", "pos": [417, 420], "informalization": "Function `ConNF.Enumeration.chooseIndex` takes an enumeration `E` of type `α`, a predicate `p` on `α`, and a proof `h` that there exists an index `i < E.max` such that `p (E.f i h)`. It returns the smallest such index `i`."}
{"full_name": "ConNF.le_of_path", "url": "ConNF/Structural/Index.html#ConNF.le_of_path", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.le_of_path [ConNF.Params🔗<|PREMISE|>🔗 ] {α : ConNF.TypeIndex} {β : ConNF.TypeIndex} :Quiver.Path🔗<|PREMISE|>🔗 α β → β ≤ α", "code": "theorem le_of_path : ∀ {β : TypeIndex}, Path α β → β ≤ α\n  | _, nil => le_rfl\n  | _, cons p f => (le_of_lt f).trans <| le_of_path p\n", "additional_info": "If there is a path between `🗟α🗟🔗../.././ConNF/Structural/Index.html#ConNF.Level.α🔗`  and `β`, we must have `β ≤ 🗟α🗟🔗../.././ConNF/Structural/Index.html#ConNF.Level.α🔗` .\nThe case `β = 🗟α🗟🔗../.././ConNF/Structural/Index.html#ConNF.Level.α🔗`  can occur with the nil path.", "used_premises": [1, 76], "def_path": "ConNF/Structural/Index.lean", "pos": [64, 67], "informalization": "The theorem `ConNF.le_of_path` states that if there is a path between two types `α` and `β` in the context of Constructive Ordinal Notation (ConNF), then `β` must be less than or equal to `α`. The case where `β = α` can occur with the nil path."}
{"full_name": "ConNF.path_eq_nil", "url": "ConNF/Structural/Index.html#ConNF.path_eq_nil", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.path_eq_nil [ConNF.Params🔗<|PREMISE|>🔗 ] {α : ConNF.TypeIndex} (p : Quiver.Path🔗<|PREMISE|>🔗 α α) :p = Quiver.Path.nil", "code": "theorem path_eq_nil : ∀ p : Path α α, p = nil\n  | nil => rfl\n  | cons p f => ((le_of_path p).not_lt f).elim\n", "additional_info": "", "used_premises": [1, 76], "def_path": "ConNF/Structural/Index.lean", "pos": [68, 71], "informalization": "The theorem `ConNF.path_eq_nil` states that in the context of Constructive Ordinal Notation (ConNF), the only path from a vertex to itself is the trivial path."}
{"full_name": "ConNF.ExtendedIndex.length_ne_zero", "url": "ConNF/Structural/Index.html#ConNF.ExtendedIndex.length_ne_zero", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.ExtendedIndex.length_ne_zero [ConNF.Params🔗<|PREMISE|>🔗 ] {α : ConNF.Λ} (A : ConNF.ExtendedIndex🔗<|PREMISE|>🔗 ↑α) :Quiver.Path.length🔗<|PREMISE|>🔗 A ≠ 0", "code": "theorem ExtendedIndex.length_ne_zero {α : Λ} (A : ExtendedIndex α) : A.length ≠ 0 := by\n  intro h\n  cases Quiver.Path.eq_of_length_zero A h\n", "additional_info": "", "used_premises": [1, 61, 137], "def_path": "ConNF/Structural/Index.lean", "pos": [72, 75], "informalization": "Function `ConNF.ExtendedIndex` defines a finite path from a type `α` to the base type `⊥` in the context of Constructive Ordinal Notation (ConNF). This path represents a way to understand extensionality by iteratively descending to lower types in the hierarchy until reaching the base type. Since `Λ` is well-ordered, there are no infinite descending paths. Function `Quiver.Path.length` calculates the length of a path in a quiver, which is defined as the number of arrows in the path. For a trivial path (`nil`), the length is 0, and for a path extended by an arrow (`cons`), the length is the length of the previous path plus 1. The theorem `ConNF.ExtendedIndex.length_ne_zero` states that the length of any non-trivial `ConNF.ExtendedIndex` path is not zero."}
{"full_name": "ConNF.mk_extendedIndex", "url": "ConNF/Structural/Index.html#ConNF.mk_extendedIndex", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.mk_extendedIndex [ConNF.Params🔗<|PREMISE|>🔗 ] (α : ConNF.TypeIndex) :Cardinal.mk🔗<|PREMISE|>🔗 (ConNF.ExtendedIndex🔗<|PREMISE|>🔗 α) ≤ Cardinal.mk🔗<|PREMISE|>🔗 ConNF.Λ", "code": "theorem mk_extendedIndex (α : TypeIndex) : #(ExtendedIndex α) ≤ #Λ := by\n  refine le_trans ((Cardinal.le_def _ _).2 ⟨⟨toList, toList_injective (α : TypeIndex) ⊥⟩⟩) ?_\n  convert mk_list_le_max _ using 1\n  simp only [mk_typeIndex, max_eq_right, aleph0_le_mk]\n", "additional_info": "There are at most `Λ` `🗟α🗟🔗../.././ConNF/Structural/Index.html#ConNF.Level.α🔗` -extended type indices.", "used_premises": [1, 29, 61, 29], "def_path": "ConNF/Structural/Index.lean", "pos": [78, 82], "informalization": "Function `ConNF.mk_extendedIndex` proves that the cardinality of the set of `α`-extended type indices is less than or equal to the cardinality of `Λ`."}
{"full_name": "ConNF.mk_extendedIndex_ne_zero", "url": "ConNF/Structural/Index.html#ConNF.mk_extendedIndex_ne_zero", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.mk_extendedIndex_ne_zero [ConNF.Params🔗<|PREMISE|>🔗 ] (α : ConNF.TypeIndex) :Cardinal.mk🔗<|PREMISE|>🔗 (ConNF.ExtendedIndex🔗<|PREMISE|>🔗 α) ≠ 0", "code": "theorem mk_extendedIndex_ne_zero (α : TypeIndex) : #(ExtendedIndex α) ≠ 0 :=\n  Cardinal.mk_ne_zero _\n", "additional_info": "There exists an `🗟α🗟🔗../.././ConNF/Structural/Index.html#ConNF.Level.α🔗` -extended type index. -", "used_premises": [1, 29, 61], "def_path": "ConNF/Structural/Index.lean", "pos": [94, 96], "informalization": "There exists an `α` -extended type index."}
{"full_name": "ConNF.Pretangle.toBot_symm", "url": "ConNF/Structural/Pretangle.html#ConNF.Pretangle.toBot_symm", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.Pretangle.toBot_symm [ConNF.Params🔗<|PREMISE|>🔗 ] :ConNF.Pretangle.toBot.symm = ConNF.Pretangle.ofBot", "code": "theorem toBot_symm : toBot.symm = ofBot :=\n  rfl\n", "additional_info": "", "used_premises": [1], "def_path": "ConNF/Structural/Pretangle.lean", "pos": [45, 47], "informalization": "The theorem `ConNF.Pretangle.toBot_symm` states that the inverse of the function `ConNF.Pretangle.toBot` is equal to the function `ConNF.Pretangle.ofBot` in the context of Constructive Ordinal Notation (ConNF)."}
{"full_name": "ConNF.Pretangle.ofBot_symm", "url": "ConNF/Structural/Pretangle.html#ConNF.Pretangle.ofBot_symm", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.Pretangle.ofBot_symm [ConNF.Params🔗<|PREMISE|>🔗 ] :ConNF.Pretangle.ofBot.symm = ConNF.Pretangle.toBot", "code": "theorem ofBot_symm : ofBot.symm = toBot :=\n  rfl\n", "additional_info": "", "used_premises": [1], "def_path": "ConNF/Structural/Pretangle.lean", "pos": [49, 51], "informalization": "The theorem `ConNF.Pretangle.ofBot_symm` states that the inverse of the function `ConNF.Pretangle.ofBot` is equal to `ConNF.Pretangle.toBot` in the context of Constructive Ordinal Notation (ConNF)."}
{"full_name": "ConNF.Pretangle.toBot_ofBot", "url": "ConNF/Structural/Pretangle.html#ConNF.Pretangle.toBot_ofBot", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.Pretangle.toBot_ofBot [ConNF.Params🔗<|PREMISE|>🔗 ] (a : ConNF.Pretangle🔗<|PREMISE|>🔗 ⊥ ) :ConNF.Pretangle.toBot (ConNF.Pretangle.ofBot a) = a", "code": "theorem toBot_ofBot (a) : toBot (ofBot a) = a := by aesop\n", "additional_info": "", "used_premises": [1, 279], "def_path": "ConNF/Structural/Pretangle.lean", "pos": [61, 62], "informalization": "The theorem `ConNF.Pretangle.toBot_ofBot` states that for any pretangle `a` in the context of Constructive Ordinal Notation (ConNF), the operation `ConNF.Pretangle.ofBot` followed by `ConNF.Pretangle.toBot` returns the original pretangle `a`."}
{"full_name": "ConNF.Pretangle", "url": "ConNF/Structural/Pretangle.html#ConNF.Pretangle", "code_src": "con-nf", "ptype": "def", "header": "def ConNF.Pretangle [ConNF.Params🔗<|PREMISE|>🔗 ] :ConNF.TypeIndex → Type u", "code": "def Pretangle : TypeIndex → Type u\n  | ⊥ => Atom\n  | (α : Λ) => ∀ β : TypeIndex, β < α → Set (Pretangle β)\ntermination_by x => x\n", "additional_info": "A *pretangle* is an object that may become a *tangle*, an element of the model.\nThe type of pretangles forms a model of TTT without extensionality.\nEquations\n* 🗟ConNF.Pretangle🗟🔗../.././ConNF/Structural/Pretangle.html#ConNF.Pretangle🔗  none 🗟=🗟🔗../.././Init/Prelude.html#Eq🔗  ConNF.Atom\n* 🗟ConNF.Pretangle🗟🔗../.././ConNF/Structural/Pretangle.html#ConNF.Pretangle🔗  (🗟some🗟🔗../.././Init/Prelude.html#Option.some🔗  α) 🗟=🗟🔗../.././Init/Prelude.html#Eq🔗  ((β : ConNF.TypeIndex) → β 🗟<🗟🔗../.././Init/Prelude.html#LT.lt🔗  ↑α → 🗟Set🗟🔗../.././Mathlib/Init/Set.html#Set🔗  (🗟ConNF.Pretangle🗟🔗../.././ConNF/Structural/Pretangle.html#ConNF.Pretangle🔗  β))\n\n", "used_premises": [1], "def_path": "ConNF/Structural/Pretangle.lean", "pos": [21, 25], "informalization": "Function `ConNF.Pretangle` defines a pretangle in the context of Constructive Ordinal Notation (ConNF), which is an object that may become a tangle, an element of the model. The type of pretangles forms a model of TTT without extensionality."}
{"full_name": "ConNF.Pretangle.ofBot_toBot", "url": "ConNF/Structural/Pretangle.html#ConNF.Pretangle.ofBot_toBot", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.Pretangle.ofBot_toBot [ConNF.Params🔗<|PREMISE|>🔗 ] (a : ConNF.Atom) :ConNF.Pretangle.ofBot (ConNF.Pretangle.toBot a) = a", "code": "theorem ofBot_toBot (a) : ofBot (toBot a) = a := by aesop\n", "additional_info": "", "used_premises": [1], "def_path": "ConNF/Structural/Pretangle.lean", "pos": [64, 65], "informalization": "The theorem `ConNF.Pretangle.ofBot_toBot` states that for any `ConNF.Atom` `a`, converting `a` to a `ConNF.Pretangle` using `ConNF.Pretangle.toBot` and then back to an `ConNF.Atom` using `ConNF.Pretangle.ofBot` results in the original `ConNF.Atom` `a`."}
{"full_name": "ConNF.Pretangle.toCoe_ofCoe", "url": "ConNF/Structural/Pretangle.html#ConNF.Pretangle.toCoe_ofCoe", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.Pretangle.toCoe_ofCoe [ConNF.Params🔗<|PREMISE|>🔗 ] {α : ConNF.Λ} (a : ConNF.Pretangle🔗<|PREMISE|>🔗 ↑α) :ConNF.Pretangle.toCoe (ConNF.Pretangle.ofCoe a) = a", "code": "theorem toCoe_ofCoe (a : Pretangle α) : toCoe (ofCoe a) = a := by simp [toCoe, ofCoe]\n", "additional_info": "", "used_premises": [1, 279], "def_path": "ConNF/Structural/Pretangle.lean", "pos": [67, 68], "informalization": "The theorem `ConNF.Pretangle.toCoe_ofCoe` states that the function `ConNF.Pretangle.toCoe` is the left inverse of the function `ConNF.Pretangle.ofCoe`. This means that applying `ConNF.Pretangle.ofCoe` to a pretangle and then applying `ConNF.Pretangle.toCoe` to the result will return the original pretangle."}
{"full_name": "ConNF.Pretangle.ofCoe_toCoe", "url": "ConNF/Structural/Pretangle.html#ConNF.Pretangle.ofCoe_toCoe", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.Pretangle.ofCoe_toCoe [ConNF.Params🔗<|PREMISE|>🔗 ] {α : ConNF.Λ} (a : (β : ConNF.TypeIndex) → β < ↑α → Set🔗<|PREMISE|>🔗 (ConNF.Pretangle🔗<|PREMISE|>🔗 β)) :ConNF.Pretangle.ofCoe (ConNF.Pretangle.toCoe a) = a", "code": "theorem ofCoe_toCoe (a) : ofCoe (toCoe a : Pretangle α) = a := by simp [toCoe, ofCoe]\n", "additional_info": "", "used_premises": [1, 69, 279], "def_path": "ConNF/Structural/Pretangle.lean", "pos": [70, 71], "informalization": "The theorem `ConNF.Pretangle.ofCoe_toCoe` states that the function `ConNF.Pretangle.ofCoe` is the left inverse of the function `ConNF.Pretangle.toCoe`. This means that applying `ConNF.Pretangle.ofCoe` to the result of `ConNF.Pretangle.toCoe` returns the original argument."}
{"full_name": "ConNF.Pretangle.toBot_inj", "url": "ConNF/Structural/Pretangle.html#ConNF.Pretangle.toBot_inj", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.Pretangle.toBot_inj [ConNF.Params🔗<|PREMISE|>🔗 ] {a : ConNF.Atom} {b : ConNF.Atom} :ConNF.Pretangle.toBot a = ConNF.Pretangle.toBot b ↔ a = b", "code": "theorem toBot_inj {a b} : toBot a = toBot b ↔ a = b :=\n  toBot.injective.eq_iff\n", "additional_info": "", "used_premises": [1], "def_path": "ConNF/Structural/Pretangle.lean", "pos": [73, 75], "informalization": "Function `ConNF.Pretangle.toBot_inj` is a theorem in Lean 4 that states the injectivity of the function `ConNF.Pretangle.toBot` in the context of Constructive Ordinal Notation (ConNF). It asserts that two `ConNF.Atom`s are equal if and only if their images under the function `ConNF.Pretangle.toBot` are equal."}
{"full_name": "ConNF.Pretangle.ofBot_inj", "url": "ConNF/Structural/Pretangle.html#ConNF.Pretangle.ofBot_inj", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.Pretangle.ofBot_inj [ConNF.Params🔗<|PREMISE|>🔗 ] {a : ConNF.Pretangle🔗<|PREMISE|>🔗 ⊥ } {b : ConNF.Pretangle🔗<|PREMISE|>🔗 ⊥ } :ConNF.Pretangle.ofBot a = ConNF.Pretangle.ofBot b ↔ a = b", "code": "theorem ofBot_inj {a b} : ofBot a = ofBot b ↔ a = b :=\n  ofBot.injective.eq_iff\n", "additional_info": "", "used_premises": [1, 279, 279], "def_path": "ConNF/Structural/Pretangle.lean", "pos": [77, 79], "informalization": "The theorem `ConNF.Pretangle.ofBot_inj` states that the function `ConNF.Pretangle.ofBot` is injective, meaning that it maps distinct pretangles to distinct tangles."}
{"full_name": "ConNF.Pretangle.toCoe_inj", "url": "ConNF/Structural/Pretangle.html#ConNF.Pretangle.toCoe_inj", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.Pretangle.toCoe_inj [ConNF.Params🔗<|PREMISE|>🔗 ] {α : ConNF.Λ} {a : (β : ConNF.TypeIndex) → β < ↑α → Set🔗<|PREMISE|>🔗 (ConNF.Pretangle🔗<|PREMISE|>🔗 β)} {b : (β : ConNF.TypeIndex) → β < ↑α → Set🔗<|PREMISE|>🔗 (ConNF.Pretangle🔗<|PREMISE|>🔗 β)} :ConNF.Pretangle.toCoe a = ConNF.Pretangle.toCoe b ↔ a = b", "code": "theorem toCoe_inj {a b} : (toCoe a : Pretangle α) = toCoe b ↔ a = b :=\n  toCoe.injective.eq_iff\n", "additional_info": "", "used_premises": [1, 69, 279, 69, 279], "def_path": "ConNF/Structural/Pretangle.lean", "pos": [81, 83], "informalization": "The theorem `ConNF.Pretangle.toCoe_inj` states that the function `ConNF.Pretangle.toCoe` is injective. This means that if two pretangles `a` and `b` have the same image under the function `ConNF.Pretangle.toCoe`, then `a` must be equal to `b`."}
{"full_name": "ConNF.Pretangle.ofCoe_inj", "url": "ConNF/Structural/Pretangle.html#ConNF.Pretangle.ofCoe_inj", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.Pretangle.ofCoe_inj [ConNF.Params🔗<|PREMISE|>🔗 ] {α : ConNF.Λ} {a : ConNF.Pretangle🔗<|PREMISE|>🔗 ↑α} {b : ConNF.Pretangle🔗<|PREMISE|>🔗 ↑α} :ConNF.Pretangle.ofCoe a = ConNF.Pretangle.ofCoe b ↔ a = b", "code": "theorem ofCoe_inj {a b : Pretangle α} : ofCoe a = ofCoe b ↔ a = b :=\n  ofCoe.injective.eq_iff\n", "additional_info": "", "used_premises": [1, 279, 279], "def_path": "ConNF/Structural/Pretangle.lean", "pos": [85, 87], "informalization": "`ConNF.Pretangle.ofCoe_inj` is a theorem in Lean 4 that states the injectivity of the `ConNF.Pretangle.ofCoe` function in the context of Constructive Ordinal Notation (ConNF). This theorem asserts that two pretangles `a` and `b` are equal if and only if their images under the `ConNF.Pretangle.ofCoe` function are equal."}
{"full_name": "ConNF.Pretangle.coe_ext", "url": "ConNF/Structural/Pretangle.html#ConNF.Pretangle.coe_ext", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.Pretangle.coe_ext [ConNF.Params🔗<|PREMISE|>🔗 ] {α : ConNF.Λ} {a : ConNF.Pretangle🔗<|PREMISE|>🔗 ↑α} {b : ConNF.Pretangle🔗<|PREMISE|>🔗 ↑α} :a = b ↔ ∀ (β : ConNF.TypeIndex) (hβ : β < ↑α) (t : ConNF.Pretangle🔗<|PREMISE|>🔗 β), t ∈ ConNF.Pretangle.ofCoe a β hβ ↔ t ∈ ConNF.Pretangle.ofCoe b β hβ", "code": "theorem coe_ext {α : Λ} {a b : Pretangle α} :\n    a = b ↔ ∀ β hβ t, t ∈ ofCoe a β hβ ↔ t ∈ ofCoe b β hβ := by\n  constructor\n  · rintro rfl\n    simp only [implies_true, forall_const]\n  intro h\n  rw [← ofCoe_inj]\n  ext β hβ t\n  exact h β hβ t\n", "additional_info": "", "used_premises": [1, 279, 279, 279], "def_path": "ConNF/Structural/Pretangle.lean", "pos": [88, 97], "informalization": "The theorem `ConNF.Pretangle.coe_ext` states that two pretangles are equal if and only if they have the same members at each type level, corresponding to restrictions of the pretangles to each type level. This theorem is crucial for proving the extensionality axiom in the context of Constructive Ordinal Notation."}
{"full_name": "ConNF.Tree.toBot_ofBot", "url": "ConNF/Structural/Tree.html#ConNF.Tree.toBot_ofBot", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.Tree.toBot_ofBot [ConNF.Params🔗<|PREMISE|>🔗 ] {τ : Type u} (a : ConNF.Tree🔗<|PREMISE|>🔗 τ ⊥ ) :ConNF.Tree.toBot (ConNF.Tree.ofBot a) = a", "code": "theorem toBot_ofBot (a : Tree τ ⊥) : toBot (ofBot a) = a := by\n  funext A\n  cases path_eq_nil A\n  rfl\n", "additional_info": "", "used_premises": [1, 289], "def_path": "ConNF/Structural/Tree.lean", "pos": [60, 64], "informalization": "In the context of Constructive Ordinal Notation (ConNF), the theorem `ConNF.Tree.toBot_ofBot` states that the function `ConNF.Tree.toBot`, which maps an `α`-tree of `τ` to a `⊥`-tree of `τ`, is the left inverse of the function `ConNF.Tree.ofBot`, which maps a `⊥`-tree of `τ` to an `α`-tree of `τ`."}
{"full_name": "ConNF.Tree", "url": "ConNF/Structural/Tree.html#ConNF.Tree", "code_src": "con-nf", "ptype": "def", "header": "def ConNF.Tree [ConNF.Params🔗<|PREMISE|>🔗 ] (τ : Type u) (α : ConNF.TypeIndex) :Type u", "code": "def Tree (τ : Type u) (α : TypeIndex) : Type u :=\n  ExtendedIndex α → τ\n", "additional_info": "For each type index `α`, an `α`-tree of `τ` is a function from `α`-extended type indices to\n`τ`.\nEquations\n* 🗟ConNF.Tree🗟🔗../.././ConNF/Structural/Tree.html#ConNF.Tree🔗  τ α 🗟=🗟🔗../.././Init/Prelude.html#Eq🔗  (🗟ConNF.ExtendedIndex🗟🔗../.././ConNF/Structural/Index.html#ConNF.ExtendedIndex🔗  α → τ)\n\n", "used_premises": [1], "def_path": "ConNF/Structural/Tree.lean", "pos": [28, 30], "informalization": "In the context of Constructive Ordinal Notation (ConNF), an `α`-tree of `τ` is defined as a function from `α`-extended type indices to `τ`. This function maps each `α`-extended type index to a value of type `τ`."}
{"full_name": "ConNF.Tree.ofBot_toBot", "url": "ConNF/Structural/Tree.html#ConNF.Tree.ofBot_toBot", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.Tree.ofBot_toBot [ConNF.Params🔗<|PREMISE|>🔗 ] {τ : Type u} (a : τ) :ConNF.Tree.ofBot (ConNF.Tree.toBot a) = a", "code": "theorem ofBot_toBot (a : τ) : ofBot (toBot a) = a := rfl\n", "additional_info": "", "used_premises": [1], "def_path": "ConNF/Structural/Tree.lean", "pos": [66, 67], "informalization": "The theorem `ConNF.Tree.ofBot_toBot` states that the function `ConNF.Tree.ofBot` is the left inverse of the function `ConNF.Tree.toBot`. This means that for any element `a` of type `τ`, applying `ConNF.Tree.toBot` to `a` and then applying `ConNF.Tree.ofBot` to the result will return the original element `a`."}
{"full_name": "ConNF.Tree.toBot_inj", "url": "ConNF/Structural/Tree.html#ConNF.Tree.toBot_inj", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.Tree.toBot_inj [ConNF.Params🔗<|PREMISE|>🔗 ] {τ : Type u} {a : τ} {b : τ} :ConNF.Tree.toBot a = ConNF.Tree.toBot b ↔ a = b", "code": "theorem toBot_inj {a b : τ} : toBot a = toBot b ↔ a = b :=\n  toBot.injective.eq_iff\n", "additional_info": "", "used_premises": [1], "def_path": "ConNF/Structural/Tree.lean", "pos": [69, 71], "informalization": "`ConNF.Tree.toBot_inj` is a theorem in Lean 4 that states the injectivity of the function `ConNF.Tree.toBot` in the context of Constructive Ordinal Notation (ConNF). Specifically, it asserts that for any two elements `a` and `b` of the same type `τ`, the equation `ConNF.Tree.toBot a = ConNF.Tree.toBot b` holds if and only if `a = b`."}
{"full_name": "ConNF.Tree.ofBot_inj", "url": "ConNF/Structural/Tree.html#ConNF.Tree.ofBot_inj", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.Tree.ofBot_inj [ConNF.Params🔗<|PREMISE|>🔗 ] {τ : Type u} {a : ConNF.Tree🔗<|PREMISE|>🔗 τ ⊥ } {b : ConNF.Tree🔗<|PREMISE|>🔗 τ ⊥ } :ConNF.Tree.ofBot a = ConNF.Tree.ofBot b ↔ a = b", "code": "theorem ofBot_inj {a b : Tree τ ⊥} : ofBot a = ofBot b ↔ a = b :=\n  ofBot.injective.eq_iff\n", "additional_info": "", "used_premises": [1, 289, 289], "def_path": "ConNF/Structural/Tree.lean", "pos": [73, 75], "informalization": "In the context of Constructive Ordinal Notation (ConNF), an `α`-tree of `τ` is defined as a function from `α`-extended type indices to `τ`. This function maps each `α`-extended type index to a value of type `τ`. The theorem `ConNF.Tree.ofBot_inj` states that for any two `⊥`-trees `a` and `b` of type `τ`, the equation `ConNF.Tree.ofBot a = ConNF.Tree.ofBot b` holds if and only if `a = b`."}
{"full_name": "ConNF.Tree.ext", "url": "ConNF/Structural/Tree.html#ConNF.Tree.ext", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.Tree.ext [ConNF.Params🔗<|PREMISE|>🔗 ] {τ : Type u} {α : ConNF.TypeIndex} (a : ConNF.Tree🔗<|PREMISE|>🔗 τ α) (b : ConNF.Tree🔗<|PREMISE|>🔗 τ α) (h : ∀ (A : ConNF.ExtendedIndex🔗<|PREMISE|>🔗 α), a A = b A) :a = b", "code": "theorem ext {α : TypeIndex} (a b : Tree τ α) (h : ∀ A, a A = b A) : a = b :=\n  funext h\n", "additional_info": "", "used_premises": [1, 289, 289, 61], "def_path": "ConNF/Structural/Tree.lean", "pos": [77, 79], "informalization": "Function `ConNF.Tree.ext` is an extensionality theorem for trees in the context of Constructive Ordinal Notation (ConNF). It states that if two trees `a` and `b` of type `τ` and index `α` are equal at every extended index `A`, then the trees themselves are equal."}
{"full_name": "ConNF.Tree.mul_apply", "url": "ConNF/Structural/Tree.html#ConNF.Tree.mul_apply", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.Tree.mul_apply [ConNF.Params🔗<|PREMISE|>🔗 ] {τ : Type u} [Group🔗<|PREMISE|>🔗 τ] {α : ConNF.TypeIndex} (a : ConNF.Tree🔗<|PREMISE|>🔗 τ α) (a' : ConNF.Tree🔗<|PREMISE|>🔗 τ α) (A : ConNF.ExtendedIndex🔗<|PREMISE|>🔗 α) :(a * a') A = a A * a' A", "code": "theorem mul_apply (a a' : Tree τ α) (A : ExtendedIndex α) :\n    (a * a') A = a A * a' A :=\n  rfl\n", "additional_info": "", "used_premises": [1, 40, 289, 289, 61], "def_path": "ConNF/Structural/Tree.lean", "pos": [91, 94], "informalization": "In the context of Constructive Ordinal Notation (ConNF), an `α`-tree of `τ` is defined as a function from `α`-extended type indices to `τ`. This function maps each `α`-extended type index to a value of type `τ`. Given two `α`-trees `a` and `a'` of type `τ`, and an `α`-extended type index `A`, the multiplication of `a` and `a'` at `A` is equal to the product of `a A` and `a' A`."}
{"full_name": "ConNF.Tree.inv_apply", "url": "ConNF/Structural/Tree.html#ConNF.Tree.inv_apply", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.Tree.inv_apply [ConNF.Params🔗<|PREMISE|>🔗 ] {τ : Type u} [Group🔗<|PREMISE|>🔗 τ] {α : ConNF.TypeIndex} (a : ConNF.Tree🔗<|PREMISE|>🔗 τ α) (A : ConNF.ExtendedIndex🔗<|PREMISE|>🔗 α) :a⁻¹ A = (a A)⁻¹", "code": "theorem inv_apply (a : Tree τ α) (A : ExtendedIndex α) :\n    a⁻¹ A = (a A)⁻¹ :=\n  rfl\n", "additional_info": "", "used_premises": [1, 40, 289, 61], "def_path": "ConNF/Structural/Tree.lean", "pos": [96, 99], "informalization": "In the context of Constructive Ordinal Notation (ConNF), the inverse of a `τ`-tree `a` at an `α`-extended type index `A` is equal to the inverse of the value of `a` at `A`."}
{"full_name": "ConNF.Tree.toBot_mul", "url": "ConNF/Structural/Tree.html#ConNF.Tree.toBot_mul", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.Tree.toBot_mul [ConNF.Params🔗<|PREMISE|>🔗 ] {τ : Type u} [Group🔗<|PREMISE|>🔗 τ] (a : τ) (a' : τ) :ConNF.Tree.toBot (a * a') = ConNF.Tree.toBot a * ConNF.Tree.toBot a'", "code": "theorem toBot_mul (a a' : τ) : toBot (a * a') = toBot a * toBot a' :=\n  toBotIso.map_mul _ _\n", "additional_info": "", "used_premises": [1, 40], "def_path": "ConNF/Structural/Tree.lean", "pos": [123, 125], "informalization": "The theorem `ConNF.Tree.toBot_mul` states that in the context of Constructive Ordinal Notation (ConNF), the function `ConNF.Tree.toBot` applied to the product of two elements `a` and `a'` of a group `τ` is equal to the product of `ConNF.Tree.toBot` applied to `a` and `ConNF.Tree.toBot` applied to `a'`."}
{"full_name": "ConNF.Tree.ofBot_mul", "url": "ConNF/Structural/Tree.html#ConNF.Tree.ofBot_mul", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.Tree.ofBot_mul [ConNF.Params🔗<|PREMISE|>🔗 ] {τ : Type u} [Group🔗<|PREMISE|>🔗 τ] (a : ConNF.Tree🔗<|PREMISE|>🔗 τ ⊥ ) (a' : ConNF.Tree🔗<|PREMISE|>🔗 τ ⊥ ) :ConNF.Tree.ofBot (a * a') = ConNF.Tree.ofBot a * ConNF.Tree.ofBot a'", "code": "theorem ofBot_mul (a a' : Tree τ ⊥) : ofBot (a * a') = ofBot a * ofBot a' :=\n  toBotIso.symm.map_mul _ _\n", "additional_info": "", "used_premises": [1, 40, 289, 289], "def_path": "ConNF/Structural/Tree.lean", "pos": [127, 129], "informalization": "In the context of Constructive Ordinal Notation (ConNF), an `α`-tree of `τ` is defined as a function from `α`-extended type indices to `τ`. This function maps each `α`-extended type index to a value of type `τ`. Given two `⊥`-trees `a` and `a'` of type `τ`, where `τ` is a group, the theorem `ConNF.Tree.ofBot_mul` states that the `⊥`-tree of the product of `a` and `a'` is equal to the product of the `⊥`-trees of `a` and `a'`."}
{"full_name": "ConNF.Tree.toBot_inv", "url": "ConNF/Structural/Tree.html#ConNF.Tree.toBot_inv", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.Tree.toBot_inv [ConNF.Params🔗<|PREMISE|>🔗 ] {τ : Type u} [Group🔗<|PREMISE|>🔗 τ] (a : τ) :ConNF.Tree.toBot a⁻¹ = (ConNF.Tree.toBot a)⁻¹", "code": "theorem toBot_inv (a : τ) : toBot a⁻¹ = (toBot a)⁻¹ :=\n  id toBotIso.map_inv a\n", "additional_info": "", "used_premises": [1, 40], "def_path": "ConNF/Structural/Tree.lean", "pos": [131, 133], "informalization": "The theorem `ConNF.Tree.toBot_inv` states that for any group element `a`, the inverse of `ConNF.Tree.toBot a` is equal to `ConNF.Tree.toBot` of the inverse of `a`."}
{"full_name": "ConNF.Tree.ofBot_inv", "url": "ConNF/Structural/Tree.html#ConNF.Tree.ofBot_inv", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.Tree.ofBot_inv [ConNF.Params🔗<|PREMISE|>🔗 ] {τ : Type u} [Group🔗<|PREMISE|>🔗 τ] (a : ConNF.Tree🔗<|PREMISE|>🔗 τ ⊥ ) :ConNF.Tree.ofBot a⁻¹ = (ConNF.Tree.ofBot a)⁻¹", "code": "theorem ofBot_inv (a : Tree τ ⊥) : ofBot a⁻¹ = (ofBot a)⁻¹ :=\n  (toBotIso (τ := τ)).symm.map_inv a\n", "additional_info": "", "used_premises": [1, 40, 289], "def_path": "ConNF/Structural/Tree.lean", "pos": [135, 137], "informalization": "The theorem `ConNF.Tree.ofBot_inv` states that in the context of Constructive Ordinal Notation (ConNF), the inverse of an `α`-tree of `τ` (where `τ` is a group) evaluated at `⊥` is equal to the inverse of the `α`-tree evaluated at `⊥`."}
{"full_name": "Quiver.Hom.comp_toPath", "url": "ConNF/Structural/Tree.html#Quiver.Hom.comp_toPath", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem Quiver.Hom.comp_toPath {V : Type u_1} [Quiver🔗<|PREMISE|>🔗 V] {a : V} {b : V} {c : V} {p : Quiver.Path🔗<|PREMISE|>🔗 a b} {e : b ⟶ c} :Quiver.Path.comp🔗<|PREMISE|>🔗 p (Quiver.Hom.toPath🔗<|PREMISE|>🔗 e) = Quiver.Path.cons🔗<|PREMISE|>🔗 p e", "code": "theorem Quiver.Hom.comp_toPath {V : Type _} [Quiver V] {a b c : V}\n    {p : Path a b} {e : b ⟶ c} :\n    p.comp e.toPath = p.cons e := rfl\n", "additional_info": "", "used_premises": [75, 76, 135, 74, 301], "def_path": "ConNF/Structural/Tree.lean", "pos": [141, 144], "informalization": "Function `Quiver.Hom.toPath` converts a single arrow in a quiver into a path of length one. Function `Quiver.Path.comp` composes two paths in a quiver. Given a path from vertex `a` to vertex `b` and a path from vertex `b` to vertex `c`, it returns a path from vertex `a` to vertex `c`. Function `Quiver.Path.cons` takes a path from `a` to `b` and an arrow from `b` to `c`, and returns a path from `a` to `c`. The theorem `Quiver.Hom.comp_toPath` states that the composition of a path `p` from `a` to `b` and an arrow `e` from `b` to `c` is equal to the path obtained by extending `p` with `e`."}
{"full_name": "Quiver.Path.cons", "url": "Mathlib/Combinatorics/Quiver/Path.html#Quiver.Path", "code_src": "mathlib4", "ptype": "constructor", "header": "constructor Quiver.Path🔗<|PREMISE|>🔗.cons: {V : Type  u} → [inst : Quiver🔗<|PREMISE|>🔗  V] → {a b c : V} → Quiver.Path🔗<|PREMISE|>🔗  a b → (b ⟶  c) → Quiver.Path🔗<|PREMISE|>🔗  a c", "code": "inductive Path {V : Type u} [Quiver.{v} V] (a : V) : V → Sort max (u + 1) v\n  | nil : Path a a\n  | cons : ∀ {b c : V}, Path a b → (b ⟶ c) → Path a c\n", "additional_info": "", "used_premises": [76, 75, 76, 76], "def_path": "Mathlib/Combinatorics/Quiver/Path.lean", "pos": [24, 27], "informalization": "Function `Quiver.Path.cons` takes a path from `a` to `b` and an arrow from `b` to `c`, and returns a path from `a` to `c`."}
{"full_name": "Quiver.Hom.comp_toPath_comp", "url": "ConNF/Structural/Tree.html#Quiver.Hom.comp_toPath_comp", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem Quiver.Hom.comp_toPath_comp {V : Type u_1} [Quiver🔗<|PREMISE|>🔗 V] {a : V} {b : V} {c : V} {d : V} {p : Quiver.Path🔗<|PREMISE|>🔗 a b} {e : b ⟶ c} {q : Quiver.Path🔗<|PREMISE|>🔗 c d} :Quiver.Path.comp🔗<|PREMISE|>🔗 p (Quiver.Path.comp🔗<|PREMISE|>🔗 (Quiver.Hom.toPath🔗<|PREMISE|>🔗 e) q) = Quiver.Path.comp🔗<|PREMISE|>🔗 (Quiver.Path.cons🔗<|PREMISE|>🔗 p e) q", "code": "theorem Quiver.Hom.comp_toPath_comp {V : Type _} [Quiver V] {a b c d : V}\n    {p : Path a b} {e : b ⟶ c} {q : Path c d} :\n    p.comp (e.toPath.comp q) = (p.cons e).comp q := by\n  rw [Hom.toPath, ← comp_assoc, comp_cons, comp_nil]\n", "additional_info": "", "used_premises": [75, 76, 76, 135, 135, 74, 135, 301], "def_path": "ConNF/Structural/Tree.lean", "pos": [146, 150], "informalization": "Function `Quiver.Hom.comp_toPath_comp` states that for any path `p` from vertex `a` to vertex `b`, any arrow `e` from vertex `b` to vertex `c`, and any path `q` from vertex `c` to vertex `d`, the composition of `p` with the composition of `e` and `q` is equal to the composition of the path obtained by extending `p` with `e` and `q`."}
{"full_name": "ConNF.Tree.comp_def", "url": "ConNF/Structural/Tree.html#ConNF.Tree.comp_def", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.Tree.comp_def [ConNF.Params🔗<|PREMISE|>🔗 ] {τ : Type u} {α : ConNF.TypeIndex} {β : ConNF.TypeIndex} (A : Quiver.Path🔗<|PREMISE|>🔗 α β) (a : ConNF.Tree🔗<|PREMISE|>🔗 τ α) :ConNF.Tree.comp🔗<|PREMISE|>🔗 A a = fun (B : Quiver.Path🔗<|PREMISE|>🔗 β ⊥ ) => a (Quiver.Path.comp🔗<|PREMISE|>🔗 A B)", "code": "theorem comp_def (A : Path α β) (a : Tree τ α) :\n    comp A a = fun B => a (A.comp B) :=\n  rfl\n", "additional_info": "", "used_premises": [1, 76, 289, 304, 76, 135], "def_path": "ConNF/Structural/Tree.lean", "pos": [164, 167], "informalization": "Function `ConNF.Tree.comp` defines the derivative functor in the context of Constructive Ordinal Notation (ConNF). Given a path `A` from type index `α` to type index `β` and an `α`-tree `a` of type `τ`, it returns a `β`-tree of type `τ` by applying `a` to the composition of `A` with any `β`-extended type index `B`."}
{"full_name": "ConNF.Tree.comp", "url": "ConNF/Structural/Tree.html#ConNF.Tree.comp", "code_src": "con-nf", "ptype": "def", "header": "def ConNF.Tree.comp [ConNF.Params🔗<|PREMISE|>🔗 ] {τ : Type u} {α : ConNF.TypeIndex} {β : ConNF.TypeIndex} (A : Quiver.Path🔗<|PREMISE|>🔗 α β) (a : ConNF.Tree🔗<|PREMISE|>🔗 τ α) :ConNF.Tree🔗<|PREMISE|>🔗 τ β", "code": "def comp (A : Path α β) (a : Tree τ α) : Tree τ β :=\n  fun B => a (A.comp B)\n", "additional_info": "The *derivative* functor.\nFor a path from `α` to `β`, this is a map from `α`-trees of `τ` to `β`-trees of `τ`.\nThis is a functor from the category of type indices where\nthe morphisms are the decreasing paths (i.e. the category where morphisms are elements of `Path α β`\nfor `α, β : TypeIndex`) to the category of all trees of a fixed type `τ`, where the morphisms are\nfunctions.\nIf `τ` has a group structure, this map preserves multiplication. This means that we can treat this\nas a functor to the category of all trees on `τ` where the morphisms are group homomorphisms.\nEquations\n* 🗟ConNF.Tree.comp🗟🔗../.././ConNF/Structural/Tree.html#ConNF.Tree.comp🔗  A a B 🗟=🗟🔗../.././Init/Prelude.html#Eq🔗  a (🗟Quiver.Path.comp🗟🔗../.././Mathlib/Combinatorics/Quiver/Path.html#Quiver.Path.comp🔗  A B)\n\n", "used_premises": [1, 76, 289, 289], "def_path": "ConNF/Structural/Tree.lean", "pos": [161, 163], "informalization": "Function `ConNF.Tree.comp` defines the derivative functor in the context of Constructive Ordinal Notation (ConNF). Given a path `A` from type index `α` to type index `β` and an `α`-tree `a` of type `τ`, it returns a `β`-tree of type `τ` by applying `a` to the composition of `A` with any `β`-extended type index `B`."}
{"full_name": "ConNF.Tree.comp_apply", "url": "ConNF/Structural/Tree.html#ConNF.Tree.comp_apply", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.Tree.comp_apply [ConNF.Params🔗<|PREMISE|>🔗 ] {τ : Type u} {α : ConNF.TypeIndex} {β : ConNF.TypeIndex} (a : ConNF.Tree🔗<|PREMISE|>🔗 τ α) (A : Quiver.Path🔗<|PREMISE|>🔗 α β) (B : ConNF.ExtendedIndex🔗<|PREMISE|>🔗 β) :ConNF.Tree.comp🔗<|PREMISE|>🔗 A a B = a (Quiver.Path.comp🔗<|PREMISE|>🔗 A B)", "code": "theorem comp_apply (a : Tree τ α) (A : Path α β) (B : ExtendedIndex β) :\n    comp A a B = a (A.comp B) :=\n  rfl\n", "additional_info": "Evaluating the derivative of a structural group element along a path is the same as evaluating\nthe original element along the composition of the paths.", "used_premises": [1, 289, 76, 61, 304, 135], "def_path": "ConNF/Structural/Tree.lean", "pos": [171, 174], "informalization": "Evaluating the derivative of a structural group element along a path is the same as evaluating the original element along the composition of the paths."}
{"full_name": "ConNF.Tree.comp_nil", "url": "ConNF/Structural/Tree.html#ConNF.Tree.comp_nil", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.Tree.comp_nil [ConNF.Params🔗<|PREMISE|>🔗 ] {τ : Type u} {α : ConNF.TypeIndex} (a : ConNF.Tree🔗<|PREMISE|>🔗 τ α) :ConNF.Tree.comp🔗<|PREMISE|>🔗 Quiver.Path.nil a = a", "code": "theorem comp_nil (a : Tree τ α) : comp nil a = a := by\n  simp only [comp_def, nil_comp, MonoidHom.coe_mk, OneHom.coe_mk]\n", "additional_info": "The derivative along the empty path does nothing.", "used_premises": [1, 289, 304], "def_path": "ConNF/Structural/Tree.lean", "pos": [177, 179], "informalization": "Function `ConNF.Tree.comp` defines the derivative functor in the context of Constructive Ordinal Notation (ConNF). Given a path `A` from type index `α` to type index `β` and an `α`-tree `a` of type `τ`, it returns a `β`-tree of type `τ` by applying `a` to the composition of `A` with any `β`-extended type index `B`. The theorem `ConNF.Tree.comp_nil` states that the derivative along the empty path `Quiver.Path.nil` does nothing, meaning it returns the original tree `a`."}
{"full_name": "ConNF.Tree.comp_cons", "url": "ConNF/Structural/Tree.html#ConNF.Tree.comp_cons", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.Tree.comp_cons [ConNF.Params🔗<|PREMISE|>🔗 ] {τ : Type u} {α : ConNF.TypeIndex} {β : ConNF.TypeIndex} (a : ConNF.Tree🔗<|PREMISE|>🔗 τ α) (p : Quiver.Path🔗<|PREMISE|>🔗 α β) {γ : ConNF.TypeIndex} (h : γ < β) :ConNF.Tree.comp🔗<|PREMISE|>🔗 (Quiver.Path.cons🔗<|PREMISE|>🔗 p h) a = ConNF.Tree.comp🔗<|PREMISE|>🔗 (Quiver.Hom.toPath🔗<|PREMISE|>🔗 h) (ConNF.Tree.comp🔗<|PREMISE|>🔗 p a)", "code": "theorem comp_cons (a : Tree τ α) (p : Path α β) {γ : TypeIndex} (h : γ < β) :\n    comp (p.cons h) a = (comp (Hom.toPath h)) (comp p a) := by\n  simp only [comp_def, MonoidHom.coe_mk, OneHom.coe_mk, Hom.comp_toPath_comp]\n", "additional_info": "", "used_premises": [1, 289, 76, 304, 301, 304, 74, 304], "def_path": "ConNF/Structural/Tree.lean", "pos": [180, 183], "informalization": "In the context of Constructive Ordinal Notation (ConNF), given an `α`-tree `a` of type `τ`, a path `p` from `α` to `β`, and an arrow `h` from `β` to `γ`, the derivative functor `ConNF.Tree.comp` applied to the composition of `p` and `h` is equal to the derivative functor applied to `h` followed by the derivative functor applied to `p` and `a`."}
{"full_name": "ConNF.Tree.comp_comp", "url": "ConNF/Structural/Tree.html#ConNF.Tree.comp_comp", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.Tree.comp_comp [ConNF.Params🔗<|PREMISE|>🔗 ] {τ : Type u} {α : ConNF.TypeIndex} {β : ConNF.TypeIndex} {γ : ConNF.TypeIndex} (a : ConNF.Tree🔗<|PREMISE|>🔗 τ α) (p : Quiver.Path🔗<|PREMISE|>🔗 α β) (q : Quiver.Path🔗<|PREMISE|>🔗 β γ) :ConNF.Tree.comp🔗<|PREMISE|>🔗 q (ConNF.Tree.comp🔗<|PREMISE|>🔗 p a) = ConNF.Tree.comp🔗<|PREMISE|>🔗 (Quiver.Path.comp🔗<|PREMISE|>🔗 p q) a", "code": "theorem comp_comp (a : Tree τ α) (p : Path α β) (q : Path β γ) :\n    comp q (comp p a) = comp (p.comp q) a := by\n  simp only [comp_def, MonoidHom.coe_mk, OneHom.coe_mk, comp_assoc]\n", "additional_info": "The derivative map is functorial.", "used_premises": [1, 289, 76, 76, 304, 304, 304, 135], "def_path": "ConNF/Structural/Tree.lean", "pos": [185, 188], "informalization": "The theorem `ConNF.Tree.comp_comp` establishes the functoriality of the derivative map in the context of Constructive Ordinal Notation (ConNF). It states that for any path `p` from type index `α` to type index `β`, and any path `q` from type index `β` to type index `γ`, the composition of the derivative maps corresponding to `p` and `q` is equal to the derivative map corresponding to the composition of `p` and `q`."}
{"full_name": "ConNF.Tree.comp_mul", "url": "ConNF/Structural/Tree.html#ConNF.Tree.comp_mul", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.Tree.comp_mul [ConNF.Params🔗<|PREMISE|>🔗 ] {τ : Type u} [Group🔗<|PREMISE|>🔗 τ] {α : ConNF.TypeIndex} {β : ConNF.TypeIndex} (a₁ : ConNF.Tree🔗<|PREMISE|>🔗 τ α) (a₂ : ConNF.Tree🔗<|PREMISE|>🔗 τ α) (A : Quiver.Path🔗<|PREMISE|>🔗 α β) :ConNF.Tree.comp🔗<|PREMISE|>🔗 A (a₁ * a₂) = ConNF.Tree.comp🔗<|PREMISE|>🔗 A a₁ * ConNF.Tree.comp🔗<|PREMISE|>🔗 A a₂", "code": "theorem comp_mul {β : TypeIndex} (a₁ a₂ : Tree τ α) (A : Path (α : TypeIndex) β) :\n    comp A (a₁ * a₂) = comp A a₁ * comp A a₂ :=\n  rfl\n", "additional_info": "The derivative map preserves multiplication.", "used_premises": [1, 40, 289, 289, 76, 304, 304, 304], "def_path": "ConNF/Structural/Tree.lean", "pos": [196, 199], "informalization": "The theorem `ConNF.Tree.comp_mul` states that in the context of Constructive Ordinal Notation (ConNF), the derivative functor preserves multiplication. Specifically, given two trees `a₁` and `a₂` of the same type index `α` and a path `A` from `α` to another type index `β`, the derivative of the product `a₁ * a₂` along `A` is equal to the product of the derivatives of `a₁` and `a₂` along `A`."}
{"full_name": "ConNF.Tree.comp_inv", "url": "ConNF/Structural/Tree.html#ConNF.Tree.comp_inv", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.Tree.comp_inv [ConNF.Params🔗<|PREMISE|>🔗 ] {τ : Type u} [Group🔗<|PREMISE|>🔗 τ] {α : ConNF.TypeIndex} {β : ConNF.TypeIndex} (a : ConNF.Tree🔗<|PREMISE|>🔗 τ α) (A : Quiver.Path🔗<|PREMISE|>🔗 α β) :(ConNF.Tree.comp🔗<|PREMISE|>🔗 A a)⁻¹ = ConNF.Tree.comp🔗<|PREMISE|>🔗 A a⁻¹", "code": "theorem comp_inv {β : TypeIndex} (a : Tree τ α) (A : Path (α : TypeIndex) β) :\n    (comp A a)⁻¹ = comp A a⁻¹ :=\n  rfl\n", "additional_info": "The derivative map preserves inverses.", "used_premises": [1, 40, 289, 76, 304, 304], "def_path": "ConNF/Structural/Tree.lean", "pos": [201, 204], "informalization": "The theorem `ConNF.Tree.comp_inv` states that in the context of Constructive Ordinal Notation (ConNF), the derivative map preserves inverses. Specifically, if `a` is an `α`-tree of type `τ` and `A` is a path from type index `α` to type index `β`, then the inverse of the `β`-tree obtained by composing `a` with `A` is equal to the `β`-tree obtained by composing the inverse of `a` with `A`."}
{"full_name": "ConNF.Tree.comp_bot", "url": "ConNF/Structural/Tree.html#ConNF.Tree.comp_bot", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.Tree.comp_bot [ConNF.Params🔗<|PREMISE|>🔗 ] {τ : Type u} {α : ConNF.TypeIndex} (a : ConNF.Tree🔗<|PREMISE|>🔗 τ α) (A : Quiver.Path🔗<|PREMISE|>🔗 α ⊥ ) :ConNF.Tree.comp🔗<|PREMISE|>🔗 A a = ConNF.Tree.toBot (a A)", "code": "theorem comp_bot (a : Tree τ α) (A : Path (α : TypeIndex) ⊥) :\n    comp A a = toBot (a A) := by\n  funext B\n  cases path_eq_nil B\n  rfl\n", "additional_info": "", "used_premises": [1, 289, 76, 304], "def_path": "ConNF/Structural/Tree.lean", "pos": [206, 211], "informalization": "Function `ConNF.Tree.comp` defines the derivative functor in the context of Constructive Ordinal Notation (ConNF). Given a path `A` from type index `α` to type index `⊥` and an `α`-tree `a` of type `τ`, it returns a `⊥`-tree of type `τ` by applying `a` to the composition of `A` with any `⊥`-extended type index `B`."}
{"full_name": "ConNF.Tree.toBot_smul", "url": "ConNF/Structural/Tree.html#ConNF.Tree.toBot_smul", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.Tree.toBot_smul [ConNF.Params🔗<|PREMISE|>🔗 ] {τ : Type u} [Group🔗<|PREMISE|>🔗 τ] {X : Type u_1} [MulAction🔗<|PREMISE|>🔗 τ X] (a : τ) (x : X) :ConNF.Tree.toBot a • x = a • x", "code": "theorem toBot_smul (a : τ) (x : X) : toBot a • x = a • x := by\n  rfl\n", "additional_info": "", "used_premises": [1, 40, 56], "def_path": "ConNF/Structural/Tree.lean", "pos": [221, 223], "informalization": "Function `ConNF.Tree.toBot_smul` simplifies the expression `ConNF.Tree.toBot a • x` to `a • x`, where `a` is an element of a group `τ` and `x` is an element of a type `X` with a multiplicative action of `τ`."}
{"full_name": "ConNF.Tree.ofBot_smul", "url": "ConNF/Structural/Tree.html#ConNF.Tree.ofBot_smul", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.Tree.ofBot_smul [ConNF.Params🔗<|PREMISE|>🔗 ] {τ : Type u} [Group🔗<|PREMISE|>🔗 τ] {X : Type u_1} [MulAction🔗<|PREMISE|>🔗 τ X] (a : ConNF.Tree🔗<|PREMISE|>🔗 τ ⊥ ) (x : X) :ConNF.Tree.ofBot a • x = a • x", "code": "theorem ofBot_smul (a : Tree τ ⊥) (x : X) : ofBot a • x = a • x := by\n  rfl\n", "additional_info": "", "used_premises": [1, 40, 56, 289], "def_path": "ConNF/Structural/Tree.lean", "pos": [225, 227], "informalization": "`ConNF.Tree.ofBot_smul` is a theorem in Lean 4 that states that for a ConNF Params structure with a `τ` which is a group and a `X` which is a type with a `τ`-multiplication action, the `ConNF.Tree.ofBot` function applied to `a : ConNF.Tree τ ⊥` and then multiplied by `x : X` yields the same result as `a • x`. In other words, the `ConNF.Tree.ofBot` function applied to an empty tree returns the tree itself when applied to a group action."}
{"full_name": "ConNF.Tree.toBot_inv_smul", "url": "ConNF/Structural/Tree.html#ConNF.Tree.toBot_inv_smul", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.Tree.toBot_inv_smul [ConNF.Params🔗<|PREMISE|>🔗 ] {τ : Type u} [Group🔗<|PREMISE|>🔗 τ] {X : Type u_1} [MulAction🔗<|PREMISE|>🔗 τ X] (a : τ) (x : X) :(ConNF.Tree.toBot a)⁻¹ • x = a⁻¹ • x", "code": "theorem toBot_inv_smul (a : τ) (x : X) : (toBot a)⁻¹ • x = a⁻¹ • x := by\n  rfl\n", "additional_info": "", "used_premises": [1, 40, 56], "def_path": "ConNF/Structural/Tree.lean", "pos": [229, 231], "informalization": "The theorem `ConNF.Tree.toBot_inv_smul` states that for a group `τ` acting on a type `X`, the inverse of the action of `ConNF.Tree.toBot a` on `x` is equal to the action of the inverse of `a` on `x`."}
{"full_name": "ConNF.Tree.ofBot_inv_smul", "url": "ConNF/Structural/Tree.html#ConNF.Tree.ofBot_inv_smul", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.Tree.ofBot_inv_smul [ConNF.Params🔗<|PREMISE|>🔗 ] {τ : Type u} [Group🔗<|PREMISE|>🔗 τ] {X : Type u_1} [MulAction🔗<|PREMISE|>🔗 τ X] (a : ConNF.Tree🔗<|PREMISE|>🔗 τ ⊥ ) (x : X) :(ConNF.Tree.ofBot a)⁻¹ • x = a⁻¹ • x", "code": "theorem ofBot_inv_smul (a : Tree τ ⊥) (x : X) : (ofBot a)⁻¹ • x = a⁻¹ • x := by\n  rfl\n", "additional_info": "", "used_premises": [1, 40, 56, 289], "def_path": "ConNF/Structural/Tree.lean", "pos": [233, 235], "informalization": "The theorem `ConNF.Tree.ofBot_inv_smul` states that in the context of Constructive Ordinal Notation (ConNF), given a tree `a` of type `⊥` and an element `x` of a type `X` with a multiplicative action by a group `τ`, the action of the inverse of the tree `a` on `x` is equal to the action of the inverse of `a` on `x`."}
{"full_name": "ConNF.StructPerm.smul_nearLitter_fst", "url": "ConNF/Structural/StructPerm.html#ConNF.StructPerm.smul_nearLitter_fst", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.StructPerm.smul_nearLitter_fst [ConNF.Params🔗<|PREMISE|>🔗 ] (π : ConNF.StructPerm🔗<|PREMISE|>🔗 ⊥ ) (N : ConNF.NearLitter) :(π • N).fst = π • N.fst", "code": "theorem smul_nearLitter_fst (π : StructPerm ⊥) (N : NearLitter) : (π • N).fst = π • N.fst :=\n  rfl\n", "additional_info": "", "used_premises": [1, 55], "def_path": "ConNF/Structural/StructPerm.lean", "pos": [45, 47], "informalization": "In the context of Constructive Ordinal Notation (ConNF), a *structural permutation* on a proper type index `α` is a near-litter permutation for each `α`-extended index. This represents how the permutation acts along each path down the type levels in the model. The theorem `ConNF.StructPerm.smul_nearLitter_fst` states that when a structural permutation `π` acts on a near-litter `N`, the first component of the resulting near-litter is equal to `π` acting on the first component of `N`."}
{"full_name": "ConNF.StructPerm.smul_nearLitter_coe", "url": "ConNF/Structural/StructPerm.html#ConNF.StructPerm.smul_nearLitter_coe", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.StructPerm.smul_nearLitter_coe [ConNF.Params🔗<|PREMISE|>🔗 ] (π : ConNF.StructPerm🔗<|PREMISE|>🔗 ⊥ ) (N : ConNF.NearLitter) :↑(π • N) = π • ↑N", "code": "theorem smul_nearLitter_coe (π : StructPerm ⊥) (N : NearLitter) :\n    (π • N : NearLitter) = π • (N : Set Atom) :=\n  NearLitterPerm.smul_nearLitter_coe (Tree.ofBot π) N\n", "additional_info": "", "used_premises": [1, 55], "def_path": "ConNF/Structural/StructPerm.lean", "pos": [48, 51], "informalization": "In the context of Constructive Ordinal Notation (ConNF), a *structural permutation* on a proper type index `α` is a near-litter permutation for each `α`-extended index. This represents how the permutation acts along each path down the type levels in the model. Note that we define structural permutations as trees of near-litter permutations. The theorem `ConNF.StructPerm.smul_nearLitter_coe` states that for a structural permutation `π` and a near-litter `N`, the action of `π` on `N` (denoted as `π • N`) is equal to the action of `π` on the underlying set of `N` (denoted as `π • ↑N`)."}
{"full_name": "ConNF.StructPerm.comp_bot_smul_atom", "url": "ConNF/Structural/StructPerm.html#ConNF.StructPerm.comp_bot_smul_atom", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.StructPerm.comp_bot_smul_atom [ConNF.Params🔗<|PREMISE|>🔗 ] {α : ConNF.TypeIndex} (π : ConNF.StructPerm🔗<|PREMISE|>🔗 α) (A : ConNF.ExtendedIndex🔗<|PREMISE|>🔗 α) (a : ConNF.Atom) :ConNF.Tree.comp🔗<|PREMISE|>🔗 A π • a = π A • a", "code": "theorem comp_bot_smul_atom {α : TypeIndex} (π : StructPerm α)\n    (A : ExtendedIndex α) (a : Atom) :\n    Tree.comp A π • a = π A • a :=\n  rfl\n", "additional_info": "", "used_premises": [1, 55, 61, 304], "def_path": "ConNF/Structural/StructPerm.lean", "pos": [57, 61], "informalization": "`ConNF.StructPerm.comp_bot_smul_atom` is a theorem in the context of Constructive Ordinal Notation (ConNF) in Lean 4. It states that for any structural permutation `π` on a proper type index `α`, any extended index `A` from `α` to the base type `⊥`, and any atom `a`, the derivative functor `ConNF.Tree.comp A π` applied to `a` is equal to `π A` applied to `a`."}
{"full_name": "ConNF.StructPerm.comp_bot_smul_litter", "url": "ConNF/Structural/StructPerm.html#ConNF.StructPerm.comp_bot_smul_litter", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.StructPerm.comp_bot_smul_litter [ConNF.Params🔗<|PREMISE|>🔗 ] {α : ConNF.TypeIndex} (π : ConNF.StructPerm🔗<|PREMISE|>🔗 α) (A : ConNF.ExtendedIndex🔗<|PREMISE|>🔗 α) (L : ConNF.Litter) :ConNF.Tree.comp🔗<|PREMISE|>🔗 A π • L = π A • L", "code": "theorem comp_bot_smul_litter {α : TypeIndex} (π : StructPerm α)\n    (A : ExtendedIndex α) (L : Litter) :\n    Tree.comp A π • L = π A • L :=\n  rfl\n", "additional_info": "", "used_premises": [1, 55, 61, 304], "def_path": "ConNF/Structural/StructPerm.lean", "pos": [63, 67], "informalization": "The theorem `ConNF.StructPerm.comp_bot_smul_litter` states that for any structural permutation `π` on a proper type index `α`, any extended index `A` from `α` to the base type `⊥`, and any litter `L`, the derivative functor `ConNF.Tree.comp A π` applied to `L` is equal to `π A` applied to `L`."}
{"full_name": "ConNF.StructPerm.comp_bot_smul_nearLitter", "url": "ConNF/Structural/StructPerm.html#ConNF.StructPerm.comp_bot_smul_nearLitter", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.StructPerm.comp_bot_smul_nearLitter [ConNF.Params🔗<|PREMISE|>🔗 ] {α : ConNF.TypeIndex} (π : ConNF.StructPerm🔗<|PREMISE|>🔗 α) (A : ConNF.ExtendedIndex🔗<|PREMISE|>🔗 α) (N : ConNF.NearLitter) :ConNF.Tree.comp🔗<|PREMISE|>🔗 A π • N = π A • N", "code": "theorem comp_bot_smul_nearLitter {α : TypeIndex} (π : StructPerm α)\n    (A : ExtendedIndex α) (N : NearLitter) :\n    Tree.comp A π • N = π A • N :=\n  rfl\n", "additional_info": "", "used_premises": [1, 55, 61, 304], "def_path": "ConNF/Structural/StructPerm.lean", "pos": [69, 73], "informalization": "The theorem `ConNF.StructPerm.comp_bot_smul_nearLitter` states that for any structural permutation `π` on a proper type index `α`, any extended index `A` from `α` to the base type `⊥`, and any near-litter permutation `N`, the derivative functor `ConNF.Tree.comp A π` applied to `N` is equal to `π A` applied to `N`."}
{"full_name": "ConNF.StructPerm.one_pretangleAction", "url": "ConNF/Structural/StructPerm.html#ConNF.StructPerm.one_pretangleAction", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.StructPerm.one_pretangleAction [ConNF.Params🔗<|PREMISE|>🔗 ] {α : ConNF.TypeIndex} (t : ConNF.Pretangle🔗<|PREMISE|>🔗 α) :ConNF.StructPerm.pretangleAction🔗<|PREMISE|>🔗 1 t = t", "code": "theorem one_pretangleAction {α : TypeIndex} (t : Pretangle α) : pretangleAction 1 t = t := by\n  have : WellFoundedLT TypeIndex := inferInstance\n  revert t\n  refine this.induction α (C := fun α => ∀ t : Pretangle α, pretangleAction 1 t = t) ?_\n  intro α ih t\n  induction α using WithBot.recBotCoe with\n  | bot =>\n      unfold pretangleAction\n      rfl\n  | coe α =>\n      unfold pretangleAction\n      rw [Pretangle.coe_ext]\n      intro β hβ u\n      simp only [Tree.comp_one, Pretangle.ofCoe_toCoe, ih β hβ, image_id']\n", "additional_info": "", "used_premises": [1, 279, 322], "def_path": "ConNF/Structural/StructPerm.lean", "pos": [80, 94], "informalization": "The theorem `ConNF.StructPerm.one_pretangleAction` states that the action of the identity permutation on a pretangle in the context of Constructive Ordinal Notation (ConNF) results in the same pretangle."}
{"full_name": "ConNF.StructPerm.pretangleAction", "url": "ConNF/Structural/StructPerm.html#ConNF.StructPerm.pretangleAction", "code_src": "con-nf", "ptype": "def", "header": "def ConNF.StructPerm.pretangleAction [ConNF.Params🔗<|PREMISE|>🔗 ] {α : ConNF.TypeIndex} :ConNF.StructPerm🔗<|PREMISE|>🔗 α → ConNF.Pretangle🔗<|PREMISE|>🔗 α → ConNF.Pretangle🔗<|PREMISE|>🔗 α", "code": "def pretangleAction : {α : TypeIndex} → StructPerm α → Pretangle α → Pretangle α\n  | ⊥, π, t => Tree.ofBot π • (Pretangle.ofBot t)\n  | (α : Λ), π, t => Pretangle.toCoe\n      (fun β hβ => pretangleAction (Tree.comp (Hom.toPath hβ) π) '' Pretangle.ofCoe t β hβ)\ntermination_by α π t => α\n", "additional_info": "Equations\n* One or more equations did not get rendered due to their size.\n* 🗟ConNF.StructPerm.pretangleAction🗟🔗../.././ConNF/Structural/StructPerm.html#ConNF.StructPerm.pretangleAction🔗  π t 🗟=🗟🔗../.././Init/Prelude.html#Eq🔗  ConNF.Tree.ofBot π 🗟•🗟🔗../.././Mathlib/Algebra/Group/Defs.html#HSMul.hSMul🔗  ConNF.Pretangle.ofBot t\n\n", "used_premises": [1, 55, 279, 279], "def_path": "ConNF/Structural/StructPerm.lean", "pos": [74, 79], "informalization": "Function `ConNF.StructPerm.pretangleAction` defines the action of a *structural permutation* on a *pretangle* in the context of Constructive Ordinal Notation (ConNF). A pretangle is an object that may become a tangle, an element of the model. The type of pretangles forms a model of TTT without extensionality. A structural permutation on a proper type index `α` is a near-litter permutation for each `α`-extended index. This represents how the permutation acts along each path down the type levels in the model."}
{"full_name": "ConNF.StructPerm.mul_pretangleAction", "url": "ConNF/Structural/StructPerm.html#ConNF.StructPerm.mul_pretangleAction", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.StructPerm.mul_pretangleAction [ConNF.Params🔗<|PREMISE|>🔗 ] {α : ConNF.TypeIndex} (π₁ : ConNF.StructPerm🔗<|PREMISE|>🔗 α) (π₂ : ConNF.StructPerm🔗<|PREMISE|>🔗 α) (t : ConNF.Pretangle🔗<|PREMISE|>🔗 α) :ConNF.StructPerm.pretangleAction🔗<|PREMISE|>🔗 (π₁ * π₂) t = ConNF.StructPerm.pretangleAction🔗<|PREMISE|>🔗 π₁ (ConNF.StructPerm.pretangleAction🔗<|PREMISE|>🔗 π₂ t)", "code": "theorem mul_pretangleAction {α : TypeIndex} (π₁ π₂ : StructPerm α) (t : Pretangle α) :\n    pretangleAction (π₁ * π₂) t = pretangleAction π₁ (pretangleAction π₂ t) := by\n  have : WellFoundedLT TypeIndex := inferInstance\n  revert π₁ π₂ t\n  refine this.induction α\n    (C := fun α => ∀ π₁ π₂ : StructPerm α, ∀ t : Pretangle α,\n      pretangleAction (π₁ * π₂) t = pretangleAction π₁ (pretangleAction π₂ t)) ?_\n  intro α ih π₁ π₂ t\n  induction α using WithBot.recBotCoe with\n  | bot =>\n      unfold pretangleAction\n      rfl\n  | coe α =>\n      rw [pretangleAction, pretangleAction, pretangleAction]\n      simp only [Tree.comp_mul, Pretangle.ofCoe_toCoe, EmbeddingLike.apply_eq_iff_eq]\n      ext β hβ u\n      simp only [ih β hβ, mem_image, exists_exists_and_eq_and]\n", "additional_info": "", "used_premises": [1, 55, 55, 279, 322, 322, 322], "def_path": "ConNF/Structural/StructPerm.lean", "pos": [95, 112], "informalization": "The theorem `ConNF.StructPerm.mul_pretangleAction` states that the action of the product of two structural permutations on a pretangle is equal to the action of the first permutation on the action of the second permutation on the pretangle."}
{"full_name": "ConNF.StructPerm.smul_eq", "url": "ConNF/Structural/StructPerm.html#ConNF.StructPerm.smul_eq", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.StructPerm.smul_eq [ConNF.Params🔗<|PREMISE|>🔗 ] {α : ConNF.TypeIndex} (π : ConNF.StructPerm🔗<|PREMISE|>🔗 α) (t : ConNF.Pretangle🔗<|PREMISE|>🔗 α) :π • t = ConNF.StructPerm.pretangleAction🔗<|PREMISE|>🔗 π t", "code": "theorem smul_eq {α : TypeIndex} (π : StructPerm α) (t : Pretangle α) :\n    π • t = pretangleAction π t :=\n  rfl\n", "additional_info": "", "used_premises": [1, 55, 279, 322], "def_path": "ConNF/Structural/StructPerm.lean", "pos": [118, 121], "informalization": "The theorem `ConNF.StructPerm.smul_eq` states that the action of a *structural permutation* on a *pretangle* in the context of Constructive Ordinal Notation (ConNF) is equivalent to the specific function `ConNF.StructPerm.pretangleAction`. This theorem is crucial for establishing the equivalence between the actions of *structural permutations* and the model of the theory of types without extensionality."}
{"full_name": "ConNF.Address.ext_iff", "url": "ConNF/Structural/Support.html#ConNF.Address.ext_iff", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.Address.ext_iff :∀ {inst : ConNF.Params🔗<|PREMISE|>🔗 } {α : ConNF.TypeIndex} (x y : ConNF.Address🔗<|PREMISE|>🔗 α), x = y ↔ x.path = y.path ∧ x.value = y.value", "code": "@[ext]\n", "additional_info": "", "used_premises": [1, 60], "def_path": "ConNF/Structural/Support.lean", "pos": [30, 31], "informalization": "The theorem `ConNF.Address.ext_iff` states that two `ConNF.Address` objects are equal if and only if their paths and values are equal."}
{"full_name": "ConNF.Address.ext", "url": "ConNF/Structural/Support.html#ConNF.Address.ext", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.Address.ext :∀ {inst : ConNF.Params🔗<|PREMISE|>🔗 } {α : ConNF.TypeIndex} (x y : ConNF.Address🔗<|PREMISE|>🔗 α), x.path = y.path → x.value = y.value → x = y", "code": "@[ext]\n", "additional_info": "", "used_premises": [1, 60], "def_path": "ConNF/Structural/Support.lean", "pos": [30, 31], "informalization": "The theorem `ConNF.Address.ext` states that two `ConNF.Address` objects are equal if and only if their `path` and `value` components are equal. This is a property of extensionality for the `ConNF.Address` structure."}
{"full_name": "ConNF.mk_address", "url": "ConNF/Structural/Support.html#ConNF.mk_address", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.mk_address [ConNF.Params🔗<|PREMISE|>🔗 ] (α : ConNF.TypeIndex) :Cardinal.mk🔗<|PREMISE|>🔗 (ConNF.Address🔗<|PREMISE|>🔗 α) = Cardinal.mk🔗<|PREMISE|>🔗 ConNF.μ", "code": "theorem mk_address (α : TypeIndex) : #(Address α) = #μ := by\n  rw [mk_congr Address_equiv]\n  simp only [Address, mk_prod, mk_sum, mk_atom, lift_id, mk_nearLitter]\n  rw [add_eq_left (Params.κ_isRegular.aleph0_le.trans Params.κ_lt_μ.le) le_rfl]\n  exact mul_eq_right\n    (Params.κ_isRegular.aleph0_le.trans Params.κ_lt_μ.le)\n    (le_trans (mk_extendedIndex α) <| le_of_lt <| lt_trans Params.Λ_lt_κ Params.κ_lt_μ)\n    (mk_ne_zero _)\n", "additional_info": "There are `μ` addresses.", "used_premises": [1, 29, 60, 29], "def_path": "ConNF/Structural/Support.lean", "pos": [45, 53], "informalization": "In the context of Constructive Ordinal Notation (ConNF), the theorem `ConNF.mk_address` states that the cardinality of the set of addresses for a given type `α` is equal to the cardinality of the type `μ`. This means that there are as many addresses as there are elements in the type `μ`."}
{"full_name": "ConNF.StructPerm.smul_address", "url": "ConNF/Structural/Support.html#ConNF.StructPerm.smul_address", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.StructPerm.smul_address [ConNF.Params🔗<|PREMISE|>🔗 ] {α : ConNF.TypeIndex} {π : ConNF.StructPerm🔗<|PREMISE|>🔗 α} {c : ConNF.Address🔗<|PREMISE|>🔗 α} :π • c = { path := c.path, value := π c.path • c.value }", "code": "theorem smul_address :\n    π • c = ⟨c.path, π c.path • c.value⟩ :=\n  rfl\n", "additional_info": "", "used_premises": [1, 55, 60], "def_path": "ConNF/Structural/Support.lean", "pos": [71, 74], "informalization": "Function `ConNF.StructPerm.smul_address` defines the action of a *structural permutation* on an *address* in the context of Constructive Ordinal Notation (ConNF). A *structural permutation* on a proper type index `α` is a near-litter permutation for each `α`-extended index, representing how the permutation acts along each path down the type levels in the model. An *address* represents an object in the base type (the atom or near-litter) together with the path detailing how we descend from type `α` to type `⊥` by looking at elements of elements and so on in the model."}
{"full_name": "ConNF.StructPerm.smul_address_eq_iff", "url": "ConNF/Structural/Support.html#ConNF.StructPerm.smul_address_eq_iff", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.StructPerm.smul_address_eq_iff [ConNF.Params🔗<|PREMISE|>🔗 ] {α : ConNF.TypeIndex} {π : ConNF.StructPerm🔗<|PREMISE|>🔗 α} {c : ConNF.Address🔗<|PREMISE|>🔗 α} :π • c = c ↔ π c.path • c.value = c.value", "code": "theorem smul_address_eq_iff :\n    π • c = c ↔ π c.path • c.value = c.value := by\n  obtain ⟨A, x⟩ := c\n  simp only [smul_address, Address.mk.injEq, true_and]\n", "additional_info": "", "used_premises": [1, 55, 60], "def_path": "ConNF/Structural/Support.lean", "pos": [76, 80], "informalization": "In the context of Constructive Ordinal Notation (ConNF), a *structural permutation* on a proper type index `α` is a near-litter permutation for each `α`-extended index. This represents how the permutation acts along each path down the type levels in the model. Note that we define structural permutations as trees of near-litter permutations. Structure `ConNF.Address` represents an object in the base type (the atom or near-litter) together with the path detailing how we descend from type `α` to type `⊥` by looking at elements of elements and so on in the model. The theorem `ConNF.StructPerm.smul_address_eq_iff` states that for a structural permutation `π` on a proper type index `α` and an address `c` of type `α`, `π • c = c` if and only if `π c.path • c.value = c.value`."}
{"full_name": "ConNF.StructPerm.smul_address_eq_smul_iff", "url": "ConNF/Structural/Support.html#ConNF.StructPerm.smul_address_eq_smul_iff", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.StructPerm.smul_address_eq_smul_iff [ConNF.Params🔗<|PREMISE|>🔗 ] {α : ConNF.TypeIndex} {π : ConNF.StructPerm🔗<|PREMISE|>🔗 α} {π' : ConNF.StructPerm🔗<|PREMISE|>🔗 α} {c : ConNF.Address🔗<|PREMISE|>🔗 α} :π • c = π' • c ↔ π c.path • c.value = π' c.path • c.value", "code": "theorem smul_address_eq_smul_iff :\n    π • c = π' • c ↔ π c.path • c.value = π' c.path • c.value := by\n  obtain ⟨A, x⟩ := c\n  simp only [smul_address, Address.mk.injEq, true_and]\n", "additional_info": "", "used_premises": [1, 55, 55, 60], "def_path": "ConNF/Structural/Support.lean", "pos": [82, 86], "informalization": "The theorem `ConNF.StructPerm.smul_address_eq_smul_iff` states that for any two structural permutations `π` and `π'` of the same type index `α`, and any address `c` of type `α`, the equation `π • c = π' • c` holds if and only if `π c.path • c.value = π' c.path • c.value`, where `c.path` and `c.value` are the path and value components of the address `c`, respectively."}
{"full_name": "ConNF.NearLitterPerm.smul_address", "url": "ConNF/Structural/Support.html#ConNF.NearLitterPerm.smul_address", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterPerm.smul_address [ConNF.Params🔗<|PREMISE|>🔗 ] {π : ConNF.NearLitterPerm} {c : ConNF.Address🔗<|PREMISE|>🔗 ⊥ } :π • c = { path := c.path, value := π • c.value }", "code": "theorem smul_address :\n    π • c = ⟨c.path, π • c.value⟩ :=\n  rfl\n", "additional_info": "", "used_premises": [1, 60], "def_path": "ConNF/Structural/Support.lean", "pos": [99, 102], "informalization": "The theorem `ConNF.NearLitterPerm.smul_address` states that for any near-litter permutation `π` and an address `c` in the base type `⊥`, the action of `π` on `c` results in a new address with the same path as `c` but with the value component transformed by `π`."}
{"full_name": "ConNF.NearLitterPerm.smul_address_eq_iff", "url": "ConNF/Structural/Support.html#ConNF.NearLitterPerm.smul_address_eq_iff", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.NearLitterPerm.smul_address_eq_iff [ConNF.Params🔗<|PREMISE|>🔗 ] {π : ConNF.NearLitterPerm} {c : ConNF.Address🔗<|PREMISE|>🔗 ⊥ } :π • c = c ↔ π • c.value = c.value", "code": "theorem smul_address_eq_iff :\n    π • c = c ↔ π • c.value = c.value := by\n  obtain ⟨A, x⟩ := c\n  simp only [smul_address, Address.mk.injEq, true_and]\n", "additional_info": "", "used_premises": [1, 60], "def_path": "ConNF/Structural/Support.lean", "pos": [104, 108], "informalization": "The theorem `ConNF.NearLitterPerm.smul_address_eq_iff` states that for a near-litter permutation `π` and an address `c`, the action of `π` on `c` is equal to `c` if and only if the action of `π` on the value of `c` is equal to the value of `c`."}
{"full_name": "ConNF.NearLitterPerm.smul_address_eq_smul_iff", "url": "ConNF/Structural/Support.html#ConNF.NearLitterPerm.smul_address_eq_smul_iff", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.NearLitterPerm.smul_address_eq_smul_iff [ConNF.Params🔗<|PREMISE|>🔗 ] {π : ConNF.NearLitterPerm} {π' : ConNF.NearLitterPerm} {c : ConNF.Address🔗<|PREMISE|>🔗 ⊥ } :π • c = π' • c ↔ π • c.value = π' • c.value", "code": "theorem smul_address_eq_smul_iff :\n    π • c = π' • c ↔ π • c.value = π' • c.value := by\n  obtain ⟨A, x⟩ := c\n  simp only [smul_address, Address.mk.injEq, true_and]\n", "additional_info": "", "used_premises": [1, 60], "def_path": "ConNF/Structural/Support.lean", "pos": [110, 114], "informalization": "The theorem `ConNF.NearLitterPerm.smul_address_eq_smul_iff` states that for two near-litter permutations `π` and `π'` and an address `c`, the equation `π • c = π' • c` holds if and only if `π • c.value = π' • c.value`, where `c.value` is the value of the address `c`."}
{"full_name": "ConNF.Support.ext_iff", "url": "ConNF/Structural/Support.html#ConNF.Support.ext_iff", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.Support.ext_iff :∀ {inst : ConNF.Params🔗<|PREMISE|>🔗 } {α : ConNF.TypeIndex} (x y : ConNF.Support🔗<|PREMISE|>🔗 α), x = y ↔ x.enum = y.enum", "code": "@[ext]\n", "additional_info": "", "used_premises": [1, 58], "def_path": "ConNF/Structural/Support.lean", "pos": [120, 121], "informalization": "Structure `ConNF.Support` represents a function from an initial segment of `κ` to the type of addresses in the context of Constructive Ordinal Notation (ConNF). It ensures that for any two near-litters `N₁` and `N₂` that are near the same litter, any atoms in their symmetric difference are included in the enumeration. The theorem `ConNF.Support.ext_iff` states that two instances of `ConNF.Support` are equal if and only if their enumerations are equal."}
{"full_name": "ConNF.Support.ext", "url": "ConNF/Structural/Support.html#ConNF.Support.ext", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.Support.ext :∀ {inst : ConNF.Params🔗<|PREMISE|>🔗 } {α : ConNF.TypeIndex} (x y : ConNF.Support🔗<|PREMISE|>🔗 α), x.enum = y.enum → x = y", "code": "@[ext]\n", "additional_info": "", "used_premises": [1, 58], "def_path": "ConNF/Structural/Support.lean", "pos": [120, 121], "informalization": "Function `ConNF.Support.ext` is an extensionality theorem for the `ConNF.Support` structure in the context of Constructive Ordinal Notation (ConNF). It states that if two `ConNF.Support` structures have the same enumeration, then they are equal."}
{"full_name": "ConNF.Support.small", "url": "ConNF/Structural/Support.html#ConNF.Support.small", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.Support.small [ConNF.Params🔗<|PREMISE|>🔗 ] {α : ConNF.TypeIndex} (S : ConNF.Support🔗<|PREMISE|>🔗 α) :ConNF.Small🔗<|PREMISE|>🔗 (ConNF.Enumeration.carrier🔗<|PREMISE|>🔗 S.enum)", "code": "theorem Support.small (S : Support α) : Small (S : Set (Address α)) :=\n  S.enum.small\n", "additional_info": "", "used_premises": [1, 58, 233, 70], "def_path": "ConNF/Structural/Support.lean", "pos": [145, 147], "informalization": "In the context of Constructive Ordinal Notation (ConNF), a `ConNF.Support` structure represents a function from an initial segment of `κ` to the type of addresses, ensuring that for any two near-litters `N₁` and `N₂` that are near the same litter, any atoms in their symmetric difference are included in the enumeration. The theorem `ConNF.Support.small` asserts that the cardinality of the carrier set of an `α`-enumeration `E`, which consists of all elements `c` of type `α` that can be expressed as `E.f i h` for some `i < E.max`, is strictly less than the cardinality of the type `ConNF.κ`."}
{"full_name": "ConNF.Support.mem_iff", "url": "ConNF/Structural/Support.html#ConNF.Support.mem_iff", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.Support.mem_iff [ConNF.Params🔗<|PREMISE|>🔗 ] {α : ConNF.TypeIndex} (c : ConNF.Address🔗<|PREMISE|>🔗 α) (S : ConNF.Support🔗<|PREMISE|>🔗 α) :c ∈ S ↔ ∃ (i : ConNF.κ) (h : i < ConNF.Support.max🔗<|PREMISE|>🔗 S), c = ConNF.Support.f🔗<|PREMISE|>🔗 S i h", "code": "theorem Support.mem_iff (c : Address α) (S : Support α) :\n    c ∈ S ↔ ∃ i, ∃ (h : i < S.max), c = S.f i h :=\n  Iff.rfl\n", "additional_info": "", "used_premises": [1, 60, 58, 338, 339], "def_path": "ConNF/Structural/Support.lean", "pos": [158, 161], "informalization": "The theorem `ConNF.Support.mem_iff` states that an element `c` of type `ConNF.Address α` is a member of a `ConNF.Support` structure `S` if and only if there exists an element `i` of type `ConNF.κ` that is less than the maximum element of `S`, and `c` is equal to the function `ConNF.Support.f` applied to `S`, `i`, and a proof that `i` is less than the maximum element of `S`."}
{"full_name": "ConNF.Support.max", "url": "ConNF/Structural/Support.html#ConNF.Support.max", "code_src": "con-nf", "ptype": "def", "header": "def ConNF.Support.max [ConNF.Params🔗<|PREMISE|>🔗 ] {α : ConNF.TypeIndex} (S : ConNF.Support🔗<|PREMISE|>🔗 α) :ConNF.κ", "code": "def Support.max (S : Support α) : κ :=\n  S.enum.max\n", "additional_info": "Equations\n* 🗟ConNF.Support.max🗟🔗../.././ConNF/Structural/Support.html#ConNF.Support.max🔗  S 🗟=🗟🔗../.././Init/Prelude.html#Eq🔗  S.enum.max\n\n", "used_premises": [1, 58], "def_path": "ConNF/Structural/Support.lean", "pos": [127, 129], "informalization": "Function `ConNF.Support.max` returns the maximum element of a `ConNF.Support` structure, which represents a function from an initial segment of `κ` to the type of addresses in the context of Constructive Ordinal Notation (ConNF). This function ensures that for any two near-litters `N₁` and `N₂` that are near the same litter, any atoms in their symmetric difference are included in the enumeration."}
{"full_name": "ConNF.Support.f", "url": "ConNF/Structural/Support.html#ConNF.Support.f", "code_src": "con-nf", "ptype": "def", "header": "def ConNF.Support.f [ConNF.Params🔗<|PREMISE|>🔗 ] {α : ConNF.TypeIndex} (S : ConNF.Support🔗<|PREMISE|>🔗 α) (i : ConNF.κ) :i < ConNF.Support.max🔗<|PREMISE|>🔗 S → ConNF.Address🔗<|PREMISE|>🔗 α", "code": "def Support.f (S : Support α) : (i : κ) → i < S.max → Address α :=\n  S.enum.f\n", "additional_info": "Equations\n* 🗟ConNF.Support.f🗟🔗../.././ConNF/Structural/Support.html#ConNF.Support.f🔗  S 🗟=🗟🔗../.././Init/Prelude.html#Eq🔗  S.enum.f\n\n", "used_premises": [1, 58, 338, 60], "def_path": "ConNF/Structural/Support.lean", "pos": [130, 132], "informalization": "Function `ConNF.Support.f` takes a `ConNF.Support` structure `S`, an element `i` of type `ConNF.κ`, and a proof that `i` is less than the maximum element of `S`. It returns an element of type `ConNF.Address α`, which represents an object in the base type (the atom or near-litter) together with the path detailing how we descend from type `α` to type `⊥` by looking at elements of elements and so on in the model."}
{"full_name": "ConNF.Support.smul_max", "url": "ConNF/Structural/Support.html#ConNF.Support.smul_max", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.Support.smul_max [ConNF.Params🔗<|PREMISE|>🔗 ] {α : ConNF.TypeIndex} (π : ConNF.StructPerm🔗<|PREMISE|>🔗 α) (S : ConNF.Support🔗<|PREMISE|>🔗 α) :ConNF.Support.max🔗<|PREMISE|>🔗 (π • S) = ConNF.Support.max🔗<|PREMISE|>🔗 S", "code": "theorem Support.smul_max (π : StructPerm α) (S : Support α) :\n    (π • S).max = S.max :=\n  rfl\n", "additional_info": "", "used_premises": [1, 55, 58, 338, 338], "def_path": "ConNF/Structural/Support.lean", "pos": [196, 199], "informalization": "The theorem `ConNF.Support.smul_max` states that the maximum element of a `ConNF.Support` structure, which represents a function from an initial segment of `κ` to the type of addresses in the context of Constructive Ordinal Notation (ConNF), is invariant under the action of a structural permutation."}
{"full_name": "ConNF.Support.smul_f", "url": "ConNF/Structural/Support.html#ConNF.Support.smul_f", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.Support.smul_f [ConNF.Params🔗<|PREMISE|>🔗 ] {α : ConNF.TypeIndex} (π : ConNF.StructPerm🔗<|PREMISE|>🔗 α) (S : ConNF.Support🔗<|PREMISE|>🔗 α) (i : ConNF.κ) (hi : i < ConNF.Support.max🔗<|PREMISE|>🔗 S) :ConNF.Support.f🔗<|PREMISE|>🔗 (π • S) i hi = π • ConNF.Support.f🔗<|PREMISE|>🔗 S i hi", "code": "theorem Support.smul_f (π : StructPerm α) (S : Support α) (i : κ) (hi : i < S.max) :\n    (π • S).f i hi = π • S.f i hi :=\n  rfl\n", "additional_info": "", "used_premises": [1, 55, 58, 338, 339, 339], "def_path": "ConNF/Structural/Support.lean", "pos": [201, 204], "informalization": "In the context of Constructive Ordinal Notation (ConNF), the function `ConNF.Support.f` takes a `ConNF.Support` structure `S`, an element `i` of type `ConNF.κ`, and a proof that `i` is less than the maximum element of `S`. It returns an element of type `ConNF.Address α`, which represents an object in the base type (the atom or near-litter) together with the path detailing how we descend from type `α` to type `⊥` by looking at elements of elements and so on in the model. The theorem `ConNF.Support.smul_f` states that applying a structural permutation `π` to a `ConNF.Support` structure `S` and then applying `ConNF.Support.f` to the result is equivalent to first applying `ConNF.Support.f` to `S` and then applying the permutation `π` to the result."}
{"full_name": "ConNF.Support.smul_mem_smul", "url": "ConNF/Structural/Support.html#ConNF.Support.smul_mem_smul", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.Support.smul_mem_smul [ConNF.Params🔗<|PREMISE|>🔗 ] {α : ConNF.TypeIndex} {S : ConNF.Support🔗<|PREMISE|>🔗 α} {c : ConNF.Address🔗<|PREMISE|>🔗 α} (h : c ∈ S) (π : ConNF.StructPerm🔗<|PREMISE|>🔗 α) :π • c ∈ π • S", "code": "theorem Support.smul_mem_smul {S : Support α} {c : Address α}\n    (h : c ∈ S) (π : StructPerm α) : π • c ∈ π • S :=\n  Enumeration.smul_mem_smul h π\n", "additional_info": "", "used_premises": [1, 58, 60, 55], "def_path": "ConNF/Structural/Support.lean", "pos": [210, 213], "informalization": "The theorem `ConNF.Support.smul_mem_smul` states that for any initial segment `α` of the type `κ`, any support function `S` defined on `α`, any address `c` that is in the support of `S`, and any structural permutation `π`, the address `π • c` is also in the support of the support function `π • S`. This is a crucial result in the proof of the main theorem of Constructive Ordinal Notation (ConNF), which states that the natural numbers are well-ordered."}
{"full_name": "ConNF.Support.smul_eq_of_smul_eq", "url": "ConNF/Structural/Support.html#ConNF.Support.smul_eq_of_smul_eq", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.Support.smul_eq_of_smul_eq [ConNF.Params🔗<|PREMISE|>🔗 ] {α : ConNF.TypeIndex} {S : ConNF.Support🔗<|PREMISE|>🔗 α} {π : ConNF.StructPerm🔗<|PREMISE|>🔗 α} (hS : π • S = S) {c : ConNF.Address🔗<|PREMISE|>🔗 α} (hc : c ∈ S) :π • c = c", "code": "theorem Support.smul_eq_of_smul_eq {S : Support α} {π : StructPerm α}\n    (hS : π • S = S) {c : Address α} (hc : c ∈ S) : π • c = c :=\n  Enumeration.smul_eq_of_smul_eq (congr_arg Support.enum hS) hc\n", "additional_info": "", "used_premises": [1, 58, 55, 60], "def_path": "ConNF/Structural/Support.lean", "pos": [214, 217], "informalization": "The theorem `ConNF.Support.smul_eq_of_smul_eq` states that if a structural permutation `π` leaves a support `S` invariant (i.e., `π • S = S`), then `π` also leaves any address `c` in `S` invariant (i.e., `π • c = c`)."}
{"full_name": "ConNF.Support.singleton_enum", "url": "ConNF/Structural/Support.html#ConNF.Support.singleton_enum", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.Support.singleton_enum [ConNF.Params🔗<|PREMISE|>🔗 ] {α : ConNF.TypeIndex} (c : ConNF.Address🔗<|PREMISE|>🔗 α) :(ConNF.Support.singleton🔗<|PREMISE|>🔗 c).enum = { max := 1, f := fun (x : ConNF.κ) (x : x < 1) => c }", "code": "theorem Support.singleton_enum (c : Address α) :\n    (Support.singleton c).enum = ⟨1, fun _ _ => c⟩ :=\n  rfl\n", "additional_info": "", "used_premises": [1, 60, 345], "def_path": "ConNF/Structural/Support.lean", "pos": [231, 234], "informalization": "Function `ConNF.Support.singleton` is a constructor for the `ConNF.Support` structure, which represents a function from an initial segment of `κ` to the type of addresses in the context of Constructive Ordinal Notation (ConNF). It ensures that for any two near-litters `N₁` and `N₂` that are near the same litter, any atoms in their symmetric difference are included in the enumeration. Given an address `c` of type `ConNF.Address α`, `ConNF.Support.singleton c` returns a `ConNF.Support α` structure where the enumeration `enum` is defined as `⟨1, fun _ _ => c⟩`, meaning it maps all elements of `κ` less than `1` to the address `c`."}
{"full_name": "ConNF.Support.singleton", "url": "ConNF/Structural/Support.html#ConNF.Support.singleton", "code_src": "con-nf", "ptype": "def", "header": "def ConNF.Support.singleton [ConNF.Params🔗<|PREMISE|>🔗 ] {α : ConNF.TypeIndex} (c : ConNF.Address🔗<|PREMISE|>🔗 α) :ConNF.Support🔗<|PREMISE|>🔗 α", "code": "def Support.singleton (c : Address α) : Support α where\n  enum := ⟨1, fun _ _ => c⟩\n  mem_of_mem_symmDiff' := by\n    intro _ N₁ N₂ b _ hb hN₁ hN₂\n    simp only [Enumeration.mem_iff, κ_lt_one_iff, exists_prop, exists_eq_left] at hN₁ hN₂\n    rw [← hN₂] at hN₁\n    simp only [Address.mk.injEq, inr.injEq, true_and] at hN₁\n    subst hN₁\n    cases hb with\n    | inl hb => cases hb.2 hb.1\n    | inr hb => cases hb.2 hb.1\n", "additional_info": "Equations\n* 🗟ConNF.Support.singleton🗟🔗../.././ConNF/Structural/Support.html#ConNF.Support.singleton🔗  c 🗟=🗟🔗../.././Init/Prelude.html#Eq🔗  { enum := { max := 1, f := fun (x : ConNF.κ) (x : x 🗟<🗟🔗../.././Init/Prelude.html#LT.lt🔗  1) => c }, mem_of_mem_symmDiff' := ⋯ }\n\n", "used_premises": [1, 60, 58], "def_path": "ConNF/Structural/Support.lean", "pos": [218, 229], "informalization": "Function `ConNF.Support.singleton` is a constructor for the `ConNF.Support` structure, which represents a function from an initial segment of `κ` to the type of addresses in the context of Constructive Ordinal Notation (ConNF). It ensures that for any two near-litters `N₁` and `N₂` that are near the same litter, any atoms in their symmetric difference are included in the enumeration. Given an address `c` of type `ConNF.Address α`, `ConNF.Support.singleton c` returns a `ConNF.Support α` structure where the enumeration `enum` is defined as `⟨1, fun _ _ => c⟩`, meaning it maps all elements of `κ` less than `1` to the address `c`."}
{"full_name": "ConNF.Support.mem_singleton_iff", "url": "ConNF/Structural/Support.html#ConNF.Support.mem_singleton_iff", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.Support.mem_singleton_iff [ConNF.Params🔗<|PREMISE|>🔗 ] {α : ConNF.TypeIndex} (c : ConNF.Address🔗<|PREMISE|>🔗 α) (d : ConNF.Address🔗<|PREMISE|>🔗 α) :c ∈ ConNF.Support.singleton🔗<|PREMISE|>🔗 d ↔ c = d", "code": "theorem Support.mem_singleton_iff (c d : Address α) : c ∈ Support.singleton d ↔ c = d := by\n  unfold singleton\n  simp only [mem_mk, Enumeration.mem_iff, κ_lt_one_iff, exists_prop, exists_eq_left]\n", "additional_info": "", "used_premises": [1, 60, 60, 345], "def_path": "ConNF/Structural/Support.lean", "pos": [236, 239], "informalization": "The theorem `ConNF.Support.mem_singleton_iff` states that for any two addresses `c` and `d` of the same type `α` in the context of Constructive Ordinal Notation (ConNF), `c` is an element of the singleton support structure `ConNF.Support.singleton d` if and only if `c` is equal to `d`."}
{"full_name": "ConNF.mk_support", "url": "ConNF/Structural/Support.html#ConNF.mk_support", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.mk_support [ConNF.Params🔗<|PREMISE|>🔗 ] {α : ConNF.TypeIndex} :Cardinal.mk🔗<|PREMISE|>🔗 (ConNF.Support🔗<|PREMISE|>🔗 α) = Cardinal.mk🔗<|PREMISE|>🔗 ConNF.μ", "code": "theorem mk_support : #(Support α) = #μ := by\n  refine le_antisymm ?_ ?_\n  · rw [← mk_enumeration (mk_address α)]\n    refine ⟨⟨Support.enum, ?_⟩⟩\n    intro S₁ S₂ h\n    ext : 1\n    exact h\n  · rw [← mk_atom]\n    refine ⟨⟨fun a => Support.singleton ⟨default, inl a⟩, ?_⟩⟩\n    intro a₁ a₂ h\n    have := Support.singleton_injective h\n    simp only [Address.mk.injEq, inl.injEq, true_and] at this\n    exact this\n", "additional_info": "There are exactly `μ` supports.", "used_premises": [1, 29, 58, 29], "def_path": "ConNF/Structural/Support.lean", "pos": [250, 263], "informalization": "The theorem `ConNF.mk_support` states that the cardinality of the set of supports for a given type index `α` in the context of Constructive Ordinal Notation (ConNF) is equal to the cardinality of the type `μ`. This means that there are exactly as many supports as there are elements in the type `μ`."}
{"full_name": "ConNF.Support.IsCompletion.smul", "url": "ConNF/Structural/Support.html#ConNF.Support.IsCompletion.smul", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.Support.IsCompletion.smul [ConNF.Params🔗<|PREMISE|>🔗 ] {α : ConNF.TypeIndex} {S : ConNF.Support🔗<|PREMISE|>🔗 α} {E : ConNF.Enumeration🔗<|PREMISE|>🔗 (ConNF.Address🔗<|PREMISE|>🔗 α)} (h : ConNF.Support.IsCompletion🔗<|PREMISE|>🔗 S E) (π : ConNF.StructPerm🔗<|PREMISE|>🔗 α) :ConNF.Support.IsCompletion🔗<|PREMISE|>🔗 (π • S) (π • E)", "code": "theorem Support.IsCompletion.smul {S : Support α} {E : Enumeration (Address α)}\n    (h : S.IsCompletion E) (π : StructPerm α) : (π • S).IsCompletion (π • E) := by\n  constructor\n  · exact Enumeration.smul_le_smul h.le π\n  · intro i hi₁ hi₂\n    obtain ⟨A, a, N₁, N₂, hN, ha, hN₁, hN₂, h⟩ := h.eq_atom i hi₁ hi₂\n    refine ⟨A, π A • a, π A • N₁, π A • N₂, ?_, ?_, ?_, ?_, ?_⟩\n    · simp only [NearLitterPerm.smul_nearLitter_fst, smul_left_cancel_iff]\n      exact hN\n    · rw [NearLitterPerm.smul_nearLitter_coe, NearLitterPerm.smul_nearLitter_coe,\n        ← Set.smul_set_symmDiff, Set.smul_mem_smul_set_iff]\n      exact ha\n    · obtain ⟨i, hi, h⟩ := hN₁\n      refine ⟨i, hi, ?_⟩\n      rw [Enumeration.smul_f, ← h]\n      rfl\n    · obtain ⟨i, hi, h⟩ := hN₂\n      refine ⟨i, hi, ?_⟩\n      rw [Enumeration.smul_f, ← h]\n      rfl\n    · rw [smul_f, h]\n      rfl\n", "additional_info": "", "used_premises": [1, 58, 59, 60, 349, 55, 349], "def_path": "ConNF/Structural/Support.lean", "pos": [274, 296], "informalization": "The theorem `ConNF.Support.IsCompletion.smul` states that if `S` is a completion of an enumeration of addresses `E`, and `π` is a structural permutation, then `π • S` is a completion of `π • E`."}
{"full_name": "ConNF.Support.IsCompletion", "url": "ConNF/Structural/Support.html#ConNF.Support.IsCompletion", "code_src": "con-nf", "ptype": "structure", "header": "structure ConNF.Support.IsCompletion [ConNF.Params🔗<|PREMISE|>🔗 ] {α : ConNF.TypeIndex} (S : ConNF.Support🔗<|PREMISE|>🔗 α) (E : ConNF.Enumeration🔗<|PREMISE|>🔗 (ConNF.Address🔗<|PREMISE|>🔗 α)) :Prop\n | le : E ≤  S.enum\n | eq_atom : ∀ (i : ConNF.κ) (hi₁ : i <  ConNF.Support.max🔗<|PREMISE|>🔗  S),\n E.max ≤  i →\n ∃ (A : ConNF.ExtendedIndex🔗<|PREMISE|>🔗  α) (a : ConNF.Atom) (N₁ : ConNF.NearLitter) (N₂ : ConNF.NearLitter),\n N₁.fst =  N₂.fst ∧  a ∈  symmDiff🔗<|PREMISE|>🔗  ↑N₁ ↑N₂ ∧  { path := A, value := Sum.inr🔗<|PREMISE|>🔗  N₁ } ∈  E ∧  { path := A, value := Sum.inr🔗<|PREMISE|>🔗  N₂ } ∈  E ∧  ConNF.Support.f🔗<|PREMISE|>🔗  S i hi₁ =  { path := A, value := Sum.inl🔗<|PREMISE|>🔗  a }", "code": "structure Support.IsCompletion (S : Support α) (E : Enumeration (Address α)) : Prop where\n  le : E ≤ S.enum\n  eq_atom (i : κ) (hi₁ : i < S.max) (hi₂ : E.max ≤ i) :\n    ∃ A : ExtendedIndex α, ∃ a : Atom, ∃ N₁ N₂ : NearLitter,\n    N₁.1 = N₂.1 ∧ a ∈ (N₁ : Set Atom) ∆ N₂ ∧\n    ⟨A, inr N₁⟩ ∈ E ∧ ⟨A, inr N₂⟩ ∈ E ∧ S.f i hi₁ = ⟨A, inl a⟩\n", "additional_info": "`S` is a *completion* of an enumeration of addresses `E` if it extends `E`,\nand every address in the extension is an atom contained in the symmetric difference of\ntwo near-litters in `E`.\n", "used_premises": [1, 58, 59, 60, 338, 61, 62, 65, 65, 339, 67], "def_path": "ConNF/Structural/Support.lean", "pos": [267, 273], "informalization": "`S` is a *completion* of an enumeration of addresses `E` if it extends `E`, and every address in the extension is an atom contained in the symmetric difference of two near-litters in `E`."}
{"full_name": "ConNF.nearLitter_not_mem_completionToAdd", "url": "ConNF/Structural/Support.html#ConNF.nearLitter_not_mem_completionToAdd", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.nearLitter_not_mem_completionToAdd [ConNF.Params🔗<|PREMISE|>🔗 ] {α : ConNF.TypeIndex} (A : ConNF.ExtendedIndex🔗<|PREMISE|>🔗 α) (N : ConNF.NearLitter) (s : Set🔗<|PREMISE|>🔗 (ConNF.Address🔗<|PREMISE|>🔗 α)) :{ path := A, value := Sum.inr🔗<|PREMISE|>🔗 N } ∉ ConNF.completionToAdd🔗<|PREMISE|>🔗 s", "code": "theorem nearLitter_not_mem_completionToAdd (A : ExtendedIndex α) (N : NearLitter)\n    (s : Set (Address α)) : ⟨A, inr N⟩ ∉ completionToAdd s := by\n  rintro ⟨_, _, _, a, h, _⟩\n  cases h\n", "additional_info": "", "used_premises": [1, 61, 69, 60, 65, 351], "def_path": "ConNF/Structural/Support.lean", "pos": [302, 306], "informalization": "The theorem `ConNF.nearLitter_not_mem_completionToAdd` states that a near-litter address does not belong to the completion of a set `s` of addresses. This is part of the construction of the natural numbers in the context of Constructive Ordinal Notation (ConNF). The completion of a set `s` is the set of addresses that need to be added to `s` to make it a \"support\" in the ConNF model. A \"support\" is a set of addresses that satisfies certain properties related to the structure of the ConNF model. The theorem shows that near-litter addresses are not added to the completion of a set `s` to make it a support, which is a key step in the proof of the natural number representation in ConNF."}
{"full_name": "ConNF.completionToAdd", "url": "ConNF/Structural/Support.html#ConNF.completionToAdd", "code_src": "con-nf", "ptype": "def", "header": "def ConNF.completionToAdd [ConNF.Params🔗<|PREMISE|>🔗 ] {α : ConNF.TypeIndex} (s : Set🔗<|PREMISE|>🔗 (ConNF.Address🔗<|PREMISE|>🔗 α)) :Set🔗<|PREMISE|>🔗 (ConNF.Address🔗<|PREMISE|>🔗 α)", "code": "def completionToAdd (s : Set (Address α)) : Set (Address α) :=\n  {x | ∃ N₁ N₂ : NearLitter, N₁.1 = N₂.1 ∧ ∃ a : Atom, x.2 = inl a ∧ a ∈ (N₁ : Set Atom) ∆ N₂ ∧\n    ⟨x.1, inr N₁⟩ ∈ s ∧ ⟨x.1, inr N₂⟩ ∈ s}\n", "additional_info": "The set of addresses that we need to add to `s` to make it a support.\nEquations\n* One or more equations did not get rendered due to their size.\n\n", "used_premises": [1, 69, 60, 69, 60], "def_path": "ConNF/Structural/Support.lean", "pos": [298, 301], "informalization": "Function `ConNF.completionToAdd` defines the set of addresses that need to be added to a given set `s` of addresses to make it a \"support\" in the context of Constructive Ordinal Notation (ConNF). A \"support\" is a set of addresses that satisfies certain properties related to the structure of the ConNF model. The function looks for pairs of near-litters `N₁` and `N₂` with the same base type, an atom `a` that belongs to the symmetric difference of `N₁` and `N₂`, and addresses `⟨x.1, inr N₁⟩` and `⟨x.1, inr N₂⟩` that are already in `s`. The function then adds the address `⟨x.1, inl a⟩` to the set `s` to ensure it becomes a support."}
{"full_name": "ConNF.completionToAdd'_small", "url": "ConNF/Structural/Support.html#ConNF.completionToAdd'_small", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.completionToAdd'_small [ConNF.Params🔗<|PREMISE|>🔗 ] {α : ConNF.TypeIndex} (s : Set🔗<|PREMISE|>🔗 (ConNF.Address🔗<|PREMISE|>🔗 α)) (hs : ConNF.Small🔗<|PREMISE|>🔗 s) (A : ConNF.ExtendedIndex🔗<|PREMISE|>🔗 α) :ConNF.Small🔗<|PREMISE|>🔗 (ConNF.completionToAdd'🔗<|PREMISE|>🔗 s A)", "code": "theorem completionToAdd'_small (s : Set (Address α)) (hs : Small s) (A : ExtendedIndex α) :\n    Small (completionToAdd' s A) := by\n  have : Function.Injective (fun N => (⟨A, inr N⟩ : Address α))\n  · intro N₁ N₂ h\n    simp only [Address.mk.injEq, inr.injEq, true_and] at h\n    exact h\n  refine Small.bUnion (Small.preimage this hs) (fun N₁ _ => ?_)\n  refine Small.bUnion (Small.preimage this hs) (fun N₂ _ => ?_)\n  refine small_iUnion_Prop (fun h => ?_)\n  refine N₁.2.prop.symm.trans ?_\n  rw [h]\n  exact N₂.2.prop\n", "additional_info": "", "used_premises": [1, 69, 60, 233, 61, 233, 353], "def_path": "ConNF/Structural/Support.lean", "pos": [313, 325], "informalization": "In the context of Constructive Ordinal Notation (ConNF), the function `ConNF.completionToAdd'` is used to define the addition operation on natural numbers. This function takes a set `s` of `ConNF.Address` objects and an `ConNF.ExtendedIndex` object `A`, and returns a set of `ConNF.Atom` objects. The theorem `ConNF.completionToAdd'_small` states that if the set `s` is small (i.e., its cardinality is strictly less than the cardinality of the type `ConNF.κ`), then the set returned by `ConNF.completionToAdd'` is also small."}
{"full_name": "ConNF.completionToAdd'", "url": "ConNF/Structural/Support.html#ConNF.completionToAdd'", "code_src": "con-nf", "ptype": "def", "header": "def ConNF.completionToAdd' [ConNF.Params🔗<|PREMISE|>🔗 ] {α : ConNF.TypeIndex} (s : Set🔗<|PREMISE|>🔗 (ConNF.Address🔗<|PREMISE|>🔗 α)) (A : ConNF.ExtendedIndex🔗<|PREMISE|>🔗 α) :Set🔗<|PREMISE|>🔗 ConNF.Atom", "code": "def completionToAdd' (s : Set (Address α)) (A : ExtendedIndex α) : Set Atom :=\n  ⋃ (N₁ : NearLitter) (_ : N₁ ∈ (fun N => ⟨A, inr N⟩) ⁻¹' s)\n    (N₂ : NearLitter) (_ : N₂ ∈ (fun N => ⟨A, inr N⟩) ⁻¹' s)\n    (_ : N₁.1 = N₂.1),\n  (N₁ : Set Atom) ∆ N₂\n", "additional_info": "Equations\n* One or more equations did not get rendered due to their size.\n\n", "used_premises": [1, 69, 60, 61, 69], "def_path": "ConNF/Structural/Support.lean", "pos": [307, 312], "informalization": "Function `ConNF.completionToAdd'` takes a set `s` of `ConNF.Address` objects and an `ConNF.ExtendedIndex` object `A`, and returns a set of `ConNF.Atom` objects. This function is part of the construction of the natural numbers in the context of Constructive Ordinal Notation (ConNF), and is used to define the addition operation on natural numbers."}
{"full_name": "ConNF.completionToAdd_eq_completionToAdd'", "url": "ConNF/Structural/Support.html#ConNF.completionToAdd_eq_completionToAdd'", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.completionToAdd_eq_completionToAdd' [ConNF.Params🔗<|PREMISE|>🔗 ] {α : ConNF.TypeIndex} (s : Set🔗<|PREMISE|>🔗 (ConNF.Address🔗<|PREMISE|>🔗 α)) :ConNF.completionToAdd🔗<|PREMISE|>🔗 s = ⋃ (A : ConNF.ExtendedIndex🔗<|PREMISE|>🔗 α), (fun (x : ConNF.Atom) => { path := A, value := Sum.inl🔗<|PREMISE|>🔗 x }) '' ConNF.completionToAdd'🔗<|PREMISE|>🔗 s A", "code": "theorem completionToAdd_eq_completionToAdd' (s : Set (Address α)) :\n    completionToAdd s = ⋃ (A : ExtendedIndex α), (⟨A, inl ·⟩) '' completionToAdd' s A := by\n  simp only [completionToAdd, completionToAdd']\n  aesop\n", "additional_info": "", "used_premises": [1, 69, 60, 351, 61, 67, 353], "def_path": "ConNF/Structural/Support.lean", "pos": [326, 330], "informalization": "The theorem `ConNF.completionToAdd_eq_completionToAdd'` establishes an equality between two sets of addresses. Specifically, it relates the set of addresses `ConNF.completionToAdd s` (which adds new addresses to a set `s` to make it a \"support\") with the union of sets obtained by applying the function `ConNF.completionToAdd'` to `s` for each `ConNF.ExtendedIndex α`. The function `ConNF.completionToAdd'` takes a set `s` and an `ConNF.ExtendedIndex α` object `A`, and returns a set of `ConNF.Atom` objects, which are used to define the addition operation on natural numbers in the context of Constructive Ordinal Notation (ConNF). The equality established by the theorem means that the set obtained by adding new addresses to `s` to make it a \"support\" can be equivalently described by taking the union of sets generated by applying `ConNF.completionToAdd'` to `s` for each possible `ConNF.ExtendedIndex α`."}
{"full_name": "ConNF.completionToAdd_small", "url": "ConNF/Structural/Support.html#ConNF.completionToAdd_small", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.completionToAdd_small [ConNF.Params🔗<|PREMISE|>🔗 ] {α : ConNF.TypeIndex} (s : Set🔗<|PREMISE|>🔗 (ConNF.Address🔗<|PREMISE|>🔗 α)) (hs : ConNF.Small🔗<|PREMISE|>🔗 s) :ConNF.Small🔗<|PREMISE|>🔗 (ConNF.completionToAdd🔗<|PREMISE|>🔗 s)", "code": "theorem completionToAdd_small (s : Set (Address α)) (hs : Small s) :\n    Small (completionToAdd s) := by\n  rw [completionToAdd_eq_completionToAdd']\n  refine small_iUnion ?_ ?_\n  · exact (mk_extendedIndex α).trans_lt Params.Λ_lt_κ\n  · intro A\n    exact Small.image (completionToAdd'_small s hs A)\n", "additional_info": "", "used_premises": [1, 69, 60, 233, 233, 351], "def_path": "ConNF/Structural/Support.lean", "pos": [331, 338], "informalization": "In the context of Constructive Ordinal Notation (ConNF), the theorem `ConNF.completionToAdd_small` states that the set of addresses that need to be added to a given set `s` of addresses to make it a \"support\" (a set of addresses that satisfies certain properties related to the structure of the ConNF model) is small, meaning its cardinality is strictly less than the cardinality of the type `ConNF.κ`."}
{"full_name": "ConNF.mem_completeEnum", "url": "ConNF/Structural/Support.html#ConNF.mem_completeEnum", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.mem_completeEnum [ConNF.Params🔗<|PREMISE|>🔗 ] {α : ConNF.TypeIndex} (E : ConNF.Enumeration🔗<|PREMISE|>🔗 (ConNF.Address🔗<|PREMISE|>🔗 α)) (c : ConNF.Address🔗<|PREMISE|>🔗 α) :c ∈ ConNF.completeEnum🔗<|PREMISE|>🔗 E ↔ c ∈ E ∨ c ∈ ConNF.completionToAdd🔗<|PREMISE|>🔗 (ConNF.Enumeration.carrier🔗<|PREMISE|>🔗 E)", "code": "theorem mem_completeEnum (E : Enumeration (Address α)) (c : Address α) :\n    c ∈ completeEnum E ↔ c ∈ E ∨ c ∈ completionToAdd E :=\n  by rw [completeEnum, Enumeration.mem_add_iff, Enumeration.mem_ofSet_iff]\n", "additional_info": "", "used_premises": [1, 59, 60, 60, 357, 351, 70], "def_path": "ConNF/Structural/Support.lean", "pos": [344, 347], "informalization": "The theorem `ConNF.mem_completeEnum` states that an address `c` belongs to the complete enumeration of an `α`-enumeration `E` if and only if `c` belongs to `E` or `c` belongs to the completion of `E` with respect to the addition operation defined in the context of Constructive Ordinal Notation (ConNF)."}
{"full_name": "ConNF.completeEnum", "url": "ConNF/Structural/Support.html#ConNF.completeEnum", "code_src": "con-nf", "ptype": "noncomputable def", "header": "noncomputable def ConNF.completeEnum [ConNF.Params🔗<|PREMISE|>🔗 ] {α : ConNF.TypeIndex} (E : ConNF.Enumeration🔗<|PREMISE|>🔗 (ConNF.Address🔗<|PREMISE|>🔗 α)) :ConNF.Enumeration🔗<|PREMISE|>🔗 (ConNF.Address🔗<|PREMISE|>🔗 α)", "code": "noncomputable def completeEnum (E : Enumeration (Address α)) :\n    Enumeration (Address α) :=\n  E + Enumeration.ofSet (completionToAdd E) (completionToAdd_small _ E.small)\n", "additional_info": "Equations\n* 🗟ConNF.completeEnum🗟🔗../.././ConNF/Structural/Support.html#ConNF.completeEnum🔗  E 🗟=🗟🔗../.././Init/Prelude.html#Eq🔗  E 🗟+🗟🔗../.././Init/Prelude.html#HAdd.hAdd🔗  🗟ConNF.Enumeration.ofSet🗟🔗../.././ConNF/Structural/Enumeration.html#ConNF.Enumeration.ofSet🔗  (🗟ConNF.completionToAdd🗟🔗../.././ConNF/Structural/Support.html#ConNF.completionToAdd🔗  (🗟ConNF.Enumeration.carrier🗟🔗../.././ConNF/Structural/Enumeration.html#ConNF.Enumeration.carrier🔗  E)) ⋯\n\n", "used_premises": [1, 59, 60, 59, 60], "def_path": "ConNF/Structural/Support.lean", "pos": [339, 342], "informalization": "Function `ConNF.completeEnum` takes an `α`-enumeration `E` (a function from an initial segment of `κ` to `α`) and returns a new `α`-enumeration, which is the sum of the original enumeration `E` and the enumeration of the completion of `E` with respect to the addition operation defined in the context of Constructive Ordinal Notation (ConNF)."}
{"full_name": "ConNF.Support.complete_isCompletion", "url": "ConNF/Structural/Support.html#ConNF.Support.complete_isCompletion", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.Support.complete_isCompletion [ConNF.Params🔗<|PREMISE|>🔗 ] {α : ConNF.TypeIndex} (E : ConNF.Enumeration🔗<|PREMISE|>🔗 (ConNF.Address🔗<|PREMISE|>🔗 α)) :ConNF.Support.IsCompletion🔗<|PREMISE|>🔗 (ConNF.Support.complete🔗<|PREMISE|>🔗 E) E", "code": "theorem Support.complete_isCompletion (E : Enumeration (Address α)) :\n    (complete E).IsCompletion E := by\n  constructor\n  · exact Enumeration.le_add _ _\n  · intro i hi₁ hi₂\n    have := Enumeration.f_mem _ (i - E.max) (κ_sub_lt hi₁ hi₂)\n    rw [← Enumeration.add_f_right hi₁ hi₂, Enumeration.mem_ofSet_iff] at this\n    obtain ⟨N₁, N₂, hN, a, ha₁, ha₂, hN₁, hN₂⟩ := this\n    refine ⟨_, a, N₁, N₂, hN, ha₂, hN₁, hN₂, ?_⟩\n    rw [← ha₁]\n    rfl\n", "additional_info": "", "used_premises": [1, 59, 60, 349, 359], "def_path": "ConNF/Structural/Support.lean", "pos": [365, 376], "informalization": "The theorem `ConNF.Support.complete_isCompletion` states that the function `ConNF.Support.complete`, which extends an enumeration to a support in the context of Constructive Ordinal Notation (ConNF), ensures that for any two near-litters `N₁` and `N₂` that are near the same litter, any atoms in their symmetric difference are included in the enumeration."}
{"full_name": "ConNF.Support.complete", "url": "ConNF/Structural/Support.html#ConNF.Support.complete", "code_src": "con-nf", "ptype": "noncomputable def", "header": "noncomputable def ConNF.Support.complete [ConNF.Params🔗<|PREMISE|>🔗 ] {α : ConNF.TypeIndex} (E : ConNF.Enumeration🔗<|PREMISE|>🔗 (ConNF.Address🔗<|PREMISE|>🔗 α)) :ConNF.Support🔗<|PREMISE|>🔗 α", "code": "noncomputable def Support.complete (E : Enumeration (Address α)) : Support α where\n  enum := completeEnum E\n  mem_of_mem_symmDiff' := completeEnum_mem_of_mem_symmDiff E\n", "additional_info": "Extend an enumeration to a support.\nEquations\n* 🗟ConNF.Support.complete🗟🔗../.././ConNF/Structural/Support.html#ConNF.Support.complete🔗  E 🗟=🗟🔗../.././Init/Prelude.html#Eq🔗  { enum := 🗟ConNF.completeEnum🗟🔗../.././ConNF/Structural/Support.html#ConNF.completeEnum🔗  E, mem_of_mem_symmDiff' := ⋯ }\n\n", "used_premises": [1, 59, 60, 58], "def_path": "ConNF/Structural/Support.lean", "pos": [361, 364], "informalization": "Function `ConNF.Support.complete` extends an enumeration to a support in the context of Constructive Ordinal Notation (ConNF), ensuring that for any two near-litters `N₁` and `N₂` that are near the same litter, any atoms in their symmetric difference are included in the enumeration."}
{"full_name": "ConNF.Support.IsSum.smul", "url": "ConNF/Structural/Support.html#ConNF.Support.IsSum.smul", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.Support.IsSum.smul [ConNF.Params🔗<|PREMISE|>🔗 ] {α : ConNF.TypeIndex} {S : ConNF.Support🔗<|PREMISE|>🔗 α} {S₁ : ConNF.Support🔗<|PREMISE|>🔗 α} {S₂ : ConNF.Support🔗<|PREMISE|>🔗 α} (h : ConNF.Support.IsSum🔗<|PREMISE|>🔗 S S₁ S₂) (π : ConNF.StructPerm🔗<|PREMISE|>🔗 α) :ConNF.Support.IsSum🔗<|PREMISE|>🔗 (π • S) (π • S₁) (π • S₂)", "code": "theorem Support.IsSum.smul {S S₁ S₂ : Support α} (h : S.IsSum S₁ S₂) (π : StructPerm α) :\n    (π • S).IsSum (π • S₁) (π • S₂) := by\n  have := IsCompletion.smul h π\n  rw [Enumeration.smul_add] at this\n  exact this\n", "additional_info": "", "used_premises": [1, 58, 58, 58, 361, 55, 361], "def_path": "ConNF/Structural/Support.lean", "pos": [380, 385], "informalization": "Function `ConNF.Support.IsSum.smul` proves that if `S` is a sum of `S₁` and `S₂`, and `π` is a structural permutation, then `π • S` is a sum of `π • S₁` and `π • S₂`."}
{"full_name": "ConNF.Support.IsSum", "url": "ConNF/Structural/Support.html#ConNF.Support.IsSum", "code_src": "con-nf", "ptype": "def", "header": "def ConNF.Support.IsSum [ConNF.Params🔗<|PREMISE|>🔗 ] {α : ConNF.TypeIndex} (S : ConNF.Support🔗<|PREMISE|>🔗 α) (S₁ : ConNF.Support🔗<|PREMISE|>🔗 α) (S₂ : ConNF.Support🔗<|PREMISE|>🔗 α) :Prop", "code": "def Support.IsSum (S S₁ S₂ : Support α) : Prop := S.IsCompletion (S₁.enum + S₂.enum)\n", "additional_info": "`S` is a *sum* of `S₁` and `S₂` if it is a completion of `S₁ + S₂`.\nEquations\n* 🗟ConNF.Support.IsSum🗟🔗../.././ConNF/Structural/Support.html#ConNF.Support.IsSum🔗  S S₁ S₂ 🗟=🗟🔗../.././Init/Prelude.html#Eq🔗  🗟ConNF.Support.IsCompletion🗟🔗../.././ConNF/Structural/Support.html#ConNF.Support.IsCompletion🔗  S (S₁.enum 🗟+🗟🔗../.././Init/Prelude.html#HAdd.hAdd🔗  S₂.enum)\n\n", "used_premises": [1, 58, 58, 58], "def_path": "ConNF/Structural/Support.lean", "pos": [378, 379], "informalization": "Function `ConNF.Support.IsSum` checks if a `ConNF.Support` object `S` is a sum of two other `ConNF.Support` objects `S₁` and `S₂`. This is determined by checking if `S` is a completion of the sum of the enumerations of `S₁` and `S₂`."}
{"full_name": "ConNF.Support.exists_isSum", "url": "ConNF/Structural/Support.html#ConNF.Support.exists_isSum", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.Support.exists_isSum [ConNF.Params🔗<|PREMISE|>🔗 ] {α : ConNF.TypeIndex} (S₁ : ConNF.Support🔗<|PREMISE|>🔗 α) (S₂ : ConNF.Support🔗<|PREMISE|>🔗 α) :∃ (S : ConNF.Support🔗<|PREMISE|>🔗 α), ConNF.Support.IsSum🔗<|PREMISE|>🔗 S S₁ S₂", "code": "theorem Support.exists_isSum (S₁ S₂ : Support α) : ∃ S : Support α, S.IsSum S₁ S₂ :=\n  ⟨_, Support.complete_isCompletion _⟩\n", "additional_info": "", "used_premises": [1, 58, 58, 58, 361], "def_path": "ConNF/Structural/Support.lean", "pos": [386, 388], "informalization": "Given two `ConNF.Support` objects `S₁` and `S₂`, there exists a `ConNF.Support` object `S` such that `S` is the sum of `S₁` and `S₂`."}
{"full_name": "ConNF.someOfMkLt_spec", "url": "ConNF/Fuzz/Construction.html#ConNF.someOfMkLt_spec", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.someOfMkLt_spec {β : Type u} {s : Set🔗<|PREMISE|>🔗 β} {h : Cardinal.mk🔗<|PREMISE|>🔗 ↑s < Cardinal.mk🔗<|PREMISE|>🔗 β} :ConNF.someOfMkLt🔗<|PREMISE|>🔗 s h ∉ s", "code": "theorem someOfMkLt_spec {s : Set β} {h : #s < #β} : someOfMkLt s h ∉ s :=\n  (nonempty_compl_of_mk_lt_mk h).choose_spec\n", "additional_info": "", "used_premises": [69, 29, 29, 364], "def_path": "ConNF/Fuzz/Construction.lean", "pos": [51, 53], "informalization": "Function `ConNF.someOfMkLt` noncomputably chooses an element from the complement of a set `s` in a type `β`, given that the cardinality of `s` is less than the cardinality of `β`. The theorem `ConNF.someOfMkLt_spec` states that the chosen element does not belong to the set `s`."}
{"full_name": "ConNF.someOfMkLt", "url": "ConNF/Fuzz/Construction.html#ConNF.someOfMkLt", "code_src": "con-nf", "ptype": "noncomputable def", "header": "noncomputable def ConNF.someOfMkLt {β : Type u} (s : Set🔗<|PREMISE|>🔗 β) (h : Cardinal.mk🔗<|PREMISE|>🔗 ↑s < Cardinal.mk🔗<|PREMISE|>🔗 β) :β", "code": "noncomputable def someOfMkLt (s : Set β) (h : #s < #β) : β :=\n  (nonempty_compl_of_mk_lt_mk h).choose\n", "additional_info": "Noncomputably chooses an element of `β \\ s`, given `#s < #β`.\nEquations\n* 🗟ConNF.someOfMkLt🗟🔗../.././ConNF/Fuzz/Construction.html#ConNF.someOfMkLt🔗  s h 🗟=🗟🔗../.././Init/Prelude.html#Eq🔗  🗟Exists.choose🗟🔗../.././Init/Classical.html#Exists.choose🔗  ⋯\n\n", "used_premises": [69, 29, 29], "def_path": "ConNF/Fuzz/Construction.lean", "pos": [48, 50], "informalization": "Function `ConNF.someOfMkLt` noncomputably chooses an element from the complement of a set `s` in a type `β`, given that the cardinality of `s` is less than the cardinality of `β`."}
{"full_name": "ConNF.mk_image₂_le", "url": "ConNF/Fuzz/Construction.html#ConNF.mk_image₂_le", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.mk_image₂_le {α : Type u} {β : Type u} {p : α → Prop } (f : (x : α) → p x → β) :Cardinal.mk🔗<|PREMISE|>🔗 { y : β // ∃ (z : α) (h : p z), f z h = y } ≤ Cardinal.mk🔗<|PREMISE|>🔗 { x : α // p x }", "code": "theorem mk_image₂_le {p : α → Prop} (f : ∀ x, p x → β) :\n    #{ y // ∃ z h, f z h = y } ≤ #{ x // p x } :=\n  ⟨⟨fun y => ⟨y.prop.choose, y.prop.choose_spec.choose⟩, by\n    intro y₁ y₂ h\n    simp only [Subtype.mk.injEq] at h\n    have := y₂.prop.choose_spec.choose_spec\n    simp_rw [← h] at this\n    rw [y₁.prop.choose_spec.choose_spec] at this\n    simp only [Subtype.coe_inj] at this\n    exact this⟩⟩\n", "additional_info": "", "used_premises": [29, 29], "def_path": "ConNF/Fuzz/Construction.lean", "pos": [54, 64], "informalization": "Function `ConNF.mk_image₂_le` proves that the cardinality of the range of a function `f : (x : α) → p x → β` is less than or equal to the cardinality of the domain `{x : α // p x}`."}
{"full_name": "ConNF.chooseWfCore_spec", "url": "ConNF/Fuzz/Construction.html#ConNF.chooseWfCore_spec", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.chooseWfCore_spec {α : Type u} {β : Type u} {r : α → α → Prop } {deny : α → Set🔗<|PREMISE|>🔗 β} {h : ∀ (x : α), Cardinal.mk🔗<|PREMISE|>🔗 { y : α // r y x } + Cardinal.mk🔗<|PREMISE|>🔗 ↑(deny x) < Cardinal.mk🔗<|PREMISE|>🔗 β} (x : α) (f : (y : α) → r y x → β) :ConNF.chooseWfCore🔗<|PREMISE|>🔗 deny h x f ∉ {z : β | ∃ (y : α) (h : r y x), f y h = z} ∪ deny x", "code": "theorem chooseWfCore_spec {deny : α → Set β} {h : ∀ x, #{ y // r y x } + #(deny x) < #β} (x : α)\n    (f : ∀ y : α, r y x → β) :\n    chooseWfCore deny h x f ∉ {z | ∃ y h, f y h = z} ∪ deny x :=\n  someOfMkLt_spec\n", "additional_info": "", "used_premises": [69, 29, 29, 29, 367], "def_path": "ConNF/Fuzz/Construction.lean", "pos": [70, 74], "informalization": "Function `ConNF.chooseWfCore` is a noncomputable function that, given a type `α`, a type `β`, a relation `r` on `α`, a function `deny` from `α` to sets of `β`, a proof `h` that for each `x` in `α`, the cardinality of the set of `y` such that `r y x` plus the cardinality of `deny x` is less than the cardinality of `β`, an element `x` of `α`, and a function `f` from the set of `y` such that `r y x` to `β`, returns an element of `β` that is not in the union of the image of `f` and `deny x`."}
{"full_name": "ConNF.chooseWfCore", "url": "ConNF/Fuzz/Construction.html#ConNF.chooseWfCore", "code_src": "con-nf", "ptype": "noncomputable def", "header": "noncomputable def ConNF.chooseWfCore {α : Type u} {β : Type u} {r : α → α → Prop } (deny : α → Set🔗<|PREMISE|>🔗 β) (h : ∀ (x : α), Cardinal.mk🔗<|PREMISE|>🔗 { y : α // r y x } + Cardinal.mk🔗<|PREMISE|>🔗 ↑(deny x) < Cardinal.mk🔗<|PREMISE|>🔗 β) (x : α) (f : (y : α) → r y x → β) :β", "code": "noncomputable def chooseWfCore (deny : α → Set β) (h : ∀ x, #{ y // r y x } + #(deny x) < #β)\n    (x : α) (f : ∀ y : α, r y x → β) : β :=\n  someOfMkLt ({z | ∃ y h, f y h = z} ∪ deny x)\n    (lt_of_le_of_lt (mk_union_le _ _) (lt_of_le_of_lt (add_le_add_right (mk_image₂_le _) _) (h x)))\n", "additional_info": "Equations\n* 🗟ConNF.chooseWfCore🗟🔗../.././ConNF/Fuzz/Construction.html#ConNF.chooseWfCore🔗  deny h x f 🗟=🗟🔗../.././Init/Prelude.html#Eq🔗  🗟ConNF.someOfMkLt🗟🔗../.././ConNF/Fuzz/Construction.html#ConNF.someOfMkLt🔗  ({z : β | ∃ (y : α) (h : r y x), f y h 🗟=🗟🔗../.././Init/Prelude.html#Eq🔗  z} 🗟∪🗟🔗../.././Init/Core.html#Union.union🔗  deny x) ⋯\n\n", "used_premises": [69, 29, 29, 29], "def_path": "ConNF/Fuzz/Construction.lean", "pos": [65, 69], "informalization": "Function `ConNF.chooseWfCore` is a noncomputable function that, given a type `α`, a type `β`, a relation `r` on `α`, a function `deny` from `α` to sets of `β`, a proof `h` that for each `x` in `α`, the cardinality of the set of `y` such that `r y x` plus the cardinality of `deny x` is less than the cardinality of `β`, an element `x` of `α`, and a function `f` from the set of `y` such that `r y x` to `β`, returns an element of `β`."}
{"full_name": "ConNF.chooseWf_spec", "url": "ConNF/Fuzz/Construction.html#ConNF.chooseWf_spec", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.chooseWf_spec {α : Type u} {β : Type u} {r : α → α → Prop } [hwf : IsWellOrder🔗<|PREMISE|>🔗 α r] {deny : α → Set🔗<|PREMISE|>🔗 β} {h : ∀ (x : α), Cardinal.mk🔗<|PREMISE|>🔗 { y : α // r y x } + Cardinal.mk🔗<|PREMISE|>🔗 ↑(deny x) < Cardinal.mk🔗<|PREMISE|>🔗 β} (x : α) :ConNF.chooseWf🔗<|PREMISE|>🔗 deny h x ∉ {z : β | ∃ (y : α) (_ : r y x), ConNF.chooseWf🔗<|PREMISE|>🔗 deny h y = z} ∪ deny x", "code": "theorem chooseWf_spec [hwf : IsWellOrder α r] {deny : α → Set β}\n    {h : ∀ x, #{ y // r y x } + #(deny x) < #β} (x : α) :\n    chooseWf deny h x ∉ {z | ∃ (y : _) (_ : r y x), chooseWf deny h y = z} ∪ deny x := by\n  rw [chooseWf, WellFounded.fix_eq]\n  exact chooseWfCore_spec x _\n", "additional_info": "", "used_premises": [15, 69, 29, 29, 29, 369, 369], "def_path": "ConNF/Fuzz/Construction.lean", "pos": [80, 85], "informalization": "Function `ConNF.chooseWf` constructs an injective function `f` such that `f x ∉ deny x`."}
{"full_name": "ConNF.chooseWf", "url": "ConNF/Fuzz/Construction.html#ConNF.chooseWf", "code_src": "con-nf", "ptype": "noncomputable def", "header": "noncomputable def ConNF.chooseWf {α : Type u} {β : Type u} {r : α → α → Prop } [hwf : IsWellOrder🔗<|PREMISE|>🔗 α r] (deny : α → Set🔗<|PREMISE|>🔗 β) (h : ∀ (x : α), Cardinal.mk🔗<|PREMISE|>🔗 { y : α // r y x } + Cardinal.mk🔗<|PREMISE|>🔗 ↑(deny x) < Cardinal.mk🔗<|PREMISE|>🔗 β) :α → β", "code": "noncomputable def chooseWf [hwf : IsWellOrder α r] (deny : α → Set β)\n    (h : ∀ x, #{ y // r y x } + #(deny x) < #β) : α → β :=\n  hwf.toIsWellFounded.wf.fix (chooseWfCore deny h)\n", "additional_info": "Constructs an injective function `f` such that `f x ∉ deny x`.\nEquations\n* 🗟ConNF.chooseWf🗟🔗../.././ConNF/Fuzz/Construction.html#ConNF.chooseWf🔗  deny h 🗟=🗟🔗../.././Init/Prelude.html#Eq🔗  🗟WellFounded.fix🗟🔗../.././Init/WF.html#WellFounded.fix🔗  ⋯ (🗟ConNF.chooseWfCore🗟🔗../.././ConNF/Fuzz/Construction.html#ConNF.chooseWfCore🔗  deny h)\n\n", "used_premises": [15, 69, 29, 29, 29], "def_path": "ConNF/Fuzz/Construction.lean", "pos": [76, 79], "informalization": "Function `ConNF.chooseWf` constructs an injective function `f` such that `f x ∉ deny x`."}
{"full_name": "ConNF.chooseWf_not_mem_deny", "url": "ConNF/Fuzz/Construction.html#ConNF.chooseWf_not_mem_deny", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.chooseWf_not_mem_deny {α : Type u} {β : Type u} {r : α → α → Prop } [IsWellOrder🔗<|PREMISE|>🔗 α r] {deny : α → Set🔗<|PREMISE|>🔗 β} {h : ∀ (x : α), Cardinal.mk🔗<|PREMISE|>🔗 { y : α // r y x } + Cardinal.mk🔗<|PREMISE|>🔗 ↑(deny x) < Cardinal.mk🔗<|PREMISE|>🔗 β} (x : α) :ConNF.chooseWf🔗<|PREMISE|>🔗 deny h x ∉ deny x", "code": "theorem chooseWf_not_mem_deny [IsWellOrder α r] {deny : α → Set β}\n    {h : ∀ x, #{ y // r y x } + #(deny x) < #β} (x : α) : chooseWf deny h x ∉ deny x :=\n  fun h' => chooseWf_spec x (mem_union_right _ h')\n", "additional_info": "", "used_premises": [15, 69, 29, 29, 29, 369], "def_path": "ConNF/Fuzz/Construction.lean", "pos": [86, 89], "informalization": "Function `ConNF.chooseWf` constructs an injective function `f` such that `f x ∉ deny x`."}
{"full_name": "ConNF.chooseWf_ne_of_r", "url": "ConNF/Fuzz/Construction.html#ConNF.chooseWf_ne_of_r", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.chooseWf_ne_of_r {α : Type u} {β : Type u} {r : α → α → Prop } [_inst : IsWellOrder🔗<|PREMISE|>🔗 α r] {deny : α → Set🔗<|PREMISE|>🔗 β} {h : ∀ (x : α), Cardinal.mk🔗<|PREMISE|>🔗 { y : α // r y x } + Cardinal.mk🔗<|PREMISE|>🔗 ↑(deny x) < Cardinal.mk🔗<|PREMISE|>🔗 β} (x₁ : α) (x₂ : α) (hx : r x₁ x₂) :ConNF.chooseWf🔗<|PREMISE|>🔗 deny h x₁ ≠ ConNF.chooseWf🔗<|PREMISE|>🔗 deny h x₂", "code": "theorem chooseWf_ne_of_r [_inst : IsWellOrder α r] {deny : α → Set β}\n    {h : ∀ x, #{ y // r y x } + #(deny x) < #β} (x₁ x₂ : α) (hx : r x₁ x₂) :\n    chooseWf deny h x₁ ≠ chooseWf deny h x₂ := fun hx' =>\n  not_mem_subset (subset_union_left _ _) (chooseWf_spec x₂) ⟨x₁, hx, hx'⟩\n", "additional_info": "", "used_premises": [15, 69, 29, 29, 29, 369, 369], "def_path": "ConNF/Fuzz/Construction.lean", "pos": [90, 94], "informalization": "Function `ConNF.chooseWf_ne_of_r` is a proof that for any two elements `x₁` and `x₂` of a well-ordered type `α`, if `r x₁ x₂` (meaning `x₁` is less than `x₂` under the well-order `r`), then `ConNF.chooseWf deny h x₁` (which is an injective function `f` such that `f x ∉ deny x`, where `deny` is a function that maps `α` to sets of `β` elements and `h` is a condition on the cardinality of the sets `{y : α // r y x}` and `deny x`) is not equal to `ConNF.chooseWf deny h x₂`. This result is crucial for showing that Conant's N-free construction can be applied to any well-ordered set."}
{"full_name": "ConNF.chooseWf_injective", "url": "ConNF/Fuzz/Construction.html#ConNF.chooseWf_injective", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.chooseWf_injective {α : Type u} {β : Type u} {r : α → α → Prop } [inst : IsWellOrder🔗<|PREMISE|>🔗 α r] {deny : α → Set🔗<|PREMISE|>🔗 β} {h : ∀ (x : α), Cardinal.mk🔗<|PREMISE|>🔗 { y : α // r y x } + Cardinal.mk🔗<|PREMISE|>🔗 ↑(deny x) < Cardinal.mk🔗<|PREMISE|>🔗 β} :Function.Injective🔗<|PREMISE|>🔗 (ConNF.chooseWf🔗<|PREMISE|>🔗 deny h)", "code": "theorem chooseWf_injective [inst : IsWellOrder α r] {deny : α → Set β}\n    {h : ∀ x, #{ y // r y x } + #(deny x) < #β} : Injective (chooseWf deny h) := by\n  intro x₁ x₂ h\n  obtain hx | hx | hx := @lt_trichotomy _ (IsWellOrder.linearOrder r) x₁ x₂\n  · cases chooseWf_ne_of_r (_inst := inst) x₁ x₂ hx h\n  · exact hx\n  · cases chooseWf_ne_of_r (_inst := inst) x₂ x₁ hx h.symm\n", "additional_info": "", "used_premises": [15, 69, 29, 29, 29, 89, 369], "def_path": "ConNF/Fuzz/Construction.lean", "pos": [95, 102], "informalization": "Function `ConNF.chooseWf` constructs an injective function `f` such that `f x ∉ deny x`. The theorem `ConNF.chooseWf_injective` proves that this function is indeed injective."}
{"full_name": "ConNF.mk_invImage_lt", "url": "ConNF/Fuzz/Construction.html#ConNF.mk_invImage_lt", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.mk_invImage_lt [ConNF.Params🔗<|PREMISE|>🔗 ] {β : ConNF.TypeIndex} [ConNF.TangleData🔗<|PREMISE|>🔗 β] [ConNF.PositionedTangles🔗<|PREMISE|>🔗 β] (t : ConNF.Tangle β) :Cardinal.mk🔗<|PREMISE|>🔗 { t' : ConNF.Tangle β // t' < t } < Cardinal.mk🔗<|PREMISE|>🔗 ConNF.μ", "code": "theorem mk_invImage_lt (t : Tangle β) : #{ t' // t' < t } < #μ := by\n  refine lt_of_le_of_lt ?_ (show #{ ν // ν < pos t } < #μ from card_Iio_lt _)\n  refine ⟨⟨fun t' => ⟨_, t'.prop⟩, ?_⟩⟩\n  intro y₁ y₂ h\n  simp only [Subtype.mk.injEq, EmbeddingLike.apply_eq_iff_eq, Subtype.coe_inj] at h\n  exact h\n", "additional_info": "", "used_premises": [1, 39, 72, 29, 29], "def_path": "ConNF/Fuzz/Construction.lean", "pos": [123, 129], "informalization": "In the context of Constructive Ordinal Notation (ConNF), the theorem `ConNF.mk_invImage_lt` asserts that for any tangle `t` at level `β`, the cardinality of the set of all tangles less than `t` is strictly less than the cardinality of the type `μ`. This result is crucial for establishing the well-foundedness of the `<` relation on tangles within the ConNF framework."}
{"full_name": "ConNF.mk_invImage_le", "url": "ConNF/Fuzz/Construction.html#ConNF.mk_invImage_le", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.mk_invImage_le [ConNF.Params🔗<|PREMISE|>🔗 ] {β : ConNF.TypeIndex} (γ : ConNF.Λ) [ConNF.TangleData🔗<|PREMISE|>🔗 β] [ConNF.PositionedTangles🔗<|PREMISE|>🔗 β] [ConNF.TangleData🔗<|PREMISE|>🔗 ↑γ] [ConNF.PositionedTangles🔗<|PREMISE|>🔗 ↑γ] (t : ConNF.Tangle β) :Cardinal.mk🔗<|PREMISE|>🔗 { t' : ConNF.Tangle ↑γ // ConNF.pos t' ≤ ConNF.pos t } < Cardinal.mk🔗<|PREMISE|>🔗 ConNF.μ", "code": "theorem mk_invImage_le (t : Tangle β) : #{ t' : Tangle γ // pos t' ≤ pos t } < #μ := by\n  refine lt_of_le_of_lt ?_ (show #{ ν // ν ≤ pos t } < #μ from card_Iic_lt _)\n  refine ⟨⟨fun t' => ⟨_, t'.prop⟩, ?_⟩⟩\n  intro y₁ y₂ h\n  simp only [Subtype.mk.injEq, EmbeddingLike.apply_eq_iff_eq, Subtype.coe_inj] at h\n  exact h\n", "additional_info": "", "used_premises": [1, 39, 72, 39, 72, 29, 29], "def_path": "ConNF/Fuzz/Construction.lean", "pos": [130, 136], "informalization": "In the context of Constructive Ordinal Notation (ConNF), the theorem `ConNF.mk_invImage_le` asserts that the cardinality of the set of tangles `t'` at level `γ` such that the position of `t'` is less than or equal to the position of a given tangle `t` at level `β`, is strictly less than the cardinality of the type `μ`. This result is crucial for establishing the well-foundedness of the ConNF hierarchy."}
{"full_name": "ConNF.mk_fuzzDeny", "url": "ConNF/Fuzz/Construction.html#ConNF.mk_fuzzDeny", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.mk_fuzzDeny [ConNF.Params🔗<|PREMISE|>🔗 ] {β : ConNF.TypeIndex} {γ : ConNF.Λ} [ConNF.TangleData🔗<|PREMISE|>🔗 β] [ConNF.PositionedTangles🔗<|PREMISE|>🔗 β] [ConNF.TangleData🔗<|PREMISE|>🔗 ↑γ] [ConNF.PositionedTangles🔗<|PREMISE|>🔗 ↑γ] [ConNF.TypedObjects🔗<|PREMISE|>🔗 γ] (t : ConNF.Tangle β) :Cardinal.mk🔗<|PREMISE|>🔗 { t' : ConNF.Tangle β // t' < t } + Cardinal.mk🔗<|PREMISE|>🔗 ↑(ConNF.fuzzDeny🔗<|PREMISE|>🔗 γ t) < Cardinal.mk🔗<|PREMISE|>🔗 ConNF.μ", "code": "theorem mk_fuzzDeny (t : Tangle β) :\n    #{ t' // t' < t } + #(fuzzDeny γ t) < #μ := by\n  refine add_lt_of_lt Params.μ_isStrongLimit.isLimit.aleph0_le (mk_invImage_lt t) ?_\n  refine lt_of_le_of_lt (mk_union_le _ _) ?_\n  refine add_lt_of_lt Params.μ_isStrongLimit.isLimit.aleph0_le ?_ ?_\n  · refine lt_of_le_of_lt ?_ (mk_invImage_le γ t)\n    refine ⟨⟨fun i => ⟨typedNearLitter i.prop.choose, i.prop.choose_spec.1⟩, ?_⟩⟩\n    intro ν₁ ν₂ h\n    have h' := typedNearLitter.injective (Subtype.coe_inj.mpr h)\n    have := ν₁.2.choose_spec.2\n    rw [h', ← ν₂.2.choose_spec.2] at this\n    exact Subtype.coe_inj.mp this\n  · have : #{ a : Atom | pos a ≤ pos t } < #μ\n    · refine lt_of_le_of_lt ?_ (card_Iic_lt (pos t))\n      refine ⟨⟨fun a => ⟨pos a.1, a.2⟩, ?_⟩⟩\n      intro a b h\n      exact Subtype.coe_inj.mp (pos_injective (Subtype.coe_inj.mpr h))\n    refine lt_of_le_of_lt ?_ this\n    refine mk_le_of_surjective (f := fun a => ⟨_, a.1, a.2, rfl⟩) ?_\n    rintro ⟨_, a, ha, rfl⟩\n    exact ⟨⟨a, ha⟩, rfl⟩\n", "additional_info": "", "used_premises": [1, 39, 72, 39, 72, 73, 29, 29, 376, 29], "def_path": "ConNF/Fuzz/Construction.lean", "pos": [139, 160], "informalization": "Function `ConNF.fuzzDeny` defines a set of elements of type `ConNF.μ` that the function `ConNF.fuzz` cannot assign to a given tangle `t` of type `ConNF.Tangle β` in the context of Constructive Ordinal Notation (ConNF). This set is the union of two subsets: one for near-litters and one for atoms. The theorem `ConNF.mk_fuzzDeny` asserts that the sum of the cardinality of the set of tangles less than `t` and the cardinality of the set `ConNF.fuzzDeny γ t` is less than the cardinality of `ConNF.μ`."}
{"full_name": "ConNF.fuzzDeny", "url": "ConNF/Fuzz/Construction.html#ConNF.fuzzDeny", "code_src": "con-nf", "ptype": "def", "header": "def ConNF.fuzzDeny [ConNF.Params🔗<|PREMISE|>🔗 ] {β : ConNF.TypeIndex} (γ : ConNF.Λ) [ConNF.TangleData🔗<|PREMISE|>🔗 β] [ConNF.PositionedTangles🔗<|PREMISE|>🔗 β] [ConNF.TangleData🔗<|PREMISE|>🔗 ↑γ] [ConNF.PositionedTangles🔗<|PREMISE|>🔗 ↑γ] [ConNF.TypedObjects🔗<|PREMISE|>🔗 γ] (t : ConNF.Tangle β) :Set🔗<|PREMISE|>🔗 ConNF.μ", "code": "def fuzzDeny (t : Tangle β) : Set μ :=\n  { ν : μ | ∃ (N : NearLitter), pos (typedNearLitter N : Tangle γ) ≤ pos t ∧ ν = N.1.1 } ∪\n  { ν : μ | ∃ (a : Atom), pos a ≤ pos t ∧ ν = a.1.1 }\n", "additional_info": "The set of elements of `ν` that `🗟fuzz🗟🔗../.././ConNF/Fuzz/Construction.html#ConNF.fuzz🔗  _ t` cannot be.\nEquations\n* One or more equations did not get rendered due to their size.\n\n", "used_premises": [1, 39, 72, 39, 72, 73, 69], "def_path": "ConNF/Fuzz/Construction.lean", "pos": [119, 122], "informalization": "Function `ConNF.fuzzDeny` defines a set of elements of type `ConNF.μ` that the function `ConNF.fuzz` cannot assign to a given tangle `t` of type `ConNF.Tangle β` in the context of Constructive Ordinal Notation (ConNF). This set is the union of two subsets: one for near-litters and one for atoms."}
{"full_name": "ConNF.fuzz_β", "url": "ConNF/Fuzz/Construction.html#ConNF.fuzz_β", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.fuzz_β [ConNF.Params🔗<|PREMISE|>🔗 ] {β : ConNF.TypeIndex} {γ : ConNF.Λ} [ConNF.TangleData🔗<|PREMISE|>🔗 β] [ConNF.PositionedTangles🔗<|PREMISE|>🔗 β] [ConNF.TangleData🔗<|PREMISE|>🔗 ↑γ] [ConNF.PositionedTangles🔗<|PREMISE|>🔗 ↑γ] [ConNF.TypedObjects🔗<|PREMISE|>🔗 γ] (hβγ : β ≠ ↑γ) (t : ConNF.Tangle β) :(ConNF.fuzz🔗<|PREMISE|>🔗 hβγ t).β = β", "code": "theorem fuzz_β (t : Tangle β) : (fuzz hβγ t).β = β :=\n  rfl\n", "additional_info": "", "used_premises": [1, 39, 72, 39, 72, 73, 78], "def_path": "ConNF/Fuzz/Construction.lean", "pos": [186, 188], "informalization": "Function `ConNF.fuzz` is a noncomputable function defined in the context of Constructive Ordinal Notation (ConNF) in Lean 4. It takes as input a tangle `t` of type `β` and returns a `Litter` object. The `Litter` object is defined as a 4-tuple consisting of a `Wf` object, a type index `β`, a `Λ` object `γ`, and a proof that `β` is not equal to `γ`. The `Wf` object is chosen using the `chooseWf` function, which selects an element from a nonempty set. The `chooseWf` function is applied to the set `fuzzDeny γ`, which is defined using the `mk_fuzzDeny` function. The `mk_fuzzDeny` function takes a tangle `t` of type `β` and returns a `Wf` object. The `Litter` object is then constructed using the chosen `Wf` object, the type index `β`, the `Λ` object `γ`, and the proof that `β` is not equal to `γ`."}
{"full_name": "ConNF.fuzz_γ", "url": "ConNF/Fuzz/Construction.html#ConNF.fuzz_γ", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.fuzz_γ [ConNF.Params🔗<|PREMISE|>🔗 ] {β : ConNF.TypeIndex} {γ : ConNF.Λ} [ConNF.TangleData🔗<|PREMISE|>🔗 β] [ConNF.PositionedTangles🔗<|PREMISE|>🔗 β] [ConNF.TangleData🔗<|PREMISE|>🔗 ↑γ] [ConNF.PositionedTangles🔗<|PREMISE|>🔗 ↑γ] [ConNF.TypedObjects🔗<|PREMISE|>🔗 γ] (hβγ : β ≠ ↑γ) (t : ConNF.Tangle β) :(ConNF.fuzz🔗<|PREMISE|>🔗 hβγ t).γ = γ", "code": "theorem fuzz_γ (t : Tangle β) : (fuzz hβγ t).γ = γ :=\n  rfl\n", "additional_info": "", "used_premises": [1, 39, 72, 39, 72, 73, 78], "def_path": "ConNF/Fuzz/Construction.lean", "pos": [190, 192], "informalization": "Function `ConNF.fuzz` is a noncomputable function defined in the context of Constructive Ordinal Notation (ConNF) in Lean 4. It takes as input a tangle `t` of type `β` and returns a `Litter` object. The `Litter` object is defined as a 4-tuple consisting of a `Wf` object, a type index `β`, a `Λ` object `γ`, and a proof that `β` is not equal to `γ`. The `Wf` object is chosen using the `chooseWf` function, which selects an element from a nonempty set. The `chooseWf` function is applied to the set `fuzzDeny γ`, which is defined using the `mk_fuzzDeny` function. The `mk_fuzzDeny` function takes a tangle `t` of type `β` and returns a `Wf` object. The `Litter` object is then constructed using the chosen `Wf` object, the type index `β`, the `Λ` object `γ`, and the proof that `β` is not equal to `γ`."}
{"full_name": "ConNF.fuzz_congr_β", "url": "ConNF/Fuzz/Construction.html#ConNF.fuzz_congr_β", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.fuzz_congr_β [ConNF.Params🔗<|PREMISE|>🔗 ] {β : ConNF.TypeIndex} {γ : ConNF.Λ} [ConNF.TangleData🔗<|PREMISE|>🔗 β] [ConNF.PositionedTangles🔗<|PREMISE|>🔗 β] [ConNF.TangleData🔗<|PREMISE|>🔗 ↑γ] [ConNF.PositionedTangles🔗<|PREMISE|>🔗 ↑γ] [ConNF.TypedObjects🔗<|PREMISE|>🔗 γ] {β' : ConNF.TypeIndex} {γ' : ConNF.Λ} [ConNF.TangleData🔗<|PREMISE|>🔗 β'] [ConNF.PositionedTangles🔗<|PREMISE|>🔗 β'] [ConNF.TangleData🔗<|PREMISE|>🔗 ↑γ'] [ConNF.PositionedTangles🔗<|PREMISE|>🔗 ↑γ'] [ConNF.TypedObjects🔗<|PREMISE|>🔗 γ'] {hβγ : β ≠ ↑γ} {hβγ' : β' ≠ ↑γ'} {t : ConNF.Tangle β} {t' : ConNF.Tangle β'} (h : ConNF.fuzz🔗<|PREMISE|>🔗 hβγ t = ConNF.fuzz🔗<|PREMISE|>🔗 hβγ' t') :β = β'", "code": "lemma fuzz_congr_β {hβγ : (β : TypeIndex) ≠ γ} {hβγ' : (β' : TypeIndex) ≠ γ'}\n  {t : Tangle β} {t' : Tangle β'} (h : fuzz hβγ t = fuzz hβγ' t') :\n  β = β' := by\n  have h₁ := fuzz_β hβγ t\n  have h₂ := fuzz_β hβγ' t'\n  rw [← h, h₁] at h₂\n  exact h₂\n", "additional_info": "", "used_premises": [1, 39, 72, 39, 72, 73, 39, 72, 39, 72, 73, 78, 78], "def_path": "ConNF/Fuzz/Construction.lean", "pos": [198, 205], "informalization": "In the context of Constructive Ordinal Notation (ConNF) in Lean 4, the theorem `ConNF.fuzz_congr_β` asserts that for any two tangles `t` and `t'` of types `β` and `β'` respectively, if the `fuzz` function applied to `t` and `t'` yields the same `Litter` object, then `β` must be equal to `β'`."}
{"full_name": "ConNF.fuzz_congr_γ", "url": "ConNF/Fuzz/Construction.html#ConNF.fuzz_congr_γ", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.fuzz_congr_γ [ConNF.Params🔗<|PREMISE|>🔗 ] {β : ConNF.TypeIndex} {γ : ConNF.Λ} [ConNF.TangleData🔗<|PREMISE|>🔗 β] [ConNF.PositionedTangles🔗<|PREMISE|>🔗 β] [ConNF.TangleData🔗<|PREMISE|>🔗 ↑γ] [ConNF.PositionedTangles🔗<|PREMISE|>🔗 ↑γ] [ConNF.TypedObjects🔗<|PREMISE|>🔗 γ] {β' : ConNF.TypeIndex} {γ' : ConNF.Λ} [ConNF.TangleData🔗<|PREMISE|>🔗 β'] [ConNF.PositionedTangles🔗<|PREMISE|>🔗 β'] [ConNF.TangleData🔗<|PREMISE|>🔗 ↑γ'] [ConNF.PositionedTangles🔗<|PREMISE|>🔗 ↑γ'] [ConNF.TypedObjects🔗<|PREMISE|>🔗 γ'] {hβγ : β ≠ ↑γ} {hβγ' : β' ≠ ↑γ'} {t : ConNF.Tangle β} {t' : ConNF.Tangle β'} (h : ConNF.fuzz🔗<|PREMISE|>🔗 hβγ t = ConNF.fuzz🔗<|PREMISE|>🔗 hβγ' t') :γ = γ'", "code": "lemma fuzz_congr_γ {hβγ : (β : TypeIndex) ≠ γ} {hβγ' : (β' : TypeIndex) ≠ γ'}\n  {t : Tangle β} {t' : Tangle β'} (h : fuzz hβγ t = fuzz hβγ' t') :\n  γ = γ' := by\n  have h₁ := fuzz_γ hβγ t\n  have h₂ := fuzz_γ hβγ' t'\n  rw [← h, h₁] at h₂\n  exact h₂\n", "additional_info": "", "used_premises": [1, 39, 72, 39, 72, 73, 39, 72, 39, 72, 73, 78, 78], "def_path": "ConNF/Fuzz/Construction.lean", "pos": [206, 213], "informalization": "In the context of Constructive Ordinal Notation (ConNF) in Lean 4, the theorem `ConNF.fuzz_congr_γ` asserts that for any two tangles `t` and `t'` of types `β` and `β'` respectively, if the `fuzz` function outputs the same `Litter` object for both tangles, then the type indices `γ` and `γ'` must be equal."}
{"full_name": "ConNF.fuzz_injective", "url": "ConNF/Fuzz/Construction.html#ConNF.fuzz_injective", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.fuzz_injective [ConNF.Params🔗<|PREMISE|>🔗 ] {β : ConNF.TypeIndex} {γ : ConNF.Λ} [ConNF.TangleData🔗<|PREMISE|>🔗 β] [ConNF.PositionedTangles🔗<|PREMISE|>🔗 β] [ConNF.TangleData🔗<|PREMISE|>🔗 ↑γ] [ConNF.PositionedTangles🔗<|PREMISE|>🔗 ↑γ] [ConNF.TypedObjects🔗<|PREMISE|>🔗 γ] (hβγ : β ≠ ↑γ) :Function.Injective🔗<|PREMISE|>🔗 (ConNF.fuzz🔗<|PREMISE|>🔗 hβγ)", "code": "theorem fuzz_injective : Injective (fuzz hβγ) := by\n  intro t₁ t₂ h\n  simp only [fuzz, Litter.mk.injEq, chooseWf_injective.eq_iff, and_self, and_true] at h\n  exact h\n", "additional_info": "", "used_premises": [1, 39, 72, 39, 72, 73, 89, 78], "def_path": "ConNF/Fuzz/Construction.lean", "pos": [216, 220], "informalization": "The function `ConNF.fuzz_injective` is a theorem in the Constructive Ordinal Notation (ConNF) context in Lean 4. It claims that the function `ConNF.fuzz` is injective. This function `ConNF.fuzz` takes a tangle `t` of type `β` and returns a `Litter` object, which is defined as a 4-tuple consisting of a `Wf` object, a type index `β`, a `Λ` object `γ`, and a proof that `β` is not equal to `γ`. The `Litter` object is constructed using a chosen `Wf` object, the type index `β`, the `Λ` object `γ`, and the proof that `β` is not equal to `γ`. The theorem `ConNF.fuzz_injective` asserts that for any `β` and `γ` of different types, the `ConNF.fuzz` function is injective, meaning that if it maps two different tangles to the same `Litter`, then those tangles must be identical."}
{"full_name": "ConNF.fuzz_not_mem_deny", "url": "ConNF/Fuzz/Construction.html#ConNF.fuzz_not_mem_deny", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.fuzz_not_mem_deny [ConNF.Params🔗<|PREMISE|>🔗 ] {β : ConNF.TypeIndex} {γ : ConNF.Λ} [ConNF.TangleData🔗<|PREMISE|>🔗 β] [ConNF.PositionedTangles🔗<|PREMISE|>🔗 β] [ConNF.TangleData🔗<|PREMISE|>🔗 ↑γ] [ConNF.PositionedTangles🔗<|PREMISE|>🔗 ↑γ] [ConNF.TypedObjects🔗<|PREMISE|>🔗 γ] (hβγ : β ≠ ↑γ) (t : ConNF.Tangle β) :(ConNF.fuzz🔗<|PREMISE|>🔗 hβγ t).ν ∉ ConNF.fuzzDeny🔗<|PREMISE|>🔗 γ t", "code": "theorem fuzz_not_mem_deny (t : Tangle β) : (fuzz hβγ t).ν ∉ fuzzDeny γ t :=\n  chooseWf_not_mem_deny t\n", "additional_info": "", "used_premises": [1, 39, 72, 39, 72, 73, 78, 376], "def_path": "ConNF/Fuzz/Construction.lean", "pos": [221, 223], "informalization": "Function `ConNF.fuzz` in the context of Constructive Ordinal Notation (ConNF) in Lean 4 takes as input a tangle `t` of type `β` and returns a `Litter` object. The `Litter` object is defined as a 4-tuple consisting of a `Wf` object, a type index `β`, a `Λ` object `γ`, and a proof that `β` is not equal to `γ`. The `Wf` object is chosen using the `chooseWf` function, which selects an element from a nonempty set. The `chooseWf` function is applied to the set `fuzzDeny γ`, which is defined using the `mk_fuzzDeny` function. The `mk_fuzzDeny` function takes a tangle `t` of type `β` and returns a `Wf` object. The `Litter` object is then constructed using the chosen `Wf` object, the type index `β`, the `Λ` object `γ`, and the proof that `β` is not equal to `γ`. The theorem `ConNF.fuzz_not_mem_deny` states that the position `ν` of the `Litter` object returned by `ConNF.fuzz` does not belong to the set `ConNF.fuzzDeny γ t`, which is the union of two subsets: one for near-litters and one for atoms."}
{"full_name": "ConNF.pos_lt_pos_fuzz", "url": "ConNF/Fuzz/Construction.html#ConNF.pos_lt_pos_fuzz", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.pos_lt_pos_fuzz [ConNF.Params🔗<|PREMISE|>🔗 ] {β : ConNF.TypeIndex} {γ : ConNF.Λ} [ConNF.TangleData🔗<|PREMISE|>🔗 β] [ConNF.PositionedTangles🔗<|PREMISE|>🔗 β] [ConNF.TangleData🔗<|PREMISE|>🔗 ↑γ] [ConNF.PositionedTangles🔗<|PREMISE|>🔗 ↑γ] [ConNF.TypedObjects🔗<|PREMISE|>🔗 γ] (hβγ : β ≠ ↑γ) (t : ConNF.Tangle β) (a : ConNF.Atom) (ha : a.1 = ConNF.fuzz🔗<|PREMISE|>🔗 hβγ t) :ConNF.pos t < ConNF.pos a", "code": "theorem pos_lt_pos_fuzz (t : Tangle β) (a : Atom) (ha : a.1 = fuzz hβγ t) :\n    pos t < pos a := by\n  have h' := fuzz_not_mem_deny hβγ t\n  contrapose! h'\n  refine Or.inr ⟨a, h', ?_⟩\n  rw [ha]\n", "additional_info": "", "used_premises": [1, 39, 72, 39, 72, 73, 78], "def_path": "ConNF/Fuzz/Construction.lean", "pos": [231, 237], "informalization": "The `ConNF.fuzz` function is a noncomputable function that takes a tangle `t` of type `β` and returns a `Litter` object. The `Litter` object is defined as a 4-tuple consisting of a `Wf` object, a type index `β`, a `Λ` object `γ`, and a proof that `β` is not equal to `γ`. The `Wf` object is chosen using the `chooseWf` function, which selects an element from a nonempty set. The `chooseWf` function is applied to the set `fuzzDeny γ`, which is defined using the `mk_fuzzDeny` function. The `mk_fuzzDeny` function takes a tangle `t` of type `β` and returns a `Wf` object. The `Litter` object is then constructed using the chosen `Wf` object, the type index `β`, the `Λ` object `γ`, and the proof that `β` is not equal to `γ`. The theorem `ConNF.pos_lt_pos_fuzz` proves that for any tangle `t` of type `β` and any atom `a` such that `a.1 = fuzz hβγ t`, the position of `t` is less than the position of `a`."}
{"full_name": "ConNF.Allowable.toStructPerm_smul", "url": "ConNF/Fuzz/Hypotheses.html#ConNF.Allowable.toStructPerm_smul", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.Allowable.toStructPerm_smul [ConNF.Params🔗<|PREMISE|>🔗 ] {α : ConNF.TypeIndex} [ConNF.TangleData🔗<|PREMISE|>🔗 α] {X : Type u_1} [MulAction🔗<|PREMISE|>🔗 (ConNF.StructPerm🔗<|PREMISE|>🔗 α) X] (ρ : ConNF.Allowable α) (x : X) :ρ • x = ConNF.Allowable.toStructPerm ρ • x", "code": "theorem toStructPerm_smul (ρ : Allowable α) (x : X) : ρ • x = Allowable.toStructPerm ρ • x :=\n  rfl\n", "additional_info": "", "used_premises": [1, 39, 56, 55], "def_path": "ConNF/Fuzz/Hypotheses.lean", "pos": [66, 68], "informalization": "The theorem `ConNF.Allowable.toStructPerm_smul` states that for any allowable permutation `ρ` on a proper type index `α`, the action of `ρ` on an element `x` of a type `X` that has a multiplicative action by the structural permutations at level `α` is equivalent to the action of the structural permutation `ConNF.Allowable.toStructPerm ρ` on `x`."}
{"full_name": "ConNF.Allowable.smul_support_max", "url": "ConNF/Fuzz/Hypotheses.html#ConNF.Allowable.smul_support_max", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.Allowable.smul_support_max [ConNF.Params🔗<|PREMISE|>🔗 ] {α : ConNF.TypeIndex} [ConNF.TangleData🔗<|PREMISE|>🔗 α] (ρ : ConNF.Allowable α) (S : ConNF.Support🔗<|PREMISE|>🔗 α) :ConNF.Support.max🔗<|PREMISE|>🔗 (ρ • S) = ConNF.Support.max🔗<|PREMISE|>🔗 S", "code": "theorem smul_support_max (ρ : Allowable α) (S : Support α) :\n    (ρ • S).max = S.max :=\n  rfl\n", "additional_info": "", "used_premises": [1, 39, 58, 338, 338], "def_path": "ConNF/Fuzz/Hypotheses.lean", "pos": [70, 73], "informalization": "The `ConNF.Allowable.smul_support_max` theorem states that for any allowable permutation `ρ` at level `α`, the maximum element of the support of `ρ` acting on a support `S` is equal to the maximum element of `S`. This theorem is used in the context of Constructive Ordinal Notation (ConNF), which is a form of ordinal notation based on a combinatorial game. The theorem is a fundamental property of the support of allowable permutations in the ConNF model."}
{"full_name": "ConNF.Allowable.smul_support_f", "url": "ConNF/Fuzz/Hypotheses.html#ConNF.Allowable.smul_support_f", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.Allowable.smul_support_f [ConNF.Params🔗<|PREMISE|>🔗 ] {α : ConNF.TypeIndex} [ConNF.TangleData🔗<|PREMISE|>🔗 α] (ρ : ConNF.Allowable α) (S : ConNF.Support🔗<|PREMISE|>🔗 α) (i : ConNF.κ) (hi : i < ConNF.Support.max🔗<|PREMISE|>🔗 S) :ConNF.Support.f🔗<|PREMISE|>🔗 (ρ • S) i hi = ρ • ConNF.Support.f🔗<|PREMISE|>🔗 S i hi", "code": "theorem smul_support_f (ρ : Allowable α) (S : Support α) (i : κ) (hi : i < S.max) :\n    (ρ • S).f i hi = ρ • S.f i hi :=\n  rfl\n", "additional_info": "", "used_premises": [1, 39, 58, 338, 339, 339], "def_path": "ConNF/Fuzz/Hypotheses.lean", "pos": [75, 78], "informalization": "In the context of Constructive Ordinal Notation (ConNF), the theorem `ConNF.Allowable.smul_support_f` states that for any allowable permutation `ρ` at level `α`, and any `ConNF.Support` structure `S` at level `α`, the function `ConNF.Support.f` applied to `ρ • S`, `i`, and `hi` (where `i` is less than the maximum element of `S`) is equal to `ρ` applied to `ConNF.Support.f` applied to `S`, `i`, and `hi`."}
{"full_name": "ConNF.Allowable.smul_mem_smul_support", "url": "ConNF/Fuzz/Hypotheses.html#ConNF.Allowable.smul_mem_smul_support", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.Allowable.smul_mem_smul_support [ConNF.Params🔗<|PREMISE|>🔗 ] {α : ConNF.TypeIndex} [ConNF.TangleData🔗<|PREMISE|>🔗 α] {S : ConNF.Support🔗<|PREMISE|>🔗 α} {c : ConNF.Address🔗<|PREMISE|>🔗 α} (h : c ∈ S) (ρ : ConNF.Allowable α) :ρ • c ∈ ρ • S", "code": "theorem smul_mem_smul_support {S : Support α} {c : Address α}\n    (h : c ∈ S) (ρ : Allowable α) : ρ • c ∈ ρ • S :=\n  Support.smul_mem_smul h _\n", "additional_info": "", "used_premises": [1, 39, 58, 60], "def_path": "ConNF/Fuzz/Hypotheses.lean", "pos": [89, 92], "informalization": "In the context of Constructive Ordinal Notation (ConNF), the theorem `ConNF.Allowable.smul_mem_smul_support` asserts that if an address `c` is a member of a support `S`, and `ρ` is an allowable permutation, then the image of `c` under `ρ` (denoted as `ρ • c`) is also a member of the image of `S` under `ρ` (denoted as `ρ • S`)."}
{"full_name": "ConNF.Allowable.smul_eq_of_smul_support_eq", "url": "ConNF/Fuzz/Hypotheses.html#ConNF.Allowable.smul_eq_of_smul_support_eq", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.Allowable.smul_eq_of_smul_support_eq [ConNF.Params🔗<|PREMISE|>🔗 ] {α : ConNF.TypeIndex} [ConNF.TangleData🔗<|PREMISE|>🔗 α] {S : ConNF.Support🔗<|PREMISE|>🔗 α} {ρ : ConNF.Allowable α} (hS : ρ • S = S) {c : ConNF.Address🔗<|PREMISE|>🔗 α} (hc : c ∈ S) :ρ • c = c", "code": "theorem smul_eq_of_smul_support_eq {S : Support α} {ρ : Allowable α}\n    (hS : ρ • S = S) {c : Address α} (hc : c ∈ S) : ρ • c = c :=\n  Support.smul_eq_of_smul_eq hS hc\n", "additional_info": "", "used_premises": [1, 39, 58, 60], "def_path": "ConNF/Fuzz/Hypotheses.lean", "pos": [93, 96], "informalization": "The theorem `ConNF.Allowable.smul_eq_of_smul_support_eq` asserts that if a support `S` is invariant under the action of an allowable permutation `ρ` (i.e., `ρ • S = S`), then for any address `c` in this support, the action of `ρ` on `c` leaves `c` unchanged (i.e., `ρ • c = c`). This theorem is crucial in establishing the correctness of the construction of natural numbers in the context of Constructive Ordinal Notation (ConNF)."}
{"full_name": "ConNF.Allowable.support_isCompletion_smul", "url": "ConNF/Fuzz/Hypotheses.html#ConNF.Allowable.support_isCompletion_smul", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.Allowable.support_isCompletion_smul [ConNF.Params🔗<|PREMISE|>🔗 ] {α : ConNF.TypeIndex} [ConNF.TangleData🔗<|PREMISE|>🔗 α] {S : ConNF.Support🔗<|PREMISE|>🔗 α} {E : ConNF.Enumeration🔗<|PREMISE|>🔗 (ConNF.Address🔗<|PREMISE|>🔗 α)} (h : ConNF.Support.IsCompletion🔗<|PREMISE|>🔗 S E) (ρ : ConNF.Allowable α) :ConNF.Support.IsCompletion🔗<|PREMISE|>🔗 (ρ • S) (ρ • E)", "code": "theorem support_isCompletion_smul {S : Support α} {E : Enumeration (Address α)}\n    (h : S.IsCompletion E) (ρ : Allowable α) :\n    (ρ • S).IsCompletion (ρ • E) :=\n  h.smul _\n", "additional_info": "", "used_premises": [1, 39, 58, 59, 60, 349, 349], "def_path": "ConNF/Fuzz/Hypotheses.lean", "pos": [97, 101], "informalization": "The theorem `ConNF.Allowable.support_isCompletion_smul` states that if `S` is a completion of an enumeration of addresses `E`, and `ρ` is an allowable permutation, then `ρ • S` is a completion of the enumeration `ρ • E`."}
{"full_name": "ConNF.Allowable.support_isSum_smul", "url": "ConNF/Fuzz/Hypotheses.html#ConNF.Allowable.support_isSum_smul", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.Allowable.support_isSum_smul [ConNF.Params🔗<|PREMISE|>🔗 ] {α : ConNF.TypeIndex} [ConNF.TangleData🔗<|PREMISE|>🔗 α] {S : ConNF.Support🔗<|PREMISE|>🔗 α} {S₁ : ConNF.Support🔗<|PREMISE|>🔗 α} {S₂ : ConNF.Support🔗<|PREMISE|>🔗 α} (h : ConNF.Support.IsSum🔗<|PREMISE|>🔗 S S₁ S₂) (ρ : ConNF.Allowable α) :ConNF.Support.IsSum🔗<|PREMISE|>🔗 (ρ • S) (ρ • S₁) (ρ • S₂)", "code": "theorem support_isSum_smul {S S₁ S₂ : Support α} (h : S.IsSum S₁ S₂) (ρ : Allowable α) :\n    (ρ • S).IsSum (ρ • S₁) (ρ • S₂) :=\n  h.smul _\n", "additional_info": "", "used_premises": [1, 39, 58, 58, 58, 361, 361], "def_path": "ConNF/Fuzz/Hypotheses.lean", "pos": [102, 105], "informalization": "The theorem `ConNF.Allowable.support_isSum_smul` states that if `S`, `S₁`, and `S₂` are `ConNF.Support` objects such that `S` is the sum of `S₁` and `S₂`, and `ρ` is an allowable permutation, then `ρ • S` is the sum of `ρ • S₁` and `ρ • S₂`."}
{"full_name": "ConNF.Allowable.smul_address", "url": "ConNF/Fuzz/Hypotheses.html#ConNF.Allowable.smul_address", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.Allowable.smul_address [ConNF.Params🔗<|PREMISE|>🔗 ] {α : ConNF.TypeIndex} [ConNF.TangleData🔗<|PREMISE|>🔗 α] {ρ : ConNF.Allowable α} {c : ConNF.Address🔗<|PREMISE|>🔗 α} :ρ • c = { path := c.path, value := ConNF.Allowable.toStructPerm ρ c.path • c.value }", "code": "theorem smul_address :\n    ρ • c = ⟨c.path, Allowable.toStructPerm ρ c.path • c.value⟩ :=\n  rfl\n", "additional_info": "", "used_premises": [1, 39, 60], "def_path": "ConNF/Fuzz/Hypotheses.lean", "pos": [108, 111], "informalization": "Function `ConNF.Allowable.smul_address` defines the action of an allowable permutation on an address in the context of Constructive Ordinal Notation (ConNF). Given an allowable permutation `ρ` at level `α` and an address `c` at level `α`, the result of the action `ρ • c` is a new address with the same path as `c` but with the value component transformed by the action of `ρ` on the path of `c`."}
{"full_name": "ConNF.Allowable.smul_address_eq_iff", "url": "ConNF/Fuzz/Hypotheses.html#ConNF.Allowable.smul_address_eq_iff", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.Allowable.smul_address_eq_iff [ConNF.Params🔗<|PREMISE|>🔗 ] {α : ConNF.TypeIndex} [ConNF.TangleData🔗<|PREMISE|>🔗 α] {ρ : ConNF.Allowable α} {c : ConNF.Address🔗<|PREMISE|>🔗 α} :ρ • c = c ↔ ConNF.Allowable.toStructPerm ρ c.path • c.value = c.value", "code": "theorem smul_address_eq_iff :\n    ρ • c = c ↔ Allowable.toStructPerm ρ c.path • c.value = c.value :=\n  StructPerm.smul_address_eq_iff\n", "additional_info": "", "used_premises": [1, 39, 60], "def_path": "ConNF/Fuzz/Hypotheses.lean", "pos": [113, 116], "informalization": "The theorem `ConNF.Allowable.smul_address_eq_iff` states that for an allowable permutation `ρ` acting on an address `c` in the context of Constructive Ordinal Notation (ConNF), the action of `ρ` on `c` results in the same address `c` if and only if the action of `ρ` on the path component of `c` results in the same value component of `c`."}
{"full_name": "ConNF.Allowable.smul_address_eq_smul_iff", "url": "ConNF/Fuzz/Hypotheses.html#ConNF.Allowable.smul_address_eq_smul_iff", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.Allowable.smul_address_eq_smul_iff [ConNF.Params🔗<|PREMISE|>🔗 ] {α : ConNF.TypeIndex} [ConNF.TangleData🔗<|PREMISE|>🔗 α] {ρ : ConNF.Allowable α} {ρ' : ConNF.Allowable α} {c : ConNF.Address🔗<|PREMISE|>🔗 α} :ρ • c = ρ' • c ↔ ConNF.Allowable.toStructPerm ρ c.path • c.value = ConNF.Allowable.toStructPerm ρ' c.path • c.value", "code": "theorem smul_address_eq_smul_iff :\n    ρ • c = ρ' • c ↔\n    Allowable.toStructPerm ρ c.path • c.value = Allowable.toStructPerm ρ' c.path • c.value :=\n  StructPerm.smul_address_eq_smul_iff\n", "additional_info": "", "used_premises": [1, 39, 60], "def_path": "ConNF/Fuzz/Hypotheses.lean", "pos": [118, 122], "informalization": "The theorem `ConNF.Allowable.smul_address_eq_smul_iff` states that for any two allowable permutations `ρ` and `ρ'` at level `α`, and any address `c` at level `α`, the equation `ρ • c = ρ' • c` holds if and only if the equation `ConNF.Allowable.toStructPerm ρ c.path • c.value = ConNF.Allowable.toStructPerm ρ' c.path • c.value` holds."}
{"full_name": "ConNF.support_supports", "url": "ConNF/Fuzz/Hypotheses.html#ConNF.support_supports", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.support_supports [ConNF.Params🔗<|PREMISE|>🔗 ] {α : ConNF.TypeIndex} [ConNF.TangleData🔗<|PREMISE|>🔗 α] (t : ConNF.Tangle α) :MulAction.Supports🔗<|PREMISE|>🔗 (ConNF.Allowable α) (ConNF.Enumeration.carrier🔗<|PREMISE|>🔗 (ConNF.TangleData.Tangle.support🔗<|PREMISE|>🔗 t).enum) t", "code": "theorem support_supports {α : TypeIndex} [TangleData α] (t : Tangle α) :\n    MulAction.Supports (Allowable α) (t.support : Set (Address α)) t :=\n  TangleData.support_supports t\n", "additional_info": "", "used_premises": [1, 39, 68, 70, 395], "def_path": "ConNF/Fuzz/Hypotheses.lean", "pos": [130, 133], "informalization": "The theorem `ConNF.support_supports` asserts that for any tangle `t` at level `α` in the context of Constructive Ordinal Notation (ConNF), the set of atoms in the small support of `t` supports `t` under the action of the allowable permutations at level `α`."}
{"full_name": "ConNF.TangleData.Tangle.support", "url": "ConNF/Fuzz/Hypotheses.html#ConNF.TangleData.Tangle.support", "code_src": "con-nf", "ptype": "def", "header": "def ConNF.TangleData.Tangle.support [ConNF.Params🔗<|PREMISE|>🔗 ] {α : ConNF.TypeIndex} [ConNF.TangleData🔗<|PREMISE|>🔗 α] (t : ConNF.Tangle α) :ConNF.Support🔗<|PREMISE|>🔗 α", "code": "def TangleData.Tangle.support {α : TypeIndex} [TangleData α] (t : Tangle α) : Support α :=\n  TangleData.support t\n", "additional_info": "For each tangle, we provide a small support for it. This is known as the designated support of\nthe tangle.\nEquations\n* 🗟ConNF.TangleData.Tangle.support🗟🔗../.././ConNF/Fuzz/Hypotheses.html#ConNF.TangleData.Tangle.support🔗  t 🗟=🗟🔗../.././Init/Prelude.html#Eq🔗  🗟ConNF.TangleData.support🗟🔗../.././ConNF/Fuzz/Hypotheses.html#ConNF.TangleData.support🔗  t\n\n", "used_premises": [1, 39, 58], "def_path": "ConNF/Fuzz/Hypotheses.lean", "pos": [127, 129], "informalization": "Function `ConNF.TangleData.Tangle.support` provides a small support for each tangle in the context of Constructive Ordinal Notation (ConNF). This designated support ensures that for any two near-litters `N₁` and `N₂` that are near the same litter, any atoms in their symmetric difference are included in the enumeration."}
{"full_name": "NearLitterPerm.ofBot_smul", "url": "ConNF/Fuzz/Hypotheses.html#NearLitterPerm.ofBot_smul", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem NearLitterPerm.ofBot_smul [ConNF.Params🔗<|PREMISE|>🔗 ] {X : Type u_1} [MulAction🔗<|PREMISE|>🔗 ConNF.NearLitterPerm X] (π : ConNF.Allowable ⊥ ) (x : X) :NearLitterPerm.ofBot π • x = π • x", "code": "theorem NearLitterPerm.ofBot_smul {X : Type _} [MulAction NearLitterPerm X]\n    (π : Allowable ⊥) (x : X) :\n    NearLitterPerm.ofBot π • x = π • x :=\n  rfl\n", "additional_info": "", "used_premises": [1, 56], "def_path": "ConNF/Fuzz/Hypotheses.lean", "pos": [205, 209], "informalization": "The theorem `NearLitterPerm.ofBot_smul` states that in the context of Constructive Ordinal Notation (ConNF), for any allowable finite sequence of litters `π` at the bottom level (represented by `⊥`), the action of the corresponding near-litter permutation `NearLitterPerm.ofBot π` on an element `x` of a type `X` that is equipped with a multiplicative action of `ConNF.NearLitterPerm` is equivalent to the action of `π` on `x`. This is a simplification statement that helps in understanding the relationship between the bottom-level allowable finite sequences and their corresponding near-litter permutations within the ConNF framework."}
{"full_name": "ConNF.pos_lt_pos", "url": "ConNF/Fuzz/Position.html#ConNF.pos_lt_pos", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.pos_lt_pos {α : Type u_2} {β : Type u_1} [ConNF.Position🔗<|PREMISE|>🔗 α β] [LT🔗<|PREMISE|>🔗 β] (c : α) (d : α) :ConNF.pos c < ConNF.pos d ↔ c < d", "code": "theorem pos_lt_pos [LT β] (c d : α) :\n    pos c < pos d ↔ c < d :=\n  Iff.rfl\n", "additional_info": "", "used_premises": [398, 6], "def_path": "ConNF/Fuzz/Position.lean", "pos": [19, 22], "informalization": "Class `ConNF.Position α β` represents an injective function from `α` to `β`, which can be thought of as a way to \"position\" elements of `α` within a larger type `β`. Given two elements `c` and `d` of `α`, the theorem `ConNF.pos_lt_pos` states that `ConNF.pos c < ConNF.pos d` if and only if `c < d`."}
{"full_name": "ConNF.Position", "url": "ConNF/Fuzz/Position.html#ConNF.Position", "code_src": "con-nf", "ptype": "class", "header": "class ConNF.Position (α : Type u_1) (β : outParam🔗<|PREMISE|>🔗 (Type u_2)) :Type (max u_1 u_2)\n | pos : α ↪  β", "code": "class Position (α : Type _) (β : outParam <| Type _) where\n  pos : α ↪ β\n", "additional_info": "", "used_premises": [399], "def_path": "ConNF/Fuzz/Position.lean", "pos": [5, 7], "informalization": "Class `Position α β` represents an injective function from `α` to `β`, which can be thought of as a way to \"position\" elements of `α` within a larger type `β`."}
{"full_name": "outParam", "url": "Init/Prelude.html#outParam", "code_src": "lean4", "ptype": "def", "header": "@[reducible]def outParam (α : Sort u) :Sort u", "code": "@[reducible] def outParam (α : Sort u) : Sort u := α\n", "additional_info": "Gadget for marking output parameters in type classes.\nFor example, the `🗟Membership🗟🔗.././Init/Prelude.html#Membership🔗`  class is defined as:\nclass 🗟Membership🗟🔗.././Init/Prelude.html#Membership🔗  (α : 🗟outParam🗟🔗.././Init/Prelude.html#outParam🔗  (Type u)) (γ : Type v)\n\nThis means that whenever a typeclass goal of the form `🗟Membership🗟🔗.././Init/Prelude.html#Membership🔗  ?α ?γ` comes\nup, Lean will wait to solve it until `?γ` is known, but then it will run\ntypeclass inference, and take the first solution it finds, for any value of `?α`,\nwhich thereby determines what `?α` should be.\nThis expresses that in a term like `a ∈ s`, `s` might be a `Set α` or\n`🗟List🗟🔗.././Init/Prelude.html#List🔗  α` or some other type with a membership operation, and in each case\nthe \"member\" type `α` is determined by looking at the container type.\nEquations\n* 🗟outParam🗟🔗.././Init/Prelude.html#outParam🔗  α 🗟=🗟🔗.././Init/Prelude.html#Eq🔗  α\n\n", "used_premises": [], "def_path": "Init/Prelude.lean", "pos": [612, 613], "informalization": "Function `outParam` is a utility in Lean 4 for marking parameters in type classes as output-oriented, influencing the order of argument processing and ensuring these parameters are determined based on the values of other parameters."}
{"full_name": "ConNF.isWellOrder_invImage", "url": "ConNF/Fuzz/Position.html#ConNF.isWellOrder_invImage", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.isWellOrder_invImage {α : Type u_2} {β : Type u_1} {r : β → β → Prop } (h : IsWellOrder🔗<|PREMISE|>🔗 β r) (f : α → β) (hf : Function.Injective🔗<|PREMISE|>🔗 f) :IsWellOrder🔗<|PREMISE|>🔗 α (InvImage🔗<|PREMISE|>🔗 r f)", "code": "theorem isWellOrder_invImage {r : β → β → Prop} (h : IsWellOrder β r)\n    (f : α → β) (hf : Function.Injective f) :\n    IsWellOrder α (InvImage r f) where\n  trichotomous := by\n    intro x y\n    have := h.trichotomous (f x) (f y)\n    rw [hf.eq_iff] at this\n    exact this\n  trans x y z := h.trans (f x) (f y) (f z)\n  wf := InvImage.wf _ h.wf\n", "additional_info": "", "used_premises": [15, 89, 15, 96], "def_path": "ConNF/Fuzz/Position.lean", "pos": [23, 33], "informalization": "If `r` is a well order on `β` and `f` is an injective function from `α` to `β`, then the inverse image of `r` under `f` is a well order on `α`."}
{"full_name": "ConNF.CodingFunction.mem_iff", "url": "ConNF/Counting/CodingFunction.html#ConNF.CodingFunction.mem_iff", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.CodingFunction.mem_iff [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.FOAAssumptions] {β : ConNF.Λ} [ConNF.LeLevel🔗<|PREMISE|>🔗 ↑β] {χ : ConNF.CodingFunction🔗<|PREMISE|>🔗 β} {S : ConNF.Support🔗<|PREMISE|>🔗 ↑β} :S ∈ χ ↔ (χ.decode S).Dom", "code": "theorem mem_iff {χ : CodingFunction β} {S : Support β} :\n    S ∈ χ ↔ (χ.decode S).Dom :=\n  Iff.rfl\n", "additional_info": "", "used_premises": [1, 402, 403, 58], "def_path": "ConNF/Counting/CodingFunction.lean", "pos": [30, 33], "informalization": "The theorem `ConNF.CodingFunction.mem_iff` in the context of Constructive Ordinal Notation (ConNF) states that for a given coding function `χ` at type level `β` and a support `S`, the support `S` is an element of the coding function `χ` if and only if the decoding of `S` by `χ` is defined. This is a fundamental property of the relationship between supports and coding functions in ConNF."}
{"full_name": "ConNF.LeLevel", "url": "ConNF/Structural/Index.html#ConNF.LeLevel", "code_src": "con-nf", "ptype": "class", "header": "class ConNF.LeLevel [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] (β : ConNF.TypeIndex) :Prop\n | elim : β ≤  ↑ConNF.α", "code": "class LeLevel (β : TypeIndex) : Prop where\n  elim : β ≤ α\n", "additional_info": "", "used_premises": [1], "def_path": "ConNF/Structural/Index.lean", "pos": [41, 43], "informalization": "Class `ConNF.LeLevel` represents the condition that a type index `β` is less than or equal to the type index `α` in the context of Constructive Ordinal Notation (ConNF)."}
{"full_name": "ConNF.CodingFunction", "url": "ConNF/Counting/CodingFunction.html#ConNF.CodingFunction", "code_src": "con-nf", "ptype": "structure", "header": "structure ConNF.CodingFunction [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.FOAAssumptions] (β : ConNF.Λ) [ConNF.LeLevel🔗<|PREMISE|>🔗 ↑β] :Type u\n | decode : ConNF.Support🔗<|PREMISE|>🔗  ↑β →.  ConNF.Tangle  ↑β\n | dom_nonempty : Set.Nonempty🔗<|PREMISE|>🔗  (PFun.Dom🔗<|PREMISE|>🔗  self.decode)\n | supports_decode' : ∀ (S : ConNF.Support🔗<|PREMISE|>🔗  ↑β) (hS : (self.decode S).Dom),\n MulAction.Supports🔗<|PREMISE|>🔗  (ConNF.Allowable  ↑β) (ConNF.Enumeration.carrier🔗<|PREMISE|>🔗  S.enum) ((self.decode S).get hS)\n | dom_iff : ∀ (S T : ConNF.Support🔗<|PREMISE|>🔗  ↑β), (self.decode S).Dom → ((self.decode T).Dom ↔  ∃ (ρ : ConNF.Allowable  ↑β), T =  ρ •  S)\n | decode_smul' : ∀ (S : ConNF.Support🔗<|PREMISE|>🔗  ↑β) (ρ : ConNF.Allowable  ↑β) (h₁ : (self.decode S).Dom) (h₂ : (self.decode (ρ •  S)).Dom),\n (self.decode (ρ •  S)).get h₂ =  ρ •  (self.decode S).get h₁", "code": "structure CodingFunction (β : Λ) [LeLevel β] where\n  decode : Support β →. Tangle β\n  dom_nonempty : decode.Dom.Nonempty\n  supports_decode' (S : Support β) (hS : (decode S).Dom) :\n    Supports (Allowable β) (S : Set (Address β)) ((decode S).get hS)\n  dom_iff (S T : Support β) (hS : (decode S).Dom) :\n    (decode T).Dom ↔ ∃ ρ : Allowable β, T = ρ • S\n  decode_smul' (S : Support β) (ρ : Allowable β)\n    (h₁ : (decode S).Dom) (h₂ : (decode (ρ • S)).Dom) :\n    (decode (ρ • S)).get h₂ = ρ • (decode S).get h₁\n", "additional_info": "", "used_premises": [1, 402, 58, 83, 404, 58, 68, 70, 58, 58], "def_path": "ConNF/Counting/CodingFunction.lean", "pos": [14, 24], "informalization": "In the context of Constructive Ordinal Notation (ConNF), a `CodingFunction` is a structure that represents a partial function from `Support β` to `Tangle β`, where `β` is a type index in the context of ConNF. The structure ensures that the domain of this partial function is nonempty, and that it satisfies certain properties related to the action of `Allowable β` on `Support β`."}
{"full_name": "PFun.Dom", "url": "Mathlib/Data/PFun.html#PFun.Dom", "code_src": "mathlib4", "ptype": "def", "header": "def PFun.Dom {α : Type u_1} {β : Type u_2} (f : α →. β) :Set🔗<|PREMISE|>🔗 α", "code": "def Dom (f : α →. β) : Set α :=\n  { a | (f a).Dom }\n", "additional_info": "The domain of a partial function\nEquations\n* 🗟PFun.Dom🗟🔗../.././Mathlib/Data/PFun.html#PFun.Dom🔗  f 🗟=🗟🔗../.././Init/Prelude.html#Eq🔗  {a : α | (f a).Dom}\n\n", "used_premises": [69], "def_path": "Mathlib/Data/PFun.lean", "pos": [74, 76], "informalization": "Function `PFun.Dom` defines the domain of a partial function, which is the set of elements for which the function is defined."}
{"full_name": "ConNF.CodingFunction.mem_iff_of_mem", "url": "ConNF/Counting/CodingFunction.html#ConNF.CodingFunction.mem_iff_of_mem", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.CodingFunction.mem_iff_of_mem [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.FOAAssumptions] {β : ConNF.Λ} [ConNF.LeLevel🔗<|PREMISE|>🔗 ↑β] {χ : ConNF.CodingFunction🔗<|PREMISE|>🔗 β} {S : ConNF.Support🔗<|PREMISE|>🔗 ↑β} {T : ConNF.Support🔗<|PREMISE|>🔗 ↑β} (h : S ∈ χ) :T ∈ χ ↔ ∃ (ρ : ConNF.Allowable ↑β), T = ρ • S", "code": "theorem mem_iff_of_mem {χ : CodingFunction β} {S T : Support β} (h : S ∈ χ) :\n    T ∈ χ ↔ ∃ ρ : Allowable β, T = ρ • S :=\n  χ.dom_iff S T h\n", "additional_info": "", "used_premises": [1, 402, 403, 58, 58], "def_path": "ConNF/Counting/CodingFunction.lean", "pos": [34, 37], "informalization": "Given a `CodingFunction` χ and two `Support`s S and T in the context of Constructive Ordinal Notation (ConNF), this theorem states that T is in the domain of χ if and only if there exists an `Allowable` ρ such that T is the image of S under the action of ρ. This theorem is crucial for proving the bijectivity of the coding function."}
{"full_name": "ConNF.CodingFunction.smul_mem", "url": "ConNF/Counting/CodingFunction.html#ConNF.CodingFunction.smul_mem", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.CodingFunction.smul_mem [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.FOAAssumptions] {β : ConNF.Λ} [ConNF.LeLevel🔗<|PREMISE|>🔗 ↑β] {χ : ConNF.CodingFunction🔗<|PREMISE|>🔗 β} {S : ConNF.Support🔗<|PREMISE|>🔗 ↑β} (ρ : ConNF.Allowable ↑β) (h : S ∈ χ) :ρ • S ∈ χ", "code": "theorem smul_mem {χ : CodingFunction β} {S : Support β} (ρ : Allowable β) (h : S ∈ χ) :\n    ρ • S ∈ χ :=\n  (χ.mem_iff_of_mem h).mpr ⟨ρ, rfl⟩\n", "additional_info": "", "used_premises": [1, 402, 403, 58], "def_path": "ConNF/Counting/CodingFunction.lean", "pos": [38, 41], "informalization": "In the context of Constructive Ordinal Notation (ConNF), given a type index `β` that is less than or equal to the type index `α`, a `CodingFunction` `χ` with domain `S`, and an `Allowable` `ρ`, the theorem `smul_mem` ensures that the scaling of `S` by `ρ` results in another element within the domain of `χ`. This property is crucial for establishing the correctness of the ConNF construction."}
{"full_name": "ConNF.CodingFunction.mem_of_smul_mem", "url": "ConNF/Counting/CodingFunction.html#ConNF.CodingFunction.mem_of_smul_mem", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.CodingFunction.mem_of_smul_mem [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.FOAAssumptions] {β : ConNF.Λ} [ConNF.LeLevel🔗<|PREMISE|>🔗 ↑β] {χ : ConNF.CodingFunction🔗<|PREMISE|>🔗 β} {S : ConNF.Support🔗<|PREMISE|>🔗 ↑β} {ρ : ConNF.Allowable ↑β} (h : ρ • S ∈ χ) :S ∈ χ", "code": "theorem mem_of_smul_mem {χ : CodingFunction β} {S : Support β} {ρ : Allowable β}\n    (h : ρ • S ∈ χ) : S ∈ χ :=\n  (χ.mem_iff_of_mem h).mpr ⟨ρ⁻¹, by rw [inv_smul_smul]⟩\n", "additional_info": "", "used_premises": [1, 402, 403, 58], "def_path": "ConNF/Counting/CodingFunction.lean", "pos": [42, 45], "informalization": "In the context of Constructive Ordinal Notation (ConNF), the theorem `ConNF.CodingFunction.mem_of_smul_mem` asserts that for any `CodingFunction` `χ` at level `β`, if `ρ • S` (where `ρ` is an `Allowable` and `S` is a `Support`) is in the domain of `χ`, then `S` itself must also be in the domain of `χ`."}
{"full_name": "ConNF.CodingFunction.exists_mem", "url": "ConNF/Counting/CodingFunction.html#ConNF.CodingFunction.exists_mem", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.CodingFunction.exists_mem [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.FOAAssumptions] {β : ConNF.Λ} [ConNF.LeLevel🔗<|PREMISE|>🔗 ↑β] (χ : ConNF.CodingFunction🔗<|PREMISE|>🔗 β) :∃ (S : ConNF.Support🔗<|PREMISE|>🔗 ↑β), S ∈ χ", "code": "theorem exists_mem (χ : CodingFunction β) :\n    ∃ S, S ∈ χ :=\n  χ.dom_nonempty\n", "additional_info": "", "used_premises": [1, 402, 403, 58], "def_path": "ConNF/Counting/CodingFunction.lean", "pos": [46, 49], "informalization": "In the context of Constructive Ordinal Notation (ConNF), a `CodingFunction` is a structure that represents a partial function from `Support β` to `Tangle β`, where `β` is a type index in the context of ConNF. The structure ensures that the domain of this partial function is nonempty, and that it satisfies certain properties related to the action of `Allowable β` on `Support β`. The theorem `ConNF.CodingFunction.exists_mem` states that for any `CodingFunction` `χ`, there exists a `Support` `S` that is a member of `χ`."}
{"full_name": "ConNF.CodingFunction.supports_decode", "url": "ConNF/Counting/CodingFunction.html#ConNF.CodingFunction.supports_decode", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.CodingFunction.supports_decode [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.FOAAssumptions] {β : ConNF.Λ} [ConNF.LeLevel🔗<|PREMISE|>🔗 ↑β] {χ : ConNF.CodingFunction🔗<|PREMISE|>🔗 β} (S : ConNF.Support🔗<|PREMISE|>🔗 ↑β) (hS : S ∈ χ) :MulAction.Supports🔗<|PREMISE|>🔗 (ConNF.Allowable ↑β) (ConNF.Enumeration.carrier🔗<|PREMISE|>🔗 S.enum) ((χ.decode S).get hS)", "code": "theorem supports_decode {χ : CodingFunction β} (S : Support β) (hS : S ∈ χ) :\n    Supports (Allowable β) (S : Set (Address β)) ((χ.decode S).get hS) :=\n  χ.supports_decode' S hS\n", "additional_info": "", "used_premises": [1, 402, 403, 58, 68, 70], "def_path": "ConNF/Counting/CodingFunction.lean", "pos": [50, 53], "informalization": "The `ConNF.CodingFunction.supports_decode` theorem states that for each `β` (a type index in the context of Constructive Ordinal Notation, ConNF) and for each `CodingFunction` `χ` defined on `β`, if `S` is a `ConNF.Support` (a function from an initial segment of `κ` to the type of addresses in ConNF), and if `S` is an element of `χ`, then the action of `ConNF.Allowable ↑β` (the set of allowable ordinals at level `β`) supports (`MulAction.Supports`) the `ConNF.Enumeration.carrier` (the set of elements `c` of type `α` that can be expressed as `S.enum.f i h` for some `i < S.enum.max`) of `S.enum` (an `α`-enumeration defined by `S`)."}
{"full_name": "ConNF.CodingFunction.ext", "url": "ConNF/Counting/CodingFunction.html#ConNF.CodingFunction.ext", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.CodingFunction.ext [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.FOAAssumptions] {β : ConNF.Λ} [ConNF.LeLevel🔗<|PREMISE|>🔗 ↑β] {χ₁ : ConNF.CodingFunction🔗<|PREMISE|>🔗 β} {χ₂ : ConNF.CodingFunction🔗<|PREMISE|>🔗 β} (S : ConNF.Support🔗<|PREMISE|>🔗 ↑β) (h₁ : S ∈ χ₁) (h₂ : S ∈ χ₂) (h : (χ₁.decode S).get h₁ = (χ₂.decode S).get h₂) :χ₁ = χ₂", "code": "theorem ext {χ₁ χ₂ : CodingFunction β}\n    (S : Support β) (h₁ : S ∈ χ₁) (h₂ : S ∈ χ₂)\n    (h : (χ₁.decode S).get h₁ = (χ₂.decode S).get h₂) :\n    χ₁ = χ₂ := by\n  rw [mk.injEq]\n  funext T\n  refine Part.ext' ?_ ?_\n  · rw [← mem_iff, mem_iff_of_mem h₁, ← mem_iff, mem_iff_of_mem h₂]\n  · intros h₁' h₂'\n    rw [← mem_iff, mem_iff_of_mem h₁] at h₁'\n    obtain ⟨ρ, rfl⟩ := h₁'\n    rw [χ₁.decode_smul' S ρ h₁ h₁', χ₂.decode_smul' S ρ h₂ h₂', h]\n", "additional_info": "Two coding functions are equal if they decode a single ordered support to the same tangle.", "used_premises": [1, 402, 403, 403, 58], "def_path": "ConNF/Counting/CodingFunction.lean", "pos": [59, 71], "informalization": "In the context of Constructive Ordinal Notation (ConNF), a `CodingFunction` is a structure that represents a partial function from `Support β` to `Tangle β`, where `β` is a type index in the context of ConNF. This theorem states that two `CodingFunction`s are equal if they decode a single ordered support to the same tangle."}
{"full_name": "ConNF.CodingFunction.smul_supports", "url": "ConNF/Counting/CodingFunction.html#ConNF.CodingFunction.smul_supports", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.CodingFunction.smul_supports [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.FOAAssumptions] {β : ConNF.Λ} [ConNF.LeLevel🔗<|PREMISE|>🔗 ↑β] {S : ConNF.Support🔗<|PREMISE|>🔗 ↑β} {t : ConNF.Tangle ↑β} (h : MulAction.Supports🔗<|PREMISE|>🔗 (ConNF.Allowable ↑β) (ConNF.Enumeration.carrier🔗<|PREMISE|>🔗 S.enum) t) (ρ : ConNF.Allowable ↑β) :MulAction.Supports🔗<|PREMISE|>🔗 (ConNF.Allowable ↑β) (ConNF.Enumeration.carrier🔗<|PREMISE|>🔗 (ρ • S).enum) (ρ • t)", "code": "theorem smul_supports {S : Support β} {t : Tangle β}\n    (h : Supports (Allowable β) (S : Set (Address β)) t) (ρ : Allowable β) :\n    Supports (Allowable β) ((ρ • S : Support β) : Set (Address β)) (ρ • t) := by\n  intro ρ' hρ'\n  have := h (ρ⁻¹ * ρ' * ρ) ?_\n  · rw [mul_assoc, mul_smul, inv_smul_eq_iff, mul_smul] at this\n    exact this\n  intros c hc\n  rw [mul_assoc, mul_smul, inv_smul_eq_iff, mul_smul]\n  refine hρ' ?_\n  exact Enumeration.smul_mem_smul hc ρ\n", "additional_info": "", "used_premises": [1, 402, 58, 68, 70, 68, 70], "def_path": "ConNF/Counting/CodingFunction.lean", "pos": [72, 83], "informalization": "In the context of Constructive Ordinal Notation (ConNF), the theorem `ConNF.CodingFunction.smul_supports` states that if a set `s` supports an element `b` under the action of a monoid `G`, and `ρ` is an element of `G`, then `ρ • s` also supports `ρ • b` under the same action."}
{"full_name": "ConNF.CodingFunction.decode_congr", "url": "ConNF/Counting/CodingFunction.html#ConNF.CodingFunction.decode_congr", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.CodingFunction.decode_congr [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.FOAAssumptions] {β : ConNF.Λ} [ConNF.LeLevel🔗<|PREMISE|>🔗 ↑β] {χ : ConNF.CodingFunction🔗<|PREMISE|>🔗 β} {S₁ : ConNF.Support🔗<|PREMISE|>🔗 ↑β} {S₂ : ConNF.Support🔗<|PREMISE|>🔗 ↑β} {h₁ : S₁ ∈ χ} {h₂ : S₂ ∈ χ} (h : S₁ = S₂) :(χ.decode S₁).get h₁ = (χ.decode S₂).get h₂", "code": "theorem decode_congr {χ : CodingFunction β} {S₁ S₂ : Support β}\n    {h₁ : S₁ ∈ χ} {h₂ : S₂ ∈ χ} (h : S₁ = S₂) :\n    (χ.decode S₁).get h₁ = (χ.decode S₂).get h₂ := by\n  subst h\n  rfl\n", "additional_info": "", "used_premises": [1, 402, 403, 58, 58], "def_path": "ConNF/Counting/CodingFunction.lean", "pos": [84, 89], "informalization": "In the context of Constructive Ordinal Notation (ConNF), a `CodingFunction` is a structure that represents a partial function from `Support β` to `Tangle β`, where `β` is a type index in the context of ConNF. The structure ensures that the domain of this partial function is nonempty, and that it satisfies certain properties related to the action of `Allowable β` on `Support β`. The theorem `ConNF.CodingFunction.decode_congr` states that for any two `CodingFunction`s `χ` with supports `S₁` and `S₂`, if `S₁` and `S₂` are equal, then the decodings of `S₁` and `S₂` are also equal."}
{"full_name": "ConNF.CodingFunction.code_decode", "url": "ConNF/Counting/CodingFunction.html#ConNF.CodingFunction.code_decode", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.CodingFunction.code_decode [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.FOAAssumptions] {β : ConNF.Λ} [ConNF.LeLevel🔗<|PREMISE|>🔗 ↑β] (S : ConNF.Support🔗<|PREMISE|>🔗 ↑β) (t : ConNF.Tangle ↑β) (h : MulAction.Supports🔗<|PREMISE|>🔗 (ConNF.Allowable ↑β) (ConNF.Enumeration.carrier🔗<|PREMISE|>🔗 S.enum) t) :(ConNF.CodingFunction.code🔗<|PREMISE|>🔗 S t h).decode S = Part.some🔗<|PREMISE|>🔗 t", "code": "theorem code_decode (S : Support β) (t : Tangle β)\n    (h : Supports (Allowable β) (S : Set (Address β)) t) :\n    (code S t h).decode S = Part.some t := by\n  refine Part.ext' ?_ ?_\n  · simp only [Allowable.toStructPerm_smul, Part.some_dom, iff_true]\n    refine ⟨1, ?_⟩\n    simp only [map_one, one_smul]\n  · intros h' _\n    refine h _ ?_\n    intros c hc\n    exact Allowable.smul_eq_of_smul_support_eq h'.choose_spec.symm hc\n", "additional_info": "", "used_premises": [1, 402, 58, 68, 70, 414, 415], "def_path": "ConNF/Counting/CodingFunction.lean", "pos": [120, 131], "informalization": "In the context of Constructive Ordinal Notation (ConNF), the theorem `ConNF.CodingFunction.code_decode` states that for any ordered support `S` and tangle `t` that it supports, the decoding of the coding function `ConNF.CodingFunction.code S t h` with respect to `S` yields a partial value that is defined and equals `t`."}
{"full_name": "ConNF.CodingFunction.code", "url": "ConNF/Counting/CodingFunction.html#ConNF.CodingFunction.code", "code_src": "con-nf", "ptype": "noncomputable def", "header": "noncomputable def ConNF.CodingFunction.code [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.FOAAssumptions] {β : ConNF.Λ} [ConNF.LeLevel🔗<|PREMISE|>🔗 ↑β] (S : ConNF.Support🔗<|PREMISE|>🔗 ↑β) (t : ConNF.Tangle ↑β) (h : MulAction.Supports🔗<|PREMISE|>🔗 (ConNF.Allowable ↑β) (ConNF.Enumeration.carrier🔗<|PREMISE|>🔗 S.enum) t) :ConNF.CodingFunction🔗<|PREMISE|>🔗 β", "code": "noncomputable def code (S : Support β) (t : Tangle β)\n    (h : Supports (Allowable β) (S : Set (Address β)) t) :\n    CodingFunction β where\n  decode T := ⟨∃ ρ : Allowable β, T = ρ • S, fun hT => hT.choose • t⟩\n  dom_nonempty := ⟨S, 1, by rw [one_smul]⟩\n  supports_decode' T hT := by\n    have := smul_supports h hT.choose\n    rw [← hT.choose_spec] at this\n    exact this\n  dom_iff T U hT := by\n    obtain ⟨ρ, rfl⟩ := hT\n    constructor\n    · rintro ⟨ρ', rfl⟩\n      refine ⟨ρ' * ρ⁻¹, ?_⟩\n      rw [smul_smul, inv_mul_cancel_right]\n    · rintro ⟨ρ', h⟩\n      refine ⟨ρ' * ρ, ?_⟩\n      rw [mul_smul]\n      exact h\n  decode_smul' T ρ h₁ h₂ := by\n    rw [← inv_smul_eq_iff, ← inv_smul_eq_iff, smul_smul, smul_smul]\n    refine h _ ?_\n    intros c hc\n    have := h₂.choose_spec.symm\n    conv_rhs at this => rw [h₁.choose_spec]\n    rw [← inv_smul_eq_iff, ← inv_smul_eq_iff, smul_smul, smul_smul] at this\n    exact Allowable.smul_eq_of_smul_support_eq this hc\n", "additional_info": "Produce a coding function for a given ordered support and tangle it supports.\nEquations\n* One or more equations did not get rendered due to their size.\n\n", "used_premises": [1, 402, 58, 68, 70, 403], "def_path": "ConNF/Counting/CodingFunction.lean", "pos": [91, 118], "informalization": "In the context of Constructive Ordinal Notation (ConNF), a `CodingFunction` is a structure that represents a partial function from `Support β` to `Tangle β`, where `β` is a type index in the context of ConNF. The structure ensures that the domain of this partial function is nonempty, and that it satisfies certain properties related to the action of `Allowable β` on `Support β`. The function `ConNF.CodingFunction.code` produces such a coding function for a given ordered support and tangle it supports."}
{"full_name": "Part.some", "url": "Mathlib/Data/Part.html#Part.some", "code_src": "mathlib4", "ptype": "def", "header": "def Part.some {α : Type u_1} (a : α) :Part🔗<|PREMISE|>🔗 α", "code": "def some (a : α) : Part α :=\n  ⟨True, fun _ => a⟩\n", "additional_info": "The `🗟some🗟🔗../.././Mathlib/Data/Part.html#Part.some🔗  a` value in `🗟Part🗟🔗../.././Mathlib/Data/Part.html#Part🔗`  has a `🗟True🗟🔗../.././Init/Prelude.html#True🔗`  domain and the\nfunction returns `a`.\nEquations\n* 🗟Part.some🗟🔗../.././Mathlib/Data/Part.html#Part.some🔗  a 🗟=🗟🔗../.././Init/Prelude.html#Eq🔗  { Dom := 🗟True🗟🔗../.././Init/Prelude.html#True🔗 , get := fun (x : 🗟True🗟🔗../.././Init/Prelude.html#True🔗 ) => a }\n\n", "used_premises": [416], "def_path": "Mathlib/Data/Part.lean", "pos": [134, 136], "informalization": "Function `Part.some` is a constructor for the `Part` type, which represents partial values. Given an element `a` of type `α`, `Part.some a` creates a partial value that is defined and equals `a`."}
{"full_name": "Part", "url": "Mathlib/Data/Part.html#Part", "code_src": "mathlib4", "ptype": "structure", "header": "structure Part (α : Type u) :Type u\n | Dom : Prop \n | get : self.Dom → α", "code": "structure Part.{u} (α : Type u) : Type u where\n  /-- The domain of a partial value -/\n  Dom : Prop\n  /-- Extract a value from a partial value given a proof of `Dom` -/\n  get : Dom → α\n", "additional_info": "`🗟Part🗟🔗../.././Mathlib/Data/Part.html#Part🔗  α` is the type of \"partial values\" of type `α`. It\nis similar to `🗟Option🗟🔗../.././Init/Prelude.html#Option🔗  α` except the domain condition can be an\narbitrary proposition, not necessarily decidable.\n- Part.Dom: The domain of a partial value\n\n\n- Part.get: Extract a value from a partial value given a proof of `🗟Dom🗟🔗../.././Mathlib/Data/Part.html#Part.Dom🔗` \n\n\n", "used_premises": [], "def_path": "Mathlib/Data/Part.lean", "pos": [51, 56], "informalization": "`Part  α` is the type of \"partial values\" of type `α`. It is similar to `Option  α` except the domain condition can be an arbitrary proposition, not necessarily decidable."}
{"full_name": "ConNF.CodingFunction.mem_code_self", "url": "ConNF/Counting/CodingFunction.html#ConNF.CodingFunction.mem_code_self", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.CodingFunction.mem_code_self [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.FOAAssumptions] {β : ConNF.Λ} [ConNF.LeLevel🔗<|PREMISE|>🔗 ↑β] {S : ConNF.Support🔗<|PREMISE|>🔗 ↑β} {t : ConNF.Tangle ↑β} {h : MulAction.Supports🔗<|PREMISE|>🔗 (ConNF.Allowable ↑β) (ConNF.Enumeration.carrier🔗<|PREMISE|>🔗 S.enum) t} :S ∈ ConNF.CodingFunction.code🔗<|PREMISE|>🔗 S t h", "code": "theorem mem_code_self {S : Support β} {t : Tangle β}\n    {h : Supports (Allowable β) (S : Set (Address β)) t} :\n    S ∈ code S t h :=\n  ⟨1, by rw [one_smul]⟩\n", "additional_info": "", "used_premises": [1, 402, 58, 68, 70, 414], "def_path": "ConNF/Counting/CodingFunction.lean", "pos": [133, 137], "informalization": "In the context of Constructive Ordinal Notation (ConNF), a `CodingFunction` is a structure that represents a partial function from `Support β` to `Tangle β`, where `β` is a type index in the context of ConNF. The structure ensures that the domain of this partial function is nonempty, and that it satisfies certain properties related to the action of `Allowable β` on `Support β`. The function `ConNF.CodingFunction.code` produces such a coding function for a given ordered support and tangle it supports. The theorem `ConNF.CodingFunction.mem_code_self` states that for any ordered support `S` and tangle `t` it supports, the ordered support `S` is in the domain of the coding function produced by `ConNF.CodingFunction.code S t h`."}
{"full_name": "ConNF.CodingFunction.mem_code", "url": "ConNF/Counting/CodingFunction.html#ConNF.CodingFunction.mem_code", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.CodingFunction.mem_code [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.FOAAssumptions] {β : ConNF.Λ} [ConNF.LeLevel🔗<|PREMISE|>🔗 ↑β] {S : ConNF.Support🔗<|PREMISE|>🔗 ↑β} {t : ConNF.Tangle ↑β} {h : MulAction.Supports🔗<|PREMISE|>🔗 (ConNF.Allowable ↑β) (ConNF.Enumeration.carrier🔗<|PREMISE|>🔗 S.enum) t} (T : ConNF.Support🔗<|PREMISE|>🔗 ↑β) :T ∈ ConNF.CodingFunction.code🔗<|PREMISE|>🔗 S t h ↔ ∃ (ρ : ConNF.Allowable ↑β), T = ρ • S", "code": "theorem mem_code {S : Support β} {t : Tangle β}\n    {h : Supports (Allowable β) (S : Set (Address β)) t} (T : Support β) :\n    T ∈ code S t h ↔ ∃ ρ : Allowable β, T = ρ • S :=\n  Iff.rfl\n", "additional_info": "", "used_premises": [1, 402, 58, 68, 70, 58, 414], "def_path": "ConNF/Counting/CodingFunction.lean", "pos": [139, 143], "informalization": "In the context of Constructive Ordinal Notation (ConNF), a `CodingFunction` is a structure that represents a partial function from `Support β` to `Tangle β`, where `β` is a type index in the context of ConNF. The structure ensures that the domain of this partial function is nonempty, and that it satisfies certain properties related to the action of `Allowable β` on `Support β`. The function `ConNF.CodingFunction.mem_code` produces such a coding function for a given ordered support and tangle it supports."}
{"full_name": "ConNF.CodingFunction.code_smul", "url": "ConNF/Counting/CodingFunction.html#ConNF.CodingFunction.code_smul", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.CodingFunction.code_smul [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.FOAAssumptions] {β : ConNF.Λ} [ConNF.LeLevel🔗<|PREMISE|>🔗 ↑β] (S : ConNF.Support🔗<|PREMISE|>🔗 ↑β) (t : ConNF.Tangle ↑β) (ρ : ConNF.Allowable ↑β) (h₁ : MulAction.Supports🔗<|PREMISE|>🔗 (ConNF.Allowable ↑β) (ConNF.Enumeration.carrier🔗<|PREMISE|>🔗 (ρ • S).enum) (ρ • t)) (h₂ : MulAction.Supports🔗<|PREMISE|>🔗 (ConNF.Allowable ↑β) (ConNF.Enumeration.carrier🔗<|PREMISE|>🔗 S.enum) t) :ConNF.CodingFunction.code🔗<|PREMISE|>🔗 (ρ • S) (ρ • t) h₁ = ConNF.CodingFunction.code🔗<|PREMISE|>🔗 S t h₂", "code": "theorem code_smul (S : Support β) (t : Tangle β) (ρ : Allowable β)\n    (h₁ : Supports (Allowable β) ((ρ • S : Support β) : Set (Address β)) (ρ • t))\n    (h₂ : Supports (Allowable β) (S : Set (Address β)) t) :\n    code (ρ • S) (ρ • t) h₁ = code S t h₂ := by\n  refine ext S ⟨ρ⁻¹, eq_inv_smul_iff.mpr rfl⟩ mem_code_self ?_\n  have := decode_smul (χ := code (ρ • S) (ρ • t) h₁) (ρ • S) ρ⁻¹ ⟨ρ⁻¹, rfl⟩\n  simp_rw [inv_smul_smul] at this\n  rw [this]\n  simp only [code_decode, Part.get_some, inv_smul_smul]\n", "additional_info": "", "used_premises": [1, 402, 58, 68, 70, 68, 70, 414, 414], "def_path": "ConNF/Counting/CodingFunction.lean", "pos": [153, 162], "informalization": "In the context of Constructive Ordinal Notation (ConNF), given an ordered support S and a tangle t supported by S, and an allowable ρ that stabilizes the enumeration of S, the coding function from S to t will be the same as the coding function from ρ • S to ρ • t. This means that if an allowable permutation ρ stabilizes the enumeration of the support S, then it also stabilizes the coding function."}
{"full_name": "ConNF.Spec.Specifies.smul", "url": "ConNF/Counting/SpecSMul.html#ConNF.Spec.Specifies.smul", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.Spec.Specifies.smul [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.FOAAssumptions] {β : ConNF.Λ} [i : ConNF.LeLevel🔗<|PREMISE|>🔗 ↑β] {σ : ConNF.Spec🔗<|PREMISE|>🔗 β} {S : ConNF.Support🔗<|PREMISE|>🔗 ↑β} (h : ConNF.Spec.Specifies🔗<|PREMISE|>🔗 σ S) (ρ : ConNF.Allowable ↑β) :ConNF.Spec.Specifies🔗<|PREMISE|>🔗 σ (ρ • S)", "code": "theorem Spec.Specifies.smul {σ : Spec β} {S : Support β} (h : σ.Specifies S) (ρ : Allowable β) :\n    σ.Specifies (ρ • S) := by\n  have : WellFoundedLT Λ := inferInstance\n  revert i σ S\n  have := this.induction\n    (C := fun β => ∀ (i : LeLevel ↑β) {σ : Spec β} {S : Support ↑β},\n      Specifies σ S → ∀ (ρ : Allowable ↑β), Specifies σ (ρ • S))\n  refine this β ?_\n  intro β ih i σ S h ρ\n  obtain ⟨_, _, max_eq_max, lS, hlS₁, hlS₂, hlS₃, cond⟩ := h\n  refine ⟨_, _, max_eq_max, fun hγ A => (Allowable.toStructPerm ρ).comp A • lS hγ A,\n      hlS₁, ?_, ?_, ?_⟩\n  · intro γ hγ A i hi\n    simp only [Support.smul_f, Allowable.smul_support_f]\n    rw [← hlS₂ hγ A i hi]\n    rfl\n  · intro γ hγ A\n    have : LeLevel γ := ⟨hγ.le.trans i.elim⟩\n    have := ih γ (coe_lt_coe.mp hγ) _ (hlS₃ hγ A) (Allowable.comp A ρ)\n    rw [Allowable.toStructPerm_smul, Allowable.toStructPerm_comp] at this\n    exact this\n  · intro i hiσ hiS\n    exact (cond i hiσ hiS).smul ρ\n", "additional_info": "", "used_premises": [1, 402, 421, 58, 422, 422], "def_path": "ConNF/Counting/SpecSMul.lean", "pos": [131, 154], "informalization": "The theorem `ConNF.Spec.Specifies.smul` asserts that the action of a scaling factor ρ on a ConNF.Spec object σ, represented by the operator `ρ • S`, results in another ConNF.Spec object that specifies the same natural number as the original object σ. This property is essential for ensuring that the construction of natural numbers in the context of ConNF is well-defined and consistent with the arithmetic operations."}
{"full_name": "ConNF.Spec", "url": "ConNF/Counting/Spec.html#ConNF.Spec", "code_src": "con-nf", "ptype": "inductive", "header": "inductive ConNF.Spec [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.FOAAssumptions] :ConNF.Λ → Type u", "code": "inductive Spec : Λ → Type u\n  | mk {β : Λ} (cond : Enumeration (SpecComponent β))\n      (lower : ∀ {γ : Λ}, (γ : TypeIndex) < β → Path (β : TypeIndex) γ → Spec γ)\n      (r : ∀ {γ : Λ}, (γ : TypeIndex) < β → Path (β : TypeIndex) γ → κ → κ) : Spec β\n", "additional_info": "", "used_premises": [1], "def_path": "ConNF/Counting/Spec.lean", "pos": [29, 33], "informalization": "The Lean 4 object `ConNF.Spec` is an inductive type used in the context of Constructive Ordinal Notation (ConNF) in Lean 4. It is parameterized by `ConNF.Params`, which defines the types `Λ`, `κ`, and `μ`, along with various properties and relationships between these types, such as linear orders, well-orders, zero elements, successor orders, and subtraction operations. Additionally, there are conditions on the cardinalities of these types and their cofinalities. The inductive type `ConNF.Spec` is used to construct the natural numbers in the context of ConNF."}
{"full_name": "ConNF.Spec.Specifies", "url": "ConNF/Counting/Spec.html#ConNF.Spec.Specifies", "code_src": "con-nf", "ptype": "inductive", "header": "inductive ConNF.Spec.Specifies [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.FOAAssumptions] {β : ConNF.Λ} :ConNF.Spec🔗<|PREMISE|>🔗 β → ConNF.Support🔗<|PREMISE|>🔗 ↑β → Prop", "code": "inductive Spec.Specifies : ∀ {β : Λ}, Spec β → Support β → Prop\n  | mk {β : Λ} (σ : Spec β) (S : Support β)\n    (max_eq_max : σ.cond.max = S.max)\n    (lS : ∀ {γ : Λ}, (γ : TypeIndex) < β → Path (β : TypeIndex) γ → Support γ)\n    (hlS₁ : ∀ {γ : Λ} (hγ : (γ : TypeIndex) < β) (A : Path (β : TypeIndex) γ),\n      ∀ i < (lS hγ A).max, σ.r hγ A i < S.max)\n    (hlS₂ : ∀ {γ : Λ} (hγ : (γ : TypeIndex) < β) (A : Path (β : TypeIndex) γ)\n      (i : κ) (hi : i < (lS hγ A).max),\n      ((lS hγ A).f i hi).comp A = S.f (σ.r hγ A i) (hlS₁ hγ A i hi))\n    (hlS₃ : ∀ {γ : Λ} (hγ : (γ : TypeIndex) < β) (A : Path (β : TypeIndex) γ),\n      (σ.lower hγ A).Specifies (lS hγ A))\n    (cond : ∀ (i : κ) (hiσ : i < σ.cond.max) (hiS : i < S.max),\n      SpecifiesC σ S lS (σ.cond.f i hiσ) (S.f i hiS)) :\n    σ.Specifies S\n", "additional_info": "", "used_premises": [1, 421, 58], "def_path": "ConNF/Counting/Spec.lean", "pos": [78, 92], "informalization": "The Lean 4 object `ConNF.Spec.Specifies` is an inductive type used in the context of Constructive Ordinal Notation (ConNF) in Lean 4. It is parameterized by `ConNF.Params`, which defines the types `Λ`, `κ`, and `μ`, along with various properties and relationships between these types, such as linear orders, well-orders, zero elements, successor orders, and subtraction operations. Additionally, there are conditions on the cardinalities of these types and their cofinalities. The inductive type `ConNF.Spec.Specifies` is used to construct the natural numbers in the context of ConNF."}
{"full_name": "ConNF.NearLitterPerm.atomPerm_injective", "url": "ConNF/BaseType/NearLitterPerm.html#ConNF.NearLitterPerm.atomPerm_injective", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterPerm.atomPerm_injective [ConNF.Params🔗<|PREMISE|>🔗 ] :Function.Injective🔗<|PREMISE|>🔗 ConNF.NearLitterPerm.atomPerm", "code": "theorem atomPerm_injective : Injective NearLitterPerm.atomPerm := by\n  rintro ⟨πa, πL, hπ⟩ ⟨πa', πL', hπ'⟩ (h : πa = πa')\n  suffices πL = πL' by\n    subst h\n    subst this\n    rfl\n  ext i : 1\n  exact isNearLitter_litterSet_iff.1\n    (((hπ <| isNearLitter_litterSet _).trans <| by rw [h]).trans\n      (hπ' <| isNearLitter_litterSet _).symm)\n", "additional_info": "The map from the type of near-litter permutations to the type of permutations of atoms is\ninjective. That is, if two near-litter permutations have the same action on atoms, they are\nequal.", "used_premises": [1, 89], "def_path": "ConNF/BaseType/NearLitterPerm.lean", "pos": [64, 74], "informalization": "The theorem `ConNF.NearLitterPerm.atomPerm_injective` states that the map from the type of near-litter permutations to the type of permutations of atoms is injective. This means that if two near-litter permutations have the same action on atoms, they are equal."}
{"full_name": "ConNF.NearLitterPerm.ext", "url": "ConNF/BaseType/NearLitterPerm.html#ConNF.NearLitterPerm.ext", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterPerm.ext [ConNF.Params🔗<|PREMISE|>🔗 ] {π : ConNF.NearLitterPerm} {π' : ConNF.NearLitterPerm} (h : π.atomPerm = π'.atomPerm) :π = π'", "code": "theorem ext (h : π.atomPerm = π'.atomPerm) : π = π' :=\n  atomPerm_injective h\n", "additional_info": "An extensionality result for near-litter permutations.\nIf two near-litter permutations have the same action on atoms, they are equal.", "used_premises": [1], "def_path": "ConNF/BaseType/NearLitterPerm.lean", "pos": [78, 80], "informalization": "The theorem `ConNF.NearLitterPerm.ext` is an extensionality result for near-litter permutations. It states that if two near-litter permutations have the same action on atoms, they are equal."}
{"full_name": "ConNF.NearLitterPerm.atomPerm_hMul", "url": "ConNF/BaseType/NearLitterPerm.html#ConNF.NearLitterPerm.atomPerm_hMul", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.NearLitterPerm.atomPerm_hMul [ConNF.Params🔗<|PREMISE|>🔗 ] (π : ConNF.NearLitterPerm) (π' : ConNF.NearLitterPerm) :(π * π').atomPerm = π.atomPerm * π'.atomPerm", "code": "theorem atomPerm_hMul (π π' : NearLitterPerm) : (π * π').atomPerm = π.atomPerm * π'.atomPerm :=\n  rfl\n", "additional_info": "", "used_premises": [1], "def_path": "ConNF/BaseType/NearLitterPerm.lean", "pos": [151, 153], "informalization": "The theorem `ConNF.NearLitterPerm.atomPerm_hMul` states that the atom permutation of the product of two near litter permutations is equal to the product of their atom permutations."}
{"full_name": "ConNF.NearLitterPerm.atomPerm_div", "url": "ConNF/BaseType/NearLitterPerm.html#ConNF.NearLitterPerm.atomPerm_div", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.NearLitterPerm.atomPerm_div [ConNF.Params🔗<|PREMISE|>🔗 ] (π : ConNF.NearLitterPerm) (π' : ConNF.NearLitterPerm) :(π / π').atomPerm = π.atomPerm / π'.atomPerm", "code": "theorem atomPerm_div (π π' : NearLitterPerm) : (π / π').atomPerm = π.atomPerm / π'.atomPerm :=\n  rfl\n", "additional_info": "", "used_premises": [1], "def_path": "ConNF/BaseType/NearLitterPerm.lean", "pos": [155, 157], "informalization": "The theorem `ConNF.NearLitterPerm.atomPerm_div` states that the atom permutation of the division of two near litter permutations is equal to the division of their atom permutations."}
{"full_name": "ConNF.NearLitterPerm.atomPerm_pow", "url": "ConNF/BaseType/NearLitterPerm.html#ConNF.NearLitterPerm.atomPerm_pow", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.NearLitterPerm.atomPerm_pow [ConNF.Params🔗<|PREMISE|>🔗 ] (π : ConNF.NearLitterPerm) (n : ℕ ) :(π ^ n).atomPerm = π.atomPerm ^ n", "code": "theorem atomPerm_pow (π : NearLitterPerm) (n : ℕ) : (π ^ n).atomPerm = π.atomPerm ^ n :=\n  rfl\n", "additional_info": "", "used_premises": [1], "def_path": "ConNF/BaseType/NearLitterPerm.lean", "pos": [159, 161], "informalization": "The theorem `ConNF.NearLitterPerm.atomPerm_pow` states that for a near litter permutation `π` and a natural number `n`, the `atomPerm` of `π` raised to the power `n` is equal to the `atomPerm` of `π` raised to the power `n`."}
{"full_name": "ConNF.NearLitterPerm.atomPerm_zpow", "url": "ConNF/BaseType/NearLitterPerm.html#ConNF.NearLitterPerm.atomPerm_zpow", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.NearLitterPerm.atomPerm_zpow [ConNF.Params🔗<|PREMISE|>🔗 ] (π : ConNF.NearLitterPerm) (n : ℤ ) :(π ^ n).atomPerm = π.atomPerm ^ n", "code": "theorem atomPerm_zpow (π : NearLitterPerm) (n : ℤ) : (π ^ n).atomPerm = π.atomPerm ^ n :=\n  rfl\n", "additional_info": "", "used_premises": [1], "def_path": "ConNF/BaseType/NearLitterPerm.lean", "pos": [163, 165], "informalization": "The theorem `ConNF.NearLitterPerm.atomPerm_zpow` states that for any near litter permutation `π` and any integer `n`, the atom permutation of `π` raised to the power `n` is equal to the atom permutation of `π` raised to the power `n`."}
{"full_name": "ConNF.NearLitterPerm.litterPerm_hMul", "url": "ConNF/BaseType/NearLitterPerm.html#ConNF.NearLitterPerm.litterPerm_hMul", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.NearLitterPerm.litterPerm_hMul [ConNF.Params🔗<|PREMISE|>🔗 ] (π : ConNF.NearLitterPerm) (π' : ConNF.NearLitterPerm) :(π * π').litterPerm = π.litterPerm * π'.litterPerm", "code": "theorem litterPerm_hMul (π π' : NearLitterPerm) : (π * π').litterPerm = π.litterPerm * π'.litterPerm :=\n  rfl\n", "additional_info": "", "used_premises": [1], "def_path": "ConNF/BaseType/NearLitterPerm.lean", "pos": [175, 177], "informalization": "The theorem `ConNF.NearLitterPerm.litterPerm_hMul` states that the multiplication of two near litter permutations `π` and `π'` results in a near litter permutation whose litter permutation is the product of the litter permutations of `π` and `π'`."}
{"full_name": "ConNF.NearLitterPerm.litterPerm_div", "url": "ConNF/BaseType/NearLitterPerm.html#ConNF.NearLitterPerm.litterPerm_div", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.NearLitterPerm.litterPerm_div [ConNF.Params🔗<|PREMISE|>🔗 ] (π : ConNF.NearLitterPerm) (π' : ConNF.NearLitterPerm) :(π / π').litterPerm = π.litterPerm / π'.litterPerm", "code": "theorem litterPerm_div (π π' : NearLitterPerm) : (π / π').litterPerm = π.litterPerm / π'.litterPerm :=\n  rfl\n", "additional_info": "", "used_premises": [1], "def_path": "ConNF/BaseType/NearLitterPerm.lean", "pos": [179, 181], "informalization": "The theorem `ConNF.NearLitterPerm.litterPerm_div` states that for two near litter permutations `π` and `π'`, the litter permutation of their quotient `π / π'` is equal to the quotient of their litter permutations `π.litterPerm / π'.litterPerm`."}
{"full_name": "ConNF.NearLitterPerm.litterPerm_pow", "url": "ConNF/BaseType/NearLitterPerm.html#ConNF.NearLitterPerm.litterPerm_pow", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.NearLitterPerm.litterPerm_pow [ConNF.Params🔗<|PREMISE|>🔗 ] (π : ConNF.NearLitterPerm) (n : ℕ ) :(π ^ n).litterPerm = π.litterPerm ^ n", "code": "theorem litterPerm_pow (π : NearLitterPerm) (n : ℕ) : (π ^ n).litterPerm = π.litterPerm ^ n :=\n  rfl\n", "additional_info": "", "used_premises": [1], "def_path": "ConNF/BaseType/NearLitterPerm.lean", "pos": [183, 185], "informalization": "The theorem `ConNF.NearLitterPerm.litterPerm_pow` states that for a near litter permutation `π` and a natural number `n`, the `litterPerm` of `π` raised to the power `n` is equal to the `litterPerm` of `π` raised to the power `n`."}
{"full_name": "ConNF.NearLitterPerm.litterPerm_zpow", "url": "ConNF/BaseType/NearLitterPerm.html#ConNF.NearLitterPerm.litterPerm_zpow", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.NearLitterPerm.litterPerm_zpow [ConNF.Params🔗<|PREMISE|>🔗 ] (π : ConNF.NearLitterPerm) (n : ℤ ) :(π ^ n).litterPerm = π.litterPerm ^ n", "code": "theorem litterPerm_zpow (π : NearLitterPerm) (n : ℤ) : (π ^ n).litterPerm = π.litterPerm ^ n :=\n  rfl\n", "additional_info": "", "used_premises": [1], "def_path": "ConNF/BaseType/NearLitterPerm.lean", "pos": [187, 189], "informalization": "The theorem `ConNF.NearLitterPerm.litterPerm_zpow` states that for a near litter permutation `π` and an integer `n`, the `litterPerm` of `π` raised to the power `n` is equal to the `litterPerm` of `π` raised to the power `n`."}
{"full_name": "ConNF.NearLitterPerm.smul_nearLitter_fst", "url": "ConNF/BaseType/NearLitterPerm.html#ConNF.NearLitterPerm.smul_nearLitter_fst", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.NearLitterPerm.smul_nearLitter_fst [ConNF.Params🔗<|PREMISE|>🔗 ] (π : ConNF.NearLitterPerm) (N : ConNF.NearLitter) :(π • N).fst = π • N.fst", "code": "theorem smul_nearLitter_fst (π : NearLitterPerm) (N : NearLitter) : (π • N).fst = π • N.fst :=\n  rfl\n", "additional_info": "", "used_premises": [1], "def_path": "ConNF/BaseType/NearLitterPerm.lean", "pos": [221, 223], "informalization": "The theorem `ConNF.NearLitterPerm.smul_nearLitter_fst` states that for any near-litter permutation `π` and near-litter `N`, the first component of the near-litter permutation action on `N` is equal to the action of `π` on the first component of `N`."}
{"full_name": "ConNF.NearLitterPerm.smul_nearLitter_coe_preimage", "url": "ConNF/BaseType/NearLitterPerm.html#ConNF.NearLitterPerm.smul_nearLitter_coe_preimage", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterPerm.smul_nearLitter_coe_preimage [ConNF.Params🔗<|PREMISE|>🔗 ] (π : ConNF.NearLitterPerm) (N : ConNF.NearLitter) :↑(π • N) = ⇑π.atomPerm⁻¹ ⁻¹' ↑N", "code": "theorem smul_nearLitter_coe_preimage (π : NearLitterPerm) (N : NearLitter) :\n    (π • N : NearLitter) = ((π.atomPerm⁻¹ : Perm Atom) : Atom → Atom) ⁻¹' N :=\n  rfl\n", "additional_info": "", "used_premises": [1], "def_path": "ConNF/BaseType/NearLitterPerm.lean", "pos": [224, 227], "informalization": "The theorem `ConNF.NearLitterPerm.smul_nearLitter_coe_preimage` states that for any near-litter permutation `π` and near-litter `N`, the set of atoms in the near-litter `π • N` is the preimage of the set of atoms in `N` under the inverse of the atom permutation of `π`."}
{"full_name": "ConNF.NearLitterPerm.smul_nearLitter_coe", "url": "ConNF/BaseType/NearLitterPerm.html#ConNF.NearLitterPerm.smul_nearLitter_coe", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterPerm.smul_nearLitter_coe [ConNF.Params🔗<|PREMISE|>🔗 ] (π : ConNF.NearLitterPerm) (N : ConNF.NearLitter) :↑(π • N) = π • ↑N", "code": "theorem smul_nearLitter_coe (π : NearLitterPerm) (N : NearLitter) :\n    (π • N : NearLitter) = π • (N : Set Atom) := by\n  rw [smul_nearLitter_coe_preimage, preimage_inv]\n  rfl\n", "additional_info": "The action of a near-litter perm on a near-litter agrees with the pointwise action on its\natoms.", "used_premises": [1], "def_path": "ConNF/BaseType/NearLitterPerm.lean", "pos": [230, 234], "informalization": "The theorem `ConNF.NearLitterPerm.smul_nearLitter_coe` states that the action of a near-litter permutation on a near-litter is consistent with the pointwise action on its atoms."}
{"full_name": "ConNF.mk_litter", "url": "ConNF/BaseType/Litter.html#ConNF.mk_litter", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.mk_litter [ConNF.Params🔗<|PREMISE|>🔗 ] :Cardinal.mk🔗<|PREMISE|>🔗 ConNF.Litter = Cardinal.mk🔗<|PREMISE|>🔗 ConNF.μ", "code": "theorem mk_litter : #Litter = #μ := by\n  refine\n    litterEquiv.cardinal_eq.trans\n      (le_antisymm ((Cardinal.mk_subtype_le _).trans_eq ?_)\n        ⟨⟨fun ν => ⟨⟨ν, ⊥, default⟩, WithBot.bot_ne_coe⟩, fun ν₁ ν₂ =>\n            congr_arg <| Prod.fst ∘ Subtype.val⟩⟩)\n  have := mul_eq_left\n    (Params.κ_isRegular.aleph0_le.trans Params.κ_lt_μ.le)\n    (Params.Λ_lt_κ.le.trans Params.κ_lt_μ.le)\n    mk_Λ_ne_zero\n  simp only [mk_prod, lift_id, mk_typeIndex, mul_eq_self aleph0_le_mk_Λ, this]\n", "additional_info": "There are precisely `μ` litters.", "used_premises": [1, 29, 29], "def_path": "ConNF/BaseType/Litter.lean", "pos": [48, 59], "informalization": "In the context of Constructive Ordinal Notation (ConNF), the number of litters is equal to the cardinality of the type `μ`."}
{"full_name": "ConNF.Small.lt", "url": "ConNF/BaseType/Small.html#ConNF.Small.lt", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.Small.lt [ConNF.Params🔗<|PREMISE|>🔗 ] {α : Type u} {s : Set🔗<|PREMISE|>🔗 α} :ConNF.Small🔗<|PREMISE|>🔗 s → Cardinal.mk🔗<|PREMISE|>🔗 ↑s < Cardinal.mk🔗<|PREMISE|>🔗 ConNF.κ", "code": "theorem Small.lt : Small s → #s < #κ :=\n  id\n", "additional_info": "", "used_premises": [1, 69, 233, 29, 29], "def_path": "ConNF/BaseType/Small.lean", "pos": [28, 30], "informalization": "The theorem `ConNF.Small.lt` states that if the cardinality of a set `s` is strictly less than the cardinality of the type `ConNF.κ`, then the cardinality of `s` is less than the cardinality of `ConNF.κ`."}
{"full_name": "ConNF.Set.Subsingleton.small", "url": "ConNF/BaseType/Small.html#ConNF.Set.Subsingleton.small", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.Set.Subsingleton.small [ConNF.Params🔗<|PREMISE|>🔗 ] {α : Type u} {s : Set🔗<|PREMISE|>🔗 α} (hs : Set.Subsingleton🔗<|PREMISE|>🔗 s) :ConNF.Small🔗<|PREMISE|>🔗 s", "code": "theorem Set.Subsingleton.small {α : Type _} {s : Set α} (hs : s.Subsingleton) : Small s :=\n  hs.cardinal_mk_le_one.trans_lt <| one_lt_aleph0.trans_le Params.κ_isRegular.aleph0_le\n", "additional_info": "", "used_premises": [1, 69, 115, 233], "def_path": "ConNF/BaseType/Small.lean", "pos": [31, 33], "informalization": "In the context of Constructive Ordinal Notation (ConNF), if a set `s` is a `Subsingleton`, meaning it contains at most one element, then the cardinality of `s` is strictly less than the cardinality of the type `ConNF.κ`."}
{"full_name": "ConNF.small_singleton", "url": "ConNF/BaseType/Small.html#ConNF.small_singleton", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.small_singleton [ConNF.Params🔗<|PREMISE|>🔗 ] {α : Type u} (x : α) :ConNF.Small🔗<|PREMISE|>🔗 {x}", "code": "theorem small_singleton (x : α) : Small ({x} : Set α) :=\n  Set.Subsingleton.small subsingleton_singleton\n", "additional_info": "", "used_premises": [1, 233], "def_path": "ConNF/BaseType/Small.lean", "pos": [39, 41], "informalization": "The theorem `ConNF.small_singleton` states that the cardinality of a singleton set is strictly less than the cardinality of the type `ConNF.κ` in the context of Constructive Ordinal Notation (ConNF)."}
{"full_name": "ConNF.small_setOf", "url": "ConNF/BaseType/Small.html#ConNF.small_setOf", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.small_setOf [ConNF.Params🔗<|PREMISE|>🔗 ] {α : Type u} (p : α → Prop ) :(ConNF.Small🔗<|PREMISE|>🔗 fun (a : α) => p a) ↔ ConNF.Small🔗<|PREMISE|>🔗 {a : α | p a}", "code": "theorem small_setOf (p : α → Prop) : (Small fun a => p a) ↔ Small {a | p a} :=\n  Iff.rfl\n", "additional_info": "", "used_premises": [1, 233, 233], "def_path": "ConNF/BaseType/Small.lean", "pos": [42, 44], "informalization": "The theorem `ConNF.small_setOf` states that in the context of Constructive Ordinal Notation (ConNF), the cardinality of a set defined by a predicate is strictly less than the cardinality of the type `ConNF.κ` if and only if the cardinality of the set of elements satisfying the predicate is strictly less than the cardinality of `ConNF.κ`."}
{"full_name": "ConNF.small_of_forall_not_mem", "url": "ConNF/BaseType/Small.html#ConNF.small_of_forall_not_mem", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.small_of_forall_not_mem [ConNF.Params🔗<|PREMISE|>🔗 ] {α : Type u} {s : Set🔗<|PREMISE|>🔗 α} (h : ∀ (x : α), x ∉ s) :ConNF.Small🔗<|PREMISE|>🔗 s", "code": "theorem small_of_forall_not_mem {s : Set α} (h : ∀ x, x ∉ s) : Small s := by\n  simp only [eq_empty_of_forall_not_mem h, small_empty]\n", "additional_info": "", "used_premises": [1, 69, 233], "def_path": "ConNF/BaseType/Small.lean", "pos": [45, 47], "informalization": "The theorem `ConNF.small_of_forall_not_mem` states that if every element of a type `α` does not belong to a set `s`, then the set `s` is considered \"small\" in the context of Constructive Ordinal Notation (ConNF), meaning its cardinality is strictly less than the cardinality of the type `ConNF.κ`."}
{"full_name": "ConNF.Small.mono", "url": "ConNF/BaseType/Small.html#ConNF.Small.mono", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.Small.mono [ConNF.Params🔗<|PREMISE|>🔗 ] {α : Type u} {s : Set🔗<|PREMISE|>🔗 α} {t : Set🔗<|PREMISE|>🔗 α} (h : s ⊆ t) :ConNF.Small🔗<|PREMISE|>🔗 t → ConNF.Small🔗<|PREMISE|>🔗 s", "code": "theorem Small.mono (h : s ⊆ t) : Small t → Small s :=\n  (mk_le_mk_of_subset h).trans_lt\n", "additional_info": "Subsets of small sets are small. We say that the 'smallness' relation is monotone.", "used_premises": [1, 69, 69, 233, 233], "def_path": "ConNF/BaseType/Small.lean", "pos": [49, 51], "informalization": "In the context of Constructive Ordinal Notation (ConNF), a set is considered \"small\" if its cardinality is strictly less than the cardinality of the type `ConNF.κ`. The theorem `ConNF.Small.mono` states that if a set `s` is a subset of another set `t`, and `t` is known to be small, then `s` must also be small. This property is known as the monotonicity of the smallness relation."}
{"full_name": "ConNF.Small.union", "url": "ConNF/BaseType/Small.html#ConNF.Small.union", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.Small.union [ConNF.Params🔗<|PREMISE|>🔗 ] {α : Type u} {s : Set🔗<|PREMISE|>🔗 α} {t : Set🔗<|PREMISE|>🔗 α} (hs : ConNF.Small🔗<|PREMISE|>🔗 s) (ht : ConNF.Small🔗<|PREMISE|>🔗 t) :ConNF.Small🔗<|PREMISE|>🔗 (s ∪ t)", "code": "theorem Small.union (hs : Small s) (ht : Small t) : Small (s ∪ t) :=\n  (mk_union_le _ _).trans_lt <| add_lt_of_lt Params.κ_isRegular.aleph0_le hs ht\n", "additional_info": "Unions of small subsets are small.", "used_premises": [1, 69, 69, 233, 233, 233], "def_path": "ConNF/BaseType/Small.lean", "pos": [53, 55], "informalization": "In the context of Constructive Ordinal Notation (ConNF), the theorem `ConNF.Small.union` states that the union of two sets, each of which has a cardinality strictly less than the cardinality of the type `ConNF.κ`, also has a cardinality strictly less than the cardinality of `ConNF.κ`."}
{"full_name": "ConNF.Small.symmDiff", "url": "ConNF/BaseType/Small.html#ConNF.Small.symmDiff", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.Small.symmDiff [ConNF.Params🔗<|PREMISE|>🔗 ] {α : Type u} {s : Set🔗<|PREMISE|>🔗 α} {t : Set🔗<|PREMISE|>🔗 α} (hs : ConNF.Small🔗<|PREMISE|>🔗 s) (ht : ConNF.Small🔗<|PREMISE|>🔗 t) :ConNF.Small🔗<|PREMISE|>🔗 (symmDiff🔗<|PREMISE|>🔗 s t)", "code": "theorem Small.symmDiff (hs : Small s) (ht : Small t) : Small (s ∆ t) :=\n  (hs.union ht).mono symmDiff_subset_union\n", "additional_info": "", "used_premises": [1, 69, 69, 233, 233, 233, 62], "def_path": "ConNF/BaseType/Small.lean", "pos": [56, 58], "informalization": "`ConNF.Small.symmDiff` is a theorem in Lean 4 that states that the symmetric difference of two sets, each of which has a cardinality strictly less than the cardinality of the type `ConNF.κ`, also has a cardinality strictly less than the cardinality of `ConNF.κ`."}
{"full_name": "ConNF.Small.symmDiff_iff", "url": "ConNF/BaseType/Small.html#ConNF.Small.symmDiff_iff", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.Small.symmDiff_iff [ConNF.Params🔗<|PREMISE|>🔗 ] {α : Type u} {s : Set🔗<|PREMISE|>🔗 α} {t : Set🔗<|PREMISE|>🔗 α} (hs : ConNF.Small🔗<|PREMISE|>🔗 s) :ConNF.Small🔗<|PREMISE|>🔗 t ↔ ConNF.Small🔗<|PREMISE|>🔗 (symmDiff🔗<|PREMISE|>🔗 s t)", "code": "theorem Small.symmDiff_iff (hs : Small s) : Small t ↔ Small (s ∆ t) :=\n  ⟨hs.symmDiff, fun ht => by simpa only [symmDiff_symmDiff_self'] using ht.symmDiff hs⟩\n", "additional_info": "", "used_premises": [1, 69, 69, 233, 233, 233, 62], "def_path": "ConNF/BaseType/Small.lean", "pos": [59, 61], "informalization": "The theorem `ConNF.Small.symmDiff_iff` states that in the context of Constructive Ordinal Notation (ConNF), the symmetric difference of two sets `s` and `t` is small (i.e., its cardinality is strictly less than the cardinality of the type `ConNF.κ`) if and only if both `s` and `t` are small."}
{"full_name": "ConNF.small_iUnion", "url": "ConNF/BaseType/Small.html#ConNF.small_iUnion", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.small_iUnion [ConNF.Params🔗<|PREMISE|>🔗 ] {ι : Type u} {α : Type u} (hι : Cardinal.mk🔗<|PREMISE|>🔗 ι < Cardinal.mk🔗<|PREMISE|>🔗 ConNF.κ) {f : ι → Set🔗<|PREMISE|>🔗 α} (hf : ∀ (i : ι), ConNF.Small🔗<|PREMISE|>🔗 (f i)) :ConNF.Small🔗<|PREMISE|>🔗 (⋃ (i : ι), f i)", "code": "theorem small_iUnion (hι : #ι < #κ) {f : ι → Set α} (hf : ∀ i, Small (f i)) :\n    Small (⋃ i, f i) :=\n  (mk_iUnion_le _).trans_lt <|\n    mul_lt_of_lt Params.κ_isRegular.aleph0_le hι <| iSup_lt_of_isRegular Params.κ_isRegular hι hf\n", "additional_info": "", "used_premises": [1, 29, 29, 69, 233, 233], "def_path": "ConNF/BaseType/Small.lean", "pos": [62, 66], "informalization": "In the context of Constructive Ordinal Notation (ConNF), the theorem `ConNF.small_iUnion` states that if the cardinality of an index set `ι` is strictly less than the cardinality of the type `ConNF.κ`, and each element of `ι` is mapped to a set whose cardinality is strictly less than the cardinality of `ConNF.κ`, then the cardinality of the union of these sets is also strictly less than the cardinality of `ConNF.κ`."}
{"full_name": "ConNF.small_iUnion_Prop", "url": "ConNF/BaseType/Small.html#ConNF.small_iUnion_Prop", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.small_iUnion_Prop [ConNF.Params🔗<|PREMISE|>🔗 ] {α : Type u} {p : Prop } {f : p → Set🔗<|PREMISE|>🔗 α} (hf : ∀ (i : p), ConNF.Small🔗<|PREMISE|>🔗 (f i)) :ConNF.Small🔗<|PREMISE|>🔗 (⋃ (i : p), f i)", "code": "theorem small_iUnion_Prop {p : Prop} {f : p → Set α} (hf : ∀ i, Small (f i)) : Small (⋃ i, f i) :=\n  by by_cases p <;> simp_all\n", "additional_info": "", "used_premises": [1, 69, 233, 233], "def_path": "ConNF/BaseType/Small.lean", "pos": [67, 69], "informalization": "In the context of Constructive Ordinal Notation (ConNF), the theorem `ConNF.small_iUnion_Prop` states that if the cardinality of each set in a family of sets is strictly less than the cardinality of the type `ConNF.κ`, then the cardinality of the union of these sets is also strictly less than the cardinality of `ConNF.κ`."}
{"full_name": "ConNF.Small.bUnion", "url": "ConNF/BaseType/Small.html#ConNF.Small.bUnion", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.Small.bUnion [ConNF.Params🔗<|PREMISE|>🔗 ] {ι : Type u} {α : Type u} {s : Set🔗<|PREMISE|>🔗 ι} (hs : ConNF.Small🔗<|PREMISE|>🔗 s) {f : (i : ι) → i ∈ s → Set🔗<|PREMISE|>🔗 α} (hf : ∀ (i : ι) (hi : i ∈ s), ConNF.Small🔗<|PREMISE|>🔗 (f i hi)) :ConNF.Small🔗<|PREMISE|>🔗 (⋃ (i : ι), ⋃ (hi : i ∈ s), f i hi)", "code": "protected theorem Small.bUnion {s : Set ι} (hs : Small s) {f : ∀ i ∈ s, Set α}\n    (hf : ∀ i (hi : i ∈ s), Small (f i hi)) : Small (⋃ (i) (hi : i ∈ s), f i hi) :=\n  (mk_bUnion_le' _ _).trans_lt <|\n    mul_lt_of_lt Params.κ_isRegular.aleph0_le hs <|\n    iSup_lt_of_isRegular Params.κ_isRegular hs (fun _ => hf _ _)\n", "additional_info": "", "used_premises": [1, 69, 233, 69, 233, 233], "def_path": "ConNF/BaseType/Small.lean", "pos": [70, 75], "informalization": "The theorem `ConNF.Small.bUnion` states that if `s` is a set whose cardinality is strictly less than the cardinality of `ConNF.κ`, and for each `i` in `s`, `f i hi` is a set whose cardinality is also strictly less than the cardinality of `ConNF.κ`, then the cardinality of the union of all `f i hi` for `i` in `s` is also strictly less than the cardinality of `ConNF.κ`."}
{"full_name": "ConNF.Small.image", "url": "ConNF/BaseType/Small.html#ConNF.Small.image", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.Small.image [ConNF.Params🔗<|PREMISE|>🔗 ] {α : Type u} {β : Type u} {f : α → β} {s : Set🔗<|PREMISE|>🔗 α} :ConNF.Small🔗<|PREMISE|>🔗 s → ConNF.Small🔗<|PREMISE|>🔗 (f '' s)", "code": "theorem Small.image : Small s → Small (f '' s) :=\n  mk_image_le.trans_lt\n", "additional_info": "The image of a small set under any function `f` is small.", "used_premises": [1, 69, 233, 233], "def_path": "ConNF/BaseType/Small.lean", "pos": [77, 79], "informalization": "The theorem `ConNF.Small.image` states that if a set `s` is small (i.e., its cardinality is strictly less than the cardinality of the type `ConNF.κ`), then the image of `s` under any function `f` is also small."}
{"full_name": "ConNF.Small.preimage", "url": "ConNF/BaseType/Small.html#ConNF.Small.preimage", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.Small.preimage [ConNF.Params🔗<|PREMISE|>🔗 ] {α : Type u} {β : Type u} {f : α → β} {s : Set🔗<|PREMISE|>🔗 β} (h : Function.Injective🔗<|PREMISE|>🔗 f) :ConNF.Small🔗<|PREMISE|>🔗 s → ConNF.Small🔗<|PREMISE|>🔗 (f ⁻¹' s)", "code": "theorem Small.preimage {s : Set β} (h : f.Injective) : Small s → Small (f ⁻¹' s) :=\n  (mk_preimage_of_injective f s h).trans_lt\n", "additional_info": "The preimage of a small set under an injective function `f` is small.", "used_premises": [1, 69, 89, 233, 233], "def_path": "ConNF/BaseType/Small.lean", "pos": [81, 83], "informalization": "The theorem `ConNF.Small.preimage` states that if `f` is an injective function and `s` is a small set, then the preimage of `s` under `f` is also small."}
{"full_name": "ConNF.Small.image_subset", "url": "ConNF/BaseType/Small.html#ConNF.Small.image_subset", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.Small.image_subset [ConNF.Params🔗<|PREMISE|>🔗 ] {α : Type u} {β : Type u} {s : Set🔗<|PREMISE|>🔗 α} {t : Set🔗<|PREMISE|>🔗 β} (f : α → β) (h : Function.Injective🔗<|PREMISE|>🔗 f) :ConNF.Small🔗<|PREMISE|>🔗 t → f '' s ⊆ t → ConNF.Small🔗<|PREMISE|>🔗 s", "code": "theorem Small.image_subset {t : Set β} (f : α → β) (h : f.Injective) :\n    Small t → f '' s ⊆ t → Small s := by\n  intro h₁ h₂\n  have := (Small.mono h₂ h₁).preimage h\n  rw [preimage_image_eq s h] at this\n  exact this\n", "additional_info": "A set is small if its image under an injective function is contained in a small set.", "used_premises": [1, 69, 69, 89, 233, 233], "def_path": "ConNF/BaseType/Small.lean", "pos": [86, 92], "informalization": "In the context of Constructive Ordinal Notation (ConNF), a set is considered \"small\" if its cardinality is strictly less than the cardinality of the type `ConNF.κ`. The theorem `ConNF.Small.image_subset` states that if the image of a set `s` under an injective function `f` is contained within a small set `t`, then `s` itself is also small."}
{"full_name": "ConNF.Small.pFun_image", "url": "ConNF/BaseType/Small.html#ConNF.Small.pFun_image", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.Small.pFun_image [ConNF.Params🔗<|PREMISE|>🔗 ] {α : Type u} {β : Type u} {s : Set🔗<|PREMISE|>🔗 α} (h : ConNF.Small🔗<|PREMISE|>🔗 s) {f : α →. β} :ConNF.Small🔗<|PREMISE|>🔗 (PFun.image🔗<|PREMISE|>🔗 f s)", "code": "theorem Small.pFun_image {α β : Type _} {s : Set α} (h : Small s) {f : α →. β} :\n    Small (f.image s) := by\n  have : Small (f '' s) := Small.image h\n  refine' Small.image_subset Part.some Part.some_injective this _\n  rintro x ⟨y, ⟨z, hz₁, hz₂⟩, rfl⟩\n  exact ⟨z, hz₁, Part.eq_some_iff.mpr hz₂⟩\n", "additional_info": "", "used_premises": [1, 69, 233, 233, 453], "def_path": "ConNF/BaseType/Small.lean", "pos": [93, 99], "informalization": "The theorem `ConNF.Small.pFun_image` states that if the cardinality of a set `s` is strictly less than the cardinality of the type `ConNF.κ`, and `f` is a partial function from `α` to `β`, then the cardinality of the image of `s` under `f` is also strictly less than the cardinality of `ConNF.κ`."}
{"full_name": "PFun.image", "url": "Mathlib/Data/PFun.html#PFun.image", "code_src": "mathlib4", "ptype": "def", "header": "def PFun.image {α : Type u_1} {β : Type u_2} (f : α →. β) (s : Set🔗<|PREMISE|>🔗 α) :Set🔗<|PREMISE|>🔗 β", "code": "def image (s : Set α) : Set β :=\n  f.graph'.image s\n", "additional_info": "Image of a set under a partial function.\nEquations\n* 🗟PFun.image🗟🔗../.././Mathlib/Data/PFun.html#PFun.image🔗  f s 🗟=🗟🔗../.././Init/Prelude.html#Eq🔗  🗟Rel.image🗟🔗../.././Mathlib/Data/Rel.html#Rel.image🔗  (🗟PFun.graph'🗟🔗../.././Mathlib/Data/PFun.html#PFun.graph'🔗  f) s\n\n", "used_premises": [69, 69], "def_path": "Mathlib/Data/PFun.lean", "pos": [396, 398], "informalization": "Function `PFun.image` computes the image of a set `s` under a partial function `f`, which is the set of all possible outputs of `f` when applied to elements of `s`."}
{"full_name": "ConNF.isNear_refl", "url": "ConNF/BaseType/Small.html#ConNF.isNear_refl", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.isNear_refl [ConNF.Params🔗<|PREMISE|>🔗 ] {α : Type u} (s : Set🔗<|PREMISE|>🔗 α) :ConNF.IsNear🔗<|PREMISE|>🔗 s s", "code": "theorem isNear_refl (s : Set α) : IsNear s s := by rw [IsNear, symmDiff_self]; exact small_empty\n", "additional_info": "A set is near itself.", "used_premises": [1, 69, 455], "def_path": "ConNF/BaseType/Small.lean", "pos": [106, 107], "informalization": "The theorem `ConNF.isNear_refl` states that any set is near itself in the context of Constructive Ordinal Notation (ConNF). This means that the symmetric difference of a set with itself, denoted as `s ∆ s`, is considered \"small\" according to the `ConNF.Small` predicate. This is a fundamental property of the `ConNF.IsNear` relation, indicating that it is reflexive."}
{"full_name": "ConNF.IsNear", "url": "ConNF/BaseType/Small.html#ConNF.IsNear", "code_src": "con-nf", "ptype": "def", "header": "def ConNF.IsNear [ConNF.Params🔗<|PREMISE|>🔗 ] {α : Type u} (s : Set🔗<|PREMISE|>🔗 α) (t : Set🔗<|PREMISE|>🔗 α) :Prop", "code": "def IsNear (s t : Set α) : Prop :=\n  Small (s ∆ t)\n", "additional_info": "Two sets are near if their symmetric difference is small.\nEquations\n* 🗟ConNF.IsNear🗟🔗../.././ConNF/BaseType/Small.html#ConNF.IsNear🔗  s t 🗟=🗟🔗../.././Init/Prelude.html#Eq🔗  🗟ConNF.Small🗟🔗../.././ConNF/BaseType/Small.html#ConNF.Small🔗  (🗟symmDiff🗟🔗../.././Mathlib/Order/SymmDiff.html#symmDiff🔗  s t)\n\n", "used_premises": [1, 69, 69], "def_path": "ConNF/BaseType/Small.lean", "pos": [101, 103], "informalization": "Function `ConNF.IsNear` defines a property of two sets `s` and `t` being \"near\" each other in the context of Constructive Ordinal Notation (ConNF). Two sets are considered near if their symmetric difference, denoted as `s ∆ t`, is considered \"small\" according to the `ConNF.Small` predicate."}
{"full_name": "ConNF.isNear_rfl", "url": "ConNF/BaseType/Small.html#ConNF.isNear_rfl", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.isNear_rfl [ConNF.Params🔗<|PREMISE|>🔗 ] {α : Type u} {s : Set🔗<|PREMISE|>🔗 α} :ConNF.IsNear🔗<|PREMISE|>🔗 s s", "code": "theorem isNear_rfl : IsNear s s :=\n  isNear_refl _\n", "additional_info": "A version of the `is_near_refl` lemma that does not require the set `s` to be given explicitly.\nThe value of `s` will be inferred automatically by the elaborator.", "used_premises": [1, 69, 455], "def_path": "ConNF/BaseType/Small.lean", "pos": [110, 112], "informalization": "The `ConNF.isNear_rfl` theorem is a version of the `is_near_refl` lemma that does not require the set `s` to be given explicitly. The value of `s` will be inferred automatically by the elaborator."}
{"full_name": "ConNF.IsNear.symm", "url": "ConNF/BaseType/Small.html#ConNF.IsNear.symm", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.IsNear.symm [ConNF.Params🔗<|PREMISE|>🔗 ] {α : Type u} {s : Set🔗<|PREMISE|>🔗 α} {t : Set🔗<|PREMISE|>🔗 α} (h : ConNF.IsNear🔗<|PREMISE|>🔗 s t) :ConNF.IsNear🔗<|PREMISE|>🔗 t s", "code": "theorem IsNear.symm (h : IsNear s t) : IsNear t s := by rwa [IsNear, symmDiff_comm]\n", "additional_info": "If `s` is near `t`, then `t` is near `s`.", "used_premises": [1, 69, 69, 455, 455], "def_path": "ConNF/BaseType/Small.lean", "pos": [115, 116], "informalization": "In the context of Constructive Ordinal Notation (ConNF), two sets `s` and `t` are considered \"near\" if their symmetric difference, denoted as `s ∆ t`, is considered \"small\" according to the `ConNF.Small` predicate. This theorem states that if `s` is near `t`, then `t` is also near `s`."}
{"full_name": "ConNF.isNear_comm", "url": "ConNF/BaseType/Small.html#ConNF.isNear_comm", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.isNear_comm [ConNF.Params🔗<|PREMISE|>🔗 ] {α : Type u} {s : Set🔗<|PREMISE|>🔗 α} {t : Set🔗<|PREMISE|>🔗 α} :ConNF.IsNear🔗<|PREMISE|>🔗 s t ↔ ConNF.IsNear🔗<|PREMISE|>🔗 t s", "code": "theorem isNear_comm : IsNear s t ↔ IsNear t s :=\n  ⟨IsNear.symm, IsNear.symm⟩\n", "additional_info": "`s` is near `t` if and only if `t` is near `s`.\nIn each direction, this is an application of the `is_near.🗟symm🗟🔗../.././Mathlib/Init/Algebra/Classes.html#symm🔗`  lemma.\nLemmas using `↔` can be used with `rw`, so this form of the result is particularly useful.", "used_premises": [1, 69, 69, 455, 455], "def_path": "ConNF/BaseType/Small.lean", "pos": [120, 122], "informalization": "`s` is near `t` if and only if `t` is near `s`."}
{"full_name": "ConNF.IsNear.trans", "url": "ConNF/BaseType/Small.html#ConNF.IsNear.trans", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.IsNear.trans [ConNF.Params🔗<|PREMISE|>🔗 ] {α : Type u} {s : Set🔗<|PREMISE|>🔗 α} {t : Set🔗<|PREMISE|>🔗 α} {u : Set🔗<|PREMISE|>🔗 α} (hst : ConNF.IsNear🔗<|PREMISE|>🔗 s t) (htu : ConNF.IsNear🔗<|PREMISE|>🔗 t u) :ConNF.IsNear🔗<|PREMISE|>🔗 s u", "code": "theorem IsNear.trans (hst : IsNear s t) (htu : IsNear t u) : IsNear s u :=\n  (hst.union htu).mono <| symmDiff_triangle s t u\n", "additional_info": "Nearness is transitive: if `s` is near `t` and `t` is near `u`, then `s` is near `u`.", "used_premises": [1, 69, 69, 69, 455, 455, 455], "def_path": "ConNF/BaseType/Small.lean", "pos": [125, 127], "informalization": "In the context of Constructive Ordinal Notation (ConNF), the property of two sets being \"near\" each other is transitive. This means that if set `s` is near set `t`, and set `t` is near set `u`, then set `s` is also near set `u`."}
{"full_name": "ConNF.IsNear.image", "url": "ConNF/BaseType/Small.html#ConNF.IsNear.image", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.IsNear.image [ConNF.Params🔗<|PREMISE|>🔗 ] {α : Type u} {β : Type u} {s : Set🔗<|PREMISE|>🔗 α} {t : Set🔗<|PREMISE|>🔗 α} (f : α → β) (h : ConNF.IsNear🔗<|PREMISE|>🔗 s t) :ConNF.IsNear🔗<|PREMISE|>🔗 (f '' s) (f '' t)", "code": "theorem IsNear.image (f : α → β) (h : IsNear s t) : IsNear (f '' s) (f '' t) :=\n  Small.mono subset_image_symmDiff (Small.image h)\n", "additional_info": "If two sets are near each other, then their images under an arbitrary function are also near.", "used_premises": [1, 69, 69, 455, 455], "def_path": "ConNF/BaseType/Small.lean", "pos": [129, 131], "informalization": "Function `ConNF.IsNear.image` proves that if two sets are \"near\" each other in the context of Constructive Ordinal Notation (ConNF), then their images under an arbitrary function are also \"near\"."}
{"full_name": "ConNF.isNear_of_small", "url": "ConNF/BaseType/Small.html#ConNF.isNear_of_small", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.isNear_of_small [ConNF.Params🔗<|PREMISE|>🔗 ] {α : Type u} {s : Set🔗<|PREMISE|>🔗 α} {t : Set🔗<|PREMISE|>🔗 α} (hs : ConNF.Small🔗<|PREMISE|>🔗 s) (ht : ConNF.Small🔗<|PREMISE|>🔗 t) :ConNF.IsNear🔗<|PREMISE|>🔗 s t", "code": "theorem isNear_of_small (hs : Small s) (ht : Small t) : IsNear s t :=\n  Small.symmDiff hs ht\n", "additional_info": "", "used_premises": [1, 69, 69, 233, 233, 455], "def_path": "ConNF/BaseType/Small.lean", "pos": [132, 134], "informalization": "The theorem `ConNF.isNear_of_small` states that if two sets `s` and `t` are both considered \"small\" in the context of Constructive Ordinal Notation (ConNF), then they are considered \"near\" each other according to the `ConNF.IsNear` predicate."}
{"full_name": "ConNF.Small.isNear_iff", "url": "ConNF/BaseType/Small.html#ConNF.Small.isNear_iff", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.Small.isNear_iff [ConNF.Params🔗<|PREMISE|>🔗 ] {α : Type u} {s : Set🔗<|PREMISE|>🔗 α} {t : Set🔗<|PREMISE|>🔗 α} (hs : ConNF.Small🔗<|PREMISE|>🔗 s) :ConNF.Small🔗<|PREMISE|>🔗 t ↔ ConNF.IsNear🔗<|PREMISE|>🔗 s t", "code": "theorem Small.isNear_iff (hs : Small s) : Small t ↔ IsNear s t :=\n  hs.symmDiff_iff\n", "additional_info": "", "used_premises": [1, 69, 69, 233, 233, 455], "def_path": "ConNF/BaseType/Small.lean", "pos": [135, 137], "informalization": "The theorem `ConNF.Small.isNear_iff` states that for two sets `s` and `t` in the context of Constructive Ordinal Notation (ConNF), if `s` is considered \"small\" (i.e., its cardinality is strictly less than the cardinality of the type `ConNF.κ`), then `t` is considered \"small\" if and only if `s` and `t` are \"near\" each other (i.e., their symmetric difference is considered \"small\")."}
{"full_name": "ConNF.IsNear.κ_le", "url": "ConNF/BaseType/Small.html#ConNF.IsNear.κ_le", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.IsNear.κ_le [ConNF.Params🔗<|PREMISE|>🔗 ] {α : Type u} {s : Set🔗<|PREMISE|>🔗 α} {t : Set🔗<|PREMISE|>🔗 α} (h : ConNF.IsNear🔗<|PREMISE|>🔗 s t) (hs : Cardinal.mk🔗<|PREMISE|>🔗 ConNF.κ ≤ Cardinal.mk🔗<|PREMISE|>🔗 ↑s) :Cardinal.mk🔗<|PREMISE|>🔗 ConNF.κ ≤ Cardinal.mk🔗<|PREMISE|>🔗 ↑t", "code": "theorem IsNear.κ_le (h : IsNear s t) (hs : #κ ≤ #s) : #κ ≤ #(t : Set α) := by\n  by_contra ht\n  rw [not_le] at ht\n  have := h.symm\n  rw [← Small.isNear_iff ht] at this\n  exact (lt_iff_not_ge _ _).mp this hs\n", "additional_info": "", "used_premises": [1, 69, 69, 455, 29, 29, 29, 29], "def_path": "ConNF/BaseType/Small.lean", "pos": [138, 144], "informalization": "The theorem `ConNF.IsNear.κ_le` states that if two sets `s` and `t` are \"near\" each other in the context of Constructive Ordinal Notation (ConNF), and the cardinality of `ConNF.κ` is less than or equal to the cardinality of `s`, then the cardinality of `ConNF.κ` is also less than or equal to the cardinality of `t`."}
{"full_name": "ConNF.IsNear.mk_inter", "url": "ConNF/BaseType/Small.html#ConNF.IsNear.mk_inter", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.IsNear.mk_inter [ConNF.Params🔗<|PREMISE|>🔗 ] {α : Type u} {s : Set🔗<|PREMISE|>🔗 α} {t : Set🔗<|PREMISE|>🔗 α} (h : ConNF.IsNear🔗<|PREMISE|>🔗 s t) (hs : Cardinal.mk🔗<|PREMISE|>🔗 ConNF.κ ≤ Cardinal.mk🔗<|PREMISE|>🔗 ↑s) :Cardinal.mk🔗<|PREMISE|>🔗 ConNF.κ ≤ Cardinal.mk🔗<|PREMISE|>🔗 ↑(s ∩ t)", "code": "theorem IsNear.mk_inter (h : IsNear s t) (hs : #κ ≤ #s) : #κ ≤ #(s ∩ t : Set α) := by\n  rw [IsNear, symmDiff_eq_sup_sdiff_inf] at h\n  exact le_of_not_gt fun hst =>\n    lt_irrefl _\n      (((hs.trans (mk_le_mk_of_subset (subset_union_left _ _))).trans\n            (le_mk_diff_add_mk (s ∪ t) (s ∩ t))).trans_lt\n        (add_lt_of_lt Params.κ_isRegular.aleph0_le h hst))\n", "additional_info": "", "used_premises": [1, 69, 69, 455, 29, 29, 29, 29], "def_path": "ConNF/BaseType/Small.lean", "pos": [145, 152], "informalization": "The theorem `ConNF.IsNear.mk_inter` states that if two sets `s` and `t` are \"near\" each other in the context of Constructive Ordinal Notation (ConNF), and the cardinality of `s` is at least the cardinality of `ConNF.κ`, then the cardinality of the intersection of `s` and `t` is also at least the cardinality of `ConNF.κ`."}
{"full_name": "ConNF.isNearLitter_litterSet", "url": "ConNF/BaseType/NearLitter.html#ConNF.isNearLitter_litterSet", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.isNearLitter_litterSet [ConNF.Params🔗<|PREMISE|>🔗 ] (L : ConNF.Litter) :ConNF.IsNearLitter🔗<|PREMISE|>🔗 L (ConNF.litterSet🔗<|PREMISE|>🔗 L)", "code": "theorem isNearLitter_litterSet (L : Litter) : IsNearLitter L (litterSet L) :=\n  isNear_rfl\n", "additional_info": "The litter set corresponding to `L` is a near-litter to litter `L`.", "used_premises": [1, 466, 467], "def_path": "ConNF/BaseType/NearLitter.lean", "pos": [38, 40], "informalization": "The litter set corresponding to a given litter `L` in the context of Constructive Ordinal Notation (ConNF) is a near-litter to litter `L`."}
{"full_name": "ConNF.IsNearLitter", "url": "ConNF/BaseType/NearLitter.html#ConNF.IsNearLitter", "code_src": "con-nf", "ptype": "def", "header": "def ConNF.IsNearLitter [ConNF.Params🔗<|PREMISE|>🔗 ] (L : ConNF.Litter) (s : Set🔗<|PREMISE|>🔗 ConNF.Atom) :Prop", "code": "def IsNearLitter (L : Litter) (s : Set Atom) : Prop :=\n  IsNear (litterSet L) s\n", "additional_info": "A `L`-near-litter is a set of small symmetric difference to litter `L`. In other words,\nit is near litter `L`.\nNote that here we keep track of which litter a set is near; a set cannot be merely a near-litter, it\nmust be an `L`-near-litter for some `L`. A priori, a set could be an `L₁`-near-litter and also a\n`L₂`-near-litter, but this is not the case.\nEquations\n* 🗟ConNF.IsNearLitter🗟🔗../.././ConNF/BaseType/NearLitter.html#ConNF.IsNearLitter🔗  L s 🗟=🗟🔗../.././Init/Prelude.html#Eq🔗  🗟ConNF.IsNear🗟🔗../.././ConNF/BaseType/Small.html#ConNF.IsNear🔗  (🗟ConNF.litterSet🗟🔗../.././ConNF/BaseType/Atom.html#ConNF.litterSet🔗  L) s\n\n", "used_premises": [1, 69], "def_path": "ConNF/BaseType/NearLitter.lean", "pos": [34, 36], "informalization": "Function `ConNF.IsNearLitter` is a predicate that checks if a given set `s` of type `ConNF.Atom` is near a litter `L` in the context of Constructive Ordinal Notation (ConNF). This means that the set `s` has a small symmetric difference with the litter set of `L`."}
{"full_name": "ConNF.litterSet", "url": "ConNF/BaseType/Atom.html#ConNF.litterSet", "code_src": "con-nf", "ptype": "def", "header": "def ConNF.litterSet [ConNF.Params🔗<|PREMISE|>🔗 ] (L : ConNF.Litter) :Set🔗<|PREMISE|>🔗 ConNF.Atom", "code": "def litterSet (L : Litter) : Set Atom :=\n  {a | a.1 = L}\n", "additional_info": "The set corresponding to litter `L`. We define a litter set as the set of atoms with first\nprojection `L`.\nEquations\n* 🗟ConNF.litterSet🗟🔗../.././ConNF/BaseType/Atom.html#ConNF.litterSet🔗  L 🗟=🗟🔗../.././Init/Prelude.html#Eq🔗  {a : ConNF.Atom | a.1 🗟=🗟🔗../.././Init/Prelude.html#Eq🔗  L}\n\n", "used_premises": [1, 69], "def_path": "ConNF/BaseType/Atom.lean", "pos": [52, 54], "informalization": "Function `ConNF.litterSet` defines a set corresponding to a given litter `L` in the context of Constructive Ordinal Notation (ConNF). This set contains all atoms `a` such that the first projection of `a` is equal to `L`."}
{"full_name": "ConNF.isNear_litterSet", "url": "ConNF/BaseType/NearLitter.html#ConNF.isNear_litterSet", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.isNear_litterSet [ConNF.Params🔗<|PREMISE|>🔗 ] {L : ConNF.Litter} {s : Set🔗<|PREMISE|>🔗 ConNF.Atom} :ConNF.IsNear🔗<|PREMISE|>🔗 (ConNF.litterSet🔗<|PREMISE|>🔗 L) s ↔ ConNF.IsNearLitter🔗<|PREMISE|>🔗 L s", "code": "theorem isNear_litterSet : IsNear (litterSet L) s ↔ IsNearLitter L s :=\n  Iff.rfl\n", "additional_info": "", "used_premises": [1, 69, 455, 467, 466], "def_path": "ConNF/BaseType/NearLitter.lean", "pos": [42, 44], "informalization": "The theorem `ConNF.isNear_litterSet` states that in the context of Constructive Ordinal Notation (ConNF), a set `s` of type `ConNF.Atom` is near a litter `L` if and only if `s` has a small symmetric difference with the litter set of `L`."}
{"full_name": "ConNF.IsNearLitter.near", "url": "ConNF/BaseType/NearLitter.html#ConNF.IsNearLitter.near", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.IsNearLitter.near [ConNF.Params🔗<|PREMISE|>🔗 ] {L : ConNF.Litter} {s : Set🔗<|PREMISE|>🔗 ConNF.Atom} {t : Set🔗<|PREMISE|>🔗 ConNF.Atom} (hs : ConNF.IsNearLitter🔗<|PREMISE|>🔗 L s) (ht : ConNF.IsNearLitter🔗<|PREMISE|>🔗 L t) :ConNF.IsNear🔗<|PREMISE|>🔗 s t", "code": "theorem IsNearLitter.near (hs : IsNearLitter L s) (ht : IsNearLitter L t) : IsNear s t :=\n  hs.symm.trans ht\n", "additional_info": "If two sets are `L`-near-litters, they are near each other.\nThis is because they are both near litter `L`, and nearness is transitive.", "used_premises": [1, 69, 69, 466, 466, 455], "def_path": "ConNF/BaseType/NearLitter.lean", "pos": [47, 49], "informalization": "The theorem `ConNF.IsNearLitter.near` states that if two sets `s` and `t` are both \"near\" a litter `L` in the context of Constructive Ordinal Notation (ConNF), then `s` and `t` are also \"near\" each other. This is a consequence of the transitivity of the \"nearness\" relation."}
{"full_name": "ConNF.IsNearLitter.mk_eq_κ", "url": "ConNF/BaseType/NearLitter.html#ConNF.IsNearLitter.mk_eq_κ", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.IsNearLitter.mk_eq_κ [ConNF.Params🔗<|PREMISE|>🔗 ] {L : ConNF.Litter} {s : Set🔗<|PREMISE|>🔗 ConNF.Atom} (hs : ConNF.IsNearLitter🔗<|PREMISE|>🔗 L s) :Cardinal.mk🔗<|PREMISE|>🔗 ↑s = Cardinal.mk🔗<|PREMISE|>🔗 ConNF.κ", "code": "theorem IsNearLitter.mk_eq_κ (hs : IsNearLitter L s) : #s = #κ :=\n  ((le_mk_diff_add_mk _ _).trans <|\n        add_le_of_le Params.κ_isRegular.aleph0_le (hs.mono <| subset_union_right _ _).lt.le\n          (mk_litterSet _).le).eq_of_not_lt\n    fun h =>\n    ((mk_litterSet _).symm.trans_le <| le_mk_diff_add_mk _ _).not_lt <|\n      add_lt_of_lt Params.κ_isRegular.aleph0_le (hs.mono <| subset_union_left _ _) h\n", "additional_info": "", "used_premises": [1, 69, 466, 29, 29], "def_path": "ConNF/BaseType/NearLitter.lean", "pos": [50, 57], "informalization": "The theorem `ConNF.IsNearLitter.mk_eq_κ` states that if a set `s` of type `ConNF.Atom` is near a litter `L` in the context of Constructive Ordinal Notation (ConNF), then the cardinality of `s` is equal to the cardinality of `ConNF.κ`."}
{"full_name": "ConNF.IsNearLitter.nonempty", "url": "ConNF/BaseType/NearLitter.html#ConNF.IsNearLitter.nonempty", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.IsNearLitter.nonempty [ConNF.Params🔗<|PREMISE|>🔗 ] {L : ConNF.Litter} {s : Set🔗<|PREMISE|>🔗 ConNF.Atom} (hs : ConNF.IsNearLitter🔗<|PREMISE|>🔗 L s) :Set.Nonempty🔗<|PREMISE|>🔗 s", "code": "protected theorem IsNearLitter.nonempty (hs : IsNearLitter L s) : s.Nonempty := by\n  rw [← nonempty_coe_sort, ← mk_ne_zero_iff, hs.mk_eq_κ]\n  exact Params.κ_isRegular.pos.ne'\n", "additional_info": "", "used_premises": [1, 69, 466, 83], "def_path": "ConNF/BaseType/NearLitter.lean", "pos": [58, 61], "informalization": "Given a litter `L` and a set `s` of atoms, if `s` is near `L`, then `s` is nonempty."}
{"full_name": "ConNF.isNearLitter_litterSet_iff", "url": "ConNF/BaseType/NearLitter.html#ConNF.isNearLitter_litterSet_iff", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.isNearLitter_litterSet_iff [ConNF.Params🔗<|PREMISE|>🔗 ] {L₁ : ConNF.Litter} {L₂ : ConNF.Litter} :ConNF.IsNearLitter🔗<|PREMISE|>🔗 L₁ (ConNF.litterSet🔗<|PREMISE|>🔗 L₂) ↔ L₁ = L₂", "code": "theorem isNearLitter_litterSet_iff : IsNearLitter L₁ (litterSet L₂) ↔ L₁ = L₂ := by\n  refine ⟨fun h => ?_, ?_⟩\n  · by_contra this\n    refine ((mk_litterSet L₁).symm.trans_le <| mk_le_mk_of_subset ?_).not_lt h\n    change litterSet L₁ ≤ _\n    exact (le_symmDiff_iff_left _ _).2 (pairwise_disjoint_litterSet this)\n  · rintro rfl\n    exact isNearLitter_litterSet _\n", "additional_info": "A litter set is only a near-litter to itself.", "used_premises": [1, 466, 467], "def_path": "ConNF/BaseType/NearLitter.lean", "pos": [64, 72], "informalization": "A litter set is only a near-litter to itself."}
{"full_name": "ConNF.IsNearLitter.unique", "url": "ConNF/BaseType/NearLitter.html#ConNF.IsNearLitter.unique", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.IsNearLitter.unique [ConNF.Params🔗<|PREMISE|>🔗 ] {L₁ : ConNF.Litter} {L₂ : ConNF.Litter} {s : Set🔗<|PREMISE|>🔗 ConNF.Atom} (h₁ : ConNF.IsNearLitter🔗<|PREMISE|>🔗 L₁ s) (h₂ : ConNF.IsNearLitter🔗<|PREMISE|>🔗 L₂ s) :L₁ = L₂", "code": "theorem IsNearLitter.unique {s : Set Atom} (h₁ : IsNearLitter L₁ s) (h₂ : IsNearLitter L₂ s) :\n    L₁ = L₂ :=\n  isNearLitter_litterSet_iff.1 <| h₁.trans h₂.symm\n", "additional_info": "A set is near at most one litter.", "used_premises": [1, 69, 466, 466], "def_path": "ConNF/BaseType/NearLitter.lean", "pos": [74, 77], "informalization": "In the context of Constructive Ordinal Notation (ConNF), a set is near at most one litter."}
{"full_name": "ConNF.mk_nearLitter'", "url": "ConNF/BaseType/NearLitter.html#ConNF.mk_nearLitter'", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.mk_nearLitter' [ConNF.Params🔗<|PREMISE|>🔗 ] (L : ConNF.Litter) :Cardinal.mk🔗<|PREMISE|>🔗 { s : Set🔗<|PREMISE|>🔗 ConNF.Atom // ConNF.IsNearLitter🔗<|PREMISE|>🔗 L s } = Cardinal.mk🔗<|PREMISE|>🔗 ConNF.μ", "code": "theorem mk_nearLitter' (L : Litter) : #{ s // IsNearLitter L s } = #μ := by\n  refine (le_antisymm ?_ ?_).trans mk_atom\n  · have := mk_subset_mk_lt_cof (Params.μ_isStrongLimit.2)\n    refine le_of_le_of_eq ?_ (mk_subset_mk_lt_cof ?_)\n    · rw [mk_atom]\n      exact (Cardinal.mk_congr <|\n          subtypeEquiv\n            ((symmDiff_right_involutive <| litterSet L).toPerm _)\n            fun s => Iff.rfl).trans_le\n        ⟨Subtype.impEmbedding _ _ fun s => Params.κ_le_μ_ord_cof.trans_lt'⟩\n    · simp_rw [mk_atom]\n      exact Params.μ_isStrongLimit.2\n  . refine ⟨⟨fun a => ⟨litterSet L ∆ {a}, ?_⟩, fun a b h => ?_⟩⟩\n    · rw [IsNearLitter, IsNear, Small, symmDiff_symmDiff_cancel_left, mk_singleton]\n      exact one_lt_aleph0.trans_le Params.κ_isRegular.aleph0_le\n    · exact singleton_injective (symmDiff_right_injective _ <| by convert congr_arg Subtype.val h)\n", "additional_info": "There are `μ` near-litters to litter `L`.", "used_premises": [1, 29, 69, 466, 29], "def_path": "ConNF/BaseType/NearLitter.lean", "pos": [80, 96], "informalization": "The theorem `ConNF.mk_nearLitter'` states that the number of near-litters to a given litter `L` in the context of Constructive Ordinal Notation (ConNF) is equal to the cardinality of the type `μ`."}
{"full_name": "ConNF.NearLitter.ext", "url": "ConNF/BaseType/NearLitter.html#ConNF.NearLitter.ext", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitter.ext [ConNF.Params🔗<|PREMISE|>🔗 ] {N₁ : ConNF.NearLitter} {N₂ : ConNF.NearLitter} (h₂ : ↑N₁ = ↑N₂) :N₁ = N₂", "code": "theorem ext (h₂ : (N₁ : Set Atom) = N₂) : N₁ = N₂ :=\n  SetLike.coe_injective h₂\n", "additional_info": "", "used_premises": [1], "def_path": "ConNF/BaseType/NearLitter.lean", "pos": [118, 120], "informalization": "The theorem `ConNF.NearLitter.ext` in Lean 4 is an extensionality theorem for the `ConNF.NearLitter` structure. It states that two `ConNF.NearLitter` objects are equal if their underlying sets are equal."}
{"full_name": "ConNF.NearLitter.nonempty", "url": "ConNF/BaseType/NearLitter.html#ConNF.NearLitter.nonempty", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitter.nonempty [ConNF.Params🔗<|PREMISE|>🔗 ] (N : ConNF.NearLitter) :Nonempty🔗<|PREMISE|>🔗 ↥N", "code": "theorem nonempty (N : NearLitter) : Nonempty N := by\n  obtain ⟨a, ha⟩ := IsNearLitter.nonempty N.2.2\n  exact ⟨a, ha⟩\n", "additional_info": "", "used_premises": [1, 212], "def_path": "ConNF/BaseType/NearLitter.lean", "pos": [121, 124], "informalization": "The theorem `ConNF.NearLitter.nonempty` asserts that every `NearLitter` in the context of Constructive Ordinal Notation (ConNF) is nonempty, meaning it contains at least one element."}
{"full_name": "ConNF.NearLitter.toProd_fst", "url": "ConNF/BaseType/NearLitter.html#ConNF.NearLitter.toProd_fst", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.NearLitter.toProd_fst [ConNF.Params🔗<|PREMISE|>🔗 ] (N : ConNF.NearLitter) :(ConNF.NearLitter.toProd🔗<|PREMISE|>🔗 N).1 = N.fst", "code": "@[simps]\n", "additional_info": "", "used_premises": [1, 478], "def_path": "ConNF/BaseType/NearLitter.lean", "pos": [126, 127], "informalization": "The function `ConNF.NearLitter.toProd` reinterprets a near-litter as a product of a litter and a set of atoms. The first component of this product is equal to the first component of the near-litter."}
{"full_name": "ConNF.NearLitter.toProd", "url": "ConNF/BaseType/NearLitter.html#ConNF.NearLitter.toProd", "code_src": "con-nf", "ptype": "def", "header": "def ConNF.NearLitter.toProd [ConNF.Params🔗<|PREMISE|>🔗 ] (N : ConNF.NearLitter) :ConNF.Litter × Set🔗<|PREMISE|>🔗 ConNF.Atom", "code": "def toProd (N : NearLitter) : Litter × Set Atom :=\n  (N.1, N.2)\n", "additional_info": "Reinterpret a near-litter as a product of a litter and a set of atoms.\nEquations\n* 🗟ConNF.NearLitter.toProd🗟🔗../.././ConNF/BaseType/NearLitter.html#ConNF.NearLitter.toProd🔗  N 🗟=🗟🔗../.././Init/Prelude.html#Eq🔗  (N.fst, ↑N.snd)\n\n", "used_premises": [1, 69], "def_path": "ConNF/BaseType/NearLitter.lean", "pos": [127, 129], "informalization": "Function `ConNF.NearLitter.toProd` reinterprets a near-litter as a product of a litter and a set of atoms."}
{"full_name": "ConNF.NearLitter.toProd_snd", "url": "ConNF/BaseType/NearLitter.html#ConNF.NearLitter.toProd_snd", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.NearLitter.toProd_snd [ConNF.Params🔗<|PREMISE|>🔗 ] (N : ConNF.NearLitter) :(ConNF.NearLitter.toProd🔗<|PREMISE|>🔗 N).2 = ↑N.snd", "code": "@[simps]\n", "additional_info": "", "used_premises": [1, 478], "def_path": "ConNF/BaseType/NearLitter.lean", "pos": [126, 127], "informalization": "Function `ConNF.NearLitter.toProd` reinterprets a near-litter as a product of a litter and a set of atoms. The second component of this product is equal to the set of atoms in the near-litter."}
{"full_name": "ConNF.NearLitter.toProd_injective", "url": "ConNF/BaseType/NearLitter.html#ConNF.NearLitter.toProd_injective", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitter.toProd_injective [ConNF.Params🔗<|PREMISE|>🔗 ] :Function.Injective🔗<|PREMISE|>🔗 ConNF.NearLitter.toProd", "code": "theorem toProd_injective : Injective toProd := by\n  rintro ⟨L₁, s⟩ ⟨L₂, t⟩ h\n  rw [Prod.ext_iff] at h\n  exact ext h.2\n", "additional_info": "", "used_premises": [1, 89], "def_path": "ConNF/BaseType/NearLitter.lean", "pos": [130, 134], "informalization": "Function `ConNF.NearLitter.toProd` is injective."}
{"full_name": "ConNF.NearLitter.isNearLitter", "url": "ConNF/BaseType/NearLitter.html#ConNF.NearLitter.isNearLitter", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.NearLitter.isNearLitter [ConNF.Params🔗<|PREMISE|>🔗 ] (N : ConNF.NearLitter) (L : ConNF.Litter) :ConNF.IsNearLitter🔗<|PREMISE|>🔗 L ↑N ↔ N.fst = L", "code": "protected theorem isNearLitter (N : NearLitter) (L : Litter) : IsNearLitter L N ↔ N.fst = L :=\n  ⟨IsNearLitter.unique N.snd.prop, by rintro rfl; exact N.2.2⟩\n", "additional_info": "A near-litter `N` is near a given litter `L` if and only if `N` has first projection `L`.", "used_premises": [1, 466], "def_path": "ConNF/BaseType/NearLitter.lean", "pos": [137, 139], "informalization": "A near-litter `N` is near a given litter `L` if and only if `N` has first projection `L`."}
{"full_name": "ConNF.Litter.toNearLitter_fst", "url": "ConNF/BaseType/NearLitter.html#ConNF.Litter.toNearLitter_fst", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.Litter.toNearLitter_fst [ConNF.Params🔗<|PREMISE|>🔗 ] (L : ConNF.Litter) :(ConNF.Litter.toNearLitter🔗<|PREMISE|>🔗 L).fst = L", "code": "theorem toNearLitter_fst (L : Litter) : L.toNearLitter.fst = L :=\n  rfl\n", "additional_info": "", "used_premises": [1, 483], "def_path": "ConNF/BaseType/NearLitter.lean", "pos": [161, 163], "informalization": "The function `ConNF.Litter.toNearLitter` converts a litter in the context of Constructive Ordinal Notation (ConNF) to its corresponding near-litter. A near-litter is defined as a pair consisting of a litter and a subset of that litter, satisfying certain properties. The function `ConNF.Litter.toNearLitter` simply wraps a litter with its litter set to form a near-litter. The theorem `ConNF.Litter.toNearLitter_fst` states that the first component of the resulting near-litter is equal to the original litter."}
{"full_name": "ConNF.Litter.toNearLitter", "url": "ConNF/BaseType/NearLitter.html#ConNF.Litter.toNearLitter", "code_src": "con-nf", "ptype": "def", "header": "def ConNF.Litter.toNearLitter [ConNF.Params🔗<|PREMISE|>🔗 ] (L : ConNF.Litter) :ConNF.NearLitter", "code": "def toNearLitter (L : Litter) : NearLitter :=\n  ⟨L, litterSet L, isNearLitter_litterSet L⟩\n", "additional_info": "Convert a litter to its associated near-litter.\nEquations\n* 🗟ConNF.Litter.toNearLitter🗟🔗../.././ConNF/BaseType/NearLitter.html#ConNF.Litter.toNearLitter🔗  L 🗟=🗟🔗../.././Init/Prelude.html#Eq🔗  { fst := L, snd := { val := 🗟ConNF.litterSet🗟🔗../.././ConNF/BaseType/Atom.html#ConNF.litterSet🔗  L, property := ⋯ } }\n\n", "used_premises": [1], "def_path": "ConNF/BaseType/NearLitter.lean", "pos": [154, 156], "informalization": "Function `ConNF.Litter.toNearLitter` converts a litter in the context of Constructive Ordinal Notation (ConNF) to its corresponding near-litter. A near-litter is defined as a pair consisting of a litter and a subset of that litter, satisfying certain properties. The function `ConNF.Litter.toNearLitter` simply wraps a litter with its litter set to form a near-litter."}
{"full_name": "ConNF.Litter.coe_toNearLitter", "url": "ConNF/BaseType/NearLitter.html#ConNF.Litter.coe_toNearLitter", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.Litter.coe_toNearLitter [ConNF.Params🔗<|PREMISE|>🔗 ] (L : ConNF.Litter) :↑(ConNF.Litter.toNearLitter🔗<|PREMISE|>🔗 L) = ConNF.litterSet🔗<|PREMISE|>🔗 L", "code": "theorem coe_toNearLitter (L : Litter) : (L.toNearLitter : Set Atom) = litterSet L :=\n  rfl\n", "additional_info": "", "used_premises": [1, 483, 467], "def_path": "ConNF/BaseType/NearLitter.lean", "pos": [165, 167], "informalization": "The theorem `ConNF.Litter.coe_toNearLitter` states that the set corresponding to a given litter `L` in the context of Constructive Ordinal Notation (ConNF) is equal to the set of all atoms `a` such that the first projection of `a` is equal to `L`."}
{"full_name": "ConNF.Litter.toNearLitter_injective", "url": "ConNF/BaseType/NearLitter.html#ConNF.Litter.toNearLitter_injective", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.Litter.toNearLitter_injective [ConNF.Params🔗<|PREMISE|>🔗 ] :Function.Injective🔗<|PREMISE|>🔗 ConNF.Litter.toNearLitter", "code": "theorem toNearLitter_injective : Injective Litter.toNearLitter :=\n  fun i j hij => by cases hij; rfl\n", "additional_info": "", "used_premises": [1, 89], "def_path": "ConNF/BaseType/NearLitter.lean", "pos": [168, 170], "informalization": "The theorem `ConNF.Litter.toNearLitter_injective` states that the function `ConNF.Litter.toNearLitter` from `ConNF.Litter` to `ConNF.NearLitter` is injective. This means that if two `ConNF.Litter`s map to the same `ConNF.NearLitter`, then they must be the same `ConNF.Litter`."}
{"full_name": "ConNF.mk_nearLitter", "url": "ConNF/BaseType/NearLitter.html#ConNF.mk_nearLitter", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.mk_nearLitter [ConNF.Params🔗<|PREMISE|>🔗 ] :Cardinal.mk🔗<|PREMISE|>🔗 ConNF.NearLitter = Cardinal.mk🔗<|PREMISE|>🔗 ConNF.μ", "code": "theorem mk_nearLitter : #NearLitter = #μ := by\n  simp_rw [NearLitter, mk_sigma, mk_nearLitter', sum_const]\n  simp only [NearLitter, mk_sigma, mk_nearLitter', sum_const, mk_litter, lift_id]\n  exact mul_eq_left\n    (Params.κ_isRegular.aleph0_le.trans Params.κ_lt_μ.le)\n    le_rfl\n    Params.μ_isStrongLimit.ne_zero\n", "additional_info": "There are `μ` near-litters in total.", "used_premises": [1, 29, 29], "def_path": "ConNF/BaseType/NearLitter.lean", "pos": [175, 182], "informalization": "In the context of Constructive Ordinal Notation (ConNF), the number of near-litters is equal to the cardinality of the type `μ`."}
{"full_name": "ConNF.mem_localCardinal", "url": "ConNF/BaseType/NearLitter.html#ConNF.mem_localCardinal", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.mem_localCardinal [ConNF.Params🔗<|PREMISE|>🔗 ] {L : ConNF.Litter} {N : ConNF.NearLitter} :N ∈ ConNF.localCardinal🔗<|PREMISE|>🔗 L ↔ N.fst = L", "code": "theorem mem_localCardinal {L : Litter} {N : NearLitter} : N ∈ localCardinal L ↔ N.1 = L :=\n  Iff.rfl\n", "additional_info": "", "used_premises": [1, 81], "def_path": "ConNF/BaseType/NearLitter.lean", "pos": [188, 190], "informalization": "The theorem `ConNF.mem_localCardinal` states that a near-litter `N` belongs to the local cardinal of a litter `L` if and only if the first component of `N` is equal to `L`."}
{"full_name": "ConNF.localCardinal_nonempty", "url": "ConNF/BaseType/NearLitter.html#ConNF.localCardinal_nonempty", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.localCardinal_nonempty [ConNF.Params🔗<|PREMISE|>🔗 ] (L : ConNF.Litter) :Set.Nonempty🔗<|PREMISE|>🔗 (ConNF.localCardinal🔗<|PREMISE|>🔗 L)", "code": "theorem localCardinal_nonempty (L : Litter) : (localCardinal L).Nonempty :=\n  ⟨⟨L, litterSet _, isNearLitter_litterSet _⟩, rfl⟩\n", "additional_info": "", "used_premises": [1, 83, 81], "def_path": "ConNF/BaseType/NearLitter.lean", "pos": [191, 193], "informalization": "The theorem `ConNF.localCardinal_nonempty` states that for any litter `L` in the context of Constructive Ordinal Notation (ConNF), the local cardinal of `L` is non-empty. This means that there exists at least one near-litter `N` such that the first component of `N` is equal to `L`."}
{"full_name": "ConNF.localCardinal_disjoint", "url": "ConNF/BaseType/NearLitter.html#ConNF.localCardinal_disjoint", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.localCardinal_disjoint [ConNF.Params🔗<|PREMISE|>🔗 ] :Pairwise🔗<|PREMISE|>🔗 (Disjoint on ConNF.localCardinal)", "code": "theorem localCardinal_disjoint : Pairwise (Disjoint on localCardinal) :=\n  fun _ _ h => disjoint_left.2 fun _ h₁ h₂ => h <| h₁.symm.trans h₂\n", "additional_info": "", "used_premises": [1, 490], "def_path": "ConNF/BaseType/NearLitter.lean", "pos": [194, 196], "informalization": "The theorem `ConNF.localCardinal_disjoint` states that the local cardinals defined in the context of Constructive Ordinal Notation (ConNF) are pairwise disjoint. This means that for any two distinct local cardinals, their intersection is empty."}
{"full_name": "Pairwise", "url": "Mathlib/Logic/Pairwise.html#Pairwise", "code_src": "mathlib4", "ptype": "def", "header": "def Pairwise {α : Type u_1} (r : α → α → Prop ) :Prop", "code": "def Pairwise (r : α → α → Prop) :=\n  ∀ ⦃i j⦄, i ≠ j → r i j\n", "additional_info": "A relation `r` holds pairwise if `r i j` for all `i ≠ j`.\nEquations\n* 🗟Pairwise🗟🔗../.././Mathlib/Logic/Pairwise.html#Pairwise🔗  r 🗟=🗟🔗../.././Init/Prelude.html#Eq🔗  ∀ ⦃i j : α⦄, i 🗟≠🗟🔗../.././Init/Core.html#Ne🔗  j → r i j\n\n", "used_premises": [], "def_path": "Mathlib/Logic/Pairwise.lean", "pos": [32, 34], "informalization": "Function `Pairwise` is a predicate that checks if a given binary relation `r` holds for all distinct pairs of elements in a type `α`."}
{"full_name": "ConNF.localCardinal_injective", "url": "ConNF/BaseType/NearLitter.html#ConNF.localCardinal_injective", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.localCardinal_injective [ConNF.Params🔗<|PREMISE|>🔗 ] :Function.Injective🔗<|PREMISE|>🔗 ConNF.localCardinal", "code": "theorem localCardinal_injective : Injective localCardinal := by\n  intro L₁ L₂ h₁₂\n  by_contra h\n  have := (localCardinal_disjoint h).inter_eq\n  rw [h₁₂, inter_self] at this\n  exact (localCardinal_nonempty _).ne_empty this\n", "additional_info": "", "used_premises": [1, 89], "def_path": "ConNF/BaseType/NearLitter.lean", "pos": [197, 203], "informalization": "In the context of Constructive Ordinal Notation (ConNF), the theorem `ConNF.localCardinal_injective` states that the function `ConNF.localCardinal` is injective. This means that if `ConNF.localCardinal x = ConNF.localCardinal y`, then `x = y`."}
{"full_name": "ConNF.Litter.toNearLitter_mem_localCardinal", "url": "ConNF/BaseType/NearLitter.html#ConNF.Litter.toNearLitter_mem_localCardinal", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.Litter.toNearLitter_mem_localCardinal [ConNF.Params🔗<|PREMISE|>🔗 ] (L : ConNF.Litter) :ConNF.Litter.toNearLitter🔗<|PREMISE|>🔗 L ∈ ConNF.localCardinal🔗<|PREMISE|>🔗 L", "code": "theorem Litter.toNearLitter_mem_localCardinal (L : Litter) : L.toNearLitter ∈ localCardinal L :=\n  rfl\n", "additional_info": "", "used_premises": [1, 483, 81], "def_path": "ConNF/BaseType/NearLitter.lean", "pos": [204, 206], "informalization": "The theorem `ConNF.Litter.toNearLitter_mem_localCardinal` states that for any litter `L` in the context of Constructive Ordinal Notation (ConNF), the near-litter formed by wrapping `L` with its litter set is an element of the local cardinal of `L`. The local cardinal of a litter `L` is defined as the set of all near-litters `N` such that the first component of `N` is equal to `L`."}
{"full_name": "ConNF.mk_localCardinal", "url": "ConNF/BaseType/NearLitter.html#ConNF.mk_localCardinal", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.mk_localCardinal [ConNF.Params🔗<|PREMISE|>🔗 ] (L : ConNF.Litter) :Cardinal.mk🔗<|PREMISE|>🔗 ↑(ConNF.localCardinal🔗<|PREMISE|>🔗 L) = Cardinal.mk🔗<|PREMISE|>🔗 ConNF.μ", "code": "theorem mk_localCardinal (L : Litter) : #(localCardinal L) = #μ := by\n  refine Eq.trans (Cardinal.eq.2 ⟨⟨?_, fun x => ⟨⟨L, x⟩, rfl⟩, ?_, ?_⟩⟩) (mk_nearLitter' L)\n  · rintro ⟨x, rfl : x.1 = L⟩\n    exact x.snd\n  · rintro ⟨⟨j, S⟩, rfl : j = L⟩\n    rfl\n  · exact fun x => rfl\n", "additional_info": "", "used_premises": [1, 29, 81, 29], "def_path": "ConNF/BaseType/NearLitter.lean", "pos": [208, 215], "informalization": "The theorem `ConNF.mk_localCardinal` states that the cardinality of the local cardinal of a given litter `L` in the context of Constructive Ordinal Notation (ConNF) is equal to the cardinality of the type `ConNF.μ`."}
{"full_name": "ConNF.NearLitter.IsLitter.eq_fst_toNearLitter", "url": "ConNF/BaseType/NearLitter.html#ConNF.NearLitter.IsLitter.eq_fst_toNearLitter", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitter.IsLitter.eq_fst_toNearLitter [ConNF.Params🔗<|PREMISE|>🔗 ] {N : ConNF.NearLitter} (h : ConNF.NearLitter.IsLitter🔗<|PREMISE|>🔗 N) :N = ConNF.Litter.toNearLitter🔗<|PREMISE|>🔗 N.fst", "code": "theorem NearLitter.IsLitter.eq_fst_toNearLitter {N : NearLitter} (h : N.IsLitter) :\n    N = N.fst.toNearLitter :=\n  by cases h; rfl\n", "additional_info": "", "used_premises": [1, 495, 483], "def_path": "ConNF/BaseType/NearLitter.lean", "pos": [220, 223], "informalization": "The theorem `ConNF.NearLitter.IsLitter.eq_fst_toNearLitter` states that if a near-litter `N` is of the form `L.toNearLitter` for some litter `L`, then `N` is equal to `ConNF.Litter.toNearLitter L`, where `L` is the first component of `N`."}
{"full_name": "ConNF.NearLitter.IsLitter", "url": "ConNF/BaseType/NearLitter.html#ConNF.NearLitter.IsLitter", "code_src": "con-nf", "ptype": "inductive", "header": "inductive ConNF.NearLitter.IsLitter [ConNF.Params🔗<|PREMISE|>🔗 ] :ConNF.NearLitter → Prop", "code": "inductive NearLitter.IsLitter : NearLitter → Prop\n  | mk (L : Litter) : IsLitter L.toNearLitter\n", "additional_info": "This near-litter is of the form `L.🗟toNearLitter🗟🔗../.././ConNF/BaseType/NearLitter.html#ConNF.Litter.toNearLitter🔗` .\n", "used_premises": [1], "def_path": "ConNF/BaseType/NearLitter.lean", "pos": [217, 219], "informalization": "Type `ConNF.NearLitter.IsLitter` represents the property that a near-litter is of the form `L.toNearLitter` for some litter `L`."}
{"full_name": "ConNF.NearLitter.IsLitter.litterSet_eq", "url": "ConNF/BaseType/NearLitter.html#ConNF.NearLitter.IsLitter.litterSet_eq", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitter.IsLitter.litterSet_eq [ConNF.Params🔗<|PREMISE|>🔗 ] {N : ConNF.NearLitter} (h : ConNF.NearLitter.IsLitter🔗<|PREMISE|>🔗 N) :ConNF.litterSet🔗<|PREMISE|>🔗 N.fst = ↑N.snd", "code": "theorem NearLitter.IsLitter.litterSet_eq {N : NearLitter} (h : N.IsLitter) :\n    litterSet N.fst = N.snd :=\n  by cases h; rfl\n", "additional_info": "", "used_premises": [1, 495, 467], "def_path": "ConNF/BaseType/NearLitter.lean", "pos": [224, 227], "informalization": "The theorem `ConNF.NearLitter.IsLitter.litterSet_eq` states that for any near-litter `N` that is also a litter (i.e., `N` is of the form `L.toNearLitter` for some litter `L`), the set of all atoms `a` such that the first projection of `a` is equal to `L` is equal to the near-litter `N` itself."}
{"full_name": "ConNF.NearLitter.IsLitter.exists_litter_eq", "url": "ConNF/BaseType/NearLitter.html#ConNF.NearLitter.IsLitter.exists_litter_eq", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitter.IsLitter.exists_litter_eq [ConNF.Params🔗<|PREMISE|>🔗 ] {N : ConNF.NearLitter} (h : ConNF.NearLitter.IsLitter🔗<|PREMISE|>🔗 N) :∃ (L : ConNF.Litter), N = ConNF.Litter.toNearLitter🔗<|PREMISE|>🔗 L", "code": "theorem NearLitter.IsLitter.exists_litter_eq {N : NearLitter} (h : N.IsLitter) :\n    ∃ L : Litter, N = L.toNearLitter :=\n  by obtain ⟨L⟩ := h; exact ⟨L, rfl⟩\n", "additional_info": "", "used_premises": [1, 495, 483], "def_path": "ConNF/BaseType/NearLitter.lean", "pos": [228, 231], "informalization": "The theorem `ConNF.NearLitter.IsLitter.exists_litter_eq` states that if a near-litter `N` is of the form `L.toNearLitter` for some litter `L`, then there exists a litter `L` such that `N` is equal to `L.toNearLitter`."}
{"full_name": "ConNF.NearLitter.not_isLitter", "url": "ConNF/BaseType/NearLitter.html#ConNF.NearLitter.not_isLitter", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitter.not_isLitter [ConNF.Params🔗<|PREMISE|>🔗 ] {N : ConNF.NearLitter} (h : ¬ ConNF.NearLitter.IsLitter🔗<|PREMISE|>🔗 N) :ConNF.litterSet🔗<|PREMISE|>🔗 N.fst ≠ ↑N.snd", "code": "theorem NearLitter.not_isLitter {N : NearLitter} (h : ¬N.IsLitter) : litterSet N.fst ≠ N.snd := by\n  contrapose! h\n  obtain ⟨L, S, hS⟩ := N\n  simp only [Subtype.coe_mk] at h\n  cases h\n  exact NearLitter.IsLitter.mk _\n", "additional_info": "", "used_premises": [1, 495, 467], "def_path": "ConNF/BaseType/NearLitter.lean", "pos": [232, 238], "informalization": "The theorem `ConNF.NearLitter.not_isLitter` states that if a near-litter `N` is not of the form `L.toNearLitter` for some litter `L`, then the set of atoms `a` such that the first projection of `a` is equal to `N.fst` is not equal to the near-litter `N.snd`."}
{"full_name": "ConNF.NearLitter.not_isLitter'", "url": "ConNF/BaseType/NearLitter.html#ConNF.NearLitter.not_isLitter'", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitter.not_isLitter' [ConNF.Params🔗<|PREMISE|>🔗 ] {N : ConNF.NearLitter} (h : ¬ ConNF.NearLitter.IsLitter🔗<|PREMISE|>🔗 N) :ConNF.Litter.toNearLitter🔗<|PREMISE|>🔗 N.fst ≠ N", "code": "theorem NearLitter.not_isLitter' {N : NearLitter} (h : ¬N.IsLitter) : N.fst.toNearLitter ≠ N := by\n  contrapose! h\n  obtain ⟨L, S, hS⟩ := N\n  simp only [Subtype.coe_mk] at h\n  cases h\n  exact NearLitter.IsLitter.mk _\n", "additional_info": "", "used_premises": [1, 495, 483], "def_path": "ConNF/BaseType/NearLitter.lean", "pos": [239, 245], "informalization": "In the context of Constructive Ordinal Notation (ConNF), the theorem `ConNF.NearLitter.not_isLitter'` states that if a near-litter `N` is not of the form `L.toNearLitter` for some litter `L`, then the near-litter obtained by wrapping the litter part of `N` (i.e., `N.fst.toNearLitter`) is not equal to `N` itself."}
{"full_name": "ConNF.mk_nearLitter''", "url": "ConNF/BaseType/NearLitter.html#ConNF.mk_nearLitter''", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.mk_nearLitter'' [ConNF.Params🔗<|PREMISE|>🔗 ] (N : ConNF.NearLitter) :Cardinal.mk🔗<|PREMISE|>🔗 ↥N = Cardinal.mk🔗<|PREMISE|>🔗 ConNF.κ", "code": "theorem mk_nearLitter'' (N : NearLitter) : #N = #κ := by\n  change #(N : Set Atom) = _\n  rw [← symmDiff_symmDiff_cancel_right (litterSet N.fst) N]\n  refine le_antisymm ?_ ?_\n  · refine (mk_le_mk_of_subset symmDiff_subset_union).trans ?_\n    refine (mk_union_le _ _).trans ?_\n    simp only [mk_litterSet, add_mk_eq_max', max_le_iff, le_refl, and_true_iff]\n    rw [symmDiff_comm]\n    exact le_of_lt N.2.2\n  · refine le_of_not_lt fun h : Small _ => ?_\n    rw [← Small.symmDiff_iff _] at h\n    · simp only [Small, mk_litterSet, lt_self_iff_false] at h\n    · rw [symmDiff_comm]\n      exact N.2.2\n", "additional_info": "The size of each near-litter is `κ`.", "used_premises": [1, 29, 29], "def_path": "ConNF/BaseType/NearLitter.lean", "pos": [248, 262], "informalization": "The size of each near-litter in the context of Constructive Ordinal Notation (ConNF) is equal to the cardinality of the type `κ`."}
{"full_name": "ConNF.symmDiff_union_inter", "url": "ConNF/BaseType/NearLitter.html#ConNF.symmDiff_union_inter", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.symmDiff_union_inter {α : Type u_1} {a : Set🔗<|PREMISE|>🔗 α} {b : Set🔗<|PREMISE|>🔗 α} :symmDiff🔗<|PREMISE|>🔗 a b ∪ a ∩ b = a ∪ b", "code": "theorem symmDiff_union_inter {α : Type _} {a b : Set α} : (a ∆ b) ∪ (a ∩ b) = a ∪ b := by\n  ext x\n  simp only [mem_union, mem_symmDiff, mem_inter_iff]\n  tauto\n", "additional_info": "", "used_premises": [69, 69, 62], "def_path": "ConNF/BaseType/NearLitter.lean", "pos": [263, 267], "informalization": "The theorem `ConNF.symmDiff_union_inter` states that for any two sets `a` and `b`, the symmetric difference of `a` and `b` union the intersection of `a` and `b` is equal to the union of `a` and `b`."}
{"full_name": "ConNF.noMaxOrder_of_ordinal_type_eq", "url": "ConNF/BaseType/Params.html#ConNF.noMaxOrder_of_ordinal_type_eq", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.noMaxOrder_of_ordinal_type_eq {α : Type u} [Preorder🔗<|PREMISE|>🔗 α] [Infinite🔗<|PREMISE|>🔗 α] [IsWellOrder🔗<|PREMISE|>🔗 α fun (x x_1 : α) => x < x_1] (h : Ordinal.IsLimit🔗<|PREMISE|>🔗 (Ordinal.type🔗<|PREMISE|>🔗 fun (x x_1 : α) => x < x_1)) :NoMaxOrder🔗<|PREMISE|>🔗 α", "code": "theorem noMaxOrder_of_ordinal_type_eq {α : Type u} [Preorder α] [Infinite α] [IsWellOrder α (· < ·)]\n    (h : (Ordinal.type ((· < ·) : α → α → Prop)).IsLimit) : NoMaxOrder α := by\n  refine ⟨fun a => ?_⟩\n  have := (Ordinal.succ_lt_of_isLimit h).mpr (Ordinal.typein_lt_type (· < ·) a)\n  obtain ⟨b, hb⟩ := Ordinal.typein_surj (· < ·) this\n  refine ⟨b, ?_⟩\n  have := Order.lt_succ (Ordinal.typein (fun x y => x < y) a)\n  rw [← hb, Ordinal.typein_lt_typein] at this\n  exact this\n", "additional_info": "", "used_premises": [4, 239, 15, 24, 26, 503], "def_path": "ConNF/BaseType/Params.lean", "pos": [90, 99], "informalization": "The theorem `ConNF.noMaxOrder_of_ordinal_type_eq` states that if the ordinal type of a well-ordered infinite set is a limit ordinal, then the set has no maximum order."}
{"full_name": "NoMaxOrder", "url": "Mathlib/Order/Max.html#NoMaxOrder", "code_src": "mathlib4", "ptype": "class", "header": "class NoMaxOrder (α : Type u_3) [LT🔗<|PREMISE|>🔗 α] :Prop\n | exists_gt : ∀ (a : α), ∃ (b : α), a <  b", "code": "class NoMaxOrder (α : Type*) [LT α] : Prop where\n  /-- For each term `a`, there is some strictly greater `b`. -/\n  exists_gt (a : α) : ∃ b, a < b\n", "additional_info": "Order without maximal elements. Sometimes called cofinal.\n- NoMaxOrder.exists_gt: For each term `a`, there is some strictly greater `b`.\n\n\n", "used_premises": [6], "def_path": "Mathlib/Order/Max.lean", "pos": [58, 61], "informalization": "Class `NoMaxOrder` represents a type where each element has another element greater than it. This means there is no maximum element in the type, as for any given element, there is always an element following it. This property is useful in certain mathematical contexts where order plays a significant role."}
{"full_name": "ConNF.typein_add_lt_of_type_eq_ord", "url": "ConNF/BaseType/Params.html#ConNF.typein_add_lt_of_type_eq_ord", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.typein_add_lt_of_type_eq_ord {α : Type u_1} [Infinite🔗<|PREMISE|>🔗 α] [LinearOrder🔗<|PREMISE|>🔗 α] [IsWellOrder🔗<|PREMISE|>🔗 α fun (x x_1 : α) => x < x_1] (h : (Ordinal.type🔗<|PREMISE|>🔗 fun (x x_1 : α) => x < x_1) = Cardinal.ord🔗<|PREMISE|>🔗 (Cardinal.mk🔗<|PREMISE|>🔗 α)) (x : α) (y : α) :Ordinal.typein🔗<|PREMISE|>🔗 (fun (x x_1 : α) => x < x_1) x + Ordinal.typein🔗<|PREMISE|>🔗 (fun (x x_1 : α) => x < x_1) y < Ordinal.type🔗<|PREMISE|>🔗 fun (x x_1 : α) => x < x_1", "code": "theorem typein_add_lt_of_type_eq_ord {α : Type _}\n    [Infinite α] [LinearOrder α] [IsWellOrder α (· < ·)]\n    (h : Ordinal.type ((· < ·) : α → α → Prop) = (#α).ord) (x y : α) :\n    Ordinal.typein (· < ·) x + Ordinal.typein (· < ·) y <\n      Ordinal.type ((· < ·) : α → α → Prop) := by\n  have h₁ := Ordinal.typein_lt_type (· < ·) x\n  have h₂ := Ordinal.typein_lt_type (· < ·) y\n  rw [h, lt_ord] at h₁ h₂ ⊢\n  exact add_lt_of_lt (infinite_iff.mp inferInstance) h₁ h₂\n", "additional_info": "", "used_premises": [239, 2, 15, 26, 27, 29, 36, 36, 26], "def_path": "ConNF/BaseType/Params.lean", "pos": [125, 134], "informalization": "The theorem `ConNF.typein_add_lt_of_type_eq_ord` in Lean 4 allows us to show that the sum of the order types of two elements in an infinite well-ordered type is strictly less than the type of the well-order itself, provided that the type's cardinality equals its own ordinal type. This theorem is crucial for constructing the Conway's nimber type, which is an important part of combinatorial game theory."}
{"full_name": "IsWellFounded.not_lt_bot", "url": "ConNF/BaseType/Params.html#IsWellFounded.not_lt_bot", "code_src": "con-nf", "ptype": "theorem", "header": "theorem IsWellFounded.not_lt_bot (α : Type u_1) [Nonempty🔗<|PREMISE|>🔗 α] (r : α → α → Prop ) [IsWellFounded🔗<|PREMISE|>🔗 α r] (x : α) :¬ r x (IsWellFounded.bot🔗<|PREMISE|>🔗 α r)", "code": "theorem IsWellFounded.not_lt_bot\n    (α : Type _) [Nonempty α] (r : α → α → Prop) [IsWellFounded α r] (x : α) :\n    ¬r x (IsWellFounded.bot α r) :=\n  IsWellFounded.wf.not_lt_min _ _ (Set.mem_univ _)\n", "additional_info": "", "used_premises": [212, 18, 506], "def_path": "ConNF/BaseType/Params.lean", "pos": [145, 149], "informalization": "Function `IsWellFounded.bot` is a noncomputable function that takes a type `α`, a relation `r` on `α`, and a proof that `r` is well-founded, and returns an element of `α`. It does this by finding the minimal element of `α` with respect to `r` using the well-foundedness of `r`. The theorem `IsWellFounded.not_lt_bot` states that for any element `x` of `α`, the relation `r` does not hold between `x` and `IsWellFounded.bot α r`."}
{"full_name": "IsWellFounded.bot", "url": "ConNF/BaseType/Params.html#IsWellFounded.bot", "code_src": "con-nf", "ptype": "noncomputable def", "header": "noncomputable def IsWellFounded.bot (α : Type u_1) [Nonempty🔗<|PREMISE|>🔗 α] (r : α → α → Prop ) [i : IsWellFounded🔗<|PREMISE|>🔗 α r] :α", "code": "noncomputable def IsWellFounded.bot\n    (α : Type _) [Nonempty α] (r : α → α → Prop) [i : IsWellFounded α r] : α :=\n  i.wf.min Set.univ Set.univ_nonempty\n", "additional_info": "Equations\n* 🗟IsWellFounded.bot🗟🔗../.././ConNF/BaseType/Params.html#IsWellFounded.bot🔗  α r 🗟=🗟🔗../.././Init/Prelude.html#Eq🔗  🗟WellFounded.min🗟🔗../.././Mathlib/Order/WellFounded.html#WellFounded.min🔗  ⋯ Set.univ ⋯\n\n", "used_premises": [212, 18], "def_path": "ConNF/BaseType/Params.lean", "pos": [141, 144], "informalization": "Function `IsWellFounded.bot` is a noncomputable function that takes a type `α`, a relation `r` on `α`, and a proof that `r` is well-founded, and returns an element of `α`. It does this by finding the minimal element of `α` with respect to `r` using the well-foundedness of `r`."}
{"full_name": "Ordinal.typein_eq_zero_iff", "url": "ConNF/BaseType/Params.html#Ordinal.typein_eq_zero_iff", "code_src": "con-nf", "ptype": "theorem", "header": "theorem Ordinal.typein_eq_zero_iff {α : Type u_1} {r : α → α → Prop } [Nonempty🔗<|PREMISE|>🔗 α] [IsWellOrder🔗<|PREMISE|>🔗 α r] {x : α} :Ordinal.typein🔗<|PREMISE|>🔗 r x = 0 ↔ ∀ (y : α), y ≠ x → r x y", "code": "theorem Ordinal.typein_eq_zero_iff\n    {α : Type _} {r : α → α → Prop} [Nonempty α] [IsWellOrder α r] {x : α} :\n    Ordinal.typein r x = 0 ↔ ∀ y ≠ x, r x y := by\n  constructor\n  · intro h y\n    rw [← Ordinal.typein_lt_typein r, h, Ordinal.pos_iff_ne_zero, ← h]\n    exact (Ordinal.typein_injective r).ne\n  · intro h\n    have : 0 < Ordinal.type r\n    · rw [Ordinal.pos_iff_ne_zero, ne_eq, Ordinal.type_eq_zero_iff_isEmpty]\n      exact not_isEmpty_of_nonempty α\n    obtain ⟨y, hy⟩ := Ordinal.typein_surj r this\n    have : y = x\n    · by_contra hyx\n      have := (Ordinal.typein_lt_typein r).mpr (h y hyx)\n      rw [hy, lt_iff_not_ge] at this\n      exact this (Ordinal.zero_le _)\n    subst this\n    exact hy\n", "additional_info": "", "used_premises": [212, 15, 36], "def_path": "ConNF/BaseType/Params.lean", "pos": [150, 169], "informalization": "Function `Ordinal.typein` computes the order type of an element `x` within a well-ordered type `α`, using the relation `r` to determine the order. The theorem `Ordinal.typein_eq_zero_iff` states that `Ordinal.typein r x = 0` if and only if `x` is the smallest element of `α` with respect to `r`."}
{"full_name": "Ordinal.typein_bot", "url": "ConNF/BaseType/Params.html#Ordinal.typein_bot", "code_src": "con-nf", "ptype": "theorem", "header": "theorem Ordinal.typein_bot {α : Type u_1} [Nonempty🔗<|PREMISE|>🔗 α] [LinearOrder🔗<|PREMISE|>🔗 α] [IsWellOrder🔗<|PREMISE|>🔗 α fun (x x_1 : α) => x < x_1] :Ordinal.typein🔗<|PREMISE|>🔗 (fun (x x_1 : α) => x < x_1) (IsWellFounded.bot🔗<|PREMISE|>🔗 α fun (x x_1 : α) => x < x_1) = 0", "code": "theorem Ordinal.typein_bot\n    {α : Type _} [Nonempty α] [LinearOrder α] [IsWellOrder α (· < ·)] :\n    Ordinal.typein (· < ·) (IsWellFounded.bot α (· < ·)) = 0 := by\n  rw [Ordinal.typein_eq_zero_iff]\n  intro x hx\n  rw [← lt_or_lt_iff_ne] at hx\n  cases hx with\n  | inl hx => cases IsWellFounded.not_lt_bot α (· < ·) x hx\n  | inr hx => exact hx\n", "additional_info": "", "used_premises": [212, 2, 15, 36, 506], "def_path": "ConNF/BaseType/Params.lean", "pos": [170, 179], "informalization": "The theorem `Ordinal.typein_bot` states that the order type of the smallest element in a well-ordered set is 0."}
{"full_name": "ConNF.aleph0_le_mk_Λ", "url": "ConNF/BaseType/Params.html#ConNF.aleph0_le_mk_Λ", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.aleph0_le_mk_Λ [ConNF.Params🔗<|PREMISE|>🔗 ] :Cardinal.aleph0🔗<|PREMISE|>🔗 ≤ Cardinal.mk🔗<|PREMISE|>🔗 ConNF.Λ", "code": "theorem aleph0_le_mk_Λ : ℵ₀ ≤ #Λ := by\n  have := Ordinal.card_le_card (Ordinal.omega_le_of_isLimit Params.Λ_isLimit)\n  simp only [Ordinal.card_omega, Ordinal.card_type] at this\n  exact this\n", "additional_info": "", "used_premises": [1, 510, 29], "def_path": "ConNF/BaseType/Params.lean", "pos": [253, 257], "informalization": "In the context of Constructive Ordinal Notation (ConNF), the theorem `ConNF.aleph0_le_mk_Λ` states that the smallest infinite cardinal number, denoted as `ℵ₀`, is less than or equal to the cardinality of the type `ConNF.Λ`."}
{"full_name": "Cardinal.aleph0", "url": "Mathlib/SetTheory/Cardinal/Basic.html#Cardinal.aleph0", "code_src": "mathlib4", "ptype": "def", "header": "def Cardinal.aleph0 :Cardinal🔗<|PREMISE|>🔗", "code": "def aleph0 : Cardinal.{u} :=\n  lift #ℕ\n", "additional_info": "`ℵ₀` is the smallest infinite cardinal.\nEquations\n* 🗟Cardinal.aleph0🗟🔗../../.././Mathlib/SetTheory/Cardinal/Basic.html#Cardinal.aleph0🔗  🗟=🗟🔗../../.././Init/Prelude.html#Eq🔗  🗟Cardinal.lift.{u, 0}🗟🔗../../.././Mathlib/SetTheory/Cardinal/Basic.html#Cardinal.lift🔗  (🗟Cardinal.mk🗟🔗../../.././Mathlib/SetTheory/Cardinal/Basic.html#Cardinal.mk🔗  🗟ℕ🗟🔗../../.././Init/Prelude.html#Nat🔗 )\n\n", "used_premises": [28], "def_path": "Mathlib/SetTheory/Cardinal/Basic.lean", "pos": [1263, 1265], "informalization": "Function `Cardinal.aleph0` represents the smallest infinite cardinal number, denoted as `ℵ₀`, which is the cardinality of the set of natural numbers. It is defined as the lift of the cardinality of the natural numbers to any universe level `u`."}
{"full_name": "ConNF.mk_Λ_ne_zero", "url": "ConNF/BaseType/Params.html#ConNF.mk_Λ_ne_zero", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.mk_Λ_ne_zero [ConNF.Params🔗<|PREMISE|>🔗 ] :Cardinal.mk🔗<|PREMISE|>🔗 ConNF.Λ ≠ 0", "code": "theorem mk_Λ_ne_zero : #Λ ≠ 0 :=\n  fun h => Cardinal.aleph0_pos.not_le (aleph0_le_mk_Λ.trans h.le)\n", "additional_info": "", "used_premises": [1, 29], "def_path": "ConNF/BaseType/Params.lean", "pos": [258, 260], "informalization": "In the context of Constructive Ordinal Notation (ConNF), the theorem `ConNF.mk_Λ_ne_zero` asserts that the cardinality of the type `ConNF.Λ`, denoted as `Cardinal.mk ConNF.Λ`, is not equal to zero. This means that there exists at least one element in the type `ConNF.Λ`."}
{"full_name": "ConNF.κ_typein_zero", "url": "ConNF/BaseType/Params.html#ConNF.κ_typein_zero", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.κ_typein_zero [ConNF.Params🔗<|PREMISE|>🔗 ] :Ordinal.typein🔗<|PREMISE|>🔗 (fun (x x_1 : ConNF.κ) => x < x_1) 0 = 0", "code": "theorem κ_typein_zero : Ordinal.typein ((· < ·) : κ → κ → Prop) 0 = 0 := by\n  have := add_zero (0 : κ)\n  rw [← Ordinal.typein_inj (· < ·), Params.κ_add_typein] at this\n  conv at this => rhs; rw [← add_zero (Ordinal.typein _ _)]\n  rw [Ordinal.add_left_cancel] at this\n  exact this\n", "additional_info": "", "used_premises": [1, 36], "def_path": "ConNF/BaseType/Params.lean", "pos": [318, 324], "informalization": "The theorem `ConNF.κ_typein_zero` states that in the context of Constructive Ordinal Notation (ConNF), the order type of `0` within the well-ordered type `ConNF.κ` is `0`."}
{"full_name": "ConNF.κ_le_zero_iff", "url": "ConNF/BaseType/Params.html#ConNF.κ_le_zero_iff", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.κ_le_zero_iff [ConNF.Params🔗<|PREMISE|>🔗 ] (i : ConNF.κ) :i ≤ 0 ↔ i = 0", "code": "theorem κ_le_zero_iff (i : κ) : i ≤ 0 ↔ i = 0 :=\n  by rw [← not_lt, ← Ordinal.typein_le_typein (· < ·), κ_typein_zero, Ordinal.le_zero,\n    ← κ_typein_zero, Ordinal.typein_inj]\n", "additional_info": "", "used_premises": [1], "def_path": "ConNF/BaseType/Params.lean", "pos": [325, 328], "informalization": "The theorem `ConNF.κ_le_zero_iff` states that in the context of Constructive Ordinal Notation (ConNF), for any ordinal `i` of type `ConNF.κ`, `i` is less than or equal to `0` if and only if `i` is equal to `0`."}
{"full_name": "ConNF.κ_not_lt_zero", "url": "ConNF/BaseType/Params.html#ConNF.κ_not_lt_zero", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.κ_not_lt_zero [ConNF.Params🔗<|PREMISE|>🔗 ] (i : ConNF.κ) :¬ i < 0", "code": "theorem κ_not_lt_zero (i : κ) : ¬i < 0 := by\n  obtain (h | h | h) := lt_trichotomy i 0\n  · cases h.ne ((κ_le_zero_iff i).mp h.le)\n  · exact h.not_lt\n  · exact h.not_lt\n", "additional_info": "", "used_premises": [1], "def_path": "ConNF/BaseType/Params.lean", "pos": [329, 334], "informalization": "The theorem `ConNF.κ_not_lt_zero` states that in the context of Constructive Ordinal Notation (ConNF), for any element `i` of the type `ConNF.κ`, it cannot be less than zero."}
{"full_name": "ConNF.κ_pos", "url": "ConNF/BaseType/Params.html#ConNF.κ_pos", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.κ_pos [ConNF.Params🔗<|PREMISE|>🔗 ] (i : ConNF.κ) :0 ≤ i", "code": "theorem κ_pos (i : κ) : 0 ≤ i := by\n  rw [← not_lt]\n  exact κ_not_lt_zero i\n", "additional_info": "", "used_premises": [1], "def_path": "ConNF/BaseType/Params.lean", "pos": [335, 338], "informalization": "The theorem `ConNF.κ_pos` states that in the context of Constructive Ordinal Notation (ConNF), for any element `i` of the type `ConNF.κ`, the value `0` is less than or equal to `i`."}
{"full_name": "ConNF.κ_add_eq_zero_iff", "url": "ConNF/BaseType/Params.html#ConNF.κ_add_eq_zero_iff", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.κ_add_eq_zero_iff [ConNF.Params🔗<|PREMISE|>🔗 ] (i : ConNF.κ) (j : ConNF.κ) :i + j = 0 ↔ i = 0 ∧ j = 0", "code": "theorem κ_add_eq_zero_iff (i j : κ) : i + j = 0 ↔ i = 0 ∧ j = 0 :=\n  by rw [← Ordinal.typein_inj (α := κ) (· < ·), ← Ordinal.typein_inj (α := κ) (· < ·),\n    ← Ordinal.typein_inj (α := κ) (· < ·), Params.κ_add_typein, κ_typein_zero, Ordinal.add_eq_zero_iff]\n", "additional_info": "", "used_premises": [1], "def_path": "ConNF/BaseType/Params.lean", "pos": [340, 343], "informalization": "The theorem `ConNF.κ_add_eq_zero_iff` states that in the context of Constructive Ordinal Notation (ConNF), for any two ordinals `i` and `j` of type `ConNF.κ`, the sum `i + j` equals zero if and only if both `i` and `j` are zero."}
{"full_name": "ConNF.κ_succ_typein", "url": "ConNF/BaseType/Params.html#ConNF.κ_succ_typein", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.κ_succ_typein [ConNF.Params🔗<|PREMISE|>🔗 ] (i : ConNF.κ) :Ordinal.typein🔗<|PREMISE|>🔗 (fun (x x_1 : ConNF.κ) => x < x_1) (Order.succ🔗<|PREMISE|>🔗 i) = Ordinal.typein🔗<|PREMISE|>🔗 (fun (x x_1 : ConNF.κ) => x < x_1) i + 1", "code": "theorem κ_succ_typein (i : κ) :\n    Ordinal.typein ((· < ·) : κ → κ → Prop) (Order.succ i) =\n    Ordinal.typein ((· < ·) : κ → κ → Prop) i + 1 := by\n  refine le_antisymm ?_ ?_\n  · have : i < Ordinal.enum (· < ·) (Ordinal.typein ((· < ·) : κ → κ → Prop) i + 1) ?_\n    · conv_lhs => rw [← Ordinal.enum_typein ((· < ·) : κ → κ → Prop) i]\n      rw [Ordinal.enum_lt_enum (r := (· < ·))]\n      · exact lt_add_one _\n      · have := Order.lt_succ i\n        rw [← Ordinal.typein_lt_typein ((· < ·) : κ → κ → Prop)] at this\n        exact (Order.succ_le_of_lt this).trans_lt (Ordinal.typein_lt_type _ _)\n    have := Order.succ_le_of_lt this\n    conv at this => lhs; rw [← Ordinal.enum_typein ((· < ·) : κ → κ → Prop) (Order.succ i)]\n    rw [← not_lt, Ordinal.enum_le_enum] at this\n    exact this\n  · simp only [Ordinal.add_one_eq_succ, Order.succ_le_iff, Ordinal.typein_lt_typein,\n      Order.lt_succ_iff_not_isMax, gt_iff_lt, not_isMax, not_false_eq_true]\n", "additional_info": "", "used_premises": [1, 36, 518, 36], "def_path": "ConNF/BaseType/Params.lean", "pos": [345, 362], "informalization": "The theorem `ConNF.κ_succ_typein` states that the order type of the successor of an element `i` in the well-ordered type `ConNF.κ` is equal to the order type of `i` plus one."}
{"full_name": "Order.succ", "url": "Mathlib/Order/SuccPred/Basic.html#Order.succ", "code_src": "mathlib4", "ptype": "def", "header": "def Order.succ {α : Type u_1} [Preorder🔗<|PREMISE|>🔗 α] [SuccOrder🔗<|PREMISE|>🔗 α] :α → α", "code": "def succ : α → α :=\n  SuccOrder.succ\n", "additional_info": "The successor of an element. If `a` is not maximal, then `🗟succ🗟🔗../../.././Mathlib/Order/SuccPred/Basic.html#SuccOrder.succ🔗  a` is the least element greater\nthan `a`. If `a` is maximal, then `🗟succ🗟🔗../../.././Mathlib/Order/SuccPred/Basic.html#SuccOrder.succ🔗  a = a`.\nEquations\n* Order.succ 🗟=🗟🔗../../.././Init/Prelude.html#Eq🔗  SuccOrder.succ\n\n", "used_premises": [4, 21], "def_path": "Mathlib/Order/SuccPred/Basic.lean", "pos": [208, 210], "informalization": "Function `Order.succ` returns the least element greater than a given element in a preordered set with a successor order."}
{"full_name": "ConNF.κ_zero_lt_one", "url": "ConNF/BaseType/Params.html#ConNF.κ_zero_lt_one", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.κ_zero_lt_one [ConNF.Params🔗<|PREMISE|>🔗 ] :0 < 1", "code": "theorem κ_zero_lt_one : (0 : κ) < 1 := by\n  rw [← Ordinal.typein_lt_typein ((· < ·) : κ → κ → Prop)]\n  exact lt_of_lt_of_eq (lt_add_one _) (κ_succ_typein 0).symm\n", "additional_info": "", "used_premises": [1], "def_path": "ConNF/BaseType/Params.lean", "pos": [363, 366], "informalization": "In the context of Constructive Ordinal Notation (ConNF), it is proven that 0 is less than 1."}
{"full_name": "ConNF.κ_lt_one_iff", "url": "ConNF/BaseType/Params.html#ConNF.κ_lt_one_iff", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.κ_lt_one_iff [ConNF.Params🔗<|PREMISE|>🔗 ] (i : ConNF.κ) :i < 1 ↔ i = 0", "code": "theorem κ_lt_one_iff (i : κ) : i < 1 ↔ i = 0 := by\n  constructor\n  · rw [← κ_le_zero_iff]\n    exact SuccOrder.le_of_lt_succ\n  · rintro rfl\n    exact κ_zero_lt_one\n", "additional_info": "", "used_premises": [1], "def_path": "ConNF/BaseType/Params.lean", "pos": [368, 374], "informalization": "The theorem `ConNF.κ_lt_one_iff` states that in the context of Constructive Ordinal Notation (ConNF), for any ordinal `i` of type `ConNF.κ`, the inequality `i < 1` holds if and only if `i` is equal to `0`."}
{"full_name": "ConNF.κ_le_self_add", "url": "ConNF/BaseType/Params.html#ConNF.κ_le_self_add", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.κ_le_self_add [ConNF.Params🔗<|PREMISE|>🔗 ] (i : ConNF.κ) (j : ConNF.κ) :i ≤ i + j", "code": "theorem κ_le_self_add (i j : κ) : i ≤ i + j := by\n  rw [← not_lt, ← Ordinal.typein_le_typein (· < ·), Params.κ_add_typein]\n  exact Ordinal.le_add_right _ _\n", "additional_info": "", "used_premises": [1], "def_path": "ConNF/BaseType/Params.lean", "pos": [375, 378], "informalization": "In the context of Constructive Ordinal Notation (ConNF), the theorem `ConNF.κ_le_self_add` states that for any two ordinals `i` and `j` of type `ConNF.κ`, the ordinal `i` is less than or equal to the sum of `i` and `j`."}
{"full_name": "ConNF.κ_add_sub_cancel", "url": "ConNF/BaseType/Params.html#ConNF.κ_add_sub_cancel", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.κ_add_sub_cancel [ConNF.Params🔗<|PREMISE|>🔗 ] (i : ConNF.κ) (j : ConNF.κ) :i + j - i = j", "code": "theorem κ_add_sub_cancel (i j : κ) : i + j - i = j := by\n  rw [← Ordinal.typein_inj (· < ·), Params.κ_sub_typein, Params.κ_add_typein]\n  exact Ordinal.add_sub_cancel _ _\n", "additional_info": "", "used_premises": [1], "def_path": "ConNF/BaseType/Params.lean", "pos": [379, 382], "informalization": "The theorem `ConNF.κ_add_sub_cancel` states that in the context of Constructive Ordinal Notation (ConNF), for any two elements `i` and `j` of type `ConNF.κ`, the expression `i + j - i` simplifies to `j`."}
{"full_name": "ConNF.κ_sub_lt", "url": "ConNF/BaseType/Params.html#ConNF.κ_sub_lt", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.κ_sub_lt [ConNF.Params🔗<|PREMISE|>🔗 ] {i : ConNF.κ} {j : ConNF.κ} {k : ConNF.κ} (h₁ : i < j + k) (h₂ : j ≤ i) :i - j < k", "code": "theorem κ_sub_lt {i j k : κ} (h₁ : i < j + k) (h₂ : j ≤ i) : i - j < k := by\n  rw [← Ordinal.typein_lt_typein (· < ·)] at h₁ ⊢\n  rw [← not_lt, ← Ordinal.typein_le_typein (· < ·)] at h₂\n  rw [Params.κ_add_typein, ← Ordinal.sub_lt_of_le h₂] at h₁\n  rw [Params.κ_sub_typein]\n  exact h₁\n", "additional_info": "", "used_premises": [1], "def_path": "ConNF/BaseType/Params.lean", "pos": [383, 389], "informalization": "The theorem `ConNF.κ_sub_lt` states that if `i < j + k` and `j ≤ i`, then `i - j < k` in the context of Constructive Ordinal Notation (ConNF)."}
{"full_name": "ConNF.mk_typeIndex", "url": "ConNF/BaseType/Params.html#ConNF.mk_typeIndex", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.mk_typeIndex [ConNF.Params🔗<|PREMISE|>🔗 ] :Cardinal.mk🔗<|PREMISE|>🔗 ConNF.TypeIndex = Cardinal.mk🔗<|PREMISE|>🔗 ConNF.Λ", "code": "theorem mk_typeIndex : #TypeIndex = #Λ :=\n  mk_option.trans <| add_eq_left aleph0_le_mk_Λ <| one_le_aleph0.trans aleph0_le_mk_Λ\n", "additional_info": "", "used_premises": [1, 29, 29], "def_path": "ConNF/BaseType/Params.lean", "pos": [406, 408], "informalization": "The cardinality of `ConNF.TypeIndex` is equal to the cardinality of `ConNF.Λ`."}
{"full_name": "ConNF.card_Iio_lt", "url": "ConNF/BaseType/Params.html#ConNF.card_Iio_lt", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.card_Iio_lt [ConNF.Params🔗<|PREMISE|>🔗 ] (x : ConNF.μ) :Cardinal.mk🔗<|PREMISE|>🔗 ↑(Set.Iio🔗<|PREMISE|>🔗 x) < Cardinal.mk🔗<|PREMISE|>🔗 ConNF.μ", "code": "theorem card_Iio_lt (x : μ) : #(Set.Iio x) < #μ :=\n  card_typein_lt (· < ·) x Params.μ_ord.symm\n", "additional_info": "Principal segments (sets of the form `{y | y < x}`) have cardinality `< 🗟μ🗟🔗../.././ConNF/BaseType/Params.html#ConNF.Params.μ🔗` .", "used_premises": [1, 29, 526, 29], "def_path": "ConNF/BaseType/Params.lean", "pos": [410, 412], "informalization": "Function `ConNF.card_Iio_lt` proves that the cardinality of the set of all elements less than a given element `x` in the type `ConNF.μ` is strictly less than the cardinality of `ConNF.μ`."}
{"full_name": "Set.Iio", "url": "Mathlib/Data/Set/Intervals/Basic.html#Set.Iio", "code_src": "mathlib4", "ptype": "def", "header": "def Set.Iio {α : Type u_1} [Preorder🔗<|PREMISE|>🔗 α] (a : α) :Set🔗<|PREMISE|>🔗 α", "code": "def Iio (a : α) :=\n  { x | x < a }\n", "additional_info": "Left-infinite right-open interval\nEquations\n* 🗟Set.Iio🗟🔗../../../.././Mathlib/Data/Set/Intervals/Basic.html#Set.Iio🔗  a 🗟=🗟🔗../../../.././Init/Prelude.html#Eq🔗  {x : α | x 🗟<🗟🔗../../../.././Init/Prelude.html#LT.lt🔗  a}\n\n", "used_premises": [4, 69], "def_path": "Mathlib/Data/Set/Intervals/Basic.lean", "pos": [53, 55], "informalization": "Function `Set.Iio` defines the left-infinite right-open interval `{x | x < a}` in a preordered type `α`, representing all elements strictly less than `a`."}
{"full_name": "ConNF.card_Iic_lt", "url": "ConNF/BaseType/Params.html#ConNF.card_Iic_lt", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.card_Iic_lt [ConNF.Params🔗<|PREMISE|>🔗 ] (x : ConNF.μ) :Cardinal.mk🔗<|PREMISE|>🔗 ↑(Set.Iic🔗<|PREMISE|>🔗 x) < Cardinal.mk🔗<|PREMISE|>🔗 ConNF.μ", "code": "theorem card_Iic_lt (x : μ) : #(Set.Iic x) < #μ := by\n  rw [← Set.Iio_union_right, mk_union_of_disjoint, mk_singleton]\n  -- TODO: This isn't the morally correct proof because it uses the fact `μ` is a limit cardinal.\n  · exact (add_one_le_succ _).trans_lt (Params.μ_isStrongLimit.isLimit.succ_lt (card_Iio_lt x))\n  · simp\n", "additional_info": "Initial segments (sets of the form `{y | y ≤ x}`) have cardinality `< 🗟μ🗟🔗../.././ConNF/BaseType/Params.html#ConNF.Params.μ🔗` .", "used_premises": [1, 29, 528, 29], "def_path": "ConNF/BaseType/Params.lean", "pos": [414, 419], "informalization": "In the context of Constructive Ordinal Notation (ConNF), for any element `x` of type `ConNF.μ`, the cardinality of the set of all elements less than or equal to `x` is strictly less than the cardinality of `ConNF.μ`."}
{"full_name": "Set.Iic", "url": "Mathlib/Data/Set/Intervals/Basic.html#Set.Iic", "code_src": "mathlib4", "ptype": "def", "header": "def Set.Iic {α : Type u_1} [Preorder🔗<|PREMISE|>🔗 α] (b : α) :Set🔗<|PREMISE|>🔗 α", "code": "def Iic (b : α) :=\n  { x | x ≤ b }\n", "additional_info": "Left-infinite right-closed interval\nEquations\n* 🗟Set.Iic🗟🔗../../../.././Mathlib/Data/Set/Intervals/Basic.html#Set.Iic🔗  b 🗟=🗟🔗../../../.././Init/Prelude.html#Eq🔗  {x : α | x 🗟≤🗟🔗../../../.././Init/Prelude.html#LE.le🔗  b}\n\n", "used_premises": [4, 69], "def_path": "Mathlib/Data/Set/Intervals/Basic.lean", "pos": [63, 65], "informalization": "Function `Set.Iic` defines the set of all elements less than or equal to a given element `b` in a preordered type `α`."}
{"full_name": "ConNF.mk_atom", "url": "ConNF/BaseType/Atom.html#ConNF.mk_atom", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.mk_atom [ConNF.Params🔗<|PREMISE|>🔗 ] :Cardinal.mk🔗<|PREMISE|>🔗 ConNF.Atom = Cardinal.mk🔗<|PREMISE|>🔗 ConNF.μ", "code": "theorem mk_atom : #Atom = #μ := by\n  simp_rw [Atom, mk_prod, lift_id, mk_litter,\n    mul_eq_left\n      (Params.κ_isRegular.aleph0_le.trans Params.κ_lt_μ.le)\n      Params.κ_lt_μ.le\n      Params.κ_isRegular.pos.ne']\n", "additional_info": "The cardinality of `🗟Atom🗟🔗../.././ConNF/BaseType/Atom.html#ConNF.Atom🔗`  is the cardinality of `μ`.\nWe will prove that all types constructed in our model have cardinality equal to `μ`.", "used_premises": [1, 29, 29], "def_path": "ConNF/BaseType/Atom.lean", "pos": [43, 49], "informalization": "Function `ConNF.mk_atom` proves that the cardinality of the type `ConNF.Atom` is equal to the cardinality of the type `ConNF.μ` in the context of Constructive Ordinal Notation (ConNF)."}
{"full_name": "ConNF.mem_litterSet", "url": "ConNF/BaseType/Atom.html#ConNF.mem_litterSet", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.mem_litterSet [ConNF.Params🔗<|PREMISE|>🔗 ] {a : ConNF.Atom} {L : ConNF.Litter} :a ∈ ConNF.litterSet🔗<|PREMISE|>🔗 L ↔ a.1 = L", "code": "theorem mem_litterSet {a : Atom} {L : Litter} : a ∈ litterSet L ↔ a.1 = L :=\n  Iff.rfl\n", "additional_info": "", "used_premises": [1, 467], "def_path": "ConNF/BaseType/Atom.lean", "pos": [56, 58], "informalization": "The theorem `ConNF.mem_litterSet` states that an atom `a` belongs to the litter set `ConNF.litterSet L` if and only if the first projection of `a` is equal to `L`."}
{"full_name": "ConNF.mk_litterSet", "url": "ConNF/BaseType/Atom.html#ConNF.mk_litterSet", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.mk_litterSet [ConNF.Params🔗<|PREMISE|>🔗 ] (L : ConNF.Litter) :Cardinal.mk🔗<|PREMISE|>🔗 ↑(ConNF.litterSet🔗<|PREMISE|>🔗 L) = Cardinal.mk🔗<|PREMISE|>🔗 ConNF.κ", "code": "theorem mk_litterSet (L : Litter) : #(litterSet L) = #κ :=\n  Cardinal.eq.2 ⟨litterSetEquiv L⟩\n", "additional_info": "Each litter set has cardinality `κ`.", "used_premises": [1, 29, 467, 29], "def_path": "ConNF/BaseType/Atom.lean", "pos": [69, 71], "informalization": "In the context of Constructive Ordinal Notation (ConNF), each litter set has the same cardinality as the type `κ`."}
{"full_name": "ConNF.litterSet_nonempty", "url": "ConNF/BaseType/Atom.html#ConNF.litterSet_nonempty", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.litterSet_nonempty [ConNF.Params🔗<|PREMISE|>🔗 ] (L : ConNF.Litter) :Nonempty🔗<|PREMISE|>🔗 ↑(ConNF.litterSet🔗<|PREMISE|>🔗 L)", "code": "theorem litterSet_nonempty (L : Litter) : Nonempty (litterSet L) := by\n  rw [← Cardinal.mk_ne_zero_iff, mk_litterSet]\n  exact mk_ne_zero κ\n", "additional_info": "", "used_premises": [1, 212, 467], "def_path": "ConNF/BaseType/Atom.lean", "pos": [72, 75], "informalization": "The theorem `ConNF.litterSet_nonempty` states that for any given litter `L` in the context of Constructive Ordinal Notation (ConNF), the set of all atoms `a` such that the first projection of `a` is equal to `L` is nonempty. This means there exists at least one such atom."}
{"full_name": "ConNF.pairwise_disjoint_litterSet", "url": "ConNF/BaseType/Atom.html#ConNF.pairwise_disjoint_litterSet", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.pairwise_disjoint_litterSet [ConNF.Params🔗<|PREMISE|>🔗 ] :Pairwise🔗<|PREMISE|>🔗 (Disjoint on ConNF.litterSet)", "code": "theorem pairwise_disjoint_litterSet : Pairwise (Disjoint on litterSet) :=\n  fun _ _ h => disjoint_left.2 fun _ h₁ h₂ => h <| h₁.symm.trans h₂\n", "additional_info": "Two litters with different indices have disjoint litter sets.", "used_premises": [1, 490], "def_path": "ConNF/BaseType/Atom.lean", "pos": [77, 79], "informalization": "In the context of Constructive Ordinal Notation (ConNF), the theorem `ConNF.pairwise_disjoint_litterSet` states that the litter sets of litters with different indices are pairwise disjoint. This means that for any two litters with different indices, their litter sets do not share any common elements. This property is crucial in ensuring that the construction of natural numbers using ConNF is well-defined and consistent."}
{"full_name": "ConNF.eq_of_mem_litterSet_of_mem_litterSet", "url": "ConNF/BaseType/Atom.html#ConNF.eq_of_mem_litterSet_of_mem_litterSet", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.eq_of_mem_litterSet_of_mem_litterSet [ConNF.Params🔗<|PREMISE|>🔗 ] {a : ConNF.Atom} {L₁ : ConNF.Litter} {L₂ : ConNF.Litter} (hi : a ∈ ConNF.litterSet🔗<|PREMISE|>🔗 L₁) (hj : a ∈ ConNF.litterSet🔗<|PREMISE|>🔗 L₂) :L₁ = L₂", "code": "theorem eq_of_mem_litterSet_of_mem_litterSet {a : Atom} {L₁ L₂ : Litter}\n    (hi : a ∈ litterSet L₁) (hj : a ∈ litterSet L₂) : L₁ = L₂ :=\n  pairwise_disjoint_litterSet.eq <| not_disjoint_iff.2 ⟨_, hi, hj⟩\n", "additional_info": "", "used_premises": [1, 467, 467], "def_path": "ConNF/BaseType/Atom.lean", "pos": [80, 83], "informalization": "The theorem `ConNF.eq_of_mem_litterSet_of_mem_litterSet` states that if an atom `a` belongs to two different litter sets `ConNF.litterSet L₁` and `ConNF.litterSet L₂`, then the litters `L₁` and `L₂` must be equal."}
{"full_name": "ConNF.litterSet_symmDiff_litterSet", "url": "ConNF/BaseType/Atom.html#ConNF.litterSet_symmDiff_litterSet", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.litterSet_symmDiff_litterSet [ConNF.Params🔗<|PREMISE|>🔗 ] {L₁ : ConNF.Litter} {L₂ : ConNF.Litter} (h : L₁ ≠ L₂) :symmDiff🔗<|PREMISE|>🔗 (ConNF.litterSet🔗<|PREMISE|>🔗 L₁) (ConNF.litterSet🔗<|PREMISE|>🔗 L₂) = ConNF.litterSet🔗<|PREMISE|>🔗 L₁ ∪ ConNF.litterSet🔗<|PREMISE|>🔗 L₂", "code": "theorem litterSet_symmDiff_litterSet {L₁ L₂ : Litter} (h : L₁ ≠ L₂) :\n    litterSet L₁ ∆ litterSet L₂ = litterSet L₁ ∪ litterSet L₂ :=\n  (pairwise_disjoint_litterSet h).symmDiff_eq_sup\n", "additional_info": "", "used_premises": [1, 62, 467, 467, 467, 467], "def_path": "ConNF/BaseType/Atom.lean", "pos": [84, 87], "informalization": "The theorem `ConNF.litterSet_symmDiff_litterSet` states that for two different litters `L₁` and `L₂`, the symmetric difference of the sets `ConNF.litterSet L₁` and `ConNF.litterSet L₂` is equal to their union."}
{"full_name": "WithBot.coe_ne_coe", "url": "ConNF/Mathlib/WithBot.html#WithBot.coe_ne_coe", "code_src": "con-nf", "ptype": "theorem", "header": "theorem WithBot.coe_ne_coe {α : Type u_1} {a : α} {b : α} :↑a ≠ ↑b ↔ a ≠ b", "code": "theorem coe_ne_coe {a b : α} : (a : WithBot α) ≠ b ↔ a ≠ b :=\n  coe_eq_coe.not\n", "additional_info": "", "used_premises": [], "def_path": "ConNF/Mathlib/WithBot.lean", "pos": [8, 10], "informalization": "The theorem `WithBot.coe_ne_coe` states that for any two elements `a` and `b` of a type `α`, the inequality `↑a ≠ ↑b` holds if and only if `a ≠ b`."}
{"full_name": "Ordinal.IsLimit.isSuccLimit", "url": "ConNF/Mathlib/Ordinal.html#Ordinal.IsLimit.isSuccLimit", "code_src": "con-nf", "ptype": "theorem", "header": "theorem Ordinal.IsLimit.isSuccLimit {o : Ordinal🔗<|PREMISE|>🔗 } (h : Ordinal.IsLimit🔗<|PREMISE|>🔗 o) :Order.IsSuccLimit🔗<|PREMISE|>🔗 o", "code": "protected theorem IsLimit.isSuccLimit {o : Ordinal} (h : o.IsLimit) : Order.IsSuccLimit o := by\n  rw [Order.isSuccLimit_iff_succ_lt]; exact h.2\n", "additional_info": "", "used_premises": [25, 24, 538], "def_path": "ConNF/Mathlib/Ordinal.lean", "pos": [10, 12], "informalization": "The theorem `Ordinal.IsLimit.isSuccLimit` states that if an ordinal is a limit ordinal, then it is also a successor limit in the order sense."}
{"full_name": "Order.IsSuccLimit", "url": "Mathlib/Order/SuccPred/Limit.html#Order.IsSuccLimit", "code_src": "mathlib4", "ptype": "def", "header": "def Order.IsSuccLimit {α : Type u_1} [LT🔗<|PREMISE|>🔗 α] (a : α) :Prop", "code": "def IsSuccLimit (a : α) : Prop :=\n  ∀ b, ¬b ⋖ a\n", "additional_info": "A successor limit is a value that doesn't cover any other.\nIt's so named because in a successor order, a successor limit can't be the successor of anything\nsmaller.\nEquations\n* 🗟Order.IsSuccLimit🗟🔗../../.././Mathlib/Order/SuccPred/Limit.html#Order.IsSuccLimit🔗  a 🗟=🗟🔗../../.././Init/Prelude.html#Eq🔗  ∀ (b : α), 🗟¬🗟🔗../../.././Init/Prelude.html#Not🔗 b 🗟⋖🗟🔗../../.././Mathlib/Order/Cover.html#CovBy🔗  a\n\n", "used_premises": [6], "def_path": "Mathlib/Order/SuccPred/Limit.lean", "pos": [41, 43], "informalization": "Function `Order.IsSuccLimit` checks if an element `a` in a preordered set is a successor limit, meaning there is no element `b` such that `b` covers `a`."}
{"full_name": "csupr_neg", "url": "ConNF/Mathlib/Order.html#csupr_neg", "code_src": "con-nf", "ptype": "theorem", "header": "theorem csupr_neg {α : Type u_1} [CompleteLattice🔗<|PREMISE|>🔗 α] {p : Prop } {f : p → α} (hp : ¬ p) :⨆ (h : p), f h = ⊥", "code": "theorem csupr_neg [CompleteLattice α] {p : Prop} {f : p → α} (hp : ¬p) : (⨆ h, f h) = ⊥ :=\n  iSup_eq_bot.2 fun h => (hp h).elim\n", "additional_info": "", "used_premises": [540], "def_path": "ConNF/Mathlib/Order.lean", "pos": [12, 14], "informalization": "In a complete lattice, if the proposition `p` is false, then the supremum of the function `f` over `p` is equal to the bottom element of the lattice."}
{"full_name": "CompleteLattice", "url": "Mathlib/Order/CompleteLattice.html#CompleteLattice", "code_src": "mathlib4", "ptype": "class", "header": "class CompleteLattice (α : Type u_9) extends Lattice🔗<|PREMISE|>🔗 , SupSet🔗<|PREMISE|>🔗 , InfSet🔗<|PREMISE|>🔗 , Top🔗<|PREMISE|>🔗 , Bot🔗<|PREMISE|>🔗 :Type u_9\n | sup : α → α → α\n | le : α → α → Prop \n | lt : α → α → Prop \n | le_refl : ∀ (a : α), a ≤  a\n | le_trans : ∀ (a b c : α), a ≤  b → b ≤  c → a ≤  c\n | lt_iff_le_not_le : ∀ (a b : α), a <  b ↔  a ≤  b ∧  ¬ b ≤  a\n | le_antisymm : ∀ (a b : α), a ≤  b → b ≤  a → a =  b\n | le_sup_left : ∀ (a b : α), a ≤  a ⊔  b\n | le_sup_right : ∀ (a b : α), b ≤  a ⊔  b\n | sup_le : ∀ (a b c : α), a ≤  c → b ≤  c → a ⊔  b ≤  c\n | inf : α → α → α\n | inf_le_left : ∀ (a b : α), a ⊓  b ≤  a\n | inf_le_right : ∀ (a b : α), a ⊓  b ≤  b\n | le_inf : ∀ (a b c : α), a ≤  b → a ≤  c → a ≤  b ⊓  c\n | sSup : Set🔗<|PREMISE|>🔗  α → α\n | le_sSup : ∀ (s : Set🔗<|PREMISE|>🔗  α), ∀ a ∈ s, a ≤  sSup  s\n | sSup_le : ∀ (s : Set🔗<|PREMISE|>🔗  α) (a : α), (∀ b ∈ s, b ≤  a) → sSup  s ≤  a\n | sInf : Set🔗<|PREMISE|>🔗  α → α\n | sInf_le : ∀ (s : Set🔗<|PREMISE|>🔗  α), ∀ a ∈ s, sInf  s ≤  a\n | le_sInf : ∀ (s : Set🔗<|PREMISE|>🔗  α) (a : α), (∀ b ∈ s, a ≤  b) → a ≤  sInf  s\n | top : α\n | bot : α\n | le_top : ∀ (x : α), x ≤  ⊤ \n | bot_le : ∀ (x : α), ⊥  ≤  x", "code": "class CompleteLattice (α : Type*) extends Lattice α, CompleteSemilatticeSup α,\n  CompleteSemilatticeInf α, Top α, Bot α where\n  /-- Any element is less than the top one. -/\n  protected le_top : ∀ x : α, x ≤ ⊤\n  /-- Any element is more than the bottom one. -/\n  protected bot_le : ∀ x : α, ⊥ ≤ x\n", "additional_info": "A complete lattice is a bounded lattice which has suprema and infima for every subset.\n- CompleteLattice.le_sSup: Any element of a set is less than the set supremum.\n\n\n- CompleteLattice.sSup_le: Any upper bound is more than the set supremum.\n\n\n- CompleteLattice.sInf_le: Any element of a set is more than the set infimum.\n\n\n- CompleteLattice.le_sInf: Any lower bound is less than the set infimum.\n\n\n- CompleteLattice.le_top: Any element is less than the top one.\n\n\n- CompleteLattice.bot_le: Any element is more than the bottom one.\n\n\n", "used_premises": [541, 544, 545, 546, 547, 69, 69, 69, 69, 69, 69], "def_path": "Mathlib/Order/CompleteLattice.lean", "pos": [197, 203], "informalization": "Class `CompleteLattice` represents a structure with both a join-semilattice (with a least upper bound operation `⊔`) and a meet-semilattice (with a greatest lower bound operation `⊓`), forming a partially ordered set where every subset has a unique supremum and infimum."}
{"full_name": "Lattice", "url": "Mathlib/Order/Lattice.html#Lattice", "code_src": "mathlib4", "ptype": "class", "header": "class Lattice (α : Type u) extends SemilatticeSup🔗<|PREMISE|>🔗 , Inf🔗<|PREMISE|>🔗 :Type u\n | sup : α → α → α\n | le : α → α → Prop \n | lt : α → α → Prop \n | le_refl : ∀ (a : α), a ≤  a\n | le_trans : ∀ (a b c : α), a ≤  b → b ≤  c → a ≤  c\n | lt_iff_le_not_le : ∀ (a b : α), a <  b ↔  a ≤  b ∧  ¬ b ≤  a\n | le_antisymm : ∀ (a b : α), a ≤  b → b ≤  a → a =  b\n | le_sup_left : ∀ (a b : α), a ≤  a ⊔  b\n | le_sup_right : ∀ (a b : α), b ≤  a ⊔  b\n | sup_le : ∀ (a b c : α), a ≤  c → b ≤  c → a ⊔  b ≤  c\n | inf : α → α → α\n | inf_le_left : ∀ (a b : α), a ⊓  b ≤  a\n | inf_le_right : ∀ (a b : α), a ⊓  b ≤  b\n | le_inf : ∀ (a b c : α), a ≤  b → a ≤  c → a ≤  b ⊓  c", "code": "class Lattice (α : Type u) extends SemilatticeSup α, SemilatticeInf α\n", "additional_info": "A lattice is a join-semilattice which is also a meet-semilattice.\n- Lattice.inf_le_left: The infimum is a lower bound on the first argument\n\n\n- Lattice.inf_le_right: The infimum is a lower bound on the second argument\n\n\n- Lattice.le_inf: The infimum is the *greatest* lower bound\n\n\n", "used_premises": [542, 543], "def_path": "Mathlib/Order/Lattice.lean", "pos": [577, 578], "informalization": "Class `Lattice` represents a structure with both a join-semilattice (with a least upper bound operation `⊔`) and a meet-semilattice (with a greatest lower bound operation `⊓`), forming a partially ordered set where every pair of elements has a unique supremum and infimum."}
{"full_name": "SemilatticeSup", "url": "Mathlib/Order/Lattice.html#SemilatticeSup", "code_src": "mathlib4", "ptype": "class", "header": "class SemilatticeSup (α : Type u) extends Sup🔗<|PREMISE|>🔗 , PartialOrder🔗<|PREMISE|>🔗 :Type u\n | sup : α → α → α\n | le : α → α → Prop \n | lt : α → α → Prop \n | le_refl : ∀ (a : α), a ≤  a\n | le_trans : ∀ (a b c : α), a ≤  b → b ≤  c → a ≤  c\n | lt_iff_le_not_le : ∀ (a b : α), a <  b ↔  a ≤  b ∧  ¬ b ≤  a\n | le_antisymm : ∀ (a b : α), a ≤  b → b ≤  a → a =  b\n | le_sup_left : ∀ (a b : α), a ≤  a ⊔  b\n | le_sup_right : ∀ (a b : α), b ≤  a ⊔  b\n | sup_le : ∀ (a b c : α), a ≤  c → b ≤  c → a ⊔  b ≤  c", "code": "class SemilatticeSup (α : Type u) extends Sup α, PartialOrder α where\n  /-- The supremum is an upper bound on the first argument -/\n  protected le_sup_left : ∀ a b : α, a ≤ a ⊔ b\n  /-- The supremum is an upper bound on the second argument -/\n  protected le_sup_right : ∀ a b : α, b ≤ a ⊔ b\n  /-- The supremum is the *least* upper bound -/\n  protected sup_le : ∀ a b c : α, a ≤ c → b ≤ c → a ⊔ b ≤ c\n", "additional_info": "A `🗟SemilatticeSup🗟🔗../.././Mathlib/Order/Lattice.html#SemilatticeSup🔗`  is a join-semilattice, that is, a partial order\nwith a join (a.k.a. lub / least upper bound, sup / supremum) operation\n`⊔` which is the least element larger than both factors.\n- SemilatticeSup.le_sup_left: The supremum is an upper bound on the first argument\n\n\n- SemilatticeSup.le_sup_right: The supremum is an upper bound on the second argument\n\n\n- SemilatticeSup.sup_le: The supremum is the *least* upper bound\n\n\n", "used_premises": [63, 3], "def_path": "Mathlib/Order/Lattice.lean", "pos": [72, 79], "informalization": "Class `SemilatticeSup` represents a join-semilattice, which is a partially ordered set with a least upper bound operation `⊔` that is associative, commutative, and idempotent, and satisfies the properties of being an upper bound and the least upper bound."}
{"full_name": "Inf", "url": "Mathlib/Order/Notation.html#Inf", "code_src": "mathlib4", "ptype": "class", "header": "class Inf (α : Type u_1) :Type u_1\n | inf : α → α → α", "code": "class Inf (α : Type*) where\n  /-- Greatest lower bound (`\\glb` notation) -/\n  inf : α → α → α\n", "additional_info": "Typeclass for the `⊓` (`\\glb`) notation\n- Inf.inf: Greatest lower bound (`\\glb` notation)\n\n\n", "used_premises": [], "def_path": "Mathlib/Order/Notation.lean", "pos": [53, 56], "informalization": "Class `Inf` represents the concept of a greatest lower bound operation, often denoted as `⊓` (`\\glb`), for a type `α`."}
{"full_name": "SupSet", "url": "Mathlib/Order/SetNotation.html#SupSet", "code_src": "mathlib4", "ptype": "class", "header": "class SupSet (α : Type u_1) :Type u_1\n | sSup : Set🔗<|PREMISE|>🔗  α → α", "code": "class SupSet (α : Type*) where\n  sSup : Set α → α\n", "additional_info": "Class for the `🗟sSup🗟🔗../.././Mathlib/Order/SetNotation.html#SupSet.sSup🔗`  operator\n- SupSet.sSup: Supremum of a set\n\n\n", "used_premises": [69], "def_path": "Mathlib/Order/SetNotation.lean", "pos": [39, 41], "informalization": "Class `SupSet` represents the concept of a supremum operation on a type `α`, which takes a set of elements of `α` and returns the least upper bound of that set."}
{"full_name": "InfSet", "url": "Mathlib/Order/SetNotation.html#InfSet", "code_src": "mathlib4", "ptype": "class", "header": "class InfSet (α : Type u_1) :Type u_1\n | sInf : Set🔗<|PREMISE|>🔗  α → α", "code": "class InfSet (α : Type*) where\n  sInf : Set α → α\n", "additional_info": "Class for the `🗟sInf🗟🔗../.././Mathlib/Order/SetNotation.html#InfSet.sInf🔗`  operator\n- InfSet.sInf: Infimum of a set\n\n\n", "used_premises": [69], "def_path": "Mathlib/Order/SetNotation.lean", "pos": [46, 48], "informalization": "Class `InfSet` represents the concept of an infimum operator on a type `α`, which computes the greatest lower bound of a set of elements in `α`."}
{"full_name": "Top", "url": "Mathlib/Order/Notation.html#Top", "code_src": "mathlib4", "ptype": "class", "header": "class Top (α : Type u_1) :Type u_1\n | top : α", "code": "class Top (α : Type*) where\n  /-- The top (`⊤`, `\\top`) element -/\n  top : α\n", "additional_info": "Typeclass for the `⊤` (`\\top`) notation\n- Top.top: The top (`⊤`, `\\top`) element\n\n\n", "used_premises": [], "def_path": "Mathlib/Order/Notation.lean", "pos": [97, 100], "informalization": "Class `Top` represents a type `α` with a distinguished element `⊤` (top), typically used to denote a maximum or universal element in a partially ordered set or lattice."}
{"full_name": "Bot", "url": "Mathlib/Order/Notation.html#Bot", "code_src": "mathlib4", "ptype": "class", "header": "class Bot (α : Type u_1) :Type u_1\n | bot : α", "code": "class Bot (α : Type*) where\n  /-- The bot (`⊥`, `\\bot`) element -/\n  bot : α\n", "additional_info": "Typeclass for the `⊥` (`\\bot`) notation\n- Bot.bot: The bot (`⊥`, `\\bot`) element\n\n\n", "used_premises": [], "def_path": "Mathlib/Order/Notation.lean", "pos": [104, 107], "informalization": "Class `Bot` represents the concept of a bottom element in a type `α`, often denoted as `⊥`, which is a minimal element in the order or hierarchy of that type."}
{"full_name": "Set.compl_eq_empty", "url": "ConNF/Mathlib/Order.html#Set.compl_eq_empty", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem Set.compl_eq_empty {α : Type u_1} {s : Set🔗<|PREMISE|>🔗 α} :sᶜ = ∅ ↔ s = Set.univ", "code": "theorem compl_eq_empty : sᶜ = ∅ ↔ s = univ :=\n  compl_eq_bot\n", "additional_info": "", "used_premises": [69], "def_path": "ConNF/Mathlib/Order.lean", "pos": [20, 22], "informalization": "The complement of a set `s` is equal to the empty set if and only if `s` is equal to the universal set."}
{"full_name": "Set.compl_eq_univ", "url": "ConNF/Mathlib/Order.html#Set.compl_eq_univ", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem Set.compl_eq_univ {α : Type u_1} {s : Set🔗<|PREMISE|>🔗 α} :sᶜ = Set.univ ↔ s = ∅", "code": "theorem compl_eq_univ : sᶜ = univ ↔ s = ∅ :=\n  compl_eq_top\n", "additional_info": "", "used_premises": [69], "def_path": "ConNF/Mathlib/Order.lean", "pos": [24, 26], "informalization": "The complement of a set `s` is equal to the universal set if and only if `s` is the empty set."}
{"full_name": "Set.image_sUnion", "url": "ConNF/Mathlib/Order.html#Set.image_sUnion", "code_src": "con-nf", "ptype": "theorem", "header": "theorem Set.image_sUnion {α : Type u_1} {β : Type u_2} (f : α → β) (S : Set🔗<|PREMISE|>🔗 (Set🔗<|PREMISE|>🔗 α)) :f '' ⋃₀ S = ⋃ s ∈ S, f '' s", "code": "theorem image_sUnion (f : α → β) (S : Set (Set α)) : f '' ⋃₀ S = ⋃ s ∈ S, f '' s := by\n  rw [sUnion_eq_biUnion, image_iUnion₂]\n", "additional_info": "", "used_premises": [69, 69], "def_path": "ConNF/Mathlib/Order.lean", "pos": [27, 29], "informalization": "The theorem `Set.image_sUnion` states that for any function `f` and any set of sets `S`, the image of the union of all sets in `S` under `f` is equal to the union of the images of each set in `S` under `f`."}
{"full_name": "Set.iUnion_pos", "url": "ConNF/Mathlib/Order.html#Set.iUnion_pos", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem Set.iUnion_pos {α : Type u_1} {p : Prop } {f : p → Set🔗<|PREMISE|>🔗 α} (hp : p) :⋃ (h : p), f h = f hp", "code": "theorem iUnion_pos {p : Prop} {f : p → Set α} (hp : p) : (⋃ h, f h) = f hp :=\n  iSup_pos hp\n", "additional_info": "", "used_premises": [69], "def_path": "ConNF/Mathlib/Order.lean", "pos": [31, 33], "informalization": "The theorem `Set.iUnion_pos` states that if `p` is a true proposition, then the union of the sets `f h` for all `h : p` is equal to `f hp`, where `hp` is a proof of `p`."}
{"full_name": "Set.iUnion_neg'", "url": "ConNF/Mathlib/Order.html#Set.iUnion_neg'", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem Set.iUnion_neg' {α : Type u_1} {p : Prop } {f : p → Set🔗<|PREMISE|>🔗 α} (hp : ¬ p) :⋃ (h : p), f h = ∅", "code": "theorem iUnion_neg' {p : Prop} {f : p → Set α} (hp : ¬p) : (⋃ h, f h) = ∅ :=\n  csupr_neg hp\n", "additional_info": "", "used_premises": [69], "def_path": "ConNF/Mathlib/Order.lean", "pos": [35, 37], "informalization": "The theorem `Set.iUnion_neg'` states that if `p` is a false proposition, then the union of sets indexed by `p` is the empty set."}
{"full_name": "Set.empty_symmDiff", "url": "ConNF/Mathlib/Order.html#Set.empty_symmDiff", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem Set.empty_symmDiff {α : Type u_1} (s : Set🔗<|PREMISE|>🔗 α) :symmDiff🔗<|PREMISE|>🔗 ∅ s = s", "code": "theorem empty_symmDiff : ∅ ∆ s = s :=\n  bot_symmDiff _\n", "additional_info": "", "used_premises": [69, 62], "def_path": "ConNF/Mathlib/Order.lean", "pos": [41, 43], "informalization": "The symmetric difference between the empty set and any set `s` is equal to `s`."}
{"full_name": "Set.symmDiff_empty", "url": "ConNF/Mathlib/Order.html#Set.symmDiff_empty", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem Set.symmDiff_empty {α : Type u_1} (s : Set🔗<|PREMISE|>🔗 α) :symmDiff🔗<|PREMISE|>🔗 s ∅ = s", "code": "theorem symmDiff_empty : s ∆ ∅ = s :=\n  symmDiff_bot _\n", "additional_info": "", "used_premises": [69, 62], "def_path": "ConNF/Mathlib/Order.lean", "pos": [45, 47], "informalization": "The symmetric difference of a set `s` and the empty set is equal to `s`."}
{"full_name": "Cardinal.nonempty_compl_of_mk_lt_mk", "url": "ConNF/Mathlib/Cardinal.html#Cardinal.nonempty_compl_of_mk_lt_mk", "code_src": "con-nf", "ptype": "theorem", "header": "theorem Cardinal.nonempty_compl_of_mk_lt_mk {α : Type u} {s : Set🔗<|PREMISE|>🔗 α} (h : Cardinal.mk🔗<|PREMISE|>🔗 ↑s < Cardinal.mk🔗<|PREMISE|>🔗 α) :Set.Nonempty🔗<|PREMISE|>🔗 sᶜ", "code": "theorem nonempty_compl_of_mk_lt_mk (h : (#s) < (#α)) : sᶜ.Nonempty := by\n  simp_rw [Set.nonempty_iff_ne_empty, Ne.def, compl_eq_empty]\n  rintro rfl\n  simp at h\n", "additional_info": "", "used_premises": [69, 29, 29, 83], "def_path": "ConNF/Mathlib/Cardinal.lean", "pos": [18, 22], "informalization": "If the cardinality of a set `s` is less than the cardinality of the type `α`, then the complement of `s` is nonempty."}
{"full_name": "PiProp.vadd_def", "url": "ConNF/Mathlib/GroupAction.html#PiProp.vadd_def", "code_src": "con-nf", "ptype": "theorem", "header": "theorem PiProp.vadd_def {I : Prop } {f : I → Type v} (x : (i : I) → f i) {α : Type u_1} [(i : I) → VAdd🔗<|PREMISE|>🔗 α (f i)] (s : α) :s +ᵥ x = fun (i : I) => s +ᵥ x i", "code": "@[to_additive]\n", "additional_info": "", "used_premises": [557], "def_path": "ConNF/Mathlib/GroupAction.lean", "pos": [33, 34], "informalization": "Function `PiProp.vadd_def` defines the vector addition operation `+ᵥ` for a dependent function type `(i : I) → f i`, where `f : I → Type v` and `x : (i : I) → f i`. It states that for any `s : α` and `x : (i : I) → f i`, the vector addition `s +ᵥ x` is equal to the function that maps each `i : I` to `s +ᵥ x i`."}
{"full_name": "VAdd", "url": "Mathlib/Algebra/Group/Defs.html#VAdd", "code_src": "mathlib4", "ptype": "class", "header": "class VAdd (G : Type u) (P : Type v) :Type (max u v)\n | vadd : G → P → P", "code": "class VAdd (G : Type u) (P : Type v) where\n  /-- `a +ᵥ b` computes the sum of `a` and `b`. The meaning of this notation is type-dependent,\n  but it is intended to be used for left actions. -/\n  vadd : G → P → P\n", "additional_info": "Type class for the `+ᵥ` notation.\n- VAdd.vadd: `a +ᵥ b` computes the sum of `a` and `b`. The meaning of this notation is type-dependent,\nbut it is intended to be used for left actions.\n\n\n", "used_premises": [], "def_path": "Mathlib/Algebra/Group/Defs.lean", "pos": [83, 87], "informalization": "Class `VAdd` represents the concept of a vector addition operation, denoted as `+ᵥ`, which is a binary operation between elements of a type `G` (often representing vectors) and elements of a type `P` (often representing points or another vector space), resulting in an element of `P`."}
{"full_name": "PiProp.smul_def", "url": "ConNF/Mathlib/GroupAction.html#PiProp.smul_def", "code_src": "con-nf", "ptype": "theorem", "header": "theorem PiProp.smul_def {I : Prop } {f : I → Type v} (x : (i : I) → f i) {α : Type u_1} [(i : I) → SMul🔗<|PREMISE|>🔗 α (f i)] (s : α) :s • x = fun (i : I) => s • x i", "code": "theorem smul_def {α : Type _} [∀ i, SMul α <| f i] (s : α) : s • x = fun i => s • x i :=\n  rfl\n", "additional_info": "", "used_premises": [57], "def_path": "ConNF/Mathlib/GroupAction.lean", "pos": [34, 36], "informalization": "`PiProp.smul_def` is a theorem in Lean 4 that defines the scalar multiplication of an element `s : α` with a dependent function `x : (i : I) → f i`, where `f : I → Type v` and `SMul α (f i)` for each `i : I`. The theorem states that `s • x` is equal to the function that maps each `i : I` to `s • x i`."}
{"full_name": "PiProp.vadd_apply", "url": "ConNF/Mathlib/GroupAction.html#PiProp.vadd_apply", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem PiProp.vadd_apply {I : Prop } {f : I → Type v} (x : (i : I) → f i) (i : I) {α : Type u_1} [(i : I) → VAdd🔗<|PREMISE|>🔗 α (f i)] (s : α) :(s +ᵥ x) i = s +ᵥ x i", "code": "@[to_additive (attr := simp)]\n", "additional_info": "", "used_premises": [557], "def_path": "ConNF/Mathlib/GroupAction.lean", "pos": [37, 38], "informalization": "`PiProp.vadd_apply` is a theorem in Lean 4 that states that for a dependent function `x : (i : I) → f i`, the vector addition `s +ᵥ x` applied to an index `i` is equal to the vector addition of `s` and `x i`."}
{"full_name": "PiProp.smul_apply", "url": "ConNF/Mathlib/GroupAction.html#PiProp.smul_apply", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem PiProp.smul_apply {I : Prop } {f : I → Type v} (x : (i : I) → f i) (i : I) {α : Type u_1} [(i : I) → SMul🔗<|PREMISE|>🔗 α (f i)] (s : α) :(s • x) i = s • x i", "code": "theorem smul_apply {α : Type _} [∀ i, SMul α <| f i] (s : α) : (s • x) i = s • x i :=\n  rfl\n", "additional_info": "", "used_premises": [57], "def_path": "ConNF/Mathlib/GroupAction.lean", "pos": [38, 40], "informalization": "The `PiProp.smul_apply` theorem states that for any indexed family of types `f : I → Type v` and any scalar `s : α`, the application of the scalar multiplication to an element `x : (i : I) → f i` at an index `i : I` is equal to the scalar multiplication of `x i` by `s`."}
{"full_name": "PiProp.vadd_apply'", "url": "ConNF/Mathlib/GroupAction.html#PiProp.vadd_apply'", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem PiProp.vadd_apply' {I : Prop } {f : I → Type v} (i : I) {g : I → Type u_1} [(i : I) → VAdd🔗<|PREMISE|>🔗 (f i) (g i)] (s : (i : I) → f i) (x : (i : I) → g i) :(s +ᵥ x) i = s i +ᵥ x i", "code": "@[to_additive (attr := simp)]\n", "additional_info": "", "used_premises": [557], "def_path": "ConNF/Mathlib/GroupAction.lean", "pos": [45, 46], "informalization": "The theorem `PiProp.vadd_apply'` states that for any indexed family of types `f : I → Type v` and `g : I → Type u_1`, where each `f i` has a vector addition operation with each `g i`, the vector addition of a dependent function `s : (i : I) → f i` and a dependent function `x : (i : I) → g i` at an index `i : I` is equal to the vector addition of `s i` and `x i`."}
{"full_name": "PiProp.smul_apply'", "url": "ConNF/Mathlib/GroupAction.html#PiProp.smul_apply'", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem PiProp.smul_apply' {I : Prop } {f : I → Type v} (i : I) {g : I → Type u_1} [(i : I) → SMul🔗<|PREMISE|>🔗 (f i) (g i)] (s : (i : I) → f i) (x : (i : I) → g i) :(s • x) i = s i • x i", "code": "theorem smul_apply' {g : I → Type _} [∀ i, SMul (f i) (g i)] (s : ∀ i, f i) (x : ∀ i, g i) :\n    (s • x) i = s i • x i :=\n  rfl\n", "additional_info": "", "used_premises": [57], "def_path": "ConNF/Mathlib/GroupAction.lean", "pos": [46, 49], "informalization": "The `PiProp.smul_apply'` theorem states that for any indexed family of types `f : I → Type v` and `g : I → Type u_1`, where `SMul (f i) (g i)` is defined for each `i : I`, and given `s : (i : I) → f i` and `x : (i : I) → g i`, the `i`-th component of `s • x` is equal to `s i • x i`."}
{"full_name": "PiProp.has_faithful_vadd_at", "url": "ConNF/Mathlib/GroupAction.html#PiProp.has_faithful_vadd_at", "code_src": "con-nf", "ptype": "theorem", "header": "theorem PiProp.has_faithful_vadd_at {I : Prop } {f : I → Type v} {α : Type u_1} [(i : I) → VAdd🔗<|PREMISE|>🔗 α (f i)] [∀ (i : I), Nonempty🔗<|PREMISE|>🔗 (f i)] (i : I) [FaithfulVAdd🔗<|PREMISE|>🔗 α (f i)] :FaithfulVAdd🔗<|PREMISE|>🔗 α ((i : I) → f i)", "code": "@[to_additive PiProp.has_faithful_vadd_at]\n", "additional_info": "", "used_premises": [557, 212, 564, 564], "def_path": "ConNF/Mathlib/GroupAction.lean", "pos": [86, 87], "informalization": "The theorem `PiProp.has_faithful_vadd_at` states that if each `f i` has a faithful vector addition operation for each `i : I`, then the type `(i : I) → f i` also has a faithful vector addition operation. This theorem is a special case of the more general `PiProp.has_faithful_vadd` which applies when `I` is a type instead of a proposition. The proof of `PiProp.has_faithful_vadd_at` is straightforward, using the `faithfulVAdd_at` lemma which is applied to each `i : I`."}
{"full_name": "FaithfulVAdd", "url": "Mathlib/GroupTheory/GroupAction/Defs.html#FaithfulVAdd", "code_src": "mathlib4", "ptype": "class", "header": "class FaithfulVAdd (G : Type u_10) (P : Type u_11) [VAdd🔗<|PREMISE|>🔗 G P] :Prop\n | eq_of_vadd_eq_vadd : ∀ {g₁ g₂ : G}, (∀ (p : P), g₁ +ᵥ  p =  g₂ +ᵥ  p) → g₁ =  g₂", "code": "class FaithfulVAdd (G : Type*) (P : Type*) [VAdd G P] : Prop where\n  /-- Two elements `g₁` and `g₂` are equal whenever they act in the same way on all points. -/\n  eq_of_vadd_eq_vadd : ∀ {g₁ g₂ : G}, (∀ p : P, g₁ +ᵥ p = g₂ +ᵥ p) → g₁ = g₂\n", "additional_info": "Typeclass for faithful actions.\n- FaithfulVAdd.eq_of_vadd_eq_vadd: Two elements `g₁` and `g₂` are equal whenever they act in the same way on all points.\n\n\n", "used_premises": [557], "def_path": "Mathlib/GroupTheory/GroupAction/Defs.lean", "pos": [60, 63], "informalization": "Class `FaithfulVAdd` represents a faithful vector addition operation, meaning that for any two distinct elements `g₁` and `g₂` of type `G`, their vector addition results in different elements for some point of type `P`."}
{"full_name": "PiProp.faithfulSMul_at", "url": "ConNF/Mathlib/GroupAction.html#PiProp.faithfulSMul_at", "code_src": "con-nf", "ptype": "theorem", "header": "theorem PiProp.faithfulSMul_at {I : Prop } {f : I → Type v} {α : Type u_1} [(i : I) → SMul🔗<|PREMISE|>🔗 α (f i)] [∀ (i : I), Nonempty🔗<|PREMISE|>🔗 (f i)] (i : I) [FaithfulSMul🔗<|PREMISE|>🔗 α (f i)] :FaithfulSMul🔗<|PREMISE|>🔗 α ((i : I) → f i)", "code": "theorem faithfulSMul_at {α : Type _} [∀ i, SMul α <| f i] [∀ i, Nonempty (f i)] (i : I)\n    [FaithfulSMul α (f i)] : FaithfulSMul α (∀ i, f i) :=\n  ⟨fun h =>\n    eq_of_smul_eq_smul fun a : f i => by\n      classical\n      have :=\n        congr_fun (h <| Function.update (fun j => Classical.choice (‹∀ i, Nonempty (f i)› j)) i a) i\n      simpa using this⟩\n", "additional_info": "If `f i` has a faithful scalar action for a given `i`, then so does `Π i, f i`. This is\nnot an instance as `i` cannot be inferred.", "used_premises": [57, 212, 566, 566], "def_path": "ConNF/Mathlib/GroupAction.lean", "pos": [87, 95], "informalization": "The theorem `PiProp.faithfulSMul_at` states that if `f i` has a faithful scalar action for a given `i`, then the product type `Π i, f i` also has a faithful scalar action. This is not an instance because the index `i` cannot be inferred from the context."}
{"full_name": "FaithfulSMul", "url": "Mathlib/GroupTheory/GroupAction/Defs.html#FaithfulSMul", "code_src": "mathlib4", "ptype": "class", "header": "class FaithfulSMul (M : Type u_10) (α : Type u_11) [SMul🔗<|PREMISE|>🔗 M α] :Prop\n | eq_of_smul_eq_smul : ∀ {m₁ m₂ : M}, (∀ (a : α), m₁ •  a =  m₂ •  a) → m₁ =  m₂", "code": "class FaithfulSMul (M : Type*) (α : Type*) [SMul M α] : Prop where\n  /-- Two elements `m₁` and `m₂` are equal whenever they act in the same way on all points. -/\n  eq_of_smul_eq_smul : ∀ {m₁ m₂ : M}, (∀ a : α, m₁ • a = m₂ • a) → m₁ = m₂\n", "additional_info": "Typeclass for faithful actions.\n- FaithfulSMul.eq_of_smul_eq_smul: Two elements `m₁` and `m₂` are equal whenever they act in the same way on all points.\n\n\n", "used_premises": [57], "def_path": "Mathlib/GroupTheory/GroupAction/Defs.lean", "pos": [67, 70], "informalization": "Class `FaithfulSMul` represents a faithful scalar multiplication, meaning that for any two scalars `m₁` and `m₂`, if `m₁` and `m₂` act in the same way on all points, then `m₁` must be equal to `m₂`."}
{"full_name": "PiProp.addAction.proof_2", "url": "ConNF/Mathlib/GroupAction.html#PiProp.addAction.proof_2", "code_src": "con-nf", "ptype": "theorem", "header": "theorem PiProp.addAction.proof_2 {I : Prop } {f : I → Type u_1} (α : Type u_2) {m : AddMonoid🔗<|PREMISE|>🔗 α} [(i : I) → AddAction🔗<|PREMISE|>🔗 α (f i)] :∀ (x x_1 : α) (x_2 : (i : I) → f i), x + x_1 +ᵥ x_2 = x +ᵥ (x_1 +ᵥ x_2)", "code": "@[to_additive]\n", "additional_info": "", "used_premises": [31, 568], "def_path": "ConNF/Mathlib/GroupAction.lean", "pos": [102, 103], "informalization": "`PiProp.addAction` is a proof that for any type `I` (which in Lean 4 is interpreted as a logical proposition), for any family of types `f : I → Type u_1`, and for any additive monoid `α` with an additive action on each `f i`, the addition operation on `α` and the action of `α` on `f i` commute. This is a property that if holds for any `x`, `x_1` from `α` and `x_2` from `(i : I) → f i`, then `x + x_1 +ᵥ x_2` equals `x +ᵥ (x_1 +ᵥ x_2)`. This property is used to define an additive action on the Pi type `(i : I) → f i` when `α` is an additive monoid."}
{"full_name": "AddAction", "url": "Mathlib/GroupTheory/GroupAction/Defs.html#AddAction", "code_src": "mathlib4", "ptype": "class", "header": "class AddAction (G : Type u_10) (P : Type u_11) [AddMonoid🔗<|PREMISE|>🔗 G] extends VAdd🔗<|PREMISE|>🔗 :Type (max u_10 u_11)\n | vadd : G → P → P\n | zero_vadd : ∀ (p : P), 0 +ᵥ  p =  p\n | add_vadd : ∀ (g₁ g₂ : G) (p : P), g₁ +  g₂ +ᵥ  p =  g₁ +ᵥ  (g₂ +ᵥ  p)", "code": "class AddAction (G : Type*) (P : Type*) [AddMonoid G] extends VAdd G P where\n  /-- Zero is a neutral element for `+ᵥ` -/\n  protected zero_vadd : ∀ p : P, (0 : G) +ᵥ p = p\n  /-- Associativity of `+` and `+ᵥ` -/\n  add_vadd : ∀ (g₁ g₂ : G) (p : P), g₁ + g₂ +ᵥ p = g₁ +ᵥ (g₂ +ᵥ p)\n", "additional_info": "Type class for additive monoid actions.\n- AddAction.zero_vadd: Zero is a neutral element for `+ᵥ`\n\n\n- AddAction.add_vadd: Associativity of `+` and `+ᵥ`\n\n\n", "used_premises": [31, 557], "def_path": "Mathlib/GroupTheory/GroupAction/Defs.lean", "pos": [98, 103], "informalization": "Class `AddAction` represents the concept of an additive action of a monoid `G` on a type `P`, where `0 +ᵥ p = p` and `(g₁ + g₂) +ᵥ p = g₁ +ᵥ (g₂ +ᵥ p)`."}
{"full_name": "PiProp.addAction'.proof_2", "url": "ConNF/Mathlib/GroupAction.html#PiProp.addAction'.proof_2", "code_src": "con-nf", "ptype": "theorem", "header": "theorem PiProp.addAction'.proof_2 {I : Prop } {f : I → Type u_2} {g : I → Type u_1} {m : (i : I) → AddMonoid🔗<|PREMISE|>🔗 (f i)} [(i : I) → AddAction🔗<|PREMISE|>🔗 (f i) (g i)] :∀ (x x_1 : (i : I) → f i) (x_2 : (i : I) → g i), x + x_1 +ᵥ x_2 = x +ᵥ (x_1 +ᵥ x_2)", "code": "@[to_additive]\n", "additional_info": "", "used_premises": [31, 568], "def_path": "ConNF/Mathlib/GroupAction.lean", "pos": [109, 110], "informalization": "`PiProp.addAction'.proof_2` is a proof of the associativity of the `+ᵥ` operation in a family of types parameterized by a proposition `I`, where each type is equipped with an `AddMonoid` and `AddAction` instance. The theorem asserts that for any two elements of the `I → f i` type (which is a product type over `f i` for all `i : I`) and an element of the `I → g i` type, the operation `+ᵥ` is associative. This property is inherent to the `AddAction` instances on each `f i` acting on each `g i`."}
{"full_name": "Equiv.orderIso_apply", "url": "ConNF/Mathlib/Transfer.html#Equiv.orderIso_apply", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem Equiv.orderIso_apply {α : Type u_2} {β : Type u_1} (e : α ≃ β) [LE🔗<|PREMISE|>🔗 β] (a : α) :(Equiv.orderIso🔗<|PREMISE|>🔗 e) a = e a", "code": "theorem orderIso_apply [LE β] (a : α) : orderIso e a = e a :=\n  rfl\n", "additional_info": "", "used_premises": [5, 571], "def_path": "ConNF/Mathlib/Transfer.lean", "pos": [88, 90], "informalization": "Function `Equiv.orderIso` constructs an order isomorphism between two types `α` and `β` given an equivalence `e : α ≃ β` and a partial order on `β`. The application of this order isomorphism to an element `a : α` is equivalent to applying the equivalence `e` to `a`."}
{"full_name": "Equiv.orderIso", "url": "ConNF/Mathlib/Transfer.html#Equiv.orderIso", "code_src": "con-nf", "ptype": "def", "header": "def Equiv.orderIso {α : Type u_1} {β : Type u_2} (e : α ≃ β) [LE🔗<|PREMISE|>🔗 β] :α ≃o β", "code": "def orderIso (e : α ≃ β) [LE β] :\n    letI := e.hasLe\n    α ≃o β :=\n  by intros; exact { e with map_rel_iff' := fun {a b} => Iff.rfl }\n", "additional_info": "An equivalence `e : α ≃ β` gives a suptiplicative equivalence `α ≃⊔ β` where the suptiplicative\nstructure on `α` is the top obtained by transporting a suptiplicative structure on `β` back along\n`e`.\nEquations\n* 🗟Equiv.orderIso🗟🔗../.././ConNF/Mathlib/Transfer.html#Equiv.orderIso🔗  e 🗟=🗟🔗../.././Init/Prelude.html#Eq🔗  { toEquiv := e, map_rel_iff' := ⋯ }\n\n", "used_premises": [5], "def_path": "ConNF/Mathlib/Transfer.lean", "pos": [82, 86], "informalization": "Function `Equiv.orderIso` constructs an order isomorphism between two types `α` and `β` given an equivalence `e : α ≃ β` and a partial order on `β`."}
{"full_name": "Set.neg_sUnion", "url": "ConNF/Mathlib/Pointwise.html#Set.neg_sUnion", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem Set.neg_sUnion {α : Type u_1} [InvolutiveNeg🔗<|PREMISE|>🔗 α] (S : Set🔗<|PREMISE|>🔗 (Set🔗<|PREMISE|>🔗 α)) :- ⋃₀ S = ⋃ s ∈ S, - s", "code": "@[to_additive (attr := simp)]\n", "additional_info": "", "used_premises": [573, 69, 69], "def_path": "ConNF/Mathlib/Pointwise.lean", "pos": [13, 14], "informalization": "The negation of the union of a set of sets is equal to the union of the negation of each set in the set of sets."}
{"full_name": "InvolutiveNeg", "url": "Mathlib/Algebra/Group/Defs.html#InvolutiveNeg", "code_src": "mathlib4", "ptype": "class", "header": "class InvolutiveNeg (A : Type u_2) extends Neg🔗<|PREMISE|>🔗 :Type u_2\n | neg : A → A\n | neg_neg : ∀ (x : A), -  - x =  x", "code": "class InvolutiveNeg (A : Type*) extends Neg A where\n  protected neg_neg : ∀ x : A, - -x = x\n", "additional_info": "Auxiliary typeclass for types with an involutive `🗟Neg🗟🔗../../.././Init/Prelude.html#Neg🔗` .\n", "used_premises": [574], "def_path": "Mathlib/Algebra/Group/Defs.lean", "pos": [794, 796], "informalization": "Class `InvolutiveNeg` represents a type with a negation operation that is involutive, meaning applying the negation twice returns the original element."}
{"full_name": "Neg", "url": "Init/Prelude.html#Neg", "code_src": "lean4", "ptype": "class", "header": "class Neg (α : Type u) :Type u\n | neg : α → α", "code": "class Neg (α : Type u) where\n  /-- `-a` computes the negative or opposite of `a`.\n  The meaning of this notation is type-dependent. -/\n  neg : α → α\n", "additional_info": "The notation typeclass for negation.\nThis enables the notation `-a : α` where `a : α`.\n- Neg.neg: `-a` computes the negative or opposite of `a`.\nThe meaning of this notation is type-dependent.\n\n\n", "used_premises": [], "def_path": "Init/Prelude.lean", "pos": [1307, 1311], "informalization": "Class `Neg` represents the concept of negation, which is a unary operation that computes the negative or opposite of an element. This operation is type-dependent, meaning its interpretation can vary based on the specific type of the element involved."}
{"full_name": "Set.inv_sUnion", "url": "ConNF/Mathlib/Pointwise.html#Set.inv_sUnion", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem Set.inv_sUnion {α : Type u_1} [InvolutiveInv🔗<|PREMISE|>🔗 α] (S : Set🔗<|PREMISE|>🔗 (Set🔗<|PREMISE|>🔗 α)) :(⋃₀ S)⁻¹ = ⋃ s ∈ S, s⁻¹", "code": "theorem inv_sUnion (S : Set (Set α)) : (⋃₀ S)⁻¹ = ⋃ s ∈ S, s⁻¹ := by\n  simp_rw [← image_inv, image_sUnion]\n", "additional_info": "", "used_premises": [576, 69, 69], "def_path": "ConNF/Mathlib/Pointwise.lean", "pos": [14, 16], "informalization": "The theorem `Set.inv_sUnion` states that the inverse of the union of a set of sets is equal to the union of the inverses of each set in the set of sets."}
{"full_name": "InvolutiveInv", "url": "Mathlib/Algebra/Group/Defs.html#InvolutiveInv", "code_src": "mathlib4", "ptype": "class", "header": "class InvolutiveInv (G : Type u_2) extends Inv🔗<|PREMISE|>🔗 :Type u_2\n | inv : G → G\n | inv_inv : ∀ (x : G), x⁻¹ ⁻¹  =  x", "code": "class InvolutiveInv (G : Type*) extends Inv G where\n  protected inv_inv : ∀ x : G, x⁻¹⁻¹ = x\n", "additional_info": "Auxiliary typeclass for types with an involutive `🗟Inv🗟🔗../../.././Mathlib/Algebra/Group/Defs.html#Inv🔗` .\n", "used_premises": [47], "def_path": "Mathlib/Algebra/Group/Defs.lean", "pos": [801, 803], "informalization": "Class `InvolutiveInv` represents a type with an involutive inverse operation. This means that for any element `x` of the type, applying the inverse operation twice returns the original element, i.e., `x⁻¹⁻¹ = x`. This class is useful in contexts where the inverse operation is expected to be its own inverse, such as complex conjugation or taking the conjugate transpose of a matrix."}
{"full_name": "Set.addActionNonempty.proof_1", "url": "ConNF/Mathlib/Pointwise.html#Set.addActionNonempty.proof_1", "code_src": "con-nf", "ptype": "theorem", "header": "theorem Set.addActionNonempty.proof_1 {β : Type u_1} :Function.Injective🔗<|PREMISE|>🔗 fun (a : { s : Set🔗<|PREMISE|>🔗 β // Set.Nonempty🔗<|PREMISE|>🔗 s }) => ↑a", "code": "@[to_additive \"An additive action on a type gives an additive action on its nonempty sets.\"]\n", "additional_info": "", "used_premises": [89, 69, 83], "def_path": "ConNF/Mathlib/Pointwise.lean", "pos": [45, 46], "informalization": "The function `fun (a : { s : Set β // Set.Nonempty s }) => ↑a` is injective."}
{"full_name": "Equiv.symm_trans", "url": "ConNF/Mathlib/Equiv.html#Equiv.symm_trans", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem Equiv.symm_trans {α : Type u_1} {β : Type u_2} {γ : Type u_3} (f : α ≃ β) (g : β ≃ γ) :(f.trans g).symm = g.symm.trans f.symm", "code": "theorem symm_trans (f : α ≃ β) (g : β ≃ γ) : (f.trans g).symm = g.symm.trans f.symm :=\n  rfl\n", "additional_info": "", "used_premises": [], "def_path": "ConNF/Mathlib/Equiv.lean", "pos": [7, 9], "informalization": "The theorem `Equiv.symm_trans` states that for any two equivalences `f : α ≃ β` and `g : β ≃ γ`, the inverse of their composition `f.trans g` is equal to the composition of their inverses `g.symm.trans f.symm`."}
{"full_name": "PiProp.addSemigroup.proof_1", "url": "ConNF/Mathlib/Group.html#PiProp.addSemigroup.proof_1", "code_src": "con-nf", "ptype": "theorem", "header": "theorem PiProp.addSemigroup.proof_1 {I : Prop } {f : I → Type u_1} [(i : I) → AddSemigroup🔗<|PREMISE|>🔗 (f i)] (a : (i : I) → f i) (b : (i : I) → f i) (c : (i : I) → f i) :a + b + c = a + (b + c)", "code": "@[to_additive]\n", "additional_info": "", "used_premises": [32], "def_path": "ConNF/Mathlib/Group.lean", "pos": [38, 39], "informalization": "`PiProp.addSemigroup.proof_1` is a proof of the associativity of addition in a product of additive semigroups."}
{"full_name": "PiProp.addCommSemigroup.proof_1", "url": "ConNF/Mathlib/Group.html#PiProp.addCommSemigroup.proof_1", "code_src": "con-nf", "ptype": "theorem", "header": "theorem PiProp.addCommSemigroup.proof_1 {I : Prop } {f : I → Type u_1} [(i : I) → AddCommSemigroup🔗<|PREMISE|>🔗 (f i)] (a : (i : I) → f i) (b : (i : I) → f i) :a + b = b + a", "code": "@[to_additive]\n", "additional_info": "", "used_premises": [581], "def_path": "ConNF/Mathlib/Group.lean", "pos": [51, 52], "informalization": "The `PiProp.addCommSemigroup.proof_1` theorem is a proof that the binary operation `+` on the set `(I → Type u_1)` of functions from a type `I` to a type `Type u_1`, where each `f i` is an `AddCommSemigroup`, is commutative. This is because `+` is defined pointwise on the components of the functions, and for each `i`, the operation `+` on `f i` is commutative by the `AddCommSemigroup` assumption."}
{"full_name": "AddCommSemigroup", "url": "Mathlib/Algebra/Group/Defs.html#AddCommSemigroup", "code_src": "mathlib4", "ptype": "class", "header": "class AddCommSemigroup (G : Type u) extends AddSemigroup🔗<|PREMISE|>🔗 :Type u\n | add : G → G → G\n | add_assoc : ∀ (a b c : G), a +  b +  c =  a +  (b +  c)\n | add_comm : ∀ (a b : G), a +  b =  b +  a", "code": "class AddCommSemigroup (G : Type u) extends AddSemigroup G, AddCommMagma G where\n", "additional_info": "A commutative additive semigroup is a type with an associative commutative `(+)`.\n- AddCommSemigroup.add_comm: Addition is commutative in an commutative additive magma.\n\n\n", "used_premises": [32], "def_path": "Mathlib/Algebra/Group/Defs.lean", "pos": [315, 316], "informalization": "Class `AddCommSemigroup` represents a type with an associative and commutative addition operation."}
{"full_name": "PiProp.addZeroClass.proof_1", "url": "ConNF/Mathlib/Group.html#PiProp.addZeroClass.proof_1", "code_src": "con-nf", "ptype": "theorem", "header": "theorem PiProp.addZeroClass.proof_1 {I : Prop } {f : I → Type u_1} [(i : I) → AddZeroClass🔗<|PREMISE|>🔗 (f i)] (a : (i : I) → f i) :0 + a = a", "code": "@[to_additive]\n", "additional_info": "", "used_premises": [583], "def_path": "ConNF/Mathlib/Group.lean", "pos": [57, 58], "informalization": "The theorem `PiProp.addZeroClass.proof_1` states that for any type family `f : I → Type u_1` where each `f i` is an `AddZeroClass`, the zero element of the product type `(i : I) → f i` (denoted as `0`) added to any element `a` of the product type results in `a`."}
{"full_name": "AddZeroClass", "url": "Mathlib/Algebra/Group/Defs.html#AddZeroClass", "code_src": "mathlib4", "ptype": "class", "header": "class AddZeroClass (M : Type u) extends Zero🔗<|PREMISE|>🔗 , Add🔗<|PREMISE|>🔗 :Type u\n | zero : M\n | add : M → M → M\n | zero_add : ∀ (a : M), 0 +  a =  a\n | add_zero : ∀ (a : M), a +  0 =  a", "code": "class AddZeroClass (M : Type u) extends Zero M, Add M where\n  /-- Zero is a left neutral element for addition -/\n  protected zero_add : ∀ a : M, 0 + a = a\n  /-- Zero is a right neutral element for addition -/\n  protected add_zero : ∀ a : M, a + 0 = a\n", "additional_info": "Typeclass for expressing that a type `M` with addition and a zero satisfies\n`0 + a = a` and `a + 0 = a` for all `a : M`.\n- AddZeroClass.zero_add: Zero is a left neutral element for addition\n\n\n- AddZeroClass.add_zero: Zero is a right neutral element for addition\n\n\n", "used_premises": [20, 33], "def_path": "Mathlib/Algebra/Group/Defs.lean", "pos": [449, 454], "informalization": "Class `AddZeroClass` represents a type with an additive identity (zero) and an addition operation that satisfies both left and right neutrality of zero."}
{"full_name": "PiProp.addZeroClass.proof_2", "url": "ConNF/Mathlib/Group.html#PiProp.addZeroClass.proof_2", "code_src": "con-nf", "ptype": "theorem", "header": "theorem PiProp.addZeroClass.proof_2 {I : Prop } {f : I → Type u_1} [(i : I) → AddZeroClass🔗<|PREMISE|>🔗 (f i)] (a : (i : I) → f i) :a + 0 = a", "code": "@[to_additive]\n", "additional_info": "", "used_premises": [583], "def_path": "ConNF/Mathlib/Group.lean", "pos": [57, 58], "informalization": "`PiProp.addZeroClass.proof_2` is a proof of the statement that for any type family `f : I → Type u_1` where each `f i` is an `AddZeroClass`, and any dependent function `a : (i : I) → f i`, the equation `a + 0 = a` holds."}
{"full_name": "PiProp.addMonoid.proof_4", "url": "ConNF/Mathlib/Group.html#PiProp.addMonoid.proof_4", "code_src": "con-nf", "ptype": "theorem", "header": "theorem PiProp.addMonoid.proof_4 {I : Prop } {f : I → Type u_1} [inst : (i : I) → AddMonoid🔗<|PREMISE|>🔗 (f i)] (n : ℕ ) (a : (i : I) → f i) :(fun (n : ℕ ) (x : (i : I) → f i) (i : I) => n • x i) (n + 1) a = a + (fun (n : ℕ ) (x : (i : I) → f i) (i : I) => n • x i) n a", "code": "@[to_additive]\n", "additional_info": "", "used_premises": [31], "def_path": "ConNF/Mathlib/Group.lean", "pos": [65, 66], "informalization": "The theorem `PiProp.addMonoid.proof_4` in Lean 4 is a part of the proof that the Pi-type `(I → f i)` forms an additive monoid when each `f i` is an additive monoid. It asserts that the addition of a natural number `n` to each element of a function-type `(i : I) → f i` at each index `i`, followed by the addition of a function-type `(i : I) → f i` itself, results in the function-type being unchanged when `n = 1`. This is essentially the property that the addition of `1` to a natural number `n` results in a function that is the identity function on `f i` at each index `i`."}
{"full_name": "PiProp.addMonoid.proof_1", "url": "ConNF/Mathlib/Group.html#PiProp.addMonoid.proof_1", "code_src": "con-nf", "ptype": "theorem", "header": "theorem PiProp.addMonoid.proof_1 {I : Prop } {f : I → Type u_1} [inst : (i : I) → AddMonoid🔗<|PREMISE|>🔗 (f i)] (a : (i : I) → f i) :0 + a = a", "code": "@[to_additive]\n", "additional_info": "", "used_premises": [31], "def_path": "ConNF/Mathlib/Group.lean", "pos": [65, 66], "informalization": "`PiProp.addMonoid.proof_1` is a proof that for any type `I` and any family of types `f : I → Type u_1`, if each `f i` is an `AddMonoid`, then the addition defined pointwise on the product type `(i : I) → f i` satisfies the property of an additive monoid that `0 + a = a`. This is one of the axioms of an additive monoid, stating that the zero element, when added to any element, results in the original element."}
{"full_name": "PiProp.addMonoid.proof_2", "url": "ConNF/Mathlib/Group.html#PiProp.addMonoid.proof_2", "code_src": "con-nf", "ptype": "theorem", "header": "theorem PiProp.addMonoid.proof_2 {I : Prop } {f : I → Type u_1} [inst : (i : I) → AddMonoid🔗<|PREMISE|>🔗 (f i)] (a : (i : I) → f i) :a + 0 = a", "code": "@[to_additive]\n", "additional_info": "", "used_premises": [31], "def_path": "ConNF/Mathlib/Group.lean", "pos": [65, 66], "informalization": "The theorem `PiProp.addMonoid.proof_2` states that for any family of types `f : I → Type u_1` where each `f i` is an additive monoid, the sum of any function `a : (i : I) → f i` with the zero function is equal to `a`."}
{"full_name": "PiProp.addMonoid.proof_3", "url": "ConNF/Mathlib/Group.html#PiProp.addMonoid.proof_3", "code_src": "con-nf", "ptype": "theorem", "header": "theorem PiProp.addMonoid.proof_3 {I : Prop } {f : I → Type u_1} [inst : (i : I) → AddMonoid🔗<|PREMISE|>🔗 (f i)] (a : (i : I) → f i) :(fun (n : ℕ ) (x : (i : I) → f i) (i : I) => n • x i) 0 a = 0", "code": "@[to_additive]\n", "additional_info": "", "used_premises": [31], "def_path": "ConNF/Mathlib/Group.lean", "pos": [65, 66], "informalization": "`PiProp.addMonoid.proof_3` proves that for any type family `f : I → Type u_1` where each `f i` is an additive monoid, and any `a : (i : I) → f i`, the operation `(fun (n : ℕ) (x : (i : I) → f i) (i : I) ↦ n • x i)` applied to `0` and `a` results in `0`."}
{"full_name": "PiProp.addCommMonoid.proof_1", "url": "ConNF/Mathlib/Group.html#PiProp.addCommMonoid.proof_1", "code_src": "con-nf", "ptype": "theorem", "header": "theorem PiProp.addCommMonoid.proof_1 {I : Prop } {f : I → Type u_1} [(i : I) → AddCommMonoid🔗<|PREMISE|>🔗 (f i)] (a : (i : I) → f i) (b : (i : I) → f i) :a + b = b + a", "code": "@[to_additive]\n", "additional_info": "", "used_premises": [590], "def_path": "ConNF/Mathlib/Group.lean", "pos": [74, 75], "informalization": "`PiProp.addCommMonoid.proof_1` is a proof that for any family of additive commutative monoids, the Pi type of that family is also an additive commutative monoid, where the addition operation is defined component-wise. This is essentially stating that the addition operation in the Pi type is commutative."}
{"full_name": "AddCommMonoid", "url": "Mathlib/Algebra/Group/Defs.html#AddCommMonoid", "code_src": "mathlib4", "ptype": "class", "header": "class AddCommMonoid (M : Type u) extends AddMonoid🔗<|PREMISE|>🔗 :Type u\n | add : M → M → M\n | add_assoc : ∀ (a b c : M), a +  b +  c =  a +  (b +  c)\n | zero : M\n | zero_add : ∀ (a : M), 0 +  a =  a\n | add_zero : ∀ (a : M), a +  0 =  a\n | nsmul : ℕ  → M → M\n | nsmul_zero : ∀ (x : M), AddMonoid.nsmul🔗<|PREMISE|>🔗  0 x =  0\n | nsmul_succ : ∀ (n : ℕ ) (x : M), AddMonoid.nsmul🔗<|PREMISE|>🔗  (n +  1) x =  x +  AddMonoid.nsmul🔗<|PREMISE|>🔗  n x\n | add_comm : ∀ (a b : M), a +  b =  b +  a", "code": "class AddCommMonoid (M : Type u) extends AddMonoid M, AddCommSemigroup M\n", "additional_info": "An additive commutative monoid is an additive monoid with commutative `(+)`.\n- AddCommMonoid.add_comm: Addition is commutative in an commutative additive magma.\n\n\n", "used_premises": [31, 34, 34, 34], "def_path": "Mathlib/Algebra/Group/Defs.lean", "pos": [674, 675], "informalization": "Class `AddCommMonoid` represents the concept of an additive commutative monoid. An additive commutative monoid is an additive monoid (a type with an associative addition operation, a zero element, and a natural number multiplication operation) where the addition operation is commutative."}
{"full_name": "PiProp.subNegMonoid.proof_2", "url": "ConNF/Mathlib/Group.html#PiProp.subNegMonoid.proof_2", "code_src": "con-nf", "ptype": "theorem", "header": "theorem PiProp.subNegMonoid.proof_2 {I : Prop } {f : I → Type u_1} [inst : (i : I) → SubNegMonoid🔗<|PREMISE|>🔗 (f i)] :∀ (a : (i : I) → f i), zsmulRec 0 a = zsmulRec 0 a", "code": "@[to_additive PiProp.subNegMonoid]\n", "additional_info": "", "used_premises": [592], "def_path": "ConNF/Mathlib/Group.lean", "pos": [80, 81], "informalization": "Given a type I, the Pi type (I → Type u_1) is also a SubNegMonoid if each component type (f i) is a SubNegMonoid. The theorem `PiProp.subNegMonoid.proof_2` is a part of the proof that the Pi type (I → Type u_1) is a SubNegMonoid. The theorem states that for any element a of the type (I → Type u_1), multiplying a by 0 using the integer scalar multiplication `zsmulRec` (which is a recursive version of `zsmul`) results in the same value as multiplying a by 0 using `zsmulRec`. This is the second part of the proof that `zsmulRec 0 a` is equal to `zsmulRec 0 a`, which is a trivial equality and does not require any further simplification."}
{"full_name": "SubNegMonoid", "url": "Mathlib/Algebra/Group/Defs.html#SubNegMonoid", "code_src": "mathlib4", "ptype": "class", "header": "class SubNegMonoid (G : Type u) extends AddMonoid🔗<|PREMISE|>🔗 , Neg🔗<|PREMISE|>🔗 , Sub🔗<|PREMISE|>🔗 :Type u\n | add : G → G → G\n | add_assoc : ∀ (a b c : G), a +  b +  c =  a +  (b +  c)\n | zero : G\n | zero_add : ∀ (a : G), 0 +  a =  a\n | add_zero : ∀ (a : G), a +  0 =  a\n | nsmul : ℕ  → G → G\n | nsmul_zero : ∀ (x : G), AddMonoid.nsmul🔗<|PREMISE|>🔗  0 x =  0\n | nsmul_succ : ∀ (n : ℕ ) (x : G), AddMonoid.nsmul🔗<|PREMISE|>🔗  (n +  1) x =  x +  AddMonoid.nsmul🔗<|PREMISE|>🔗  n x\n | neg : G → G\n | sub : G → G → G\n | sub_eq_add_neg : ∀ (a b : G), a -  b =  a +  - b\n | zsmul : ℤ  → G → G\n | zsmul_zero' : ∀ (a : G), SubNegMonoid.zsmul🔗<|PREMISE|>🔗  0 a =  0\n | zsmul_succ' : ∀ (n : ℕ ) (a : G), SubNegMonoid.zsmul🔗<|PREMISE|>🔗  (Int.ofNat🔗<|PREMISE|>🔗  (Nat.succ🔗<|PREMISE|>🔗  n)) a =  a +  SubNegMonoid.zsmul🔗<|PREMISE|>🔗  (Int.ofNat🔗<|PREMISE|>🔗  n) a\n | zsmul_neg' : ∀ (n : ℕ ) (a : G), SubNegMonoid.zsmul🔗<|PREMISE|>🔗  (Int.negSucc🔗<|PREMISE|>🔗  n) a =  - SubNegMonoid.zsmul🔗<|PREMISE|>🔗  (↑(Nat.succ🔗<|PREMISE|>🔗  n)) a", "code": "class SubNegMonoid (G : Type u) extends AddMonoid G, Neg G, Sub G where\n  protected sub := SubNegMonoid.sub'\n  protected sub_eq_add_neg : ∀ a b : G, a - b = a + -b := by intros; rfl\n  protected zsmul : ℤ → G → G := zsmulRec\n  protected zsmul_zero' : ∀ a : G, zsmul 0 a = 0 := by intros; rfl\n  protected zsmul_succ' (n : ℕ) (a : G) :\n      zsmul (Int.ofNat n.succ) a = a + zsmul (Int.ofNat n) a := by\n    intros; rfl\n  protected zsmul_neg' (n : ℕ) (a : G) : zsmul (Int.negSucc n) a = -zsmul n.succ a := by intros; rfl\n", "additional_info": "A `🗟SubNegMonoid🗟🔗../../.././Mathlib/Algebra/Group/Defs.html#SubNegMonoid🔗`  is an `🗟AddMonoid🗟🔗../../.././Mathlib/Algebra/Group/Defs.html#AddMonoid🔗`  with unary `-` and binary `-` operations\nsatisfying `🗟sub_eq_add_neg🗟🔗../../.././Mathlib/Algebra/Group/Defs.html#sub_eq_add_neg🔗  : ∀ a b, a - b = a + -b`.\nThe default for `sub` is such that `a - b = a + -b` holds by definition.\nAdding `sub` as a field rather than defining `a - b := a + -b` allows us to\navoid certain classes of unification failures, for example:\nLet `foo X` be a type with a `∀ X, 🗟Sub🗟🔗../../.././Init/Prelude.html#Sub🔗  (Foo X)` instance but no\n`∀ X, 🗟Neg🗟🔗../../.././Init/Prelude.html#Neg🔗  (Foo X)`. Suppose we also have an instance\n`∀ X [Cromulent X], 🗟AddGroup🗟🔗../../.././Mathlib/Algebra/Group/Defs.html#AddGroup🔗  (Foo X)`. Then the `(-)` coming from\n`AddGroup.sub` cannot be definitionally equal to the `(-)` coming from\n`Foo.🗟Sub🗟🔗../../.././Init/Prelude.html#Sub🔗` .\nIn the same way, adding a `🗟zsmul🗟🔗../../.././Mathlib/Algebra/Group/Defs.html#SubNegMonoid.zsmul🔗`  field makes it possible to avoid definitional failures\nin diamonds. See the definition of `🗟AddMonoid🗟🔗../../.././Mathlib/Algebra/Group/Defs.html#AddMonoid🔗`  and Note [forgetful inheritance] for more\nexplanations on this.\n", "used_premises": [31, 574, 35, 34, 34, 34, 593, 593, 50, 53, 593, 50, 593, 54, 593, 53], "def_path": "Mathlib/Algebra/Group/Defs.lean", "pos": [918, 927], "informalization": "Class `SubNegMonoid` represents the concept of a type `G` that extends an additive monoid (`AddMonoid`) with additional operations: negation (`Neg`) and subtraction (`Sub`). This algebraic structure includes all the properties of an additive monoid, such as associative addition, a zero element, and natural number scalar multiplication (`nsmul`), along with the unary operation of negation and the binary operation of subtraction. The subtraction operation is defined in terms of addition and negation, satisfying the property `sub_eq_add_neg`, which states that subtracting an element is equivalent to adding its negation. Additionally, `SubNegMonoid` introduces integer scalar multiplication (`zsmul`), which extends the natural number scalar multiplication to include negative integers, providing a more comprehensive framework for handling scalar operations in the context of additive structures. This class is designed to avoid certain unification failures and definitional ambiguities that can arise in more complex type hierarchies, ensuring a robust and flexible approach to defining and working with additive algebraic structures."}
{"full_name": "SubNegMonoid.zsmul", "url": "Mathlib/Algebra/Group/Defs.html#SubNegMonoid", "code_src": "mathlib4", "ptype": "structure_field", "header": "structure_field SubNegMonoid🔗<|PREMISE|>🔗.zsmul : ℤ  → G → G", "code": "class SubNegMonoid (G : Type u) extends AddMonoid G, Neg G, Sub G where\n  protected sub := SubNegMonoid.sub'\n  protected sub_eq_add_neg : ∀ a b : G, a - b = a + -b := by intros; rfl\n  protected zsmul : ℤ → G → G := zsmulRec\n  protected zsmul_zero' : ∀ a : G, zsmul 0 a = 0 := by intros; rfl\n  protected zsmul_succ' (n : ℕ) (a : G) :\n      zsmul (Int.ofNat n.succ) a = a + zsmul (Int.ofNat n) a := by\n    intros; rfl\n  protected zsmul_neg' (n : ℕ) (a : G) : zsmul (Int.negSucc n) a = -zsmul n.succ a := by intros; rfl\n", "additional_info": "", "used_premises": [592], "def_path": "Mathlib/Algebra/Group/Defs.lean", "pos": [918, 927], "informalization": "Function `SubNegMonoid.zsmul` takes an integer and an element from a type `G` that extends an additive monoid with negation and subtraction, and returns the result of their multiplication, extending natural number scalar multiplication to include negative integers."}
{"full_name": "PiProp.subNegMonoid.proof_1", "url": "ConNF/Mathlib/Group.html#PiProp.subNegMonoid.proof_1", "code_src": "con-nf", "ptype": "theorem", "header": "theorem PiProp.subNegMonoid.proof_1 {I : Prop } {f : I → Type u_1} [inst : (i : I) → SubNegMonoid🔗<|PREMISE|>🔗 (f i)] (a : (i : I) → f i) (b : (i : I) → f i) :a - b = a + - b", "code": "@[to_additive PiProp.subNegMonoid]\n", "additional_info": "", "used_premises": [592], "def_path": "ConNF/Mathlib/Group.lean", "pos": [80, 81], "informalization": "The theorem `PiProp.subNegMonoid.proof_1` states that for any type family `f : I → Type u_1` where each `f i` is a `SubNegMonoid`, the subtraction operation on the Pi type `(i : I) → f i` is equivalent to addition with the negation of the second operand."}
{"full_name": "PiProp.subNegMonoid.proof_4", "url": "ConNF/Mathlib/Group.html#PiProp.subNegMonoid.proof_4", "code_src": "con-nf", "ptype": "theorem", "header": "theorem PiProp.subNegMonoid.proof_4 {I : Prop } {f : I → Type u_1} [inst : (i : I) → SubNegMonoid🔗<|PREMISE|>🔗 (f i)] :∀ (n : ℕ ) (a : (i : I) → f i), zsmulRec (Int.negSucc🔗<|PREMISE|>🔗 n) a = zsmulRec (Int.negSucc🔗<|PREMISE|>🔗 n) a", "code": "@[to_additive PiProp.subNegMonoid]\n", "additional_info": "", "used_premises": [592, 54, 54], "def_path": "ConNF/Mathlib/Group.lean", "pos": [80, 81], "informalization": "The `PiProp.subNegMonoid.proof_4` theorem is a proof of the property that `zsmulRec (Int.negSucc n) a` equals itself, which is a part of extending the `SubNegMonoid` class to the pi-type `∀ i, f i` where each `f i` is a `SubNegMonoid`. This theorem ensures that the negation operation `zsmulRec` on negative integers satisfies the properties required by the `SubNegMonoid` class."}
{"full_name": "PiProp.subNegMonoid.proof_3", "url": "ConNF/Mathlib/Group.html#PiProp.subNegMonoid.proof_3", "code_src": "con-nf", "ptype": "theorem", "header": "theorem PiProp.subNegMonoid.proof_3 {I : Prop } {f : I → Type u_1} [inst : (i : I) → SubNegMonoid🔗<|PREMISE|>🔗 (f i)] :∀ (n : ℕ ) (a : (i : I) → f i), zsmulRec (Int.ofNat🔗<|PREMISE|>🔗 (Nat.succ🔗<|PREMISE|>🔗 n)) a = zsmulRec (Int.ofNat🔗<|PREMISE|>🔗 (Nat.succ🔗<|PREMISE|>🔗 n)) a", "code": "@[to_additive PiProp.subNegMonoid]\n", "additional_info": "", "used_premises": [592, 50, 53, 50, 53], "def_path": "ConNF/Mathlib/Group.lean", "pos": [80, 81], "informalization": "The proof `PiProp.subNegMonoid.proof_3` is a part of the proof that the Pi type (a dependent function type) of `SubNegMonoid`s is itself a `SubNegMonoid`. This proof is specifically for the case when the exponent in the zsmul (scalar multiplication by an integer) is a natural number with a successor (i.e., a whole number plus one). It asserts that for any natural number `n` and any dependent function `a` (an element of the Pi type), the zsmul operation using `Int.ofNat (Nat.succ n)` (which represents the successor of `n` as an integer) on `a` is equal to itself, which is a trivial statement in the context of the successor operation. This proof is part of the construction of the `SubNegMonoid` instance for the Pi type, which is necessary for the development of the Lean mathematical library."}
{"full_name": "PiProp.hasInvolutiveNeg.proof_1", "url": "ConNF/Mathlib/Group.html#PiProp.hasInvolutiveNeg.proof_1", "code_src": "con-nf", "ptype": "theorem", "header": "theorem PiProp.hasInvolutiveNeg.proof_1 {I : Prop } {f : I → Type u_1} [(i : I) → InvolutiveNeg🔗<|PREMISE|>🔗 (f i)] (a : (i : I) → f i) :- - a = a", "code": "@[to_additive]\n", "additional_info": "", "used_premises": [573], "def_path": "ConNF/Mathlib/Group.lean", "pos": [87, 88], "informalization": "The theorem `PiProp.hasInvolutiveNeg.proof_1` states that for any family of types `f : I → Type u_1` where each type `f i` has an involutive negation, the negation of a dependent function `a : (i : I) → f i` is equal to the function itself, i.e., `- - a = a`."}
{"full_name": "PiProp.subtractionMonoid.proof_1", "url": "ConNF/Mathlib/Group.html#PiProp.subtractionMonoid.proof_1", "code_src": "con-nf", "ptype": "theorem", "header": "theorem PiProp.subtractionMonoid.proof_1 {I : Prop } {f : I → Type u_1} [inst : (i : I) → SubtractionMonoid🔗<|PREMISE|>🔗 (f i)] (x : (i : I) → f i) :- - x = x", "code": "@[to_additive PiProp.subtractionMonoid]\n", "additional_info": "", "used_premises": [599], "def_path": "ConNF/Mathlib/Group.lean", "pos": [93, 94], "informalization": "This theorem states that, for any function `x` from a type `I` to a family of types `f i`, where each `f i` is a `SubtractionMonoid`, the negation of `x` is equal to `x` itself. This property only holds under certain conditions, specifically when the domain `I` is a proposition, which means it contains only two elements: `True` and `False`. In this context, `x`, being a function from a proposition to a type, essentially represents a single value when evaluated at `True` or `False`. The negation of `x`, which in the context of `SubtractionMonoid` is defined as `-x`, results in the same value as `x`, as indicated by the equation `- - x = x`. This behavior aligns with the properties of `SubtractionMonoid`, where negating a number twice returns the original number, and thus, negating a function from a proposition to a `SubtractionMonoid` type results in the same function."}
{"full_name": "SubtractionMonoid", "url": "Mathlib/Algebra/Group/Defs.html#SubtractionMonoid", "code_src": "mathlib4", "ptype": "class", "header": "class SubtractionMonoid (G : Type u) extends SubNegMonoid🔗<|PREMISE|>🔗 :Type u\n | add : G → G → G\n | add_assoc : ∀ (a b c : G), a +  b +  c =  a +  (b +  c)\n | zero : G\n | zero_add : ∀ (a : G), 0 +  a =  a\n | add_zero : ∀ (a : G), a +  0 =  a\n | nsmul : ℕ  → G → G\n | nsmul_zero : ∀ (x : G), AddMonoid.nsmul🔗<|PREMISE|>🔗  0 x =  0\n | nsmul_succ : ∀ (n : ℕ ) (x : G), AddMonoid.nsmul🔗<|PREMISE|>🔗  (n +  1) x =  x +  AddMonoid.nsmul🔗<|PREMISE|>🔗  n x\n | neg : G → G\n | sub : G → G → G\n | sub_eq_add_neg : ∀ (a b : G), a -  b =  a +  - b\n | zsmul : ℤ  → G → G\n | zsmul_zero' : ∀ (a : G), SubNegMonoid.zsmul🔗<|PREMISE|>🔗  0 a =  0\n | zsmul_succ' : ∀ (n : ℕ ) (a : G), SubNegMonoid.zsmul🔗<|PREMISE|>🔗  (Int.ofNat🔗<|PREMISE|>🔗  (Nat.succ🔗<|PREMISE|>🔗  n)) a =  a +  SubNegMonoid.zsmul🔗<|PREMISE|>🔗  (Int.ofNat🔗<|PREMISE|>🔗  n) a\n | zsmul_neg' : ∀ (n : ℕ ) (a : G), SubNegMonoid.zsmul🔗<|PREMISE|>🔗  (Int.negSucc🔗<|PREMISE|>🔗  n) a =  - SubNegMonoid.zsmul🔗<|PREMISE|>🔗  (↑(Nat.succ🔗<|PREMISE|>🔗  n)) a\n | neg_neg : ∀ (x : G), -  - x =  x\n | neg_add_rev : ∀ (a b : G), - (a +  b) =  - b +  - a\n | neg_eq_of_add : ∀ (a b : G), a +  b =  0 → - a =  b", "code": "class SubtractionMonoid (G : Type u) extends SubNegMonoid G, InvolutiveNeg G where\n  protected neg_add_rev (a b : G) : -(a + b) = -b + -a\n  /- Despite the asymmetry of `neg_eq_of_add`, the symmetric version is true thanks to the\n  involutivity of negation. -/\n  protected neg_eq_of_add (a b : G) : a + b = 0 → -a = b\n", "additional_info": "A `🗟SubtractionMonoid🗟🔗../../.././Mathlib/Algebra/Group/Defs.html#SubtractionMonoid🔗`  is a `🗟SubNegMonoid🗟🔗../../.././Mathlib/Algebra/Group/Defs.html#SubNegMonoid🔗`  with involutive negation and such that\n`-(a + b) = -b + -a` and `a + b = 0 → -a = b`.\n", "used_premises": [592, 34, 34, 34, 593, 593, 50, 53, 593, 50, 593, 54, 593, 53], "def_path": "Mathlib/Algebra/Group/Defs.lean", "pos": [1039, 1044], "informalization": "The `SubtractionMonoid` class in Lean 4 is an extension of the `SubNegMonoid` class, which represents a type `G` that extends an additive monoid with additional operations: negation (`Neg`) and subtraction (`Sub`). This algebraic structure includes all the properties of an additive monoid, such as associative addition, a zero element, and natural number scalar multiplication (`nsmul`), along with the unary operation of negation and the binary operation of subtraction. The subtraction operation is defined in terms of addition and negation, satisfying the property `sub_eq_add_neg`, which states that subtracting an element is equivalent to adding its negation. Additionally, `SubtractionMonoid` introduces integer scalar multiplication (`zsmul`), which extends the natural number scalar multiplication to include negative integers, providing a more comprehensive framework for handling scalar operations in the context of additive algebraic structures. This class is designed to avoid certain unification failures and definitional ambiguities that can arise in more complex type hierarchies, ensuring a robust and flexible approach to defining and working with additive algebraic structures."}
{"full_name": "PiProp.subtractionMonoid.proof_2", "url": "ConNF/Mathlib/Group.html#PiProp.subtractionMonoid.proof_2", "code_src": "con-nf", "ptype": "theorem", "header": "theorem PiProp.subtractionMonoid.proof_2 {I : Prop } {f : I → Type u_1} [inst : (i : I) → SubtractionMonoid🔗<|PREMISE|>🔗 (f i)] (a : (i : I) → f i) (b : (i : I) → f i) :- (a + b) = - b + - a", "code": "@[to_additive PiProp.subtractionMonoid]\n", "additional_info": "", "used_premises": [599], "def_path": "ConNF/Mathlib/Group.lean", "pos": [93, 94], "informalization": "`PiProp.subtractionMonoid.proof_2` is a proof of the property for the negation operation in the `SubtractionMonoid` class in Lean 4. It states that for any two elements `a` and `b` in the product type `(i : I) → f i`, where each component `f i` is a subtraction monoid, the negation of the sum `- (a + b)` is equal to the sum of the negations `- b + - a`. This property is crucial for establishing the full subtraction monoid structure in the product type."}
{"full_name": "PiProp.subtractionMonoid.proof_3", "url": "ConNF/Mathlib/Group.html#PiProp.subtractionMonoid.proof_3", "code_src": "con-nf", "ptype": "theorem", "header": "theorem PiProp.subtractionMonoid.proof_3 {I : Prop } {f : I → Type u_1} [inst : (i : I) → SubtractionMonoid🔗<|PREMISE|>🔗 (f i)] (a : (i : I) → f i) (b : (i : I) → f i) (h : a + b = 0) :- a = b", "code": "@[to_additive PiProp.subtractionMonoid]\n", "additional_info": "", "used_premises": [599], "def_path": "ConNF/Mathlib/Group.lean", "pos": [93, 94], "informalization": "In mathematics, the concept of subtraction is defined as the inverse of addition. In an algebraic structure where addition is commutative, subtraction is well-defined as a binary operation, and the structure is known as a commutative group. The `SubtractionMonoid` class in Lean 4 represents a type `G` that extends an additive monoid with additional operations, including subtraction. Given an instance of `SubtractionMonoid` for a type `G`, we can define a subtraction operation `a - b` on elements of `G` using the `Sub.sub` function. The theorem `PiProp.subtractionMonoid.proof_3` asserts that for a type `G` that is a `SubtractionMonoid`, in a pointwise manner, if the sum of two elements `a` and `b` of type `G` is equal to zero, then `a` must be equal to `b`. This theorem is crucial for establishing the uniqueness of negation in a `SubtractionMonoid`, which is part of the definition of a `SubtractionMonoid`."}
{"full_name": "PiProp.subtractionCommMonoid.proof_1", "url": "ConNF/Mathlib/Group.html#PiProp.subtractionCommMonoid.proof_1", "code_src": "con-nf", "ptype": "theorem", "header": "theorem PiProp.subtractionCommMonoid.proof_1 {I : Prop } {f : I → Type u_1} [(i : I) → SubtractionCommMonoid🔗<|PREMISE|>🔗 (f i)] (a : (i : I) → f i) (b : (i : I) → f i) :a + b = b + a", "code": "@[to_additive PiProp.subtractionCommMonoid]\n", "additional_info": "", "used_premises": [603], "def_path": "ConNF/Mathlib/Group.lean", "pos": [101, 102], "informalization": "`PiProp.subtractionCommMonoid.proof_1` is a proof of the commutativity of addition in a product of subtraction commutative monoids."}
{"full_name": "SubtractionCommMonoid", "url": "Mathlib/Algebra/Group/Defs.html#SubtractionCommMonoid", "code_src": "mathlib4", "ptype": "class", "header": "class SubtractionCommMonoid (G : Type u) extends SubtractionMonoid🔗<|PREMISE|>🔗 :Type u\n | add : G → G → G\n | add_assoc : ∀ (a b c : G), a +  b +  c =  a +  (b +  c)\n | zero : G\n | zero_add : ∀ (a : G), 0 +  a =  a\n | add_zero : ∀ (a : G), a +  0 =  a\n | nsmul : ℕ  → G → G\n | nsmul_zero : ∀ (x : G), AddMonoid.nsmul🔗<|PREMISE|>🔗  0 x =  0\n | nsmul_succ : ∀ (n : ℕ ) (x : G), AddMonoid.nsmul🔗<|PREMISE|>🔗  (n +  1) x =  x +  AddMonoid.nsmul🔗<|PREMISE|>🔗  n x\n | neg : G → G\n | sub : G → G → G\n | sub_eq_add_neg : ∀ (a b : G), a -  b =  a +  - b\n | zsmul : ℤ  → G → G\n | zsmul_zero' : ∀ (a : G), SubNegMonoid.zsmul🔗<|PREMISE|>🔗  0 a =  0\n | zsmul_succ' : ∀ (n : ℕ ) (a : G), SubNegMonoid.zsmul🔗<|PREMISE|>🔗  (Int.ofNat🔗<|PREMISE|>🔗  (Nat.succ🔗<|PREMISE|>🔗  n)) a =  a +  SubNegMonoid.zsmul🔗<|PREMISE|>🔗  (Int.ofNat🔗<|PREMISE|>🔗  n) a\n | zsmul_neg' : ∀ (n : ℕ ) (a : G), SubNegMonoid.zsmul🔗<|PREMISE|>🔗  (Int.negSucc🔗<|PREMISE|>🔗  n) a =  - SubNegMonoid.zsmul🔗<|PREMISE|>🔗  (↑(Nat.succ🔗<|PREMISE|>🔗  n)) a\n | neg_neg : ∀ (x : G), -  - x =  x\n | neg_add_rev : ∀ (a b : G), - (a +  b) =  - b +  - a\n | neg_eq_of_add : ∀ (a b : G), a +  b =  0 → - a =  b\n | add_comm : ∀ (a b : G), a +  b =  b +  a", "code": "class SubtractionCommMonoid (G : Type u) extends SubtractionMonoid G, AddCommMonoid G\n", "additional_info": "Commutative `🗟SubtractionMonoid🗟🔗../../.././Mathlib/Algebra/Group/Defs.html#SubtractionMonoid🔗` .\n- SubtractionCommMonoid.add_comm: Addition is commutative in an commutative additive magma.\n\n\n", "used_premises": [599, 34, 34, 34, 593, 593, 50, 53, 593, 50, 593, 54, 593, 53], "def_path": "Mathlib/Algebra/Group/Defs.lean", "pos": [1091, 1092], "informalization": "Class `SubtractionCommMonoid` represents a commutative group that is also a subtraction monoid, meaning it has operations of addition, negation, subtraction, and scalar multiplication by both natural numbers and integers, all of which are commutative."}
{"full_name": "PiProp.addGroup.proof_1", "url": "ConNF/Mathlib/Group.html#PiProp.addGroup.proof_1", "code_src": "con-nf", "ptype": "theorem", "header": "theorem PiProp.addGroup.proof_1 {I : Prop } {f : I → Type u_1} [(i : I) → AddGroup🔗<|PREMISE|>🔗 (f i)] (a : (i : I) → f i) :- a + a = 0", "code": "@[to_additive]\n", "additional_info": "", "used_premises": [605], "def_path": "ConNF/Mathlib/Group.lean", "pos": [107, 108], "informalization": "Function `PiProp.addGroup.proof_1` is a proof that for any type family `f : I → Type u_1` where each `f i` is an additive group, the sum of any element `a : (i : I) → f i` with itself is equal to zero."}
{"full_name": "AddGroup", "url": "Mathlib/Algebra/Group/Defs.html#AddGroup", "code_src": "mathlib4", "ptype": "class", "header": "class AddGroup (A : Type u) extends SubNegMonoid🔗<|PREMISE|>🔗 :Type u\n | add : A → A → A\n | add_assoc : ∀ (a b c : A), a +  b +  c =  a +  (b +  c)\n | zero : A\n | zero_add : ∀ (a : A), 0 +  a =  a\n | add_zero : ∀ (a : A), a +  0 =  a\n | nsmul : ℕ  → A → A\n | nsmul_zero : ∀ (x : A), AddMonoid.nsmul🔗<|PREMISE|>🔗  0 x =  0\n | nsmul_succ : ∀ (n : ℕ ) (x : A), AddMonoid.nsmul🔗<|PREMISE|>🔗  (n +  1) x =  x +  AddMonoid.nsmul🔗<|PREMISE|>🔗  n x\n | neg : A → A\n | sub : A → A → A\n | sub_eq_add_neg : ∀ (a b : A), a -  b =  a +  - b\n | zsmul : ℤ  → A → A\n | zsmul_zero' : ∀ (a : A), SubNegMonoid.zsmul🔗<|PREMISE|>🔗  0 a =  0\n | zsmul_succ' : ∀ (n : ℕ ) (a : A), SubNegMonoid.zsmul🔗<|PREMISE|>🔗  (Int.ofNat🔗<|PREMISE|>🔗  (Nat.succ🔗<|PREMISE|>🔗  n)) a =  a +  SubNegMonoid.zsmul🔗<|PREMISE|>🔗  (Int.ofNat🔗<|PREMISE|>🔗  n) a\n | zsmul_neg' : ∀ (n : ℕ ) (a : A), SubNegMonoid.zsmul🔗<|PREMISE|>🔗  (Int.negSucc🔗<|PREMISE|>🔗  n) a =  - SubNegMonoid.zsmul🔗<|PREMISE|>🔗  (↑(Nat.succ🔗<|PREMISE|>🔗  n)) a\n | add_left_neg : ∀ (a : A), - a +  a =  0", "code": "class AddGroup (A : Type u) extends SubNegMonoid A where\n  protected add_left_neg : ∀ a : A, -a + a = 0\n", "additional_info": "An `🗟AddGroup🗟🔗../../.././Mathlib/Algebra/Group/Defs.html#AddGroup🔗`  is an `🗟AddMonoid🗟🔗../../.././Mathlib/Algebra/Group/Defs.html#AddMonoid🔗`  with a unary `-` satisfying `-a + a = 0`.\nThere is also a binary operation `-` such that `a - b = a + -b`,\nwith a default so that `a - b = a + -b` holds by definition.\nUse `AddGroup.ofLeftAxioms` or `AddGroup.ofRightAxioms` to define an\nadditive group structure on a type with the minumum proof obligations.\n", "used_premises": [592, 34, 34, 34, 593, 593, 50, 53, 593, 50, 593, 54, 593, 53], "def_path": "Mathlib/Algebra/Group/Defs.lean", "pos": [1123, 1125], "informalization": "Class `AddGroup` represents the concept of an additive group, which is an additive monoid with an additional operation of negation that satisfies the property of having an inverse for every element, ensuring that the sum of any element and its negation equals the zero element."}
{"full_name": "PiProp.addCommGroup.proof_1", "url": "ConNF/Mathlib/Group.html#PiProp.addCommGroup.proof_1", "code_src": "con-nf", "ptype": "theorem", "header": "theorem PiProp.addCommGroup.proof_1 {I : Prop } {f : I → Type u_1} [(i : I) → AddCommGroup🔗<|PREMISE|>🔗 (f i)] (a : (i : I) → f i) (b : (i : I) → f i) :a + b = b + a", "code": "@[to_additive]\n", "additional_info": "", "used_premises": [607], "def_path": "ConNF/Mathlib/Group.lean", "pos": [113, 114], "informalization": "Function `PiProp.addCommGroup.proof_1` is a proof of the commutativity of addition in a product of additive commutative groups."}
{"full_name": "AddCommGroup", "url": "Mathlib/Algebra/Group/Defs.html#AddCommGroup", "code_src": "mathlib4", "ptype": "class", "header": "class AddCommGroup (G : Type u) extends AddGroup🔗<|PREMISE|>🔗 :Type u\n | add : G → G → G\n | add_assoc : ∀ (a b c : G), a +  b +  c =  a +  (b +  c)\n | zero : G\n | zero_add : ∀ (a : G), 0 +  a =  a\n | add_zero : ∀ (a : G), a +  0 =  a\n | nsmul : ℕ  → G → G\n | nsmul_zero : ∀ (x : G), AddMonoid.nsmul🔗<|PREMISE|>🔗  0 x =  0\n | nsmul_succ : ∀ (n : ℕ ) (x : G), AddMonoid.nsmul🔗<|PREMISE|>🔗  (n +  1) x =  x +  AddMonoid.nsmul🔗<|PREMISE|>🔗  n x\n | neg : G → G\n | sub : G → G → G\n | sub_eq_add_neg : ∀ (a b : G), a -  b =  a +  - b\n | zsmul : ℤ  → G → G\n | zsmul_zero' : ∀ (a : G), SubNegMonoid.zsmul🔗<|PREMISE|>🔗  0 a =  0\n | zsmul_succ' : ∀ (n : ℕ ) (a : G), SubNegMonoid.zsmul🔗<|PREMISE|>🔗  (Int.ofNat🔗<|PREMISE|>🔗  (Nat.succ🔗<|PREMISE|>🔗  n)) a =  a +  SubNegMonoid.zsmul🔗<|PREMISE|>🔗  (Int.ofNat🔗<|PREMISE|>🔗  n) a\n | zsmul_neg' : ∀ (n : ℕ ) (a : G), SubNegMonoid.zsmul🔗<|PREMISE|>🔗  (Int.negSucc🔗<|PREMISE|>🔗  n) a =  - SubNegMonoid.zsmul🔗<|PREMISE|>🔗  (↑(Nat.succ🔗<|PREMISE|>🔗  n)) a\n | add_left_neg : ∀ (a : G), - a +  a =  0\n | add_comm : ∀ (a b : G), a +  b =  b +  a", "code": "class AddCommGroup (G : Type u) extends AddGroup G, AddCommMonoid G\n", "additional_info": "An additive commutative group is an additive group with commutative `(+)`.\n- AddCommGroup.add_comm: Addition is commutative in an commutative additive magma.\n\n\n", "used_premises": [605, 34, 34, 34, 593, 593, 50, 53, 593, 50, 593, 54, 593, 53], "def_path": "Mathlib/Algebra/Group/Defs.lean", "pos": [1202, 1203], "informalization": "Class `AddCommGroup` represents the concept of an additive commutative group, which is an additive group with the additional property that addition is commutative."}
{"full_name": "PiProp.AddLeftCancelSemigroup.proof_1", "url": "ConNF/Mathlib/Group.html#PiProp.AddLeftCancelSemigroup.proof_1", "code_src": "con-nf", "ptype": "theorem", "header": "theorem PiProp.AddLeftCancelSemigroup.proof_1 {I : Prop } {f : I → Type u_1} [inst : (i : I) → AddLeftCancelSemigroup🔗<|PREMISE|>🔗 (f i)] (a : (i : I) → f i) (b : (i : I) → f i) (c : (i : I) → f i) (h : a + b = a + c) :b = c", "code": "@[to_additive AddLeftCancelSemigroup]\n", "additional_info": "", "used_premises": [609], "def_path": "ConNF/Mathlib/Group.lean", "pos": [119, 120], "informalization": "Function `PiProp.AddLeftCancelSemigroup.proof_1` proves that if `a`, `b`, and `c` are elements of a family of additive left-cancellative semigroups, and `a + b = a + c`, then `b = c`."}
{"full_name": "AddLeftCancelSemigroup", "url": "Mathlib/Algebra/Group/Defs.html#AddLeftCancelSemigroup", "code_src": "mathlib4", "ptype": "class", "header": "class AddLeftCancelSemigroup (G : Type u) extends AddSemigroup🔗<|PREMISE|>🔗 :Type u\n | add : G → G → G\n | add_assoc : ∀ (a b c : G), a +  b +  c =  a +  (b +  c)\n | add_left_cancel : ∀ (a b c : G), a +  b =  a +  c → b =  c", "code": "class AddLeftCancelSemigroup (G : Type u) extends AddSemigroup G where\n  protected add_left_cancel : ∀ a b c : G, a + b = a + c → b = c\n", "additional_info": "An `🗟AddLeftCancelSemigroup🗟🔗../../.././Mathlib/Algebra/Group/Defs.html#AddLeftCancelSemigroup🔗`  is an additive semigroup such that\n`a + b = a + c` implies `b = c`.\n", "used_premises": [32], "def_path": "Mathlib/Algebra/Group/Defs.lean", "pos": [387, 389], "informalization": "An `AddLeftCancelSemigroup` is an additive semigroup where addition is left-cancellative, meaning that if `a + b = a + c`, then `b = c`."}
{"full_name": "PiProp.AddRightCancelSemigroup.proof_1", "url": "ConNF/Mathlib/Group.html#PiProp.AddRightCancelSemigroup.proof_1", "code_src": "con-nf", "ptype": "theorem", "header": "theorem PiProp.AddRightCancelSemigroup.proof_1 {I : Prop } {f : I → Type u_1} [inst : (i : I) → AddRightCancelSemigroup🔗<|PREMISE|>🔗 (f i)] (a : (i : I) → f i) (b : (i : I) → f i) (c : (i : I) → f i) (h : a + b = c + b) :a = c", "code": "@[to_additive AddRightCancelSemigroup]\n", "additional_info": "", "used_premises": [611], "def_path": "ConNF/Mathlib/Group.lean", "pos": [127, 128], "informalization": "`PiProp.AddRightCancelSemigroup.proof_1` is a proof that for any family of types `f : I → Type u_1`, if each `f i` is an `AddRightCancelSemigroup`, then the type `(i : I) → f i` is also an `AddRightCancelSemigroup`."}
{"full_name": "AddRightCancelSemigroup", "url": "Mathlib/Algebra/Group/Defs.html#AddRightCancelSemigroup", "code_src": "mathlib4", "ptype": "class", "header": "class AddRightCancelSemigroup (G : Type u) extends AddSemigroup🔗<|PREMISE|>🔗 :Type u\n | add : G → G → G\n | add_assoc : ∀ (a b c : G), a +  b +  c =  a +  (b +  c)\n | add_right_cancel : ∀ (a b c : G), a +  b =  c +  b → a =  c", "code": "class AddRightCancelSemigroup (G : Type u) extends AddSemigroup G where\n  protected add_right_cancel : ∀ a b c : G, a + b = c + b → a = c\n", "additional_info": "An `🗟AddRightCancelSemigroup🗟🔗../../.././Mathlib/Algebra/Group/Defs.html#AddRightCancelSemigroup🔗`  is an additive semigroup such that\n`a + b = c + b` implies `a = c`.\n", "used_premises": [32], "def_path": "Mathlib/Algebra/Group/Defs.lean", "pos": [419, 421], "informalization": "An `AddRightCancelSemigroup` is an additive semigroup where `a + b = c + b` implies `a = c`."}
{"full_name": "PiProp.AddLeftCancelMonoid.proof_5", "url": "ConNF/Mathlib/Group.html#PiProp.AddLeftCancelMonoid.proof_5", "code_src": "con-nf", "ptype": "theorem", "header": "theorem PiProp.AddLeftCancelMonoid.proof_5 {I : Prop } {f : I → Type u_1} [(i : I) → AddLeftCancelMonoid🔗<|PREMISE|>🔗 (f i)] (n : ℕ ) (x : (i : I) → f i) :AddMonoid.nsmul🔗<|PREMISE|>🔗 (n + 1) x = x + AddMonoid.nsmul🔗<|PREMISE|>🔗 n x", "code": "@[to_additive AddLeftCancelMonoid]\n", "additional_info": "", "used_premises": [613, 34, 34], "def_path": "ConNF/Mathlib/Group.lean", "pos": [135, 136], "informalization": "The theorem `PiProp.AddLeftCancelMonoid.proof_5` states that for an indexed family of additive left-cancellative monoids, the `n+1`th multiple of an element `x` is equal to `x` plus the `n`th multiple of `x`."}
{"full_name": "AddLeftCancelMonoid", "url": "Mathlib/Algebra/Group/Defs.html#AddLeftCancelMonoid", "code_src": "mathlib4", "ptype": "class", "header": "class AddLeftCancelMonoid (M : Type u) extends AddLeftCancelSemigroup🔗<|PREMISE|>🔗 , Zero🔗<|PREMISE|>🔗 :Type u\n | add : M → M → M\n | add_assoc : ∀ (a b c : M), a +  b +  c =  a +  (b +  c)\n | add_left_cancel : ∀ (a b c : M), a +  b =  a +  c → b =  c\n | zero : M\n | zero_add : ∀ (a : M), 0 +  a =  a\n | add_zero : ∀ (a : M), a +  0 =  a\n | nsmul : ℕ  → M → M\n | nsmul_zero : ∀ (x : M), AddLeftCancelMonoid.nsmul🔗<|PREMISE|>🔗  0 x =  0\n | nsmul_succ : ∀ (n : ℕ ) (x : M), AddLeftCancelMonoid.nsmul🔗<|PREMISE|>🔗  (n +  1) x =  x +  AddLeftCancelMonoid.nsmul🔗<|PREMISE|>🔗  n x", "code": "class AddLeftCancelMonoid (M : Type u) extends AddLeftCancelSemigroup M, AddMonoid M\n", "additional_info": "An additive monoid in which addition is left-cancellative.\nMain examples are `ℕ` and groups. This is the right typeclass for many sum lemmas, as having a zero\nis useful to define the sum over the empty set, so `🗟AddLeftCancelSemigroup🗟🔗../../.././Mathlib/Algebra/Group/Defs.html#AddLeftCancelSemigroup🔗`  is not enough.\n- AddLeftCancelMonoid.zero_add: Zero is a left neutral element for addition\n\n\n- AddLeftCancelMonoid.add_zero: Zero is a right neutral element for addition\n\n\n- AddLeftCancelMonoid.nsmul: Multiplication by a natural number.\n\n\n- AddLeftCancelMonoid.nsmul_zero: Multiplication by `(0 : ℕ)` gives `0`.\n\n\n- AddLeftCancelMonoid.nsmul_succ: Multiplication by `(n + 1 : ℕ)` behaves as expected.\n\n\n", "used_premises": [609, 20, 614, 614, 614], "def_path": "Mathlib/Algebra/Group/Defs.lean", "pos": [689, 690], "informalization": "The Lean 4 object `AddLeftCancelMonoid` represents an additive monoid where addition is left-cancellative, meaning if `a + b = a + c`, then `b = c`. This is useful to define the sum over the empty set, so `AddLeftCancelSemigroup` is not enough."}
{"full_name": "AddLeftCancelMonoid.nsmul", "url": "Mathlib/Algebra/Group/Defs.html#AddLeftCancelMonoid", "code_src": "mathlib4", "ptype": "structure_field", "header": "structure_field AddLeftCancelMonoid🔗<|PREMISE|>🔗.nsmul : ℕ  → M → M", "code": "class AddLeftCancelMonoid (M : Type u) extends AddLeftCancelSemigroup M, AddMonoid M\n", "additional_info": "Multiplication by a natural number.\n\n", "used_premises": [613], "def_path": "Mathlib/Algebra/Group/Defs.lean", "pos": [689, 690], "informalization": "Function `AddLeftCancelMonoid.nsmul` takes a natural number and an element from an additive monoid where addition is left-cancellative, and returns the result of their multiplication."}
{"full_name": "PiProp.AddLeftCancelMonoid.proof_1", "url": "ConNF/Mathlib/Group.html#PiProp.AddLeftCancelMonoid.proof_1", "code_src": "con-nf", "ptype": "theorem", "header": "theorem PiProp.AddLeftCancelMonoid.proof_1 {I : Prop } {f : I → Type u_1} [(i : I) → AddLeftCancelMonoid🔗<|PREMISE|>🔗 (f i)] (a : (i : I) → f i) (b : (i : I) → f i) (c : (i : I) → f i) :a + b = a + c → b = c", "code": "@[to_additive AddLeftCancelMonoid]\n", "additional_info": "", "used_premises": [613], "def_path": "ConNF/Mathlib/Group.lean", "pos": [135, 136], "informalization": "The theorem `PiProp.AddLeftCancelMonoid.proof_1` states that if you have a dependent family of types `f : I → Type u_1`, each of which is an additive left-cancellative monoid (a monoid where `a + b = a + c` implies `b = c`), then for any `a : (i : I) → f i` and `b : (i : I) → f i` and `c : (i : I) → f i`, if `a + b = a + c`, then `b = c`. This is a generalization of the property of left-cancellative monoids to dependent families of types."}
{"full_name": "PiProp.AddLeftCancelMonoid.proof_4", "url": "ConNF/Mathlib/Group.html#PiProp.AddLeftCancelMonoid.proof_4", "code_src": "con-nf", "ptype": "theorem", "header": "theorem PiProp.AddLeftCancelMonoid.proof_4 {I : Prop } {f : I → Type u_1} [(i : I) → AddLeftCancelMonoid🔗<|PREMISE|>🔗 (f i)] (x : (i : I) → f i) :AddMonoid.nsmul🔗<|PREMISE|>🔗 0 x = 0", "code": "@[to_additive AddLeftCancelMonoid]\n", "additional_info": "", "used_premises": [613, 34], "def_path": "ConNF/Mathlib/Group.lean", "pos": [135, 136], "informalization": "The theorem `PiProp.AddLeftCancelMonoid.proof_4` states that for any type family `f : I → Type u_1` where each `f i` is an additive left-cancellative monoid, the zeroth power of any element `x : (i : I) → f i` is equal to zero."}
{"full_name": "PiProp.AddLeftCancelMonoid.proof_2", "url": "ConNF/Mathlib/Group.html#PiProp.AddLeftCancelMonoid.proof_2", "code_src": "con-nf", "ptype": "theorem", "header": "theorem PiProp.AddLeftCancelMonoid.proof_2 {I : Prop } {f : I → Type u_1} [(i : I) → AddLeftCancelMonoid🔗<|PREMISE|>🔗 (f i)] (a : (i : I) → f i) :0 + a = a", "code": "@[to_additive AddLeftCancelMonoid]\n", "additional_info": "", "used_premises": [613], "def_path": "ConNF/Mathlib/Group.lean", "pos": [135, 136], "informalization": "The proof provided for the theorem stating that for any type family indexed by a proposition $I$, the additive monoid structure on the product type $(\\prod_{i : I} f_i)$ is an additive left-cancel monoid. This requires the proof that the sum of the zero element with any element of the product type is equal to that element (i.e., $0 + a = a$). This theorem is derived from the instance of `AddLeftCancelMonoid` for each $f_i$, which ensures that within each component of the product, the sum of zero with any element is equal to that element. Hence, the proof is completed by using the `pi_zero` (which states that the zero vector is the constant function mapping to the zero of each component) and `pi_add` (which states that addition in the product is done component-wise)."}
{"full_name": "PiProp.AddLeftCancelMonoid.proof_3", "url": "ConNF/Mathlib/Group.html#PiProp.AddLeftCancelMonoid.proof_3", "code_src": "con-nf", "ptype": "theorem", "header": "theorem PiProp.AddLeftCancelMonoid.proof_3 {I : Prop } {f : I → Type u_1} [(i : I) → AddLeftCancelMonoid🔗<|PREMISE|>🔗 (f i)] (a : (i : I) → f i) :a + 0 = a", "code": "@[to_additive AddLeftCancelMonoid]\n", "additional_info": "", "used_premises": [613], "def_path": "ConNF/Mathlib/Group.lean", "pos": [135, 136], "informalization": "The theorem `PiProp.AddLeftCancelMonoid.proof_3` is a part of the `PiProp` class which is used to define a monoid structure on the type `(I → Type u_1)` where `I` is a type and `u_1` is a universe level. The theorem states that for any dependent function `a : (i : I) → f i` where `f i` are additive left-cancellative monoids, the sum of `a` and the zero function is equal to `a`."}
{"full_name": "PiProp.AddRightCancelMonoid.proof_1", "url": "ConNF/Mathlib/Group.html#PiProp.AddRightCancelMonoid.proof_1", "code_src": "con-nf", "ptype": "theorem", "header": "theorem PiProp.AddRightCancelMonoid.proof_1 {I : Prop } {f : I → Type u_1} [(i : I) → AddRightCancelMonoid🔗<|PREMISE|>🔗 (f i)] (a : (i : I) → f i) (b : (i : I) → f i) (c : (i : I) → f i) :a + b = c + b → a = c", "code": "@[to_additive AddRightCancelMonoid]\n", "additional_info": "", "used_premises": [620], "def_path": "ConNF/Mathlib/Group.lean", "pos": [141, 142], "informalization": "Function `PiProp.AddRightCancelMonoid.proof_1` is a proof that for any family of types `f : I → Type u_1` where each `f i` is an `AddRightCancelMonoid`, the product type `(i : I) → f i` is also an `AddRightCancelMonoid`. Specifically, it proves that for any `a, b, c : (i : I) → f i`, if `a + b = c + b`, then `a = c`."}
{"full_name": "AddRightCancelMonoid", "url": "Mathlib/Algebra/Group/Defs.html#AddRightCancelMonoid", "code_src": "mathlib4", "ptype": "class", "header": "class AddRightCancelMonoid (M : Type u) extends AddRightCancelSemigroup🔗<|PREMISE|>🔗 , Zero🔗<|PREMISE|>🔗 :Type u\n | add : M → M → M\n | add_assoc : ∀ (a b c : M), a +  b +  c =  a +  (b +  c)\n | add_right_cancel : ∀ (a b c : M), a +  b =  c +  b → a =  c\n | zero : M\n | zero_add : ∀ (a : M), 0 +  a =  a\n | add_zero : ∀ (a : M), a +  0 =  a\n | nsmul : ℕ  → M → M\n | nsmul_zero : ∀ (x : M), AddRightCancelMonoid.nsmul🔗<|PREMISE|>🔗  0 x =  0\n | nsmul_succ : ∀ (n : ℕ ) (x : M), AddRightCancelMonoid.nsmul🔗<|PREMISE|>🔗  (n +  1) x =  x +  AddRightCancelMonoid.nsmul🔗<|PREMISE|>🔗  n x", "code": "class AddRightCancelMonoid (M : Type u) extends AddRightCancelSemigroup M, AddMonoid M\n", "additional_info": "An additive monoid in which addition is right-cancellative.\nMain examples are `ℕ` and groups. This is the right typeclass for many sum lemmas, as having a zero\nis useful to define the sum over the empty set, so `🗟AddRightCancelSemigroup🗟🔗../../.././Mathlib/Algebra/Group/Defs.html#AddRightCancelSemigroup🔗`  is not enough.\n- AddRightCancelMonoid.zero_add: Zero is a left neutral element for addition\n\n\n- AddRightCancelMonoid.add_zero: Zero is a right neutral element for addition\n\n\n- AddRightCancelMonoid.nsmul: Multiplication by a natural number.\n\n\n- AddRightCancelMonoid.nsmul_zero: Multiplication by `(0 : ℕ)` gives `0`.\n\n\n- AddRightCancelMonoid.nsmul_succ: Multiplication by `(n + 1 : ℕ)` behaves as expected.\n\n\n", "used_premises": [611, 20, 621, 621, 621], "def_path": "Mathlib/Algebra/Group/Defs.lean", "pos": [710, 711], "informalization": "Class `AddRightCancelMonoid` represents an additive monoid where addition is right-cancellative, meaning that if `a + b = c + b`, then `a = c`. This class extends `AddRightCancelSemigroup` and `AddMonoid`, ensuring that the monoid has a zero element and satisfies the properties of an additive monoid."}
{"full_name": "AddRightCancelMonoid.nsmul", "url": "Mathlib/Algebra/Group/Defs.html#AddRightCancelMonoid", "code_src": "mathlib4", "ptype": "structure_field", "header": "structure_field AddRightCancelMonoid🔗<|PREMISE|>🔗.nsmul : ℕ  → M → M", "code": "class AddRightCancelMonoid (M : Type u) extends AddRightCancelSemigroup M, AddMonoid M\n", "additional_info": "Multiplication by a natural number.\n\n", "used_premises": [620], "def_path": "Mathlib/Algebra/Group/Defs.lean", "pos": [710, 711], "informalization": "Function `AddRightCancelMonoid.nsmul` takes a natural number and an element from an additive monoid where addition is right-cancellative, and returns the result of their multiplication."}
{"full_name": "PiProp.AddRightCancelMonoid.proof_2", "url": "ConNF/Mathlib/Group.html#PiProp.AddRightCancelMonoid.proof_2", "code_src": "con-nf", "ptype": "theorem", "header": "theorem PiProp.AddRightCancelMonoid.proof_2 {I : Prop } {f : I → Type u_1} [(i : I) → AddRightCancelMonoid🔗<|PREMISE|>🔗 (f i)] (a : (i : I) → f i) :0 + a = a", "code": "@[to_additive AddRightCancelMonoid]\n", "additional_info": "", "used_premises": [620], "def_path": "ConNF/Mathlib/Group.lean", "pos": [141, 142], "informalization": "The theorem `PiProp.AddRightCancelMonoid.proof_2` states that for any family of types `f : I → Type u_1`, where each `f i` is an additive right-cancellative monoid, the zero element added to any element `a : (i : I) → f i` is equal to `a`."}
{"full_name": "PiProp.AddRightCancelMonoid.proof_4", "url": "ConNF/Mathlib/Group.html#PiProp.AddRightCancelMonoid.proof_4", "code_src": "con-nf", "ptype": "theorem", "header": "theorem PiProp.AddRightCancelMonoid.proof_4 {I : Prop } {f : I → Type u_1} [(i : I) → AddRightCancelMonoid🔗<|PREMISE|>🔗 (f i)] (x : (i : I) → f i) :AddMonoid.nsmul🔗<|PREMISE|>🔗 0 x = 0", "code": "@[to_additive AddRightCancelMonoid]\n", "additional_info": "", "used_premises": [620, 34], "def_path": "ConNF/Mathlib/Group.lean", "pos": [141, 142], "informalization": "`PiProp.AddRightCancelMonoid.proof_4` is a proof of the statement that for any type family `f : I → Type u_1` where each `f i` is an additive right-cancellative monoid, the zero scalar multiplication of any element `x : (i : I) → f i` is equal to zero."}
{"full_name": "PiProp.AddRightCancelMonoid.proof_3", "url": "ConNF/Mathlib/Group.html#PiProp.AddRightCancelMonoid.proof_3", "code_src": "con-nf", "ptype": "theorem", "header": "theorem PiProp.AddRightCancelMonoid.proof_3 {I : Prop } {f : I → Type u_1} [(i : I) → AddRightCancelMonoid🔗<|PREMISE|>🔗 (f i)] (a : (i : I) → f i) :a + 0 = a", "code": "@[to_additive AddRightCancelMonoid]\n", "additional_info": "", "used_premises": [620], "def_path": "ConNF/Mathlib/Group.lean", "pos": [141, 142], "informalization": "The theorem `PiProp.AddRightCancelMonoid.proof_3` states that for any family of types `f : I → Type u_1`, where each `f i` is an additive right-cancellative monoid, the sum of any element `a : (i : I) → f i` with the zero element of the product type is equal to `a`."}
{"full_name": "PiProp.AddRightCancelMonoid.proof_5", "url": "ConNF/Mathlib/Group.html#PiProp.AddRightCancelMonoid.proof_5", "code_src": "con-nf", "ptype": "theorem", "header": "theorem PiProp.AddRightCancelMonoid.proof_5 {I : Prop } {f : I → Type u_1} [(i : I) → AddRightCancelMonoid🔗<|PREMISE|>🔗 (f i)] (n : ℕ ) (x : (i : I) → f i) :AddMonoid.nsmul🔗<|PREMISE|>🔗 (n + 1) x = x + AddMonoid.nsmul🔗<|PREMISE|>🔗 n x", "code": "@[to_additive AddRightCancelMonoid]\n", "additional_info": "", "used_premises": [620, 34, 34], "def_path": "ConNF/Mathlib/Group.lean", "pos": [141, 142], "informalization": "Function `PiProp.AddRightCancelMonoid.proof_5` is a proof of the property that the `n+1`th multiple of an element `x` in a product of additive right-cancellative monoids is equal to `x` plus the `n`th multiple of `x`."}
{"full_name": "PiProp.AddCancelMonoid.proof_1", "url": "ConNF/Mathlib/Group.html#PiProp.AddCancelMonoid.proof_1", "code_src": "con-nf", "ptype": "theorem", "header": "theorem PiProp.AddCancelMonoid.proof_1 {I : Prop } {f : I → Type u_1} [(i : I) → AddCancelMonoid🔗<|PREMISE|>🔗 (f i)] (a : (i : I) → f i) (b : (i : I) → f i) (c : (i : I) → f i) :a + b = c + b → a = c", "code": "@[to_additive AddCancelMonoid]\n", "additional_info": "", "used_premises": [627], "def_path": "ConNF/Mathlib/Group.lean", "pos": [147, 148], "informalization": "Class `AddCancelMonoid` represents an additive monoid where addition is cancellative on both sides, meaning if `a + b = c + b`, then `a = c`. This is useful to define the sum over the empty set, so `AddRightCancelMonoid` is not enough."}
{"full_name": "AddCancelMonoid", "url": "Mathlib/Algebra/Group/Defs.html#AddCancelMonoid", "code_src": "mathlib4", "ptype": "class", "header": "class AddCancelMonoid (M : Type u) extends AddLeftCancelMonoid🔗<|PREMISE|>🔗 :Type u\n | add : M → M → M\n | add_assoc : ∀ (a b c : M), a +  b +  c =  a +  (b +  c)\n | add_left_cancel : ∀ (a b c : M), a +  b =  a +  c → b =  c\n | zero : M\n | zero_add : ∀ (a : M), 0 +  a =  a\n | add_zero : ∀ (a : M), a +  0 =  a\n | nsmul : ℕ  → M → M\n | nsmul_zero : ∀ (x : M), AddLeftCancelMonoid.nsmul🔗<|PREMISE|>🔗  0 x =  0\n | nsmul_succ : ∀ (n : ℕ ) (x : M), AddLeftCancelMonoid.nsmul🔗<|PREMISE|>🔗  (n +  1) x =  x +  AddLeftCancelMonoid.nsmul🔗<|PREMISE|>🔗  n x\n | add_right_cancel : ∀ (a b c : M), a +  b =  c +  b → a =  c", "code": "class AddCancelMonoid (M : Type u) extends AddLeftCancelMonoid M, AddRightCancelMonoid M\n", "additional_info": "An additive monoid in which addition is cancellative on both sides.\nMain examples are `ℕ` and groups. This is the right typeclass for many sum lemmas, as having a zero\nis useful to define the sum over the empty set, so `🗟AddRightCancelMonoid🗟🔗../../.././Mathlib/Algebra/Group/Defs.html#AddRightCancelMonoid🔗`  is not enough.\n", "used_premises": [613, 614, 614, 614], "def_path": "Mathlib/Algebra/Group/Defs.lean", "pos": [731, 732], "informalization": "Class `AddCancelMonoid` represents an additive monoid where addition is cancellative on both sides, meaning if `a + b = c + b`, then `a = c`. This is useful to define the sum over the empty set, so `AddRightCancelMonoid` is not enough."}
{"full_name": "PiProp.AddCancelCommMonoid.proof_1", "url": "ConNF/Mathlib/Group.html#PiProp.AddCancelCommMonoid.proof_1", "code_src": "con-nf", "ptype": "theorem", "header": "theorem PiProp.AddCancelCommMonoid.proof_1 {I : Prop } {f : I → Type u_1} [(i : I) → AddCancelCommMonoid🔗<|PREMISE|>🔗 (f i)] (a : (i : I) → f i) (b : (i : I) → f i) :a + b = b + a", "code": "@[to_additive AddCancelCommMonoid]\n", "additional_info": "", "used_premises": [629], "def_path": "ConNF/Mathlib/Group.lean", "pos": [153, 154], "informalization": "`PiProp.AddCancelCommMonoid.proof_1` is a proof of the commutativity of addition in a product of additive cancellative commutative monoids."}
{"full_name": "AddCancelCommMonoid", "url": "Mathlib/Algebra/Group/Defs.html#AddCancelCommMonoid", "code_src": "mathlib4", "ptype": "class", "header": "class AddCancelCommMonoid (M : Type u) extends AddLeftCancelMonoid🔗<|PREMISE|>🔗 :Type u\n | add : M → M → M\n | add_assoc : ∀ (a b c : M), a +  b +  c =  a +  (b +  c)\n | add_left_cancel : ∀ (a b c : M), a +  b =  a +  c → b =  c\n | zero : M\n | zero_add : ∀ (a : M), 0 +  a =  a\n | add_zero : ∀ (a : M), a +  0 =  a\n | nsmul : ℕ  → M → M\n | nsmul_zero : ∀ (x : M), AddLeftCancelMonoid.nsmul🔗<|PREMISE|>🔗  0 x =  0\n | nsmul_succ : ∀ (n : ℕ ) (x : M), AddLeftCancelMonoid.nsmul🔗<|PREMISE|>🔗  (n +  1) x =  x +  AddLeftCancelMonoid.nsmul🔗<|PREMISE|>🔗  n x\n | add_comm : ∀ (a b : M), a +  b =  b +  a", "code": "class AddCancelCommMonoid (M : Type u) extends AddLeftCancelMonoid M, AddCommMonoid M\n", "additional_info": "Commutative version of `🗟AddCancelMonoid🗟🔗../../.././Mathlib/Algebra/Group/Defs.html#AddCancelMonoid🔗` .\n- AddCancelCommMonoid.add_comm: Addition is commutative in an commutative additive magma.\n\n\n", "used_premises": [613, 614, 614, 614], "def_path": "Mathlib/Algebra/Group/Defs.lean", "pos": [742, 743], "informalization": "Class `AddCancelCommMonoid` represents a commutative additive monoid where addition is left-cancellative, meaning if `a + b = a + c`, then `b = c`. This is useful to define the sum over the empty set, so `AddLeftCancelSemigroup` is not enough."}
{"full_name": "Nat.odd_succ", "url": "ConNF/Mathlib/Nat.html#Nat.odd_succ", "code_src": "con-nf", "ptype": "theorem", "header": "theorem Nat.odd_succ {n : ℕ } :Odd🔗<|PREMISE|>🔗 (Nat.succ🔗<|PREMISE|>🔗 n) ↔ ¬ Odd🔗<|PREMISE|>🔗 n", "code": "theorem odd_succ : Odd (succ n) ↔ ¬Odd n := by rw [succ_eq_add_one, odd_add]; simp [not_even_one]\n", "additional_info": "", "used_premises": [631, 53, 631], "def_path": "ConNF/Mathlib/Nat.lean", "pos": [7, 8], "informalization": "The theorem `Nat.odd_succ` states that for any natural number `n`, the successor of `n` is odd if and only if `n` is not odd."}
{"full_name": "Odd", "url": "Mathlib/Algebra/Parity.html#Odd", "code_src": "mathlib4", "ptype": "def", "header": "def Odd {α : Type u_2} [Semiring🔗<|PREMISE|>🔗 α] (a : α) :Prop", "code": "def Odd (a : α) : Prop :=\n  ∃ k, a = 2 * k + 1\n", "additional_info": "An element `a` of a semiring is odd if there exists `k` such `a = 2*k + 1`.\nEquations\n* 🗟Odd🗟🔗../.././Mathlib/Algebra/Parity.html#Odd🔗  a 🗟=🗟🔗../.././Init/Prelude.html#Eq🔗  ∃ (k : α), a 🗟=🗟🔗../.././Init/Prelude.html#Eq🔗  2 🗟*🗟🔗../.././Init/Prelude.html#HMul.hMul🔗  k 🗟+🗟🔗../.././Init/Prelude.html#HAdd.hAdd🔗  1\n\n", "used_premises": [632], "def_path": "Mathlib/Algebra/Parity.lean", "pos": [335, 337], "informalization": "`Odd` is a predicate asserting that an element `a` in a semiring `α` can be expressed as `2*k + 1` for some element `k` in `α`."}
{"full_name": "Semiring", "url": "Mathlib/Algebra/Ring/Defs.html#Semiring", "code_src": "mathlib4", "ptype": "class", "header": "class Semiring (α : Type u) extends NonUnitalSemiring🔗<|PREMISE|>🔗 , One🔗<|PREMISE|>🔗 , NatCast🔗<|PREMISE|>🔗 :Type u\n | add : α → α → α\n | add_assoc : ∀ (a b c : α), a +  b +  c =  a +  (b +  c)\n | zero : α\n | zero_add : ∀ (a : α), 0 +  a =  a\n | add_zero : ∀ (a : α), a +  0 =  a\n | nsmul : ℕ  → α → α\n | nsmul_zero : ∀ (x : α), AddMonoid.nsmul🔗<|PREMISE|>🔗  0 x =  0\n | nsmul_succ : ∀ (n : ℕ ) (x : α), AddMonoid.nsmul🔗<|PREMISE|>🔗  (n +  1) x =  x +  AddMonoid.nsmul🔗<|PREMISE|>🔗  n x\n | add_comm : ∀ (a b : α), a +  b =  b +  a\n | mul : α → α → α\n | left_distrib : ∀ (a b c : α), a *  (b +  c) =  a *  b +  a *  c\n | right_distrib : ∀ (a b c : α), (a +  b) *  c =  a *  c +  b *  c\n | zero_mul : ∀ (a : α), 0 *  a =  0\n | mul_zero : ∀ (a : α), a *  0 =  0\n | mul_assoc : ∀ (a b c : α), a *  b *  c =  a *  (b *  c)\n | one : α\n | one_mul : ∀ (a : α), 1 *  a =  a\n | mul_one : ∀ (a : α), a *  1 =  a\n | natCast : ℕ  → α\n | natCast_zero : NatCast.natCast🔗<|PREMISE|>🔗  0 =  0\n | natCast_succ : ∀ (n : ℕ ), NatCast.natCast🔗<|PREMISE|>🔗  (n +  1) =  NatCast.natCast🔗<|PREMISE|>🔗  n +  1\n | npow : ℕ  → α → α\n | npow_zero : ∀ (x : α), Semiring.npow🔗<|PREMISE|>🔗  0 x =  1\n | npow_succ : ∀ (n : ℕ ) (x : α), Semiring.npow🔗<|PREMISE|>🔗  (n +  1) x =  x *  Semiring.npow🔗<|PREMISE|>🔗  n x", "code": "class Semiring (α : Type u) extends NonUnitalSemiring α, NonAssocSemiring α, MonoidWithZero α\n", "additional_info": "A `🗟Semiring🗟🔗../../.././Mathlib/Algebra/Ring/Defs.html#Semiring🔗`  is a type with addition, multiplication, a `0` and a `1` where addition is\ncommutative and associative, multiplication is associative and left and right distributive over\naddition, and `0` and `1` are additive and multiplicative identities.\n- Semiring.one_mul: One is a left neutral element for multiplication\n\n\n- Semiring.mul_one: One is a right neutral element for multiplication\n\n\n- Semiring.natCast_zero: The canonical map `ℕ → R` sends `0 : ℕ` to `0 : R`.\n\n\n- Semiring.natCast_succ: The canonical map `ℕ → R` is a homomorphism.\n\n\n- Semiring.npow: Raising to the power of a natural number.\n\n\n- Semiring.npow_zero: Raising to the power `(0 : ℕ)` gives `1`.\n\n\n- Semiring.npow_succ: Raising to the power `(n + 1 : ℕ)` behaves as expected.\n\n\n", "used_premises": [633, 45, 635, 34, 34, 34, 636, 636, 636, 637, 637, 637], "def_path": "Mathlib/Algebra/Ring/Defs.lean", "pos": [140, 141], "informalization": "Class `Semiring` represents the concept of a semiring, which is an algebraic structure that combines aspects of both additive and multiplicative systems."}
{"full_name": "NonUnitalSemiring", "url": "Mathlib/Algebra/Ring/Defs.html#NonUnitalSemiring", "code_src": "mathlib4", "ptype": "class", "header": "class NonUnitalSemiring (α : Type u) extends NonUnitalNonAssocSemiring🔗<|PREMISE|>🔗 :Type u\n | add : α → α → α\n | add_assoc : ∀ (a b c : α), a +  b +  c =  a +  (b +  c)\n | zero : α\n | zero_add : ∀ (a : α), 0 +  a =  a\n | add_zero : ∀ (a : α), a +  0 =  a\n | nsmul : ℕ  → α → α\n | nsmul_zero : ∀ (x : α), AddMonoid.nsmul🔗<|PREMISE|>🔗  0 x =  0\n | nsmul_succ : ∀ (n : ℕ ) (x : α), AddMonoid.nsmul🔗<|PREMISE|>🔗  (n +  1) x =  x +  AddMonoid.nsmul🔗<|PREMISE|>🔗  n x\n | add_comm : ∀ (a b : α), a +  b =  b +  a\n | mul : α → α → α\n | left_distrib : ∀ (a b c : α), a *  (b +  c) =  a *  b +  a *  c\n | right_distrib : ∀ (a b c : α), (a +  b) *  c =  a *  c +  b *  c\n | zero_mul : ∀ (a : α), 0 *  a =  0\n | mul_zero : ∀ (a : α), a *  0 =  0\n | mul_assoc : ∀ (a b c : α), a *  b *  c =  a *  (b *  c)", "code": "class NonUnitalSemiring (α : Type u) extends NonUnitalNonAssocSemiring α, SemigroupWithZero α\n", "additional_info": "An associative but not-necessarily unital semiring.\n- NonUnitalSemiring.mul_assoc: Multiplication is associative\n\n\n", "used_premises": [634, 34, 34, 34], "def_path": "Mathlib/Algebra/Ring/Defs.lean", "pos": [116, 117], "informalization": "Class `NonUnitalSemiring` represents the concept of a non-unital semiring, which is an algebraic structure that extends `NonUnitalNonAssocSemiring` by adding the requirement for associative multiplication. This means that in addition to the properties of a non-unital, non-associative semiring (such as having an additive commutative monoid structure with associative and commutative addition, a zero element, natural number multiplication, distributive multiplication over addition, and zero as an absorbing element for multiplication), the multiplication operation is now associative. This is expressed by the property `mul_assoc`, which states that for any elements `a`, `b`, and `c`, `a * b * c = a * (b * c)`."}
{"full_name": "NonUnitalNonAssocSemiring", "url": "Mathlib/Algebra/Ring/Defs.html#NonUnitalNonAssocSemiring", "code_src": "mathlib4", "ptype": "class", "header": "class NonUnitalNonAssocSemiring (α : Type u) extends AddCommMonoid🔗<|PREMISE|>🔗 , Mul🔗<|PREMISE|>🔗 :Type u\n | add : α → α → α\n | add_assoc : ∀ (a b c : α), a +  b +  c =  a +  (b +  c)\n | zero : α\n | zero_add : ∀ (a : α), 0 +  a =  a\n | add_zero : ∀ (a : α), a +  0 =  a\n | nsmul : ℕ  → α → α\n | nsmul_zero : ∀ (x : α), AddMonoid.nsmul🔗<|PREMISE|>🔗  0 x =  0\n | nsmul_succ : ∀ (n : ℕ ) (x : α), AddMonoid.nsmul🔗<|PREMISE|>🔗  (n +  1) x =  x +  AddMonoid.nsmul🔗<|PREMISE|>🔗  n x\n | add_comm : ∀ (a b : α), a +  b =  b +  a\n | mul : α → α → α\n | left_distrib : ∀ (a b c : α), a *  (b +  c) =  a *  b +  a *  c\n | right_distrib : ∀ (a b c : α), (a +  b) *  c =  a *  c +  b *  c\n | zero_mul : ∀ (a : α), 0 *  a =  0\n | mul_zero : ∀ (a : α), a *  0 =  0", "code": "class NonUnitalNonAssocSemiring (α : Type u) extends AddCommMonoid α, Distrib α, MulZeroClass α\n", "additional_info": "A not-necessarily-unital, not-necessarily-associative semiring.\n- NonUnitalNonAssocSemiring.left_distrib: Multiplication is left distributive over addition\n\n\n- NonUnitalNonAssocSemiring.right_distrib: Multiplication is right distributive over addition\n\n\n- NonUnitalNonAssocSemiring.zero_mul: Zero is a left absorbing element for multiplication\n\n\n- NonUnitalNonAssocSemiring.mul_zero: Zero is a right absorbing element for multiplication\n\n\n", "used_premises": [590, 44, 34, 34, 34], "def_path": "Mathlib/Algebra/Ring/Defs.lean", "pos": [112, 113], "informalization": "Class `NonUnitalNonAssocSemiring` represents the concept of a non-unital, non-associative semiring. This algebraic structure extends `AddCommMonoid` and includes multiplication operations, but without the requirement for a multiplicative identity (unital) or associative multiplication. It features an additive commutative monoid structure, where addition is associative and commutative, there is a zero element that acts as a neutral element for addition, and natural number multiplication (nsmul) is defined with specific behaviors for zero and successor. Additionally, it includes a multiplication operation (`mul`) that is distributive over addition (both left and right) and has zero as an absorbing element for multiplication (both left and right). This means that multiplying any element by zero results in zero, and multiplication distributes over addition, meaning `a * (b + c) = a * b + a * c` and `(a + b) * c = a * c + b * c`."}
{"full_name": "NatCast", "url": "Init/Data/Cast.html#NatCast", "code_src": "lean4", "ptype": "class", "header": "class NatCast (R : Type u) :Type u\n | natCast : Nat🔗<|PREMISE|>🔗  → R", "code": "class NatCast (R : Type u) where\n  /-- The canonical map `Nat → R`. -/\n  protected natCast : Nat → R\n", "additional_info": "Type class for the canonical homomorphism `🗟Nat🗟🔗../.././Init/Prelude.html#Nat🔗  → R`.\n- NatCast.natCast: The canonical map `🗟Nat🗟🔗../.././Init/Prelude.html#Nat🔗  → R`.\n\n\n", "used_premises": [52], "def_path": "Init/Data/Cast.lean", "pos": [47, 50], "informalization": "Class `NatCast` represents the concept of a canonical homomorphism from natural numbers to another type `R`. It provides a method `natCast` that maps natural numbers to elements of type `R`."}
{"full_name": "NatCast.natCast", "url": "Init/Data/Cast.html#NatCast", "code_src": "lean4", "ptype": "structure_field", "header": "structure_field NatCast🔗<|PREMISE|>🔗.natCast : Nat🔗<|PREMISE|>🔗  → R", "code": "class NatCast (R : Type u) where\n  /-- The canonical map `Nat → R`. -/\n  protected natCast : Nat → R\n", "additional_info": "The canonical map `🗟Nat🗟🔗../.././Init/Prelude.html#Nat🔗  → R`.\n\n", "used_premises": [635, 52], "def_path": "Init/Data/Cast.lean", "pos": [47, 50], "informalization": "Function `NatCast.natCast` is a method provided by the `NatCast` class that takes a natural number (of type `Nat`) and returns an element of another type `R`. This function serves as a canonical homomorphism, or a mapping, from the natural numbers to the type `R`."}
{"full_name": "Semiring.npow", "url": "Mathlib/Algebra/Ring/Defs.html#Semiring", "code_src": "mathlib4", "ptype": "structure_field", "header": "structure_field Semiring🔗<|PREMISE|>🔗.npow : ℕ  → α → α", "code": "class Semiring (α : Type u) extends NonUnitalSemiring α, NonAssocSemiring α, MonoidWithZero α\n", "additional_info": "Raising to the power of a natural number.\n\n", "used_premises": [632], "def_path": "Mathlib/Algebra/Ring/Defs.lean", "pos": [140, 141], "informalization": "Function `Semiring.npow` takes a natural number and an element from a semiring, and returns the result of raising the element to the power of the natural number. This operation is defined recursively, where raising an element to the power of zero results in the multiplicative identity (usually denoted as `1`), and raising an element to the power of `n + 1` is equivalent to multiplying the element by its power of `n`. This function is essential for defining and working with exponentiation within the algebraic structure of a semiring."}
{"full_name": "Nat.not_even", "url": "ConNF/Mathlib/Nat.html#Nat.not_even", "code_src": "con-nf", "ptype": "theorem", "header": "theorem Nat.not_even {n : ℕ } :¬ Even🔗<|PREMISE|>🔗 n ↔ Odd🔗<|PREMISE|>🔗 n", "code": "theorem not_even : ¬Even n ↔ Odd n :=\n  Nat.odd_iff_not_even.symm\n", "additional_info": "", "used_premises": [639, 631], "def_path": "ConNF/Mathlib/Nat.lean", "pos": [9, 11], "informalization": "A natural number is odd if and only if it is not even."}
{"full_name": "Even", "url": "Mathlib/Algebra/Parity.html#Even", "code_src": "mathlib4", "ptype": "def", "header": "def Even {α : Type u_2} [Add🔗<|PREMISE|>🔗 α] (a : α) :Prop", "code": "@[to_additive\n      \"An element `a` of a type `α` with addition satisfies `Even a` if `a = r + r`,\n      for some `r : α`.\"]\n", "additional_info": "An element `a` of a type `α` with addition satisfies `🗟Even🗟🔗../.././Mathlib/Algebra/Parity.html#Even🔗  a` if `a = r + r`,\nfor some `r : α`.\nEquations\n* 🗟Even🗟🔗../.././Mathlib/Algebra/Parity.html#Even🔗  a 🗟=🗟🔗../.././Init/Prelude.html#Eq🔗  ∃ (r : α), a 🗟=🗟🔗../.././Init/Prelude.html#Eq🔗  r 🗟+🗟🔗../.././Init/Prelude.html#HAdd.hAdd🔗  r\n\n", "used_premises": [33], "def_path": "Mathlib/Algebra/Parity.lean", "pos": [47, 50], "informalization": "Function `Even` checks if an element `a` in a type `α` with addition can be expressed as the sum of two identical elements `r`, i.e., `a = r + r`."}
{"full_name": "Nat.not_odd", "url": "ConNF/Mathlib/Nat.html#Nat.not_odd", "code_src": "con-nf", "ptype": "theorem", "header": "theorem Nat.not_odd {n : ℕ } :¬ Odd🔗<|PREMISE|>🔗 n ↔ Even🔗<|PREMISE|>🔗 n", "code": "theorem not_odd : ¬Odd n ↔ Even n :=\n  Nat.even_iff_not_odd.symm\n", "additional_info": "", "used_premises": [631, 639], "def_path": "ConNF/Mathlib/Nat.lean", "pos": [12, 14], "informalization": "A natural number is not odd if and only if it is even."}
{"full_name": "AddAction.forall_mem_image", "url": "ConNF/Mathlib/Support.html#AddAction.forall_mem_image", "code_src": "con-nf", "ptype": "theorem", "header": "theorem AddAction.forall_mem_image {α : Type u_3} {β : Type u_4} {f : α → β} {s : Set🔗<|PREMISE|>🔗 α} {p : β → Prop } :(∀ y ∈ f '' s, p y) ↔ ∀ ⦃x : α⦄, x ∈ s → p (f x)", "code": "@[to_additive]\n", "additional_info": "", "used_premises": [69], "def_path": "ConNF/Mathlib/Support.lean", "pos": [10, 11], "informalization": "The theorem `AddAction.forall_mem_image` states that for any function `f : α → β`, a set `s : Set α`, and a property `p : β → Prop`, the statement \"for all `y` in the image of `s` under `f`, `p y` holds\" is equivalent to \"for all `x` in `s`, `p (f x)` holds\"."}
{"full_name": "MulAction.forall_mem_image", "url": "ConNF/Mathlib/Support.html#MulAction.forall_mem_image", "code_src": "con-nf", "ptype": "theorem", "header": "theorem MulAction.forall_mem_image {α : Type u_3} {β : Type u_4} {f : α → β} {s : Set🔗<|PREMISE|>🔗 α} {p : β → Prop } :(∀ y ∈ f '' s, p y) ↔ ∀ ⦃x : α⦄, x ∈ s → p (f x)", "code": "theorem forall_mem_image {f : α → β} {s : Set α} {p : β → Prop} :\n    (∀ y ∈ f '' s, p y) ↔ ∀ ⦃x⦄, x ∈ s → p (f x) := by simp\n", "additional_info": "", "used_premises": [69], "def_path": "ConNF/Mathlib/Support.lean", "pos": [11, 13], "informalization": "Given a function `f : α → β` and a set `s : Set α`, the statement `∀ y ∈ f '' s, p y` is equivalent to `∀ ⦃x : α⦄, x ∈ s → p (f x)`."}
{"full_name": "PartialPerm.coe_symm_mk", "url": "ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm.coe_symm_mk", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem PartialPerm.coe_symm_mk {α : Type u_1} (f : α → α) (g : α → α) (s : Set🔗<|PREMISE|>🔗 α) (ml : ∀ ⦃x : α⦄, x ∈ s → f x ∈ s) (mr : ∀ ⦃x : α⦄, x ∈ s → g x ∈ s) (il : ∀ ⦃x : α⦄, x ∈ s → g (f x) = x) (ir : ∀ ⦃x : α⦄, x ∈ s → f (g x) = x) :(PartialPerm.symm🔗<|PREMISE|>🔗 { toFun := f, invFun := g, domain := s, toFun_domain' := ml, invFun_domain' := mr, left_inv' := il, right_inv' := ir }).toFun = g", "code": "theorem coe_symm_mk (f : α → α) (g s ml mr il ir) :\n    ((PartialPerm.mk f g s ml mr il ir).symm : α → α) = g :=\n  rfl\n", "additional_info": "", "used_premises": [69, 644], "def_path": "ConNF/Mathlib/Logic/Equiv/PartialPerm.lean", "pos": [64, 67], "informalization": "The theorem `PartialPerm.coe_symm_mk` states that for a partial permutation defined by a function `f`, an inverse function `g`, and a domain `s`, the inverse function of the partial permutation is indeed `g`."}
{"full_name": "PartialPerm.symm", "url": "ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm.symm", "code_src": "con-nf", "ptype": "def", "header": "def PartialPerm.symm {α : Type u_1} (π : PartialPerm🔗<|PREMISE|>🔗 α) :PartialPerm🔗<|PREMISE|>🔗 α", "code": "protected def symm : PartialPerm α where\n  toFun := π.invFun\n  invFun := π.toFun\n  domain := π.domain\n  toFun_domain' := π.invFun_domain'\n  invFun_domain' := π.toFun_domain'\n  left_inv' := π.right_inv'\n  right_inv' := π.left_inv'\n", "additional_info": "The inverse of a partial permutation.\nEquations\n* 🗟PartialPerm.symm🗟🔗../../../.././ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm.symm🔗  π 🗟=🗟🔗../../../.././Init/Prelude.html#Eq🔗  { toFun := π.invFun, invFun := π.toFun, domain := π.domain, toFun_domain' := ⋯, invFun_domain' := ⋯, left_inv' := ⋯,\n right_inv' := ⋯ }\n\n", "used_premises": [645, 645], "def_path": "ConNF/Mathlib/Logic/Equiv/PartialPerm.lean", "pos": [47, 55], "informalization": "Function `PartialPerm.symm` returns the inverse of a partial permutation."}
{"full_name": "PartialPerm", "url": "ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm", "code_src": "con-nf", "ptype": "structure", "header": "structure PartialPerm (α : Type u_1) :Type u_1\n | toFun : α → α\n | invFun : α → α\n | domain : Set🔗<|PREMISE|>🔗  α\n | toFun_domain' : ∀ ⦃x : α⦄, x ∈  self.domain → self.toFun x ∈  self.domain\n | invFun_domain' : ∀ ⦃x : α⦄, x ∈  self.domain → self.invFun x ∈  self.domain\n | left_inv' : ∀ ⦃x : α⦄, x ∈  self.domain → self.invFun (self.toFun x) =  x\n | right_inv' : ∀ ⦃x : α⦄, x ∈  self.domain → self.toFun (self.invFun x) =  x", "code": "structure PartialPerm (α : Type _) where\n  (toFun invFun : α → α)\n  domain : Set α\n  toFun_domain' : ∀ ⦃x⦄, x ∈ domain → toFun x ∈ domain\n  invFun_domain' : ∀ ⦃x⦄, x ∈ domain → invFun x ∈ domain\n  left_inv' : ∀ ⦃x⦄, x ∈ domain → invFun (toFun x) = x\n  right_inv' : ∀ ⦃x⦄, x ∈ domain → toFun (invFun x) = x\n", "additional_info": "A partial permutation of a subset `🗟domain🗟🔗../../../.././ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm.domain🔗`  of `α`. The (global) maps `🗟toFun🗟🔗../../../.././ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm.toFun🔗  : α → α` and\n`🗟invFun🗟🔗../../../.././ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm.invFun🔗  : α → α` map `🗟domain🗟🔗../../../.././ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm.domain🔗`  to itself, and are inverse to each other there. The values of\n`🗟toFun🗟🔗../../../.././ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm.toFun🔗`  and `🗟invFun🗟🔗../../../.././ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm.invFun🔗`  outside of `🗟domain🗟🔗../../../.././ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm.domain🔗`  are irrelevant.\n", "used_premises": [69], "def_path": "ConNF/Mathlib/Logic/Equiv/PartialPerm.lean", "pos": [23, 30], "informalization": "Structure `PartialPerm` represents a partial permutation of a subset `domain` of `α`. The (global) maps `toFun` and `invFun` map `domain` to itself, and are inverse to each other there. The values of `toFun` and `invFun` outside of `domain` are irrelevant."}
{"full_name": "PartialPerm.toFun_as_coe", "url": "ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm.toFun_as_coe", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem PartialPerm.toFun_as_coe {α : Type u_1} (π : PartialPerm🔗<|PREMISE|>🔗 α) :π.toFun = π.toFun", "code": "theorem toFun_as_coe : π.toFun = π :=\n  rfl\n", "additional_info": "", "used_premises": [645], "def_path": "ConNF/Mathlib/Logic/Equiv/PartialPerm.lean", "pos": [69, 71], "informalization": "The theorem `PartialPerm.toFun_as_coe` states that the function `toFun` of a partial permutation `π` is equal to itself when considered as a coercion to a function."}
{"full_name": "PartialPerm.invFun_as_coe", "url": "ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm.invFun_as_coe", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem PartialPerm.invFun_as_coe {α : Type u_1} (π : PartialPerm🔗<|PREMISE|>🔗 α) :π.invFun = (PartialPerm.symm🔗<|PREMISE|>🔗 π).toFun", "code": "theorem invFun_as_coe : π.invFun = π.symm :=\n  rfl\n", "additional_info": "", "used_premises": [645, 644], "def_path": "ConNF/Mathlib/Logic/Equiv/PartialPerm.lean", "pos": [73, 75], "informalization": "Function `invFun` of a partial permutation `π` is equal to the function `toFun` of its inverse `symm π`."}
{"full_name": "PartialPerm.map_domain", "url": "ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm.map_domain", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem PartialPerm.map_domain {α : Type u_1} (π : PartialPerm🔗<|PREMISE|>🔗 α) {x : α} (h : x ∈ π.domain) :π.toFun x ∈ π.domain", "code": "theorem map_domain {x : α} (h : x ∈ π.domain) : π x ∈ π.domain :=\n  π.toFun_domain' h\n", "additional_info": "", "used_premises": [645], "def_path": "ConNF/Mathlib/Logic/Equiv/PartialPerm.lean", "pos": [77, 79], "informalization": "Given a partial permutation `π` and an element `x` in its domain, the image of `x` under `π` is also in its domain."}
{"full_name": "PartialPerm.iterate_domain", "url": "ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm.iterate_domain", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem PartialPerm.iterate_domain {α : Type u_1} (π : PartialPerm🔗<|PREMISE|>🔗 α) {x : α} (h : x ∈ π.domain) {n : ℕ } :π.toFun^[ n] x ∈ π.domain", "code": "theorem iterate_domain {x : α} (h : x ∈ π.domain) {n : ℕ} : π^[n] x ∈ π.domain := by\n  induction' n with n ih\n  exact h\n  rw [Function.iterate_succ']\n  exact π.map_domain ih\n", "additional_info": "", "used_premises": [645], "def_path": "ConNF/Mathlib/Logic/Equiv/PartialPerm.lean", "pos": [81, 86], "informalization": "The theorem `PartialPerm.iterate_domain` states that if `x` is in the domain of a partial permutation `π` and `n` is a natural number, then the `n`th iterate of `π` applied to `x` is also in the domain of `π`."}
{"full_name": "PartialPerm.left_inv", "url": "ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm.left_inv", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem PartialPerm.left_inv {α : Type u_1} (π : PartialPerm🔗<|PREMISE|>🔗 α) {x : α} (h : x ∈ π.domain) :(PartialPerm.symm🔗<|PREMISE|>🔗 π).toFun (π.toFun x) = x", "code": "theorem left_inv {x : α} (h : x ∈ π.domain) : π.symm (π x) = x :=\n  π.left_inv' h\n", "additional_info": "", "used_premises": [645, 644], "def_path": "ConNF/Mathlib/Logic/Equiv/PartialPerm.lean", "pos": [88, 90], "informalization": "`PartialPerm.left_inv` states that for a partial permutation `π`, if `x` is in the domain of `π`, then the inverse of `π` applied to `π` applied to `x` equals `x`."}
{"full_name": "PartialPerm.right_inv", "url": "ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm.right_inv", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem PartialPerm.right_inv {α : Type u_1} (π : PartialPerm🔗<|PREMISE|>🔗 α) {x : α} (h : x ∈ π.domain) :π.toFun ((PartialPerm.symm🔗<|PREMISE|>🔗 π).toFun x) = x", "code": "theorem right_inv {x : α} (h : x ∈ π.domain) : π (π.symm x) = x :=\n  π.right_inv' h\n", "additional_info": "", "used_premises": [645, 644], "def_path": "ConNF/Mathlib/Logic/Equiv/PartialPerm.lean", "pos": [92, 94], "informalization": "Function `PartialPerm.right_inv` states that for any partial permutation `π` and any element `x` in the domain of `π`, applying `π` to the result of applying the inverse of `π` to `x` yields `x`."}
{"full_name": "PartialPerm.symm_domain", "url": "ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm.symm_domain", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem PartialPerm.symm_domain {α : Type u_1} (π : PartialPerm🔗<|PREMISE|>🔗 α) :(PartialPerm.symm🔗<|PREMISE|>🔗 π).domain = π.domain", "code": "theorem symm_domain : π.symm.domain = π.domain :=\n  rfl\n", "additional_info": "", "used_premises": [645, 644], "def_path": "ConNF/Mathlib/Logic/Equiv/PartialPerm.lean", "pos": [96, 98], "informalization": "The domain of a partial permutation and its inverse are the same."}
{"full_name": "PartialPerm.symm_symm", "url": "ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm.symm_symm", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem PartialPerm.symm_symm {α : Type u_1} (π : PartialPerm🔗<|PREMISE|>🔗 α) :PartialPerm.symm🔗<|PREMISE|>🔗 (PartialPerm.symm🔗<|PREMISE|>🔗 π) = π", "code": "theorem symm_symm : π.symm.symm = π := by cases π; rfl\n", "additional_info": "", "used_premises": [645, 644, 644], "def_path": "ConNF/Mathlib/Logic/Equiv/PartialPerm.lean", "pos": [100, 101], "informalization": "Function `PartialPerm.symm_symm` states that the inverse of the inverse of a partial permutation is the original partial permutation."}
{"full_name": "PartialPerm.eq_symm_apply", "url": "ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm.eq_symm_apply", "code_src": "con-nf", "ptype": "theorem", "header": "theorem PartialPerm.eq_symm_apply {α : Type u_1} (π : PartialPerm🔗<|PREMISE|>🔗 α) {x : α} {y : α} (hx : x ∈ π.domain) (hy : y ∈ π.domain) :x = (PartialPerm.symm🔗<|PREMISE|>🔗 π).toFun y ↔ π.toFun x = y", "code": "theorem eq_symm_apply {x : α} {y : α} (hx : x ∈ π.domain) (hy : y ∈ π.domain) :\n    x = π.symm y ↔ π x = y :=\n  ⟨fun h => by rw [← π.right_inv hy, h], fun h => by rw [← π.left_inv hx, h]⟩\n", "additional_info": "", "used_premises": [645, 644], "def_path": "ConNF/Mathlib/Logic/Equiv/PartialPerm.lean", "pos": [102, 105], "informalization": "Function `eq_symm_apply` states that for a partial permutation `π`, if `x` and `y` are both in the domain of `π`, then `x` equals the inverse of `π` applied to `y` if and only if `π` applied to `x` equals `y`."}
{"full_name": "PartialPerm.mapsTo", "url": "ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm.mapsTo", "code_src": "con-nf", "ptype": "theorem", "header": "theorem PartialPerm.mapsTo {α : Type u_1} (π : PartialPerm🔗<|PREMISE|>🔗 α) :Set.MapsTo🔗<|PREMISE|>🔗 π.toFun π.domain π.domain", "code": "protected theorem mapsTo : MapsTo π π.domain π.domain := fun _ => π.map_domain\n", "additional_info": "", "used_premises": [645, 656], "def_path": "ConNF/Mathlib/Logic/Equiv/PartialPerm.lean", "pos": [106, 107], "informalization": "The function `PartialPerm.toFun` maps the domain of the partial permutation `π` to itself."}
{"full_name": "Set.MapsTo", "url": "Mathlib/Data/Set/Defs.html#Set.MapsTo", "code_src": "mathlib4", "ptype": "def", "header": "def Set.MapsTo {α : Type u} {β : Type v} (f : α → β) (s : Set🔗<|PREMISE|>🔗 α) (t : Set🔗<|PREMISE|>🔗 β) :Prop", "code": "def MapsTo (f : α → β) (s : Set α) (t : Set β) : Prop := ∀ ⦃x⦄, x ∈ s → f x ∈ t\n", "additional_info": "`🗟MapsTo🗟🔗../../.././Mathlib/Data/Set/Defs.html#Set.MapsTo🔗  f a b` means that the image of `a` is contained in `b`.\nEquations\n* 🗟Set.MapsTo🗟🔗../../.././Mathlib/Data/Set/Defs.html#Set.MapsTo🔗  f s t 🗟=🗟🔗../../.././Init/Prelude.html#Eq🔗  ∀ ⦃x : α⦄, x 🗟∈🗟🔗../../.././Init/Prelude.html#Membership.mem🔗  s → f x 🗟∈🗟🔗../../.././Init/Prelude.html#Membership.mem🔗  t\n\n", "used_premises": [69, 69], "def_path": "Mathlib/Data/Set/Defs.lean", "pos": [266, 267], "informalization": "Function `Set.MapsTo` checks if the image of a set `s` under a function `f` is contained within another set `t`."}
{"full_name": "PartialPerm.leftInvOn", "url": "ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm.leftInvOn", "code_src": "con-nf", "ptype": "theorem", "header": "theorem PartialPerm.leftInvOn {α : Type u_1} (π : PartialPerm🔗<|PREMISE|>🔗 α) :Set.LeftInvOn🔗<|PREMISE|>🔗 (PartialPerm.symm🔗<|PREMISE|>🔗 π).toFun π.toFun π.domain", "code": "protected theorem leftInvOn : LeftInvOn π.symm π π.domain := fun _ => π.left_inv\n", "additional_info": "", "used_premises": [645, 658, 644], "def_path": "ConNF/Mathlib/Logic/Equiv/PartialPerm.lean", "pos": [108, 109], "informalization": "Function `PartialPerm.leftInvOn` proves that the inverse of a partial permutation `π` is indeed a left inverse to `π` on the domain of `π`."}
{"full_name": "Set.LeftInvOn", "url": "Mathlib/Data/Set/Defs.html#Set.LeftInvOn", "code_src": "mathlib4", "ptype": "def", "header": "def Set.LeftInvOn {α : Type u} {β : Type v} (f' : β → α) (f : α → β) (s : Set🔗<|PREMISE|>🔗 α) :Prop", "code": "def LeftInvOn (f' : β → α) (f : α → β) (s : Set α) : Prop := ∀ ⦃x⦄, x ∈ s → f' (f x) = x\n", "additional_info": "`g` is a left inverse to `f` on `a` means that `g (f x) = x` for all `x ∈ a`.\nEquations\n* 🗟Set.LeftInvOn🗟🔗../../.././Mathlib/Data/Set/Defs.html#Set.LeftInvOn🔗  f' f s 🗟=🗟🔗../../.././Init/Prelude.html#Eq🔗  ∀ ⦃x : α⦄, x 🗟∈🗟🔗../../.././Init/Prelude.html#Membership.mem🔗  s → f' (f x) 🗟=🗟🔗../../.././Init/Prelude.html#Eq🔗  x\n\n", "used_premises": [69], "def_path": "Mathlib/Data/Set/Defs.lean", "pos": [305, 306], "informalization": "Function `Set.LeftInvOn` checks if a function `f'` is a left inverse to a function `f` on a subset `s`, meaning `f' (f x) = x` for all `x ∈ s`."}
{"full_name": "PartialPerm.rightInvOn", "url": "ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm.rightInvOn", "code_src": "con-nf", "ptype": "theorem", "header": "theorem PartialPerm.rightInvOn {α : Type u_1} (π : PartialPerm🔗<|PREMISE|>🔗 α) :Set.RightInvOn🔗<|PREMISE|>🔗 (PartialPerm.symm🔗<|PREMISE|>🔗 π).toFun π.toFun π.domain", "code": "protected theorem rightInvOn : RightInvOn π.symm π π.domain := fun _ => π.right_inv\n", "additional_info": "", "used_premises": [645, 660, 644], "def_path": "ConNF/Mathlib/Logic/Equiv/PartialPerm.lean", "pos": [110, 111], "informalization": "Function `PartialPerm.rightInvOn` proves that the inverse of a partial permutation `π` is indeed a right inverse on the domain of `π`."}
{"full_name": "Set.RightInvOn", "url": "Mathlib/Data/Set/Defs.html#Set.RightInvOn", "code_src": "mathlib4", "ptype": "def", "header": "@[reducible]def Set.RightInvOn {α : Type u} {β : Type v} (f' : β → α) (f : α → β) (t : Set🔗<|PREMISE|>🔗 β) :Prop", "code": "def RightInvOn (f' : β → α) (f : α → β) (t : Set β) : Prop := LeftInvOn f f' t\n", "additional_info": "`g` is a right inverse to `f` on `b` if `f (g x) = x` for all `x ∈ b`.\nEquations\n* 🗟Set.RightInvOn🗟🔗../../.././Mathlib/Data/Set/Defs.html#Set.RightInvOn🔗  f' f t 🗟=🗟🔗../../.././Init/Prelude.html#Eq🔗  🗟Set.LeftInvOn🗟🔗../../.././Mathlib/Data/Set/Defs.html#Set.LeftInvOn🔗  f f' t\n\n", "used_premises": [69], "def_path": "Mathlib/Data/Set/Defs.lean", "pos": [310, 311], "informalization": "Function `Set.RightInvOn` defines the property that a function `f'` is a right inverse to a function `f` on a set `t`. This means that for every element `x` in the set `t`, applying the function `f` to the result of applying `f'` to `x` yields `x` itself, i.e., `f (f' x) = x` for all `x ∈ t`."}
{"full_name": "PartialPerm.invOn", "url": "ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm.invOn", "code_src": "con-nf", "ptype": "theorem", "header": "theorem PartialPerm.invOn {α : Type u_1} (π : PartialPerm🔗<|PREMISE|>🔗 α) :Set.InvOn🔗<|PREMISE|>🔗 (PartialPerm.symm🔗<|PREMISE|>🔗 π).toFun π.toFun π.domain π.domain", "code": "protected theorem invOn : InvOn π.symm π π.domain π.domain :=\n  ⟨π.leftInvOn, π.rightInvOn⟩\n", "additional_info": "", "used_premises": [645, 662, 644], "def_path": "ConNF/Mathlib/Logic/Equiv/PartialPerm.lean", "pos": [112, 114], "informalization": "Function `PartialPerm.invOn` proves that the inverse of a partial permutation `π` is indeed an inverse on the domain of `π`."}
{"full_name": "Set.InvOn", "url": "Mathlib/Data/Set/Defs.html#Set.InvOn", "code_src": "mathlib4", "ptype": "def", "header": "def Set.InvOn {α : Type u} {β : Type v} (g : β → α) (f : α → β) (s : Set🔗<|PREMISE|>🔗 α) (t : Set🔗<|PREMISE|>🔗 β) :Prop", "code": "def InvOn (g : β → α) (f : α → β) (s : Set α) (t : Set β) : Prop :=\n  LeftInvOn g f s ∧ RightInvOn g f t\n", "additional_info": "`g` is an inverse to `f` viewed as a map from `a` to `b`\nEquations\n* 🗟Set.InvOn🗟🔗../../.././Mathlib/Data/Set/Defs.html#Set.InvOn🔗  g f s t 🗟=🗟🔗../../.././Init/Prelude.html#Eq🔗  (🗟Set.LeftInvOn🗟🔗../../.././Mathlib/Data/Set/Defs.html#Set.LeftInvOn🔗  g f s 🗟∧🗟🔗../../.././Init/Prelude.html#And🔗  🗟Set.RightInvOn🗟🔗../../.././Mathlib/Data/Set/Defs.html#Set.RightInvOn🔗  g f t)\n\n", "used_premises": [69, 69], "def_path": "Mathlib/Data/Set/Defs.lean", "pos": [314, 316], "informalization": "Function `Set.InvOn` checks if a function `g : β → α` is an inverse to a function `f : α → β` on sets `s : Set α` and `t : Set β`. This means that `g` is a left inverse of `f` on `s` and a right inverse of `f` on `t`."}
{"full_name": "PartialPerm.injOn", "url": "ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm.injOn", "code_src": "con-nf", "ptype": "theorem", "header": "theorem PartialPerm.injOn {α : Type u_1} (π : PartialPerm🔗<|PREMISE|>🔗 α) :Set.InjOn🔗<|PREMISE|>🔗 π.toFun π.domain", "code": "protected theorem injOn : InjOn π π.domain :=\n  π.leftInvOn.injOn\n", "additional_info": "", "used_premises": [645, 111], "def_path": "ConNF/Mathlib/Logic/Equiv/PartialPerm.lean", "pos": [115, 117], "informalization": "The function `toFun` of a partial permutation `π` is injective on its domain."}
{"full_name": "PartialPerm.bijOn", "url": "ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm.bijOn", "code_src": "con-nf", "ptype": "theorem", "header": "theorem PartialPerm.bijOn {α : Type u_1} (π : PartialPerm🔗<|PREMISE|>🔗 α) :Set.BijOn🔗<|PREMISE|>🔗 π.toFun π.domain π.domain", "code": "protected theorem bijOn : BijOn π π.domain π.domain :=\n  π.invOn.bijOn π.mapsTo π.symm.mapsTo\n", "additional_info": "", "used_premises": [645, 665], "def_path": "ConNF/Mathlib/Logic/Equiv/PartialPerm.lean", "pos": [118, 120], "informalization": "Function `PartialPerm.bijOn` proves that a partial permutation `π` is bijective between its domain and itself."}
{"full_name": "Set.BijOn", "url": "Mathlib/Data/Set/Defs.html#Set.BijOn", "code_src": "mathlib4", "ptype": "def", "header": "def Set.BijOn {α : Type u} {β : Type v} (f : α → β) (s : Set🔗<|PREMISE|>🔗 α) (t : Set🔗<|PREMISE|>🔗 β) :Prop", "code": "def BijOn (f : α → β) (s : Set α) (t : Set β) : Prop := MapsTo f s t ∧ InjOn f s ∧ SurjOn f s t\n", "additional_info": "`f` is bijective from `s` to `t` if `f` is injective on `s` and `f '' s = t`.\nEquations\n* 🗟Set.BijOn🗟🔗../../.././Mathlib/Data/Set/Defs.html#Set.BijOn🔗  f s t 🗟=🗟🔗../../.././Init/Prelude.html#Eq🔗  (🗟Set.MapsTo🗟🔗../../.././Mathlib/Data/Set/Defs.html#Set.MapsTo🔗  f s t 🗟∧🗟🔗../../.././Init/Prelude.html#And🔗  🗟Set.InjOn🗟🔗../../.././Mathlib/Data/Set/Defs.html#Set.InjOn🔗  f s 🗟∧🗟🔗../../.././Init/Prelude.html#And🔗  🗟Set.SurjOn🗟🔗../../.././Mathlib/Data/Set/Defs.html#Set.SurjOn🔗  f s t)\n\n", "used_premises": [69, 69], "def_path": "Mathlib/Data/Set/Defs.lean", "pos": [301, 302], "informalization": "Function `Set.BijOn` checks if a function `f` is bijective between two sets `s` and `t`, meaning `f` is both injective (one-to-one) and surjective (onto) from `s` to `t`."}
{"full_name": "PartialPerm.surjOn", "url": "ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm.surjOn", "code_src": "con-nf", "ptype": "theorem", "header": "theorem PartialPerm.surjOn {α : Type u_1} (π : PartialPerm🔗<|PREMISE|>🔗 α) :Set.SurjOn🔗<|PREMISE|>🔗 π.toFun π.domain π.domain", "code": "protected theorem surjOn : SurjOn π π.domain π.domain :=\n  π.bijOn.surjOn\n", "additional_info": "", "used_premises": [645, 667], "def_path": "ConNF/Mathlib/Logic/Equiv/PartialPerm.lean", "pos": [121, 123], "informalization": "The theorem `PartialPerm.surjOn` states that for any partial permutation `π` of a set `α`, the function `π.toFun` is surjective on the domain `π.domain`."}
{"full_name": "Set.SurjOn", "url": "Mathlib/Data/Set/Defs.html#Set.SurjOn", "code_src": "mathlib4", "ptype": "def", "header": "def Set.SurjOn {α : Type u} {β : Type v} (f : α → β) (s : Set🔗<|PREMISE|>🔗 α) (t : Set🔗<|PREMISE|>🔗 β) :Prop", "code": "def SurjOn (f : α → β) (s : Set α) (t : Set β) : Prop := t ⊆ f '' s\n", "additional_info": "`f` is surjective from `a` to `b` if `b` is contained in the image of `a`.\nEquations\n* 🗟Set.SurjOn🗟🔗../../.././Mathlib/Data/Set/Defs.html#Set.SurjOn🔗  f s t 🗟=🗟🔗../../.././Init/Prelude.html#Eq🔗  (t 🗟⊆🗟🔗../../.././Init/Core.html#HasSubset.Subset🔗  f 🗟''🗟🔗../../.././Mathlib/Init/Set.html#Set.image🔗  s)\n\n", "used_premises": [69, 69], "def_path": "Mathlib/Data/Set/Defs.lean", "pos": [297, 298], "informalization": "Function `Set.SurjOn` checks if the image of set `s` under function `f` contains set `t`."}
{"full_name": "PartialPerm.copy_toFun", "url": "ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm.copy_toFun", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem PartialPerm.copy_toFun {α : Type u_1} (π : PartialPerm🔗<|PREMISE|>🔗 α) (f : α → α) (hf : π.toFun = f) (g : α → α) (hg : (PartialPerm.symm🔗<|PREMISE|>🔗 π).toFun = g) (s : Set🔗<|PREMISE|>🔗 α) (hs : π.domain = s) :(PartialPerm.copy🔗<|PREMISE|>🔗 π f hf g hg s hs).toFun = f", "code": "@[simps (config := { fullyApplied := false })]\n", "additional_info": "", "used_premises": [645, 644, 69, 669], "def_path": "ConNF/Mathlib/Logic/Equiv/PartialPerm.lean", "pos": [125, 126], "informalization": "Function `PartialPerm.copy` is used to create a copy of a `PartialPerm` object, which represents a partial permutation of a subset of a type. It provides better definitional equalities for the function and its inverse, as well as the domain of the permutation. The theorem `PartialPerm.copy_toFun` states that the function of the copy is equal to the function of the original partial permutation."}
{"full_name": "PartialPerm.copy", "url": "ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm.copy", "code_src": "con-nf", "ptype": "def", "header": "def PartialPerm.copy {α : Type u_1} (π : PartialPerm🔗<|PREMISE|>🔗 α) (f : α → α) (hf : π.toFun = f) (g : α → α) (hg : (PartialPerm.symm🔗<|PREMISE|>🔗 π).toFun = g) (s : Set🔗<|PREMISE|>🔗 α) (hs : π.domain = s) :PartialPerm🔗<|PREMISE|>🔗 α", "code": "def copy (π : PartialPerm α) (f : α → α) (hf : ⇑π = f) (g : α → α) (hg : ⇑π.symm = g) (s : Set α)\n    (hs : π.domain = s) : PartialPerm α where\n  toFun := f\n  invFun := g\n  domain := s\n  toFun_domain' := hs ▸ hf ▸ π.toFun_domain'\n  invFun_domain' := hs ▸ hg ▸ π.invFun_domain'\n  left_inv' _ := hs ▸ hf ▸ hg ▸ π.left_inv\n  right_inv' _ := hs ▸ hf ▸ hg ▸ π.right_inv\n", "additional_info": "Create a copy of a `🗟PartialPerm🗟🔗../../../.././ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm🔗`  providing better definitional equalities.\nEquations\n* 🗟PartialPerm.copy🗟🔗../../../.././ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm.copy🔗  π f hf g hg s hs 🗟=🗟🔗../../../.././Init/Prelude.html#Eq🔗  { toFun := f, invFun := g, domain := s, toFun_domain' := ⋯, invFun_domain' := ⋯, left_inv' := ⋯, right_inv' := ⋯ }\n\n", "used_premises": [645, 644, 69, 645], "def_path": "ConNF/Mathlib/Logic/Equiv/PartialPerm.lean", "pos": [126, 135], "informalization": "Function `PartialPerm.copy` is used to create a copy of a `PartialPerm` object, which represents a partial permutation of a subset of a type. It provides better definitional equalities for the function and its inverse, as well as the domain of the permutation."}
{"full_name": "PartialPerm.copy_domain", "url": "ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm.copy_domain", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem PartialPerm.copy_domain {α : Type u_1} (π : PartialPerm🔗<|PREMISE|>🔗 α) (f : α → α) (hf : π.toFun = f) (g : α → α) (hg : (PartialPerm.symm🔗<|PREMISE|>🔗 π).toFun = g) (s : Set🔗<|PREMISE|>🔗 α) (hs : π.domain = s) :(PartialPerm.copy🔗<|PREMISE|>🔗 π f hf g hg s hs).domain = s", "code": "@[simps (config := { fullyApplied := false })]\n", "additional_info": "", "used_premises": [645, 644, 69, 669], "def_path": "ConNF/Mathlib/Logic/Equiv/PartialPerm.lean", "pos": [125, 126], "informalization": "Function `PartialPerm.copy_domain` is used to create a copy of a `PartialPerm` object, which represents a partial permutation of a subset of a type. It provides better definitional equalities for the function and its inverse, as well as the domain of the permutation."}
{"full_name": "PartialPerm.copy_invFun", "url": "ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm.copy_invFun", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem PartialPerm.copy_invFun {α : Type u_1} (π : PartialPerm🔗<|PREMISE|>🔗 α) (f : α → α) (hf : π.toFun = f) (g : α → α) (hg : (PartialPerm.symm🔗<|PREMISE|>🔗 π).toFun = g) (s : Set🔗<|PREMISE|>🔗 α) (hs : π.domain = s) :(PartialPerm.copy🔗<|PREMISE|>🔗 π f hf g hg s hs).invFun = g", "code": "@[simps (config := { fullyApplied := false })]\n", "additional_info": "", "used_premises": [645, 644, 69, 669], "def_path": "ConNF/Mathlib/Logic/Equiv/PartialPerm.lean", "pos": [125, 126], "informalization": "Function `PartialPerm.copy` is used to create a copy of a `PartialPerm` object, which represents a partial permutation of a subset of a type. It provides better definitional equalities for the function and its inverse, as well as the domain of the permutation. The theorem `PartialPerm.copy_invFun` states that the inverse function of the copy is equal to the inverse function of the original partial permutation."}
{"full_name": "PartialPerm.copy_eq", "url": "ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm.copy_eq", "code_src": "con-nf", "ptype": "theorem", "header": "theorem PartialPerm.copy_eq {α : Type u_1} (π : PartialPerm🔗<|PREMISE|>🔗 α) (f : α → α) (hf : π.toFun = f) (g : α → α) (hg : (PartialPerm.symm🔗<|PREMISE|>🔗 π).toFun = g) (s : Set🔗<|PREMISE|>🔗 α) (hs : π.domain = s) :PartialPerm.copy🔗<|PREMISE|>🔗 π f hf g hg s hs = π", "code": "theorem copy_eq (π : PartialPerm α) (f : α → α) (hf : ⇑π = f) (g : α → α) (hg : ⇑π.symm = g)\n    (s : Set α) (hs : π.domain = s) : π.copy f hf g hg s hs = π := by substs f g s; cases π; rfl\n", "additional_info": "", "used_premises": [645, 644, 69, 669], "def_path": "ConNF/Mathlib/Logic/Equiv/PartialPerm.lean", "pos": [136, 138], "informalization": "Function `PartialPerm.copy` is used to create a copy of a `PartialPerm` object, which represents a partial permutation of a subset of a type. It provides better definitional equalities for the function and its inverse, as well as the domain of the permutation."}
{"full_name": "PartialPerm.image_domain", "url": "ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm.image_domain", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem PartialPerm.image_domain {α : Type u_1} (π : PartialPerm🔗<|PREMISE|>🔗 α) :π.toFun '' π.domain = π.domain", "code": "theorem image_domain : π '' π.domain = π.domain :=\n  π.bijOn.image_eq\n", "additional_info": "", "used_premises": [645], "def_path": "ConNF/Mathlib/Logic/Equiv/PartialPerm.lean", "pos": [148, 150], "informalization": "The image of the domain of a partial permutation is equal to the domain itself."}
{"full_name": "PartialPerm.forall_mem_domain", "url": "ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm.forall_mem_domain", "code_src": "con-nf", "ptype": "theorem", "header": "theorem PartialPerm.forall_mem_domain {α : Type u_1} (π : PartialPerm🔗<|PREMISE|>🔗 α) {p : α → Prop } :(∀ y ∈ π.domain, p y) ↔ ∀ x ∈ π.domain, p (π.toFun x)", "code": "theorem forall_mem_domain {p : α → Prop} : (∀ y ∈ π.domain, p y) ↔ ∀ x ∈ π.domain, p (π x) := by\n  conv_lhs => rw [← image_domain, ball_image_iff]\n", "additional_info": "", "used_premises": [645], "def_path": "ConNF/Mathlib/Logic/Equiv/PartialPerm.lean", "pos": [151, 153], "informalization": "The statement `∀ y ∈ π.domain, p y` is equivalent to `∀ x ∈ π.domain, p (π.toFun x)`."}
{"full_name": "PartialPerm.exists_mem_domain", "url": "ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm.exists_mem_domain", "code_src": "con-nf", "ptype": "theorem", "header": "theorem PartialPerm.exists_mem_domain {α : Type u_1} (π : PartialPerm🔗<|PREMISE|>🔗 α) {p : α → Prop } :(∃ y ∈ π.domain, p y) ↔ ∃ x ∈ π.domain, p (π.toFun x)", "code": "theorem exists_mem_domain {p : α → Prop} : (∃ y ∈ π.domain, p y) ↔ ∃ x ∈ π.domain, p (π x) := by\n  conv_lhs => rw [← image_domain, bex_image_iff]\n", "additional_info": "", "used_premises": [645], "def_path": "ConNF/Mathlib/Logic/Equiv/PartialPerm.lean", "pos": [154, 156], "informalization": "Given a partial permutation `π` and a property `p`, if there exists an element `y` in the domain of `π` such that `p y` holds, then there exists an element `x` in the domain of `π` such that `p (π.toFun x)` holds."}
{"full_name": "PartialPerm.IsStable.apply_mem_iff", "url": "ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm.IsStable.apply_mem_iff", "code_src": "con-nf", "ptype": "theorem", "header": "theorem PartialPerm.IsStable.apply_mem_iff {α : Type u_1} {π : PartialPerm🔗<|PREMISE|>🔗 α} {s : Set🔗<|PREMISE|>🔗 α} {x : α} (h : PartialPerm.IsStable🔗<|PREMISE|>🔗 π s) (hx : x ∈ π.domain) :π.toFun x ∈ s ↔ x ∈ s", "code": "theorem apply_mem_iff (h : π.IsStable s) (hx : x ∈ π.domain) : π x ∈ s ↔ x ∈ s :=\n  h hx\n", "additional_info": "", "used_premises": [645, 69, 677], "def_path": "ConNF/Mathlib/Logic/Equiv/PartialPerm.lean", "pos": [165, 167], "informalization": "Given a partial permutation `π` and a set `s`, if `π` is stable on `s`, then for any element `x` in the domain of `π`, `x` is in `s` if and only if its image under `π` is also in `s`."}
{"full_name": "PartialPerm.IsStable", "url": "ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm.IsStable", "code_src": "con-nf", "ptype": "def", "header": "def PartialPerm.IsStable {α : Type u_1} (π : PartialPerm🔗<|PREMISE|>🔗 α) (s : Set🔗<|PREMISE|>🔗 α) :Prop", "code": "def IsStable (s : Set α) : Prop :=\n  ∀ ⦃x⦄, x ∈ π.domain → (π x ∈ s ↔ x ∈ s)\n", "additional_info": "A set `s` is *stable* under a partial equivalence `π` if it preserved by it.\nEquations\n* 🗟PartialPerm.IsStable🗟🔗../../../.././ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm.IsStable🔗  π s 🗟=🗟🔗../../../.././Init/Prelude.html#Eq🔗  ∀ ⦃x : α⦄, x 🗟∈🗟🔗../../../.././Init/Prelude.html#Membership.mem🔗  π.domain → (π.toFun x 🗟∈🗟🔗../../../.././Init/Prelude.html#Membership.mem🔗  s 🗟↔🗟🔗../../../.././Init/Core.html#Iff🔗  x 🗟∈🗟🔗../../../.././Init/Prelude.html#Membership.mem🔗  s)\n\n", "used_premises": [645, 69], "def_path": "ConNF/Mathlib/Logic/Equiv/PartialPerm.lean", "pos": [158, 160], "informalization": "Function `PartialPerm.IsStable` checks if a set `s` is preserved by a partial permutation `π`, meaning that for any element `x` in the domain of `π`, `x` is in `s` if and only if its image under `π` is also in `s`."}
{"full_name": "PartialPerm.IsStable.symm_apply_mem_iff", "url": "ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm.IsStable.symm_apply_mem_iff", "code_src": "con-nf", "ptype": "theorem", "header": "theorem PartialPerm.IsStable.symm_apply_mem_iff {α : Type u_1} {π : PartialPerm🔗<|PREMISE|>🔗 α} {s : Set🔗<|PREMISE|>🔗 α} (h : PartialPerm.IsStable🔗<|PREMISE|>🔗 π s) ⦃y : α⦄ :y ∈ π.domain → ((PartialPerm.symm🔗<|PREMISE|>🔗 π).toFun y ∈ s ↔ y ∈ s)", "code": "theorem symm_apply_mem_iff (h : π.IsStable s) : ∀ ⦃y⦄, y ∈ π.domain → (π.symm y ∈ s ↔ y ∈ s) :=\n  π.forall_mem_domain.mpr fun x hx => by rw [π.left_inv hx, h hx]\n", "additional_info": "", "used_premises": [645, 69, 677, 644], "def_path": "ConNF/Mathlib/Logic/Equiv/PartialPerm.lean", "pos": [168, 170], "informalization": "Function `PartialPerm.IsStable.symm_apply_mem_iff` states that for a partial permutation `π` that is stable on a set `s`, if `y` is in the domain of `π`, then `y` is in `s` if and only if its image under the inverse of `π` is also in `s`."}
{"full_name": "PartialPerm.IsStable.symm", "url": "ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm.IsStable.symm", "code_src": "con-nf", "ptype": "theorem", "header": "theorem PartialPerm.IsStable.symm {α : Type u_1} {π : PartialPerm🔗<|PREMISE|>🔗 α} {s : Set🔗<|PREMISE|>🔗 α} (h : PartialPerm.IsStable🔗<|PREMISE|>🔗 π s) :PartialPerm.IsStable🔗<|PREMISE|>🔗 (PartialPerm.symm🔗<|PREMISE|>🔗 π) s", "code": "protected theorem symm (h : π.IsStable s) : π.symm.IsStable s :=\n  h.symm_apply_mem_iff\n", "additional_info": "", "used_premises": [645, 69, 677, 677, 644], "def_path": "ConNF/Mathlib/Logic/Equiv/PartialPerm.lean", "pos": [171, 173], "informalization": "If a partial permutation `π` is stable on a set `s`, then its inverse `π.symm` is also stable on `s`."}
{"full_name": "PartialPerm.IsStable.symm_iff", "url": "ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm.IsStable.symm_iff", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem PartialPerm.IsStable.symm_iff {α : Type u_1} {π : PartialPerm🔗<|PREMISE|>🔗 α} {s : Set🔗<|PREMISE|>🔗 α} :PartialPerm.IsStable🔗<|PREMISE|>🔗 (PartialPerm.symm🔗<|PREMISE|>🔗 π) s ↔ PartialPerm.IsStable🔗<|PREMISE|>🔗 π s", "code": "theorem symm_iff : π.symm.IsStable s ↔ π.IsStable s :=\n  ⟨fun h => h.symm, fun h => h.symm⟩\n", "additional_info": "", "used_premises": [645, 69, 677, 644, 677], "def_path": "ConNF/Mathlib/Logic/Equiv/PartialPerm.lean", "pos": [175, 177], "informalization": "Function `PartialPerm.IsStable.symm_iff` states that a set `s` is preserved by the inverse of a partial permutation `π` if and only if `s` is preserved by `π` itself."}
{"full_name": "PartialPerm.IsStable.mapsTo", "url": "ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm.IsStable.mapsTo", "code_src": "con-nf", "ptype": "theorem", "header": "theorem PartialPerm.IsStable.mapsTo {α : Type u_1} {π : PartialPerm🔗<|PREMISE|>🔗 α} {s : Set🔗<|PREMISE|>🔗 α} (h : PartialPerm.IsStable🔗<|PREMISE|>🔗 π s) :Set.MapsTo🔗<|PREMISE|>🔗 π.toFun (π.domain ∩ s) (π.domain ∩ s)", "code": "protected theorem mapsTo (h : π.IsStable s) : MapsTo π (π.domain ∩ s) (π.domain ∩ s) :=\n  fun _ hx => ⟨π.mapsTo hx.1, (h hx.1).2 hx.2⟩\n", "additional_info": "", "used_premises": [645, 69, 677, 656], "def_path": "ConNF/Mathlib/Logic/Equiv/PartialPerm.lean", "pos": [178, 180], "informalization": "Function `PartialPerm.IsStable` checks if a set `s` is preserved by a partial permutation `π`, meaning that for any element `x` in the domain of `π`, `x` is in `s` if and only if its image under `π` is also in `s`. Function `Set.MapsTo` checks if the image of a set `s` under a function `f` is contained within another set `t`. The theorem `PartialPerm.IsStable.mapsTo` states that if a set `s` is preserved by a partial permutation `π`, then the image of the intersection of the domain of `π` and `s` under `π` is contained within the intersection of the domain of `π` and `s`."}
{"full_name": "PartialPerm.IsStable.symm_mapsTo", "url": "ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm.IsStable.symm_mapsTo", "code_src": "con-nf", "ptype": "theorem", "header": "theorem PartialPerm.IsStable.symm_mapsTo {α : Type u_1} {π : PartialPerm🔗<|PREMISE|>🔗 α} {s : Set🔗<|PREMISE|>🔗 α} (h : PartialPerm.IsStable🔗<|PREMISE|>🔗 π s) :Set.MapsTo🔗<|PREMISE|>🔗 (PartialPerm.symm🔗<|PREMISE|>🔗 π).toFun (π.domain ∩ s) (π.domain ∩ s)", "code": "theorem symm_mapsTo (h : π.IsStable s) : MapsTo π.symm (π.domain ∩ s) (π.domain ∩ s) :=\n  h.symm.mapsTo\n", "additional_info": "", "used_premises": [645, 69, 677, 656, 644], "def_path": "ConNF/Mathlib/Logic/Equiv/PartialPerm.lean", "pos": [181, 183], "informalization": "The theorem `PartialPerm.IsStable.symm_mapsTo` proves that the inverse of a partial permutation `π` maps elements of the intersection of its domain and a set `s` back into the intersection of its domain and `s`, assuming `s` is preserved by `π` (i.e., `s` is `π.IsStable`). This is a crucial property for understanding how partial permutations interact with sets, especially in the context where the set is preserved by the permutation."}
{"full_name": "PartialPerm.IsStable.restr_toFun", "url": "ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm.IsStable.restr_toFun", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem PartialPerm.IsStable.restr_toFun {α : Type u_1} {π : PartialPerm🔗<|PREMISE|>🔗 α} {s : Set🔗<|PREMISE|>🔗 α} (h : PartialPerm.IsStable🔗<|PREMISE|>🔗 π s) :(PartialPerm.IsStable.restr🔗<|PREMISE|>🔗 h).toFun = π.toFun", "code": "@[simps (config := { fullyApplied := false })]\n", "additional_info": "", "used_premises": [645, 69, 677, 684], "def_path": "ConNF/Mathlib/Logic/Equiv/PartialPerm.lean", "pos": [185, 186], "informalization": "Function `PartialPerm.IsStable.restr` restricts a partial permutation `π` to a subset `s` of its domain, where `s` is preserved by `π` in the sense that for any element `x` in the domain of `π`, `x` is in `s` if and only if its image under `π` is also in `s`. The result is a new partial permutation whose domain is the intersection of the original domain of `π` and `s`, and whose action on this domain is the same as that of `π`. The theorem `PartialPerm.IsStable.restr_toFun` states that the function `toFun` of the restricted partial permutation is equal to the function `toFun` of the original partial permutation."}
{"full_name": "PartialPerm.IsStable.restr", "url": "ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm.IsStable.restr", "code_src": "con-nf", "ptype": "def", "header": "def PartialPerm.IsStable.restr {α : Type u_1} {π : PartialPerm🔗<|PREMISE|>🔗 α} {s : Set🔗<|PREMISE|>🔗 α} (h : PartialPerm.IsStable🔗<|PREMISE|>🔗 π s) :PartialPerm🔗<|PREMISE|>🔗 α", "code": "def restr (h : π.IsStable s) : PartialPerm α\n    where\n  toFun := π\n  invFun := π.symm\n  domain := π.domain ∩ s\n  toFun_domain' := h.mapsTo\n  invFun_domain' := h.symm_mapsTo\n  left_inv' := π.leftInvOn.mono (inter_subset_left _ _)\n  right_inv' := π.rightInvOn.mono (inter_subset_left _ _)\n", "additional_info": "Restrict a `🗟PartialPerm🗟🔗../../../.././ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm🔗`  to a stable subset.\nEquations\n* 🗟PartialPerm.IsStable.restr🗟🔗../../../.././ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm.IsStable.restr🔗  h 🗟=🗟🔗../../../.././Init/Prelude.html#Eq🔗  { toFun := π.toFun, invFun := (🗟PartialPerm.symm🗟🔗../../../.././ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm.symm🔗  π).toFun, domain := π.domain 🗟∩🗟🔗../../../.././Init/Core.html#Inter.inter🔗  s, toFun_domain' := ⋯,\n invFun_domain' := ⋯, left_inv' := ⋯, right_inv' := ⋯ }\n\n", "used_premises": [645, 69, 677, 645], "def_path": "ConNF/Mathlib/Logic/Equiv/PartialPerm.lean", "pos": [186, 195], "informalization": "Function `PartialPerm.IsStable.restr` restricts a partial permutation `π` to a subset `s` of its domain, where `s` is preserved by `π` in the sense that for any element `x` in the domain of `π`, `x` is in `s` if and only if its image under `π` is also in `s`. The result is a new partial permutation whose domain is the intersection of the original domain of `π` and `s`, and whose action on this domain is the same as that of `π`."}
{"full_name": "PartialPerm.IsStable.restr_invFun", "url": "ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm.IsStable.restr_invFun", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem PartialPerm.IsStable.restr_invFun {α : Type u_1} {π : PartialPerm🔗<|PREMISE|>🔗 α} {s : Set🔗<|PREMISE|>🔗 α} (h : PartialPerm.IsStable🔗<|PREMISE|>🔗 π s) :(PartialPerm.IsStable.restr🔗<|PREMISE|>🔗 h).invFun = (PartialPerm.symm🔗<|PREMISE|>🔗 π).toFun", "code": "@[simps (config := { fullyApplied := false })]\n", "additional_info": "", "used_premises": [645, 69, 677, 684, 644], "def_path": "ConNF/Mathlib/Logic/Equiv/PartialPerm.lean", "pos": [185, 186], "informalization": "Function `PartialPerm.IsStable.restr_invFun` states that the inverse function of the restriction of a partial permutation `π` to a set `s`, where `s` is preserved by `π`, is equal to the function of the inverse of `π`."}
{"full_name": "PartialPerm.IsStable.restr_domain", "url": "ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm.IsStable.restr_domain", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem PartialPerm.IsStable.restr_domain {α : Type u_1} {π : PartialPerm🔗<|PREMISE|>🔗 α} {s : Set🔗<|PREMISE|>🔗 α} (h : PartialPerm.IsStable🔗<|PREMISE|>🔗 π s) :(PartialPerm.IsStable.restr🔗<|PREMISE|>🔗 h).domain = π.domain ∩ s", "code": "@[simps (config := { fullyApplied := false })]\n", "additional_info": "", "used_premises": [645, 69, 677, 684], "def_path": "ConNF/Mathlib/Logic/Equiv/PartialPerm.lean", "pos": [185, 186], "informalization": "Function `PartialPerm.IsStable.restr_domain` states that the domain of a partial permutation `π` restricted to a subset `s` of its domain, where `s` is preserved by `π`, is equal to the intersection of the original domain of `π` and `s`."}
{"full_name": "PartialPerm.IsStable.image_eq", "url": "ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm.IsStable.image_eq", "code_src": "con-nf", "ptype": "theorem", "header": "theorem PartialPerm.IsStable.image_eq {α : Type u_1} {π : PartialPerm🔗<|PREMISE|>🔗 α} {s : Set🔗<|PREMISE|>🔗 α} (h : PartialPerm.IsStable🔗<|PREMISE|>🔗 π s) :π.toFun '' (π.domain ∩ s) = π.domain ∩ s", "code": "theorem image_eq (h : π.IsStable s) : π '' (π.domain ∩ s) = π.domain ∩ s :=\n  h.restr.image_domain\n", "additional_info": "", "used_premises": [645, 69, 677], "def_path": "ConNF/Mathlib/Logic/Equiv/PartialPerm.lean", "pos": [196, 198], "informalization": "Given a partial permutation `π` and a set `s`, if `π` is stable on `s`, the image of the intersection of the domain of `π` and `s` under `π` is equal to the intersection of the domain of `π` and `s`."}
{"full_name": "PartialPerm.IsStable.symm_image_eq", "url": "ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm.IsStable.symm_image_eq", "code_src": "con-nf", "ptype": "theorem", "header": "theorem PartialPerm.IsStable.symm_image_eq {α : Type u_1} {π : PartialPerm🔗<|PREMISE|>🔗 α} {s : Set🔗<|PREMISE|>🔗 α} (h : PartialPerm.IsStable🔗<|PREMISE|>🔗 π s) :(PartialPerm.symm🔗<|PREMISE|>🔗 π).toFun '' (π.domain ∩ s) = π.domain ∩ s", "code": "theorem symm_image_eq (h : π.IsStable s) : π.symm '' (π.domain ∩ s) = π.domain ∩ s :=\n  h.symm.image_eq\n", "additional_info": "", "used_premises": [645, 69, 677, 644], "def_path": "ConNF/Mathlib/Logic/Equiv/PartialPerm.lean", "pos": [199, 201], "informalization": "Function `PartialPerm.IsStable.symm_image_eq` states that for a partial permutation `π` that is stable on a set `s`, the image of the intersection of the domain of `π` and `s` under the inverse of `π` is equal to the intersection of the domain of `π` and `s`."}
{"full_name": "PartialPerm.IsStable.iff_preimage_eq", "url": "ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm.IsStable.iff_preimage_eq", "code_src": "con-nf", "ptype": "theorem", "header": "theorem PartialPerm.IsStable.iff_preimage_eq {α : Type u_1} {π : PartialPerm🔗<|PREMISE|>🔗 α} {s : Set🔗<|PREMISE|>🔗 α} :PartialPerm.IsStable🔗<|PREMISE|>🔗 π s ↔ π.domain ∩ π.toFun ⁻¹' s = π.domain ∩ s", "code": "theorem iff_preimage_eq : π.IsStable s ↔ π.domain ∩ π ⁻¹' s = π.domain ∩ s := by\n  simp only [IsStable, Set.ext_iff, mem_inter_iff, and_congr_right_iff, mem_preimage]\n", "additional_info": "", "used_premises": [645, 69, 677], "def_path": "ConNF/Mathlib/Logic/Equiv/PartialPerm.lean", "pos": [202, 204], "informalization": "Function `PartialPerm.IsStable` checks if a set `s` is preserved by a partial permutation `π`, meaning that for any element `x` in the domain of `π`, `x` is in `s` if and only if its image under `π` is also in `s`. The theorem `iff_preimage_eq` states that this condition is equivalent to the intersection of the domain of `π` and the preimage of `s` under `π.toFun` being equal to the intersection of the domain of `π` and `s`."}
{"full_name": "PartialPerm.IsStable.of_preimage_eq", "url": "ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm.IsStable.of_preimage_eq", "code_src": "con-nf", "ptype": "theorem", "header": "theorem PartialPerm.IsStable.of_preimage_eq {α : Type u_1} {π : PartialPerm🔗<|PREMISE|>🔗 α} {s : Set🔗<|PREMISE|>🔗 α} :π.domain ∩ π.toFun ⁻¹' s = π.domain ∩ s → PartialPerm.IsStable🔗<|PREMISE|>🔗 π s", "code": "alias ⟨preimage_eq, of_preimage_eq⟩ := iff_preimage_eq\n", "additional_info": "**Alias** of the reverse direction of `🗟PartialPerm.IsStable.iff_preimage_eq🗟🔗../../../.././ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm.IsStable.iff_preimage_eq🔗` .", "used_premises": [645, 69, 677], "def_path": "ConNF/Mathlib/Logic/Equiv/PartialPerm.lean", "pos": [205, 206], "informalization": "Given a partial permutation `π` and a set `s`, if the intersection of the domain of `π` and the preimage of `s` under `π` is equal to the intersection of the domain of `π` and `s`, then `s` is preserved by `π`."}
{"full_name": "PartialPerm.IsStable.preimage_eq", "url": "ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm.IsStable.preimage_eq", "code_src": "con-nf", "ptype": "theorem", "header": "theorem PartialPerm.IsStable.preimage_eq {α : Type u_1} {π : PartialPerm🔗<|PREMISE|>🔗 α} {s : Set🔗<|PREMISE|>🔗 α} :PartialPerm.IsStable🔗<|PREMISE|>🔗 π s → π.domain ∩ π.toFun ⁻¹' s = π.domain ∩ s", "code": "alias ⟨preimage_eq, of_preimage_eq⟩ := iff_preimage_eq\n", "additional_info": "**Alias** of the forward direction of `🗟PartialPerm.IsStable.iff_preimage_eq🗟🔗../../../.././ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm.IsStable.iff_preimage_eq🔗` .", "used_premises": [645, 69, 677], "def_path": "ConNF/Mathlib/Logic/Equiv/PartialPerm.lean", "pos": [205, 206], "informalization": "Function `PartialPerm.IsStable.preimage_eq` is an alias of the forward direction of `PartialPerm.IsStable.iff_preimage_eq`. It states that if a partial permutation `π` is stable on a set `s`, then the intersection of the domain of `π` and the preimage of `s` under `π` is equal to the intersection of the domain of `π` and `s`."}
{"full_name": "PartialPerm.IsStable.iff_symm_preimage_eq", "url": "ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm.IsStable.iff_symm_preimage_eq", "code_src": "con-nf", "ptype": "theorem", "header": "theorem PartialPerm.IsStable.iff_symm_preimage_eq {α : Type u_1} {π : PartialPerm🔗<|PREMISE|>🔗 α} {s : Set🔗<|PREMISE|>🔗 α} :PartialPerm.IsStable🔗<|PREMISE|>🔗 π s ↔ π.domain ∩ (PartialPerm.symm🔗<|PREMISE|>🔗 π).toFun ⁻¹' s = π.domain ∩ s", "code": "theorem iff_symm_preimage_eq : π.IsStable s ↔ π.domain ∩ π.symm ⁻¹' s = π.domain ∩ s :=\n  symm_iff.symm.trans iff_preimage_eq\n", "additional_info": "", "used_premises": [645, 69, 677, 644], "def_path": "ConNF/Mathlib/Logic/Equiv/PartialPerm.lean", "pos": [207, 209], "informalization": "The theorem `PartialPerm.IsStable.iff_symm_preimage_eq` states that a set `s` is preserved by a partial permutation `π` if and only if the intersection of the domain of `π` and the preimage of `s` under the inverse of `π` is equal to the intersection of the domain of `π` and `s`."}
{"full_name": "PartialPerm.IsStable.symm_preimage_eq", "url": "ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm.IsStable.symm_preimage_eq", "code_src": "con-nf", "ptype": "theorem", "header": "theorem PartialPerm.IsStable.symm_preimage_eq {α : Type u_1} {π : PartialPerm🔗<|PREMISE|>🔗 α} {s : Set🔗<|PREMISE|>🔗 α} :PartialPerm.IsStable🔗<|PREMISE|>🔗 π s → π.domain ∩ (PartialPerm.symm🔗<|PREMISE|>🔗 π).toFun ⁻¹' s = π.domain ∩ s", "code": "alias ⟨symm_preimage_eq, of_symm_preimage_eq⟩ := iff_symm_preimage_eq\n", "additional_info": "**Alias** of the forward direction of `🗟PartialPerm.IsStable.iff_symm_preimage_eq🗟🔗../../../.././ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm.IsStable.iff_symm_preimage_eq🔗` .", "used_premises": [645, 69, 677, 644], "def_path": "ConNF/Mathlib/Logic/Equiv/PartialPerm.lean", "pos": [210, 211], "informalization": "Function `PartialPerm.IsStable.symm_preimage_eq` is an alias of the forward direction of `PartialPerm.IsStable.iff_symm_preimage_eq`, which states that if a set `s` is preserved by a partial permutation `π`, then the intersection of the domain of `π` and the preimage of `s` under the inverse of `π` is equal to the intersection of the domain of `π` and `s`."}
{"full_name": "PartialPerm.IsStable.of_symm_preimage_eq", "url": "ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm.IsStable.of_symm_preimage_eq", "code_src": "con-nf", "ptype": "theorem", "header": "theorem PartialPerm.IsStable.of_symm_preimage_eq {α : Type u_1} {π : PartialPerm🔗<|PREMISE|>🔗 α} {s : Set🔗<|PREMISE|>🔗 α} :π.domain ∩ (PartialPerm.symm🔗<|PREMISE|>🔗 π).toFun ⁻¹' s = π.domain ∩ s → PartialPerm.IsStable🔗<|PREMISE|>🔗 π s", "code": "alias ⟨symm_preimage_eq, of_symm_preimage_eq⟩ := iff_symm_preimage_eq\n", "additional_info": "**Alias** of the reverse direction of `🗟PartialPerm.IsStable.iff_symm_preimage_eq🗟🔗../../../.././ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm.IsStable.iff_symm_preimage_eq🔗` .", "used_premises": [645, 69, 644, 677], "def_path": "ConNF/Mathlib/Logic/Equiv/PartialPerm.lean", "pos": [210, 211], "informalization": "The theorem `PartialPerm.IsStable.of_symm_preimage_eq` is an alias of the reverse direction of `PartialPerm.IsStable.iff_symm_preimage_eq`. It states that if the intersection of the domain of a partial permutation `π` and the preimage of a set `s` under the inverse of `π` is equal to the intersection of the domain of `π` and `s`, then `s` is stable under `π`."}
{"full_name": "PartialPerm.IsStable.compl", "url": "ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm.IsStable.compl", "code_src": "con-nf", "ptype": "theorem", "header": "theorem PartialPerm.IsStable.compl {α : Type u_1} {π : PartialPerm🔗<|PREMISE|>🔗 α} {s : Set🔗<|PREMISE|>🔗 α} (h : PartialPerm.IsStable🔗<|PREMISE|>🔗 π s) :PartialPerm.IsStable🔗<|PREMISE|>🔗 π sᶜ", "code": "protected theorem compl (h : π.IsStable s) : π.IsStable (sᶜ) :=\n  fun _ hx => not_congr (h hx)\n", "additional_info": "", "used_premises": [645, 69, 677, 677], "def_path": "ConNF/Mathlib/Logic/Equiv/PartialPerm.lean", "pos": [212, 214], "informalization": "If a partial permutation `π` is stable on a set `s`, then it is also stable on the complement of `s`."}
{"full_name": "PartialPerm.IsStable.inter", "url": "ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm.IsStable.inter", "code_src": "con-nf", "ptype": "theorem", "header": "theorem PartialPerm.IsStable.inter {α : Type u_1} {π : PartialPerm🔗<|PREMISE|>🔗 α} {s : Set🔗<|PREMISE|>🔗 α} {s' : Set🔗<|PREMISE|>🔗 α} (h : PartialPerm.IsStable🔗<|PREMISE|>🔗 π s) (h' : PartialPerm.IsStable🔗<|PREMISE|>🔗 π s') :PartialPerm.IsStable🔗<|PREMISE|>🔗 π (s ∩ s')", "code": "protected theorem inter {s'} (h : π.IsStable s) (h' : π.IsStable s') : π.IsStable (s ∩ s') :=\n  fun _ hx => and_congr (h hx) (h' hx)\n", "additional_info": "", "used_premises": [645, 69, 69, 677, 677, 677], "def_path": "ConNF/Mathlib/Logic/Equiv/PartialPerm.lean", "pos": [215, 217], "informalization": "Function `PartialPerm.IsStable.inter` proves that if two sets `s` and `s'` are preserved by a partial permutation `π`, then their intersection `s ∩ s'` is also preserved by `π`."}
{"full_name": "PartialPerm.IsStable.union", "url": "ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm.IsStable.union", "code_src": "con-nf", "ptype": "theorem", "header": "theorem PartialPerm.IsStable.union {α : Type u_1} {π : PartialPerm🔗<|PREMISE|>🔗 α} {s : Set🔗<|PREMISE|>🔗 α} {s' : Set🔗<|PREMISE|>🔗 α} (h : PartialPerm.IsStable🔗<|PREMISE|>🔗 π s) (h' : PartialPerm.IsStable🔗<|PREMISE|>🔗 π s') :PartialPerm.IsStable🔗<|PREMISE|>🔗 π (s ∪ s')", "code": "protected theorem union {s'} (h : π.IsStable s) (h' : π.IsStable s') : π.IsStable (s ∪ s') :=\n  fun _ hx => or_congr (h hx) (h' hx)\n", "additional_info": "", "used_premises": [645, 69, 69, 677, 677, 677], "def_path": "ConNF/Mathlib/Logic/Equiv/PartialPerm.lean", "pos": [218, 220], "informalization": "Function `PartialPerm.IsStable.union` proves that if two sets `s` and `s'` are both preserved by a partial permutation `π`, then their union `s ∪ s'` is also preserved by `π`."}
{"full_name": "PartialPerm.IsStable.diff", "url": "ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm.IsStable.diff", "code_src": "con-nf", "ptype": "theorem", "header": "theorem PartialPerm.IsStable.diff {α : Type u_1} {π : PartialPerm🔗<|PREMISE|>🔗 α} {s : Set🔗<|PREMISE|>🔗 α} {s' : Set🔗<|PREMISE|>🔗 α} (h : PartialPerm.IsStable🔗<|PREMISE|>🔗 π s) (h' : PartialPerm.IsStable🔗<|PREMISE|>🔗 π s') :PartialPerm.IsStable🔗<|PREMISE|>🔗 π (s \\ s')", "code": "protected theorem diff {s'} (h : π.IsStable s) (h' : π.IsStable s') : π.IsStable (s \\ s') :=\n  h.inter h'.compl\n", "additional_info": "", "used_premises": [645, 69, 69, 677, 677, 677], "def_path": "ConNF/Mathlib/Logic/Equiv/PartialPerm.lean", "pos": [221, 223], "informalization": "Function `PartialPerm.IsStable.diff` proves that if two sets `s` and `s'` are preserved by a partial permutation `π`, then their difference `s \\ s'` is also preserved by `π`."}
{"full_name": "PartialPerm.IsStable.leftInvOn_piecewise", "url": "ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm.IsStable.leftInvOn_piecewise", "code_src": "con-nf", "ptype": "theorem", "header": "theorem PartialPerm.IsStable.leftInvOn_piecewise {α : Type u_1} {π : PartialPerm🔗<|PREMISE|>🔗 α} {s : Set🔗<|PREMISE|>🔗 α} {π' : PartialPerm🔗<|PREMISE|>🔗 α} [(i : α) → Decidable🔗<|PREMISE|>🔗 (i ∈ s)] (h : PartialPerm.IsStable🔗<|PREMISE|>🔗 π s) (h' : PartialPerm.IsStable🔗<|PREMISE|>🔗 π' s) :Set.LeftInvOn🔗<|PREMISE|>🔗 (Set.piecewise🔗<|PREMISE|>🔗 s (PartialPerm.symm🔗<|PREMISE|>🔗 π).toFun (PartialPerm.symm🔗<|PREMISE|>🔗 π').toFun) (Set.piecewise🔗<|PREMISE|>🔗 s π.toFun π'.toFun) (Set.ite🔗<|PREMISE|>🔗 s π.domain π'.domain)", "code": "theorem leftInvOn_piecewise {π' : PartialPerm α} [∀ i, Decidable (i ∈ s)] (h : π.IsStable s)\n    (h' : π'.IsStable s) :\n    LeftInvOn (s.piecewise π.symm π'.symm) (s.piecewise π π') (s.ite π.domain π'.domain) := by\n  rintro x (⟨he, hs⟩ | ⟨he, hs : x ∉ s⟩)\n  · rw [piecewise_eq_of_mem _ _ _ hs, piecewise_eq_of_mem _ _ _ ((h he).2 hs), π.left_inv he]\n  · rw [piecewise_eq_of_not_mem _ _ _ hs, piecewise_eq_of_not_mem _ _ _ ((h'.compl he).2 hs),\n      π'.left_inv he]\n", "additional_info": "", "used_premises": [645, 69, 645, 14, 677, 677, 658, 700, 644, 644, 700, 701], "def_path": "ConNF/Mathlib/Logic/Equiv/PartialPerm.lean", "pos": [224, 231], "informalization": "Given a partial permutation `π` and a set `s`, if both `π` and `π'` are stable on `s`, then the piecewise function defined by them and their inverses is a left inverse on the union of the domains of `π` and `π'` restricted to `s`."}
{"full_name": "Set.piecewise", "url": "Mathlib/Logic/Function/Basic.html#Set.piecewise", "code_src": "mathlib4", "ptype": "def", "header": "def Set.piecewise {α : Type u} {β : α → Sort v} (s : Set🔗<|PREMISE|>🔗 α) (f : (i : α) → β i) (g : (i : α) → β i) [(j : α) → Decidable🔗<|PREMISE|>🔗 (j ∈ s)] (i : α) :β i", "code": "def Set.piecewise {α : Type u} {β : α → Sort v} (s : Set α) (f g : ∀ i, β i)\n    [∀ j, Decidable (j ∈ s)] : ∀ i, β i :=\n  fun i ↦ if i ∈ s then f i else g i\n", "additional_info": "`s.🗟piecewise🗟🔗../../.././Mathlib/Logic/Function/Basic.html#Set.piecewise🔗  f g` is the function equal to `f` on the set `s`, and to `g` on its complement.\nEquations\n* 🗟Set.piecewise🗟🔗../../.././Mathlib/Logic/Function/Basic.html#Set.piecewise🔗  s f g i 🗟=🗟🔗../../.././Init/Prelude.html#Eq🔗  if i 🗟∈🗟🔗../../.././Init/Prelude.html#Membership.mem🔗  s then f i else g i\n\n", "used_premises": [69, 14], "def_path": "Mathlib/Logic/Function/Basic.lean", "pos": [1038, 1041], "informalization": "`Set.piecewise` is a function that takes a set `s`, two functions `f` and `g`, and an element `i`. It returns `f i` if `i` is in `s`, and `g i` otherwise."}
{"full_name": "Set.ite", "url": "Mathlib/Data/Set/Basic.html#Set.ite", "code_src": "mathlib4", "ptype": "def", "header": "def Set.ite {α : Type u} (t : Set🔗<|PREMISE|>🔗 α) (s : Set🔗<|PREMISE|>🔗 α) (s' : Set🔗<|PREMISE|>🔗 α) :Set🔗<|PREMISE|>🔗 α", "code": "protected def ite (t s s' : Set α) : Set α :=\n  s ∩ t ∪ s' \\ t\n", "additional_info": "`🗟ite🗟🔗../../.././Init/Prelude.html#ite🔗`  for sets: `🗟Set.ite🗟🔗../../.././Mathlib/Data/Set/Basic.html#Set.ite🔗  t s s' ∩ t = s ∩ t`, `🗟Set.ite🗟🔗../../.././Mathlib/Data/Set/Basic.html#Set.ite🔗  t s s' ∩ tᶜ = s' ∩ tᶜ`.\nDefined as `s ∩ t ∪ s' \\ t`.\nEquations\n* 🗟Set.ite🗟🔗../../.././Mathlib/Data/Set/Basic.html#Set.ite🔗  t s s' 🗟=🗟🔗../../.././Init/Prelude.html#Eq🔗  s 🗟∩🗟🔗../../.././Init/Core.html#Inter.inter🔗  t 🗟∪🗟🔗../../.././Init/Core.html#Union.union🔗  s' 🗟\\🗟🔗../../.././Init/Core.html#SDiff.sdiff🔗  t\n\n", "used_premises": [69, 69, 69, 69], "def_path": "Mathlib/Data/Set/Basic.lean", "pos": [2235, 2237], "informalization": "`Set.ite` is a function that takes three sets `t`, `s`, and `s'`, and returns the union of the intersection of `s` and `t`, and the difference of `s'` and `t`."}
{"full_name": "PartialPerm.IsStable.inter_eq_of_inter_eq_of_eqOn", "url": "ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm.IsStable.inter_eq_of_inter_eq_of_eqOn", "code_src": "con-nf", "ptype": "theorem", "header": "theorem PartialPerm.IsStable.inter_eq_of_inter_eq_of_eqOn {α : Type u_1} {π : PartialPerm🔗<|PREMISE|>🔗 α} {s : Set🔗<|PREMISE|>🔗 α} {π' : PartialPerm🔗<|PREMISE|>🔗 α} (h : PartialPerm.IsStable🔗<|PREMISE|>🔗 π s) (h' : PartialPerm.IsStable🔗<|PREMISE|>🔗 π' s) (hs : π.domain ∩ s = π'.domain ∩ s) (Heq : Set.EqOn🔗<|PREMISE|>🔗 π.toFun π'.toFun (π.domain ∩ s)) :π.domain ∩ s = π'.domain ∩ s", "code": "theorem inter_eq_of_inter_eq_of_eqOn {π' : PartialPerm α} (h : π.IsStable s) (h' : π'.IsStable s)\n    (hs : π.domain ∩ s = π'.domain ∩ s) (Heq : EqOn π π' (π.domain ∩ s)) :\n    π.domain ∩ s = π'.domain ∩ s := by rw [← h.image_eq, ← h'.image_eq, ← hs, Heq.image_eq]\n", "additional_info": "", "used_premises": [645, 69, 645, 677, 677, 703], "def_path": "ConNF/Mathlib/Logic/Equiv/PartialPerm.lean", "pos": [232, 235], "informalization": "This theorem proves that, given two partial permutations `π` and `π'` of some type `α` which are stable on a set `s` (i.e., `s` is preserved by both permutations), and given that the intersection of the domains of `π` and `π'` with `s` is equal, and that `π` and `π'` are equal on the intersection of their domains with `s`, then the intersection of the domains of `π` and `s` is equal to the intersection of the domains of `π'` and `s`. This theorem helps in proving that the set `s` can be used as a domain for a larger partial permutation which is the union of `π` and `π'`, making the intersection of the domains of the resulting permutation and `s` equal to `s` itself."}
{"full_name": "Set.EqOn", "url": "Mathlib/Data/Set/Defs.html#Set.EqOn", "code_src": "mathlib4", "ptype": "def", "header": "def Set.EqOn {α : Type u} {β : Type v} (f₁ : α → β) (f₂ : α → β) (s : Set🔗<|PREMISE|>🔗 α) :Prop", "code": "def EqOn (f₁ f₂ : α → β) (s : Set α) : Prop := ∀ ⦃x⦄, x ∈ s → f₁ x = f₂ x\n", "additional_info": "Two functions `f₁ f₂ : α → β` are equal on `s` if `f₁ x = f₂ x` for all `x ∈ s`.\nEquations\n* 🗟Set.EqOn🗟🔗../../.././Mathlib/Data/Set/Defs.html#Set.EqOn🔗  f₁ f₂ s 🗟=🗟🔗../../.././Init/Prelude.html#Eq🔗  ∀ ⦃x : α⦄, x 🗟∈🗟🔗../../.././Init/Prelude.html#Membership.mem🔗  s → f₁ x 🗟=🗟🔗../../.././Init/Prelude.html#Eq🔗  f₂ x\n\n", "used_premises": [69], "def_path": "Mathlib/Data/Set/Defs.lean", "pos": [262, 263], "informalization": "Function `Set.EqOn` checks if two functions `f₁` and `f₂` are equal on a given set `s`. This means that for every element `x` in the set `s`, the values of `f₁ x` and `f₂ x` are equal."}
{"full_name": "PartialPerm.IsStable.symm_eqOn_of_inter_eq_of_eqOn", "url": "ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm.IsStable.symm_eqOn_of_inter_eq_of_eqOn", "code_src": "con-nf", "ptype": "theorem", "header": "theorem PartialPerm.IsStable.symm_eqOn_of_inter_eq_of_eqOn {α : Type u_1} {π : PartialPerm🔗<|PREMISE|>🔗 α} {s : Set🔗<|PREMISE|>🔗 α} {π' : PartialPerm🔗<|PREMISE|>🔗 α} (h : PartialPerm.IsStable🔗<|PREMISE|>🔗 π s) (hs : π.domain ∩ s = π'.domain ∩ s) (Heq : Set.EqOn🔗<|PREMISE|>🔗 π.toFun π'.toFun (π.domain ∩ s)) :Set.EqOn🔗<|PREMISE|>🔗 (PartialPerm.symm🔗<|PREMISE|>🔗 π).toFun (PartialPerm.symm🔗<|PREMISE|>🔗 π').toFun (π.domain ∩ s)", "code": "theorem symm_eqOn_of_inter_eq_of_eqOn {π' : PartialPerm α} (h : π.IsStable s)\n    (hs : π.domain ∩ s = π'.domain ∩ s) (Heq : EqOn π π' (π.domain ∩ s)) :\n    EqOn π.symm π'.symm (π.domain ∩ s) := by\n  rw [← h.image_eq]\n  rintro y ⟨x, hx, rfl⟩\n  have hx' := hx; rw [hs] at hx'\n  rw [π.left_inv hx.1, Heq hx, π'.left_inv hx'.1]\n", "additional_info": "", "used_premises": [645, 69, 645, 677, 703, 703, 644, 644], "def_path": "ConNF/Mathlib/Logic/Equiv/PartialPerm.lean", "pos": [236, 243], "informalization": "The theorem `PartialPerm.IsStable.symm_eqOn_of_inter_eq_of_eqOn` states that if a partial permutation `π` is stable on a set `s`, and `π` and `π'` are equal on the intersection of their domains with `s`, then the inverses of `π` and `π'` are equal on the intersection of their domains with `s`."}
{"full_name": "PartialPerm.image_domain_inter_eq'", "url": "ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm.image_domain_inter_eq'", "code_src": "con-nf", "ptype": "theorem", "header": "theorem PartialPerm.image_domain_inter_eq' {α : Type u_1} (π : PartialPerm🔗<|PREMISE|>🔗 α) (s : Set🔗<|PREMISE|>🔗 α) :π.toFun '' (π.domain ∩ s) = π.domain ∩ (PartialPerm.symm🔗<|PREMISE|>🔗 π).toFun ⁻¹' s", "code": "theorem image_domain_inter_eq' (s : Set α) : π '' (π.domain ∩ s) = π.domain ∩ π.symm ⁻¹' s := by\n  rw [inter_comm, π.leftInvOn.image_inter', image_domain, inter_comm]\n", "additional_info": "", "used_premises": [645, 69, 644], "def_path": "ConNF/Mathlib/Logic/Equiv/PartialPerm.lean", "pos": [246, 248], "informalization": "Function `image_domain_inter_eq'` states that for a partial permutation `π` and a set `s`, the image of the intersection of the domain of `π` and `s` under `π` is equal to the intersection of the domain of `π` and the preimage of `s` under the inverse of `π`."}
{"full_name": "PartialPerm.image_domain_inter_eq", "url": "ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm.image_domain_inter_eq", "code_src": "con-nf", "ptype": "theorem", "header": "theorem PartialPerm.image_domain_inter_eq {α : Type u_1} (π : PartialPerm🔗<|PREMISE|>🔗 α) (s : Set🔗<|PREMISE|>🔗 α) :π.toFun '' (π.domain ∩ s) = π.domain ∩ (PartialPerm.symm🔗<|PREMISE|>🔗 π).toFun ⁻¹' (π.domain ∩ s)", "code": "theorem image_domain_inter_eq (s : Set α) :\n    π '' (π.domain ∩ s) = π.domain ∩ π.symm ⁻¹' (π.domain ∩ s) := by\n  rw [inter_comm, π.leftInvOn.image_inter, image_domain, inter_comm]\n", "additional_info": "", "used_premises": [645, 69, 644], "def_path": "ConNF/Mathlib/Logic/Equiv/PartialPerm.lean", "pos": [249, 252], "informalization": "The theorem `image_domain_inter_eq` states that for a partial permutation `π` and a set `s`, the image of the intersection of the domain of `π` and `s` under `π` is equal to the intersection of the domain of `π` and the preimage of the intersection of the domain of `π` and `s` under the inverse of `π`."}
{"full_name": "PartialPerm.image_eq_domain_inter_inv_preimage", "url": "ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm.image_eq_domain_inter_inv_preimage", "code_src": "con-nf", "ptype": "theorem", "header": "theorem PartialPerm.image_eq_domain_inter_inv_preimage {α : Type u_1} (π : PartialPerm🔗<|PREMISE|>🔗 α) {s : Set🔗<|PREMISE|>🔗 α} (h : s ⊆ π.domain) :π.toFun '' s = π.domain ∩ (PartialPerm.symm🔗<|PREMISE|>🔗 π).toFun ⁻¹' s", "code": "theorem image_eq_domain_inter_inv_preimage {s : Set α} (h : s ⊆ π.domain) :\n    π '' s = π.domain ∩ π.symm ⁻¹' s := by\n  rw [← π.image_domain_inter_eq', inter_eq_self_of_subset_right h]\n", "additional_info": "", "used_premises": [645, 69, 644], "def_path": "ConNF/Mathlib/Logic/Equiv/PartialPerm.lean", "pos": [253, 256], "informalization": "The image of a set `s` under a partial permutation `π` is equal to the intersection of the domain of `π` and the preimage of `s` under the inverse of `π`."}
{"full_name": "PartialPerm.symm_image_eq_domain_inter_preimage", "url": "ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm.symm_image_eq_domain_inter_preimage", "code_src": "con-nf", "ptype": "theorem", "header": "theorem PartialPerm.symm_image_eq_domain_inter_preimage {α : Type u_1} (π : PartialPerm🔗<|PREMISE|>🔗 α) {s : Set🔗<|PREMISE|>🔗 α} (h : s ⊆ π.domain) :(PartialPerm.symm🔗<|PREMISE|>🔗 π).toFun '' s = π.domain ∩ π.toFun ⁻¹' s", "code": "theorem symm_image_eq_domain_inter_preimage {s : Set α} (h : s ⊆ π.domain) :\n    π.symm '' s = π.domain ∩ π ⁻¹' s :=\n  π.symm.image_eq_domain_inter_inv_preimage h\n", "additional_info": "", "used_premises": [645, 69, 644], "def_path": "ConNF/Mathlib/Logic/Equiv/PartialPerm.lean", "pos": [257, 260], "informalization": "The theorem `PartialPerm.symm_image_eq_domain_inter_preimage` states that for a partial permutation `π` and a subset `s` of its domain, the image of `s` under the inverse of `π` is equal to the intersection of `π`'s domain with the preimage of `s` under `π`."}
{"full_name": "PartialPerm.symm_image_domain_inter_eq", "url": "ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm.symm_image_domain_inter_eq", "code_src": "con-nf", "ptype": "theorem", "header": "theorem PartialPerm.symm_image_domain_inter_eq {α : Type u_1} (π : PartialPerm🔗<|PREMISE|>🔗 α) (s : Set🔗<|PREMISE|>🔗 α) :(PartialPerm.symm🔗<|PREMISE|>🔗 π).toFun '' (π.domain ∩ s) = π.domain ∩ π.toFun ⁻¹' (π.domain ∩ s)", "code": "theorem symm_image_domain_inter_eq (s : Set α) :\n    π.symm '' (π.domain ∩ s) = π.domain ∩ π ⁻¹' (π.domain ∩ s) :=\n  π.symm.image_domain_inter_eq _\n", "additional_info": "", "used_premises": [645, 69, 644], "def_path": "ConNF/Mathlib/Logic/Equiv/PartialPerm.lean", "pos": [261, 264], "informalization": "The theorem `PartialPerm.symm_image_domain_inter_eq` states that for a partial permutation `π` and a set `s`, the image of the intersection of the domain of `π` and `s` under the inverse of `π` is equal to the intersection of the domain of `π` and the preimage of the intersection of the domain of `π` and `s` under `π`."}
{"full_name": "PartialPerm.symm_image_domain_inter_eq'", "url": "ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm.symm_image_domain_inter_eq'", "code_src": "con-nf", "ptype": "theorem", "header": "theorem PartialPerm.symm_image_domain_inter_eq' {α : Type u_1} (π : PartialPerm🔗<|PREMISE|>🔗 α) (s : Set🔗<|PREMISE|>🔗 α) :(PartialPerm.symm🔗<|PREMISE|>🔗 π).toFun '' (π.domain ∩ s) = π.domain ∩ π.toFun ⁻¹' s", "code": "theorem symm_image_domain_inter_eq' (s : Set α) : π.symm '' (π.domain ∩ s) = π.domain ∩ π ⁻¹' s :=\n  π.symm.image_domain_inter_eq' _\n", "additional_info": "", "used_premises": [645, 69, 644], "def_path": "ConNF/Mathlib/Logic/Equiv/PartialPerm.lean", "pos": [265, 267], "informalization": "The theorem `PartialPerm.symm_image_domain_inter_eq'` states that for a partial permutation `π` and a set `s`, the image of the intersection of the domain of `π` and `s` under the inverse of `π` is equal to the intersection of the domain of `π` and the preimage of `s` under `π`."}
{"full_name": "PartialPerm.domain_inter_preimage_inv_preimage", "url": "ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm.domain_inter_preimage_inv_preimage", "code_src": "con-nf", "ptype": "theorem", "header": "theorem PartialPerm.domain_inter_preimage_inv_preimage {α : Type u_1} (π : PartialPerm🔗<|PREMISE|>🔗 α) (s : Set🔗<|PREMISE|>🔗 α) :π.domain ∩ π.toFun ⁻¹' ((PartialPerm.symm🔗<|PREMISE|>🔗 π).toFun ⁻¹' s) = π.domain ∩ s", "code": "theorem domain_inter_preimage_inv_preimage (s : Set α) :\n    π.domain ∩ π ⁻¹' (π.symm ⁻¹' s) = π.domain ∩ s :=\n  Set.ext fun x => and_congr_right_iff.2 fun hx => by simp only [mem_preimage, π.left_inv hx]\n", "additional_info": "", "used_premises": [645, 69, 644], "def_path": "ConNF/Mathlib/Logic/Equiv/PartialPerm.lean", "pos": [268, 271], "informalization": "The theorem `domain_inter_preimage_inv_preimage` states that for a partial permutation `π` and a set `s`, the intersection of the domain of `π` with the preimage of the preimage of `s` under the inverse of `π` is equal to the intersection of the domain of `π` with `s`."}
{"full_name": "PartialPerm.domain_inter_preimage_domain_inter", "url": "ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm.domain_inter_preimage_domain_inter", "code_src": "con-nf", "ptype": "theorem", "header": "theorem PartialPerm.domain_inter_preimage_domain_inter {α : Type u_1} (π : PartialPerm🔗<|PREMISE|>🔗 α) (s : Set🔗<|PREMISE|>🔗 α) :π.domain ∩ π.toFun ⁻¹' (π.domain ∩ s) = π.domain ∩ π.toFun ⁻¹' s", "code": "theorem domain_inter_preimage_domain_inter (s : Set α) :\n    π.domain ∩ π ⁻¹' (π.domain ∩ s) = π.domain ∩ π ⁻¹' s :=\n  ext fun _ => ⟨fun hx => ⟨hx.1, hx.2.2⟩, fun hx => ⟨hx.1, π.map_domain hx.1, hx.2⟩⟩\n", "additional_info": "", "used_premises": [645, 69], "def_path": "ConNF/Mathlib/Logic/Equiv/PartialPerm.lean", "pos": [272, 275], "informalization": "The theorem `domain_inter_preimage_domain_inter` states that for a partial permutation `π`, the intersection of its domain with the preimage of the intersection of its domain and a set `s` is equal to the intersection of its domain and the preimage of `s`."}
{"full_name": "PartialPerm.domain_inter_inv_preimage_preimage", "url": "ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm.domain_inter_inv_preimage_preimage", "code_src": "con-nf", "ptype": "theorem", "header": "theorem PartialPerm.domain_inter_inv_preimage_preimage {α : Type u_1} (π : PartialPerm🔗<|PREMISE|>🔗 α) (s : Set🔗<|PREMISE|>🔗 α) :π.domain ∩ (PartialPerm.symm🔗<|PREMISE|>🔗 π).toFun ⁻¹' (π.toFun ⁻¹' s) = π.domain ∩ s", "code": "theorem domain_inter_inv_preimage_preimage (s : Set α) :\n    π.domain ∩ π.symm ⁻¹' (π ⁻¹' s) = π.domain ∩ s :=\n  π.symm.domain_inter_preimage_inv_preimage _\n", "additional_info": "", "used_premises": [645, 69, 644], "def_path": "ConNF/Mathlib/Logic/Equiv/PartialPerm.lean", "pos": [276, 279], "informalization": "The theorem `domain_inter_inv_preimage_preimage` states that for a partial permutation `π`, the intersection of its domain with the preimage of the preimage of a set `s` under `π` is equal to the intersection of its domain with `s`."}
{"full_name": "PartialPerm.symm_image_image_of_subset_domain", "url": "ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm.symm_image_image_of_subset_domain", "code_src": "con-nf", "ptype": "theorem", "header": "theorem PartialPerm.symm_image_image_of_subset_domain {α : Type u_1} (π : PartialPerm🔗<|PREMISE|>🔗 α) {s : Set🔗<|PREMISE|>🔗 α} (h : s ⊆ π.domain) :(PartialPerm.symm🔗<|PREMISE|>🔗 π).toFun '' (π.toFun '' s) = s", "code": "theorem symm_image_image_of_subset_domain {s : Set α} (h : s ⊆ π.domain) : π.symm '' (π '' s) = s :=\n  (π.leftInvOn.mono h).image_image\n", "additional_info": "", "used_premises": [645, 69, 644], "def_path": "ConNF/Mathlib/Logic/Equiv/PartialPerm.lean", "pos": [280, 282], "informalization": "The theorem `PartialPerm.symm_image_image_of_subset_domain` states that for a partial permutation `π` and a set `s` that is a subset of the domain of `π`, the image of `s` under `π` followed by the image of the result under the inverse of `π` is equal to `s`."}
{"full_name": "PartialPerm.image_symm_image_of_subset_domain", "url": "ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm.image_symm_image_of_subset_domain", "code_src": "con-nf", "ptype": "theorem", "header": "theorem PartialPerm.image_symm_image_of_subset_domain {α : Type u_1} (π : PartialPerm🔗<|PREMISE|>🔗 α) {s : Set🔗<|PREMISE|>🔗 α} (h : s ⊆ π.domain) :π.toFun '' ((PartialPerm.symm🔗<|PREMISE|>🔗 π).toFun '' s) = s", "code": "theorem image_symm_image_of_subset_domain {s : Set α} (h : s ⊆ π.domain) : π '' (π.symm '' s) = s :=\n  π.symm.symm_image_image_of_subset_domain h\n", "additional_info": "", "used_premises": [645, 69, 644], "def_path": "ConNF/Mathlib/Logic/Equiv/PartialPerm.lean", "pos": [283, 285], "informalization": "The theorem `image_symm_image_of_subset_domain` states that for a partial permutation `π` and a set `s` that is a subset of the domain of `π`, the image of `s` under `π` followed by the image of the result under the inverse of `π` is equal to `s`."}
{"full_name": "PartialPerm.domain_subset_preimage_domain", "url": "ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm.domain_subset_preimage_domain", "code_src": "con-nf", "ptype": "theorem", "header": "theorem PartialPerm.domain_subset_preimage_domain {α : Type u_1} {π : PartialPerm🔗<|PREMISE|>🔗 α} :π.domain ⊆ π.toFun ⁻¹' π.domain", "code": "theorem domain_subset_preimage_domain : π.domain ⊆ π ⁻¹' π.domain :=\n  π.mapsTo\n", "additional_info": "", "used_premises": [645], "def_path": "ConNF/Mathlib/Logic/Equiv/PartialPerm.lean", "pos": [288, 290], "informalization": "The domain of a partial permutation is a subset of the preimage of its domain under its forward function."}
{"full_name": "PartialPerm.symm_image_domain", "url": "ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm.symm_image_domain", "code_src": "con-nf", "ptype": "theorem", "header": "theorem PartialPerm.symm_image_domain {α : Type u_1} {π : PartialPerm🔗<|PREMISE|>🔗 α} :(PartialPerm.symm🔗<|PREMISE|>🔗 π).toFun '' π.domain = π.domain", "code": "theorem symm_image_domain : π.symm '' π.domain = π.domain :=\n  π.symm.image_domain\n", "additional_info": "", "used_premises": [645, 644], "def_path": "ConNF/Mathlib/Logic/Equiv/PartialPerm.lean", "pos": [291, 293], "informalization": "The image of the domain of a partial permutation under its inverse is equal to the domain itself."}
{"full_name": "PartialPerm.ext", "url": "ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm.ext", "code_src": "con-nf", "ptype": "theorem", "header": "theorem PartialPerm.ext {α : Type u_1} {π : PartialPerm🔗<|PREMISE|>🔗 α} {π' : PartialPerm🔗<|PREMISE|>🔗 α} (h : ∀ (x : α), π.toFun x = π'.toFun x) (hsymm : ∀ (x : α), (PartialPerm.symm🔗<|PREMISE|>🔗 π).toFun x = (PartialPerm.symm🔗<|PREMISE|>🔗 π').toFun x) (hs : π.domain = π'.domain) :π = π'", "code": "protected theorem ext (h : ∀ x, π x = π' x) (hsymm : ∀ x, π.symm x = π'.symm x)\n    (hs : π.domain = π'.domain) : π = π' := by\n  have A : (π : α → α) = π' := by ext x; exact h x\n  have B : (π.symm : α → α) = π'.symm := by ext x; exact hsymm x\n  have I : π '' π.domain = π.domain := π.image_domain\n  have I' : π' '' π'.domain = π'.domain := π'.image_domain\n  rw [A, hs, I'] at I\n  cases π; cases π'\n  simp_all only [coe_symm_mk, coe_mk, eq_self_iff_true, and_self_iff]\n", "additional_info": "Two partial permutations that have the same `🗟domain🗟🔗../../../.././ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm.domain🔗` , same `🗟toFun🗟🔗../../../.././ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm.toFun🔗`  and same `🗟invFun🗟🔗../../../.././ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm.invFun🔗` , coincide.", "used_premises": [645, 645, 644, 644], "def_path": "ConNF/Mathlib/Logic/Equiv/PartialPerm.lean", "pos": [296, 305], "informalization": "Two partial permutations are equal if they have the same domain, the same function, and the same inverse function."}
{"full_name": "PartialPerm.refl_domain", "url": "ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm.refl_domain", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem PartialPerm.refl_domain {α : Type u_1} :(PartialPerm.refl🔗<|PREMISE|>🔗 α).domain = Set.univ", "code": "theorem refl_domain : (PartialPerm.refl α).domain = univ :=\n  rfl\n", "additional_info": "", "used_premises": [720], "def_path": "ConNF/Mathlib/Logic/Equiv/PartialPerm.lean", "pos": [311, 313], "informalization": "The domain of the identity partial permutation is the universal set."}
{"full_name": "PartialPerm.refl", "url": "ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm.refl", "code_src": "con-nf", "ptype": "def", "header": "def PartialPerm.refl (α : Type u_1) :PartialPerm🔗<|PREMISE|>🔗 α", "code": "protected def refl (α : Type _) : PartialPerm α :=\n  Equiv.Perm.toPartialPerm <| Equiv.refl _\n", "additional_info": "The identity partial permutation.\nEquations\n* 🗟PartialPerm.refl🗟🔗../../../.././ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm.refl🔗  α 🗟=🗟🔗../../../.././Init/Prelude.html#Eq🔗  🗟Equiv.Perm.toPartialPerm🗟🔗../../../.././ConNF/Mathlib/Logic/Equiv/PartialPerm.html#Equiv.Perm.toPartialPerm🔗  (🗟Equiv.refl🗟🔗../../../.././Mathlib/Logic/Equiv/Defs.html#Equiv.refl🔗  α)\n\n", "used_premises": [645], "def_path": "ConNF/Mathlib/Logic/Equiv/PartialPerm.lean", "pos": [307, 309], "informalization": "Function `PartialPerm.refl` defines the identity partial permutation on a type `α`, which maps every element of `α` to itself."}
{"full_name": "PartialPerm.coe_refl", "url": "ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm.coe_refl", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem PartialPerm.coe_refl {α : Type u_1} :(PartialPerm.refl🔗<|PREMISE|>🔗 α).toFun = id", "code": "theorem coe_refl : ⇑(PartialPerm.refl α) = id :=\n  rfl\n", "additional_info": "", "used_premises": [720], "def_path": "ConNF/Mathlib/Logic/Equiv/PartialPerm.lean", "pos": [315, 317], "informalization": "The theorem `PartialPerm.coe_refl` states that the identity partial permutation on a type `α`, when coerced to a function, is equal to the identity function on `α`."}
{"full_name": "PartialPerm.symm_refl", "url": "ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm.symm_refl", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem PartialPerm.symm_refl {α : Type u_1} :PartialPerm.symm🔗<|PREMISE|>🔗 (PartialPerm.refl🔗<|PREMISE|>🔗 α) = PartialPerm.refl🔗<|PREMISE|>🔗 α", "code": "theorem symm_refl : (PartialPerm.refl α).symm = PartialPerm.refl α :=\n  rfl\n", "additional_info": "", "used_premises": [644, 720, 720], "def_path": "ConNF/Mathlib/Logic/Equiv/PartialPerm.lean", "pos": [319, 321], "informalization": "The inverse of the identity partial permutation is itself."}
{"full_name": "PartialPerm.trans_invFun", "url": "ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm.trans_invFun", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem PartialPerm.trans_invFun {α : Type u_1} (π : PartialPerm🔗<|PREMISE|>🔗 α) (π' : PartialPerm🔗<|PREMISE|>🔗 α) (h : π.domain = π'.domain) :∀ (a : α), (PartialPerm.trans🔗<|PREMISE|>🔗 π π' h).invFun a = ((PartialPerm.symm🔗<|PREMISE|>🔗 π).toFun ∘ (PartialPerm.symm🔗<|PREMISE|>🔗 π').toFun) a", "code": "@[simps]\n", "additional_info": "", "used_premises": [645, 645, 724, 644, 644], "def_path": "ConNF/Mathlib/Logic/Equiv/PartialPerm.lean", "pos": [330, 331], "informalization": "Function `PartialPerm.trans_invFun` states that the inverse of the composition of two partial permutations `π` and `π'` is equal to the composition of the inverses of `π` and `π'` in reverse order."}
{"full_name": "PartialPerm.trans", "url": "ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm.trans", "code_src": "con-nf", "ptype": "def", "header": "def PartialPerm.trans {α : Type u_1} (π : PartialPerm🔗<|PREMISE|>🔗 α) (π' : PartialPerm🔗<|PREMISE|>🔗 α) (h : π.domain = π'.domain) :PartialPerm🔗<|PREMISE|>🔗 α", "code": "protected def trans (π' : PartialPerm α) (h : π.domain = π'.domain) : PartialPerm α\n    where\n  toFun := π' ∘ π\n  invFun := π.symm ∘ π'.symm\n  domain := π.domain\n  toFun_domain' x hx := by\n    rw [h]\n    refine map_domain _ ?_\n    have := map_domain π hx\n    rwa [h] at this\n  invFun_domain' y hy := by\n    refine map_domain _ ?_\n    rw [h] at hy\n    have := map_domain π'.symm hy\n    rwa [symm_domain, ← h] at this\n  left_inv' x hx := by\n    simp [hx, h.symm]\n    rw [left_inv π', left_inv π hx]\n    have := map_domain π hx\n    rwa [← h]\n  right_inv' y hy := by\n    simp\n    rw [h] at hy\n    rw [right_inv π, right_inv π' hy]\n    have := map_domain π'.symm hy\n    rwa [symm_domain, ← h] at this\n", "additional_info": "Composing two partial permutations if the domain of the first coincides with the domain of the\nsecond.\nEquations\n* One or more equations did not get rendered due to their size.\n\n", "used_premises": [645, 645, 645], "def_path": "ConNF/Mathlib/Logic/Equiv/PartialPerm.lean", "pos": [331, 357], "informalization": "Function `PartialPerm.trans` composes two partial permutations if the domain of the first coincides with the domain of the second, resulting in a new partial permutation."}
{"full_name": "PartialPerm.trans_toFun", "url": "ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm.trans_toFun", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem PartialPerm.trans_toFun {α : Type u_1} (π : PartialPerm🔗<|PREMISE|>🔗 α) (π' : PartialPerm🔗<|PREMISE|>🔗 α) (h : π.domain = π'.domain) :∀ (a : α), (PartialPerm.trans🔗<|PREMISE|>🔗 π π' h).toFun a = (π'.toFun ∘ π.toFun) a", "code": "@[simps]\n", "additional_info": "", "used_premises": [645, 645, 724], "def_path": "ConNF/Mathlib/Logic/Equiv/PartialPerm.lean", "pos": [330, 331], "informalization": "Function `PartialPerm.trans` composes two partial permutations if the domain of the first coincides with the domain of the second, resulting in a new partial permutation. The `toFun` of the resulting partial permutation is the composition of the `toFun`s of the two original partial permutations."}
{"full_name": "PartialPerm.trans_domain", "url": "ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm.trans_domain", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem PartialPerm.trans_domain {α : Type u_1} (π : PartialPerm🔗<|PREMISE|>🔗 α) (π' : PartialPerm🔗<|PREMISE|>🔗 α) (h : π.domain = π'.domain) :(PartialPerm.trans🔗<|PREMISE|>🔗 π π' h).domain = π.domain", "code": "@[simps]\n", "additional_info": "", "used_premises": [645, 645, 724], "def_path": "ConNF/Mathlib/Logic/Equiv/PartialPerm.lean", "pos": [330, 331], "informalization": "`PartialPerm.trans_domain` states that the domain of the composition of two partial permutations is equal to the domain of the first partial permutation."}
{"full_name": "PartialPerm.ofSet_domain", "url": "ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm.ofSet_domain", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem PartialPerm.ofSet_domain {α : Type u_1} (s : Set🔗<|PREMISE|>🔗 α) :(PartialPerm.ofSet🔗<|PREMISE|>🔗 s).domain = s", "code": "theorem ofSet_domain (s : Set α) : (ofSet s).domain = s :=\n  rfl\n", "additional_info": "", "used_premises": [69, 728], "def_path": "ConNF/Mathlib/Logic/Equiv/PartialPerm.lean", "pos": [369, 371], "informalization": "The domain of the partial permutation `PartialPerm.ofSet s` is equal to the set `s`."}
{"full_name": "PartialPerm.ofSet", "url": "ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm.ofSet", "code_src": "con-nf", "ptype": "def", "header": "def PartialPerm.ofSet {α : Type u_1} (s : Set🔗<|PREMISE|>🔗 α) :PartialPerm🔗<|PREMISE|>🔗 α", "code": "def ofSet (s : Set α) : PartialPerm α where\n  toFun := id\n  invFun := id\n  domain := s\n  toFun_domain' _ hx := hx\n  invFun_domain' _ hx := hx\n  left_inv' _ _ := rfl\n  right_inv' _ _ := rfl\n", "additional_info": "The identity partial PERMUTATION on a set `s`\nEquations\n* 🗟PartialPerm.ofSet🗟🔗../../../.././ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm.ofSet🔗  s 🗟=🗟🔗../../../.././Init/Prelude.html#Eq🔗  { toFun := id, invFun := id, domain := s, toFun_domain' := ⋯, invFun_domain' := ⋯, left_inv' := ⋯, right_inv' := ⋯ }\n\n", "used_premises": [69, 645], "def_path": "ConNF/Mathlib/Logic/Equiv/PartialPerm.lean", "pos": [359, 367], "informalization": "Function `PartialPerm.ofSet` constructs a partial permutation from a given set `s`. This partial permutation is the identity function on `s`, meaning it maps each element of `s` to itself, and its inverse also maps each element of `s` to itself. The domain of this partial permutation is `s`, and it is undefined outside of `s`."}
{"full_name": "PartialPerm.coe_ofSet", "url": "ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm.coe_ofSet", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem PartialPerm.coe_ofSet {α : Type u_1} (s : Set🔗<|PREMISE|>🔗 α) :(PartialPerm.ofSet🔗<|PREMISE|>🔗 s).toFun = id", "code": "theorem coe_ofSet (s : Set α) : (ofSet s : α → α) = id :=\n  rfl\n", "additional_info": "", "used_premises": [69, 728], "def_path": "ConNF/Mathlib/Logic/Equiv/PartialPerm.lean", "pos": [373, 375], "informalization": "Function `PartialPerm.ofSet` constructs a partial permutation from a given set `s`. This partial permutation is the identity function on `s`, meaning it maps each element of `s` to itself, and its inverse also maps each element of `s` to itself. The domain of this partial permutation is `s`, and it is undefined outside of `s`."}
{"full_name": "PartialPerm.ofSet_symm", "url": "ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm.ofSet_symm", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem PartialPerm.ofSet_symm {α : Type u_1} (s : Set🔗<|PREMISE|>🔗 α) :PartialPerm.symm🔗<|PREMISE|>🔗 (PartialPerm.ofSet🔗<|PREMISE|>🔗 s) = PartialPerm.ofSet🔗<|PREMISE|>🔗 s", "code": "theorem ofSet_symm (s : Set α) : (ofSet s).symm = ofSet s :=\n  rfl\n", "additional_info": "", "used_premises": [69, 644, 728, 728], "def_path": "ConNF/Mathlib/Logic/Equiv/PartialPerm.lean", "pos": [377, 379], "informalization": "Function `PartialPerm.ofSet_symm` states that the inverse of a partial permutation constructed from a set `s` is equal to the partial permutation itself."}
{"full_name": "PartialPerm.ofSet_univ", "url": "ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm.ofSet_univ", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem PartialPerm.ofSet_univ {α : Type u_1} :PartialPerm.ofSet🔗<|PREMISE|>🔗 Set.univ = PartialPerm.refl🔗<|PREMISE|>🔗 α", "code": "theorem ofSet_univ : ofSet univ = PartialPerm.refl α :=\n  rfl\n", "additional_info": "", "used_premises": [728, 720], "def_path": "ConNF/Mathlib/Logic/Equiv/PartialPerm.lean", "pos": [385, 387], "informalization": "Function `PartialPerm.ofSet` constructs a partial permutation from a given set `s`. This partial permutation is the identity function on `s`, meaning it maps each element of `s` to itself, and its inverse also maps each element of `s` to itself. The domain of this partial permutation is `s`, and it is undefined outside of `s`. When `s` is the universal set `univ`, the partial permutation `ofSet univ` is equivalent to the identity partial permutation `refl`."}
{"full_name": "PartialPerm.coe_toPartialEquiv", "url": "ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm.coe_toPartialEquiv", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem PartialPerm.coe_toPartialEquiv {α : Type u_1} (π : PartialPerm🔗<|PREMISE|>🔗 α) :↑(PartialPerm.toPartialEquiv🔗<|PREMISE|>🔗 π) = π.toFun", "code": "theorem coe_toPartialEquiv : ⇑π.toPartialEquiv = π :=\n  rfl\n", "additional_info": "", "used_premises": [645, 733], "def_path": "ConNF/Mathlib/Logic/Equiv/PartialPerm.lean", "pos": [400, 402], "informalization": "The theorem `PartialPerm.coe_toPartialEquiv` states that the coercion of a partial permutation `π` to a partial equivalence is equal to the function `toFun` of `π`."}
{"full_name": "PartialPerm.toPartialEquiv", "url": "ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm.toPartialEquiv", "code_src": "con-nf", "ptype": "def", "header": "def PartialPerm.toPartialEquiv {α : Type u_1} (π : PartialPerm🔗<|PREMISE|>🔗 α) :PartialEquiv🔗<|PREMISE|>🔗 α α", "code": "def toPartialEquiv : PartialEquiv α α where\n  toFun := π\n  invFun := π.symm\n  source := π.domain\n  target := π.domain\n  map_source' := π.mapsTo\n  map_target' := π.symm.mapsTo\n  left_inv' := π.leftInvOn\n  right_inv' := π.rightInvOn\n", "additional_info": "Reinterpret a partial permutation as a partial equivalence.\nEquations\n* One or more equations did not get rendered due to their size.\n\n", "used_premises": [645, 734], "def_path": "ConNF/Mathlib/Logic/Equiv/PartialPerm.lean", "pos": [389, 398], "informalization": "Function `PartialPerm.toPartialEquiv` converts a partial permutation `π` of a type `α` into a partial equivalence, which is a structure consisting of two functions `toFun` and `invFun` (representing the partial permutation and its inverse, respectively), and two sets `source` and `target` (both equal to the domain of the partial permutation), along with proofs that these functions are inverses of each other on their respective domains."}
{"full_name": "PartialEquiv", "url": "Mathlib/Logic/Equiv/PartialEquiv.html#PartialEquiv", "code_src": "mathlib4", "ptype": "structure", "header": "structure PartialEquiv (α : Type u_5) (β : Type u_6) :Type (max u_5 u_6)\n | toFun : α → β\n | invFun : β → α\n | source : Set🔗<|PREMISE|>🔗  α\n | target : Set🔗<|PREMISE|>🔗  β\n | map_source' : ∀ ⦃x : α⦄, x ∈  self.source → ↑self x ∈  self.target\n | map_target' : ∀ ⦃x : β⦄, x ∈  self.target → self.invFun x ∈  self.source\n | left_inv' : ∀ ⦃x : α⦄, x ∈  self.source → self.invFun (↑self x) =  x\n | right_inv' : ∀ ⦃x : β⦄, x ∈  self.target → ↑self (self.invFun x) =  x", "code": "structure PartialEquiv (α : Type*) (β : Type*) where\n  /-- The global function which has a partial inverse. Its value outside of the `source` subset is\n  irrelevant. -/\n  toFun : α → β\n  /-- The partial inverse to `toFun`. Its value outside of the `target` subset is irrelevant. -/\n  invFun : β → α\n  /-- The domain of the partial equivalence. -/\n  source : Set α\n  /-- The codomain of the partial equivalence. -/\n  target : Set β\n  /-- The proposition that elements of `source` are mapped to elements of `target`. -/\n  map_source' : ∀ ⦃x⦄, x ∈ source → toFun x ∈ target\n  /-- The proposition that elements of `target` are mapped to elements of `source`. -/\n  map_target' : ∀ ⦃x⦄, x ∈ target → invFun x ∈ source\n  /-- The proposition that `invFun` is a left-inverse of `toFun` on `source`. -/\n  left_inv' : ∀ ⦃x⦄, x ∈ source → invFun (toFun x) = x\n  /-- The proposition that `invFun` is a right-inverse of `toFun` on `target`. -/\n  right_inv' : ∀ ⦃x⦄, x ∈ target → toFun (invFun x) = x\n", "additional_info": "Local equivalence between subsets `🗟source🗟🔗../../.././Mathlib/Logic/Equiv/PartialEquiv.html#PartialEquiv.source🔗`  and `🗟target🗟🔗../../.././Mathlib/Logic/Equiv/PartialEquiv.html#PartialEquiv.target🔗`  of `α` and `β` respectively. The\n(global) maps `🗟toFun🗟🔗../../.././Mathlib/Logic/Equiv/PartialEquiv.html#PartialEquiv.toFun🔗  : α → β` and `🗟invFun🗟🔗../../.././Mathlib/Logic/Equiv/PartialEquiv.html#PartialEquiv.invFun🔗  : β → α` map `🗟source🗟🔗../../.././Mathlib/Logic/Equiv/PartialEquiv.html#PartialEquiv.source🔗`  to `🗟target🗟🔗../../.././Mathlib/Logic/Equiv/PartialEquiv.html#PartialEquiv.target🔗`  and conversely, and are\ninverse to each other there. The values of `🗟toFun🗟🔗../../.././Mathlib/Logic/Equiv/PartialEquiv.html#PartialEquiv.toFun🔗`  outside of `🗟source🗟🔗../../.././Mathlib/Logic/Equiv/PartialEquiv.html#PartialEquiv.source🔗`  and of `🗟invFun🗟🔗../../.././Mathlib/Logic/Equiv/PartialEquiv.html#PartialEquiv.invFun🔗`  outside of\n`🗟target🗟🔗../../.././Mathlib/Logic/Equiv/PartialEquiv.html#PartialEquiv.target🔗`  are irrelevant.\n- PartialEquiv.toFun: The global function which has a partial inverse. Its value outside of the `🗟source🗟🔗../../.././Mathlib/Logic/Equiv/PartialEquiv.html#PartialEquiv.source🔗`  subset is\nirrelevant.\n\n\n- PartialEquiv.invFun: The partial inverse to `🗟toFun🗟🔗../../.././Mathlib/Logic/Equiv/PartialEquiv.html#PartialEquiv.toFun🔗` . Its value outside of the `🗟target🗟🔗../../.././Mathlib/Logic/Equiv/PartialEquiv.html#PartialEquiv.target🔗`  subset is irrelevant.\n\n\n- PartialEquiv.source: The domain of the partial equivalence.\n\n\n- PartialEquiv.target: The codomain of the partial equivalence.\n\n\n- PartialEquiv.map_source': The proposition that elements of `🗟source🗟🔗../../.././Mathlib/Logic/Equiv/PartialEquiv.html#PartialEquiv.source🔗`  are mapped to elements of `🗟target🗟🔗../../.././Mathlib/Logic/Equiv/PartialEquiv.html#PartialEquiv.target🔗` .\n\n\n- PartialEquiv.map_target': The proposition that elements of `🗟target🗟🔗../../.././Mathlib/Logic/Equiv/PartialEquiv.html#PartialEquiv.target🔗`  are mapped to elements of `🗟source🗟🔗../../.././Mathlib/Logic/Equiv/PartialEquiv.html#PartialEquiv.source🔗` .\n\n\n- PartialEquiv.left_inv': The proposition that `🗟invFun🗟🔗../../.././Mathlib/Logic/Equiv/PartialEquiv.html#PartialEquiv.invFun🔗`  is a left-inverse of `🗟toFun🗟🔗../../.././Mathlib/Logic/Equiv/PartialEquiv.html#PartialEquiv.toFun🔗`  on `🗟source🗟🔗../../.././Mathlib/Logic/Equiv/PartialEquiv.html#PartialEquiv.source🔗` .\n\n\n- PartialEquiv.right_inv': The proposition that `🗟invFun🗟🔗../../.././Mathlib/Logic/Equiv/PartialEquiv.html#PartialEquiv.invFun🔗`  is a right-inverse of `🗟toFun🗟🔗../../.././Mathlib/Logic/Equiv/PartialEquiv.html#PartialEquiv.toFun🔗`  on `🗟target🗟🔗../../.././Mathlib/Logic/Equiv/PartialEquiv.html#PartialEquiv.target🔗` .\n\n\n", "used_premises": [69, 69], "def_path": "Mathlib/Logic/Equiv/PartialEquiv.lean", "pos": [119, 137], "informalization": "The Lean 4 object `Prod` represents a product type (pair) of two types, providing two projections to access the first and second elements."}
{"full_name": "PartialPerm.coe_toPartialEquiv_symm", "url": "ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm.coe_toPartialEquiv_symm", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem PartialPerm.coe_toPartialEquiv_symm {α : Type u_1} (π : PartialPerm🔗<|PREMISE|>🔗 α) :↑(PartialEquiv.symm🔗<|PREMISE|>🔗 (PartialPerm.toPartialEquiv🔗<|PREMISE|>🔗 π)) = (PartialPerm.symm🔗<|PREMISE|>🔗 π).toFun", "code": "theorem coe_toPartialEquiv_symm : ⇑π.toPartialEquiv.symm = π.symm :=\n  rfl\n", "additional_info": "", "used_premises": [645, 736, 733, 644], "def_path": "ConNF/Mathlib/Logic/Equiv/PartialPerm.lean", "pos": [404, 406], "informalization": "The theorem `PartialPerm.coe_toPartialEquiv_symm` states that for a partial permutation `π` of a type `α`, the inverse of the partial equivalence obtained from `π` is equal to the function representing the inverse of `π`."}
{"full_name": "PartialEquiv.symm", "url": "Mathlib/Logic/Equiv/PartialEquiv.html#PartialEquiv.symm", "code_src": "mathlib4", "ptype": "def", "header": "def PartialEquiv.symm {α : Type u_1} {β : Type u_2} (e : PartialEquiv🔗<|PREMISE|>🔗 α β) :PartialEquiv🔗<|PREMISE|>🔗 β α", "code": "protected def symm : PartialEquiv β α where\n  toFun := e.invFun\n  invFun := e.toFun\n  source := e.target\n  target := e.source\n  map_source' := e.map_target'\n  map_target' := e.map_source'\n  left_inv' := e.right_inv'\n  right_inv' := e.left_inv'\n", "additional_info": "The inverse of a partial equivalence\nEquations\n* 🗟PartialEquiv.symm🗟🔗../../.././Mathlib/Logic/Equiv/PartialEquiv.html#PartialEquiv.symm🔗  e 🗟=🗟🔗../../.././Init/Prelude.html#Eq🔗  { toFun := e.invFun, invFun := ↑e, source := e.target, target := e.source, map_source' := ⋯, map_target' := ⋯,\n left_inv' := ⋯, right_inv' := ⋯ }\n\n", "used_premises": [734, 734], "def_path": "Mathlib/Logic/Equiv/PartialEquiv.lean", "pos": [151, 160], "informalization": "Function `PartialEquiv.symm` defines the inverse of a partial equivalence `e` between two types `α` and `β`. A partial equivalence is a relation that is one-to-one and onto between a subset of `α` and a subset of `β`. The inverse of a partial equivalence is another partial equivalence that reverses the roles of `α` and `β`, essentially swapping the domain and range of the original partial equivalence. This operation is crucial in understanding the structure of partial equivalences and their applications in various mathematical contexts."}
{"full_name": "PartialPerm.toPartialEquiv_source", "url": "ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm.toPartialEquiv_source", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem PartialPerm.toPartialEquiv_source {α : Type u_1} (π : PartialPerm🔗<|PREMISE|>🔗 α) :(PartialPerm.toPartialEquiv🔗<|PREMISE|>🔗 π).source = π.domain", "code": "theorem toPartialEquiv_source : π.toPartialEquiv.source = π.domain :=\n  rfl\n", "additional_info": "", "used_premises": [645, 733], "def_path": "ConNF/Mathlib/Logic/Equiv/PartialPerm.lean", "pos": [408, 410], "informalization": "The function `PartialPerm.toPartialEquiv` converts a partial permutation `π` of a type `α` into a partial equivalence. The `source` of this partial equivalence is equal to the `domain` of the partial permutation `π`."}
{"full_name": "PartialPerm.toPartialEquiv_target", "url": "ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm.toPartialEquiv_target", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem PartialPerm.toPartialEquiv_target {α : Type u_1} (π : PartialPerm🔗<|PREMISE|>🔗 α) :(PartialPerm.toPartialEquiv🔗<|PREMISE|>🔗 π).target = π.domain", "code": "theorem toPartialEquiv_target : π.toPartialEquiv.target = π.domain :=\n  rfl\n", "additional_info": "", "used_premises": [645, 733], "def_path": "ConNF/Mathlib/Logic/Equiv/PartialPerm.lean", "pos": [412, 414], "informalization": "Function `PartialPerm.toPartialEquiv` converts a partial permutation `π` of a type `α` into a partial equivalence. The `target` of this partial equivalence is equal to the `domain` of the partial permutation `π`."}
{"full_name": "PartialPerm.toPartialEquiv_refl", "url": "ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm.toPartialEquiv_refl", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem PartialPerm.toPartialEquiv_refl {α : Type u_1} :PartialPerm.toPartialEquiv🔗<|PREMISE|>🔗 (PartialPerm.refl🔗<|PREMISE|>🔗 α) = PartialEquiv.refl🔗<|PREMISE|>🔗 α", "code": "theorem toPartialEquiv_refl : (PartialPerm.refl α).toPartialEquiv = PartialEquiv.refl _ :=\n  rfl\n", "additional_info": "", "used_premises": [733, 720, 740], "def_path": "ConNF/Mathlib/Logic/Equiv/PartialPerm.lean", "pos": [416, 418], "informalization": "Function `PartialPerm.toPartialEquiv_refl` states that converting the identity partial permutation to a partial equivalence yields the identity partial equivalence."}
{"full_name": "PartialEquiv.refl", "url": "Mathlib/Logic/Equiv/PartialEquiv.html#PartialEquiv.refl", "code_src": "mathlib4", "ptype": "def", "header": "def PartialEquiv.refl (α : Type u_5) :PartialEquiv🔗<|PREMISE|>🔗 α α", "code": "protected def refl (α : Type*) : PartialEquiv α α :=\n  (Equiv.refl α).toPartialEquiv\n", "additional_info": "The identity partial equiv\nEquations\n* 🗟PartialEquiv.refl🗟🔗../../.././Mathlib/Logic/Equiv/PartialEquiv.html#PartialEquiv.refl🔗  α 🗟=🗟🔗../../.././Init/Prelude.html#Eq🔗  🗟Equiv.toPartialEquiv🗟🔗../../.././Mathlib/Logic/Equiv/PartialEquiv.html#Equiv.toPartialEquiv🔗  (🗟Equiv.refl🗟🔗../../.././Mathlib/Logic/Equiv/Defs.html#Equiv.refl🔗  α)\n\n", "used_premises": [734], "def_path": "Mathlib/Logic/Equiv/PartialEquiv.lean", "pos": [608, 610], "informalization": "Function `PartialEquiv.refl` defines the identity partial equivalence on a type `α`."}
{"full_name": "PartialPerm.toPartialEquiv_symm", "url": "ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm.toPartialEquiv_symm", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem PartialPerm.toPartialEquiv_symm {α : Type u_1} (π : PartialPerm🔗<|PREMISE|>🔗 α) :PartialPerm.toPartialEquiv🔗<|PREMISE|>🔗 (PartialPerm.symm🔗<|PREMISE|>🔗 π) = PartialEquiv.symm🔗<|PREMISE|>🔗 (PartialPerm.toPartialEquiv🔗<|PREMISE|>🔗 π)", "code": "theorem toPartialEquiv_symm : π.symm.toPartialEquiv = π.toPartialEquiv.symm :=\n  rfl\n", "additional_info": "", "used_premises": [645, 733, 644, 736, 733], "def_path": "ConNF/Mathlib/Logic/Equiv/PartialPerm.lean", "pos": [420, 422], "informalization": "Function `PartialPerm.toPartialEquiv_symm` states that the inverse of a partial permutation, when converted to a partial equivalence, is equal to the inverse of the partial equivalence obtained from the original partial permutation."}
{"full_name": "PartialPerm.toPartialEquiv_trans", "url": "ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm.toPartialEquiv_trans", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem PartialPerm.toPartialEquiv_trans {α : Type u_1} (π : PartialPerm🔗<|PREMISE|>🔗 α) (π' : PartialPerm🔗<|PREMISE|>🔗 α) (h : π.domain = π'.domain) :PartialPerm.toPartialEquiv🔗<|PREMISE|>🔗 (PartialPerm.trans🔗<|PREMISE|>🔗 π π' h) = PartialEquiv.trans🔗<|PREMISE|>🔗 (PartialPerm.toPartialEquiv🔗<|PREMISE|>🔗 π) (PartialPerm.toPartialEquiv🔗<|PREMISE|>🔗 π')", "code": "theorem toPartialEquiv_trans (h) :\n    (π.trans π' h).toPartialEquiv = π.toPartialEquiv.trans π'.toPartialEquiv := by\n  ext\n  · rfl\n  · rfl\n  · simpa [← h] using fun hx => π.mapsTo hx\n", "additional_info": "", "used_premises": [645, 645, 733, 724, 743, 733, 733], "def_path": "ConNF/Mathlib/Logic/Equiv/PartialPerm.lean", "pos": [424, 430], "informalization": "The theorem `PartialPerm.toPartialEquiv_trans` states that the composition of two partial permutations, when converted to partial equivalences, is equal to the composition of the partial equivalences themselves."}
{"full_name": "PartialEquiv.trans", "url": "Mathlib/Logic/Equiv/PartialEquiv.html#PartialEquiv.trans", "code_src": "mathlib4", "ptype": "def", "header": "def PartialEquiv.trans {α : Type u_1} {β : Type u_2} {γ : Type u_3} (e : PartialEquiv🔗<|PREMISE|>🔗 α β) (e' : PartialEquiv🔗<|PREMISE|>🔗 β γ) :PartialEquiv🔗<|PREMISE|>🔗 α γ", "code": "protected def trans : PartialEquiv α γ :=\n  PartialEquiv.trans' (e.symm.restr e'.source).symm (e'.restr e.target) (inter_comm _ _)\n", "additional_info": "Composing two partial equivs, by restricting to the maximal domain where their composition\nis well defined.\nEquations\n* 🗟PartialEquiv.trans🗟🔗../../.././Mathlib/Logic/Equiv/PartialEquiv.html#PartialEquiv.trans🔗  e e' 🗟=🗟🔗../../.././Init/Prelude.html#Eq🔗  🗟PartialEquiv.trans'🗟🔗../../.././Mathlib/Logic/Equiv/PartialEquiv.html#PartialEquiv.trans'🔗  (🗟PartialEquiv.symm🗟🔗../../.././Mathlib/Logic/Equiv/PartialEquiv.html#PartialEquiv.symm🔗  (🗟PartialEquiv.restr🗟🔗../../.././Mathlib/Logic/Equiv/PartialEquiv.html#PartialEquiv.restr🔗  (🗟PartialEquiv.symm🗟🔗../../.././Mathlib/Logic/Equiv/PartialEquiv.html#PartialEquiv.symm🔗  e) e'.source))\n(🗟PartialEquiv.restr🗟🔗../../.././Mathlib/Logic/Equiv/PartialEquiv.html#PartialEquiv.restr🔗  e' e.target) ⋯\n\n", "used_premises": [734, 734, 734], "def_path": "Mathlib/Logic/Equiv/PartialEquiv.lean", "pos": [693, 695], "informalization": "Function `PartialEquiv.trans` composes two partial equivs, by restricting to the maximal domain where their composition is well defined."}
{"full_name": "PartialPerm.eq_on_domain_refl", "url": "ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm.eq_on_domain_refl", "code_src": "con-nf", "ptype": "theorem", "header": "theorem PartialPerm.eq_on_domain_refl {α : Type u_1} {π : PartialPerm🔗<|PREMISE|>🔗 α} :π ≈ π", "code": "theorem eq_on_domain_refl : π ≈ π :=\n  Setoid.refl _\n", "additional_info": "", "used_premises": [645], "def_path": "ConNF/Mathlib/Logic/Equiv/PartialPerm.lean", "pos": [458, 460], "informalization": "The theorem `eq_on_domain_refl` states that a partial permutation is equal to itself on its domain."}
{"full_name": "PartialPerm.EqOnDomain.domain_eq", "url": "ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm.EqOnDomain.domain_eq", "code_src": "con-nf", "ptype": "theorem", "header": "theorem PartialPerm.EqOnDomain.domain_eq {α : Type u_1} {π : PartialPerm🔗<|PREMISE|>🔗 α} {π' : PartialPerm🔗<|PREMISE|>🔗 α} (h : π ≈ π') :π.domain = π'.domain", "code": "theorem EqOnDomain.domain_eq (h : π ≈ π') : π.domain = π'.domain :=\n  h.1\n", "additional_info": "Two equivalent partial permutations have the same domain", "used_premises": [645, 645], "def_path": "ConNF/Mathlib/Logic/Equiv/PartialPerm.lean", "pos": [462, 464], "informalization": "Two equivalent partial permutations have the same domain."}
{"full_name": "PartialPerm.EqOnDomain.symm_domain_eq", "url": "ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm.EqOnDomain.symm_domain_eq", "code_src": "con-nf", "ptype": "theorem", "header": "theorem PartialPerm.EqOnDomain.symm_domain_eq {α : Type u_1} {π : PartialPerm🔗<|PREMISE|>🔗 α} {π' : PartialPerm🔗<|PREMISE|>🔗 α} (h : π ≈ π') :(PartialPerm.symm🔗<|PREMISE|>🔗 π).domain = (PartialPerm.symm🔗<|PREMISE|>🔗 π').domain", "code": "theorem EqOnDomain.symm_domain_eq (h : π ≈ π') : π.symm.domain = π'.symm.domain :=\n  h.1\n", "additional_info": "", "used_premises": [645, 645, 644, 644], "def_path": "ConNF/Mathlib/Logic/Equiv/PartialPerm.lean", "pos": [465, 467], "informalization": "`PartialPerm.EqOnDomain.symm_domain_eq` states that for two partial permutations `π` and `π'` that are equal on their domains, the domains of their inverses are also equal."}
{"full_name": "PartialPerm.EqOnDomain.eqOn", "url": "ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm.EqOnDomain.eqOn", "code_src": "con-nf", "ptype": "theorem", "header": "theorem PartialPerm.EqOnDomain.eqOn {α : Type u_1} {π : PartialPerm🔗<|PREMISE|>🔗 α} {π' : PartialPerm🔗<|PREMISE|>🔗 α} (h : π ≈ π') :Set.EqOn🔗<|PREMISE|>🔗 π.toFun π'.toFun π.domain", "code": "theorem EqOnDomain.eqOn (h : π ≈ π') : π.domain.EqOn π π' :=\n  h.2\n", "additional_info": "Two equivalent partial permutations coincide on the domain", "used_premises": [645, 645, 703], "def_path": "ConNF/Mathlib/Logic/Equiv/PartialPerm.lean", "pos": [469, 471], "informalization": "Function `eqOn` checks if two partial permutations `π` and `π'` are equal on the domain of `π`."}
{"full_name": "PartialPerm.EqOnDomain.symm'", "url": "ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm.EqOnDomain.symm'", "code_src": "con-nf", "ptype": "theorem", "header": "theorem PartialPerm.EqOnDomain.symm' {α : Type u_1} {π : PartialPerm🔗<|PREMISE|>🔗 α} {π' : PartialPerm🔗<|PREMISE|>🔗 α} (h : π ≈ π') :PartialPerm.symm🔗<|PREMISE|>🔗 π ≈ PartialPerm.symm🔗<|PREMISE|>🔗 π'", "code": "theorem EqOnDomain.symm' (h : π ≈ π') : π.symm ≈ π'.symm := by\n  refine ⟨EqOnDomain.symm_domain_eq h, eqOn_of_leftInvOn_of_rightInvOn π.leftInvOn ?_ ?_⟩ <;>\n    simp only [symm_domain, EqOnDomain.domain_eq h, π'.symm.mapsTo]\n  exact π'.rightInvOn.congr_right π'.symm.mapsTo (EqOnDomain.domain_eq h ▸ h.eqOn.symm)\n  exact π'.symm.mapsTo\n", "additional_info": "If two partial permutations are equivalent, so are their inverses.", "used_premises": [645, 645, 644, 644], "def_path": "ConNF/Mathlib/Logic/Equiv/PartialPerm.lean", "pos": [473, 478], "informalization": "Function `PartialPerm.EqOnDomain.symm'` proves that if two partial permutations are equivalent, then their inverses are also equivalent."}
{"full_name": "PartialPerm.EqOnDomain.symm_eqOn", "url": "ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm.EqOnDomain.symm_eqOn", "code_src": "con-nf", "ptype": "theorem", "header": "theorem PartialPerm.EqOnDomain.symm_eqOn {α : Type u_1} {π : PartialPerm🔗<|PREMISE|>🔗 α} {π' : PartialPerm🔗<|PREMISE|>🔗 α} (h : π ≈ π') :Set.EqOn🔗<|PREMISE|>🔗 (PartialPerm.symm🔗<|PREMISE|>🔗 π).toFun (PartialPerm.symm🔗<|PREMISE|>🔗 π').toFun π.domain", "code": "theorem EqOnDomain.symm_eqOn (h : π ≈ π') : EqOn π.symm π'.symm π.domain :=\n  EqOnDomain.eqOn (EqOnDomain.symm' h)\n", "additional_info": "Two equivalent partial permutations have coinciding inverses on the domain", "used_premises": [645, 645, 703, 644, 644], "def_path": "ConNF/Mathlib/Logic/Equiv/PartialPerm.lean", "pos": [480, 482], "informalization": "If two partial permutations are equivalent, then their inverses are equal on the domain of the partial permutations."}
{"full_name": "PartialPerm.EqOnDomain.domain_inter_preimage_eq", "url": "ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm.EqOnDomain.domain_inter_preimage_eq", "code_src": "con-nf", "ptype": "theorem", "header": "theorem PartialPerm.EqOnDomain.domain_inter_preimage_eq {α : Type u_1} {π : PartialPerm🔗<|PREMISE|>🔗 α} {π' : PartialPerm🔗<|PREMISE|>🔗 α} (hπ : π ≈ π') (s : Set🔗<|PREMISE|>🔗 α) :π.domain ∩ π.toFun ⁻¹' s = π'.domain ∩ π'.toFun ⁻¹' s", "code": "theorem EqOnDomain.domain_inter_preimage_eq (hπ : π ≈ π') (s : Set α) :\n    π.domain ∩ π ⁻¹' s = π'.domain ∩ π' ⁻¹' s := by rw [hπ.eqOn.inter_preimage_eq, EqOnDomain.domain_eq hπ]\n", "additional_info": "Preimages are respected by equivalence.", "used_premises": [645, 645, 69], "def_path": "ConNF/Mathlib/Logic/Equiv/PartialPerm.lean", "pos": [484, 486], "informalization": "Function `PartialPerm.EqOnDomain.domain_inter_preimage_eq` proves that the intersection of the domain of a partial permutation `π` and the preimage of a set `s` under `π.toFun` is equal to the intersection of the domain of an equivalent partial permutation `π'` and the preimage of `s` under `π'.toFun`."}
{"full_name": "PartialPerm.EqOnDomain.eq", "url": "ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm.EqOnDomain.eq", "code_src": "con-nf", "ptype": "theorem", "header": "theorem PartialPerm.EqOnDomain.eq {α : Type u_1} {π : PartialPerm🔗<|PREMISE|>🔗 α} {π' : PartialPerm🔗<|PREMISE|>🔗 α} (h : π ≈ π') (hπ : π.domain = Set.univ) :π = π'", "code": "protected theorem EqOnDomain.eq (h : π ≈ π') (hπ : π.domain = univ) : π = π' := by\n  apply PartialPerm.ext (fun x => h.2 _) (fun x => h.symm'.2 _) h.1 <;> simp [hπ]\n", "additional_info": "Two equivalent partial permutations are equal when the domain and domain are univ.", "used_premises": [645, 645], "def_path": "ConNF/Mathlib/Logic/Equiv/PartialPerm.lean", "pos": [488, 490], "informalization": "The theorem `PartialPerm.EqOnDomain.eq` states that two equivalent partial permutations are equal when the domain and domain are univ."}
{"full_name": "PartialPerm.domain_mono", "url": "ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm.domain_mono", "code_src": "con-nf", "ptype": "theorem", "header": "theorem PartialPerm.domain_mono {α : Type u_1} {π : PartialPerm🔗<|PREMISE|>🔗 α} {π' : PartialPerm🔗<|PREMISE|>🔗 α} (h : π ≤ π') :π.domain ⊆ π'.domain", "code": "theorem domain_mono (h : π ≤ π') : π.domain ⊆ π'.domain :=\n  h.1\n", "additional_info": "", "used_premises": [645, 645], "def_path": "ConNF/Mathlib/Logic/Equiv/PartialPerm.lean", "pos": [499, 501], "informalization": "For partial permutations `π` and `π'`, if `π ≤ π'`, then the domain of `π` is a subset of the domain of `π'`."}
{"full_name": "PartialPerm.eqOn_domain_of_le", "url": "ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm.eqOn_domain_of_le", "code_src": "con-nf", "ptype": "theorem", "header": "theorem PartialPerm.eqOn_domain_of_le {α : Type u_1} {π : PartialPerm🔗<|PREMISE|>🔗 α} {π' : PartialPerm🔗<|PREMISE|>🔗 α} (h : π ≤ π') :Set.EqOn🔗<|PREMISE|>🔗 π.toFun π'.toFun π.domain", "code": "theorem eqOn_domain_of_le (h : π ≤ π') : π.domain.EqOn π π' :=\n  h.2\n", "additional_info": "", "used_premises": [645, 645, 703], "def_path": "ConNF/Mathlib/Logic/Equiv/PartialPerm.lean", "pos": [502, 504], "informalization": "Given two partial permutations `π` and `π'`, if `π` is less than or equal to `π'`, then `π` and `π'` are equal on the domain of `π`."}
{"full_name": "PartialPerm.le_of_eq_on_domain", "url": "ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm.le_of_eq_on_domain", "code_src": "con-nf", "ptype": "theorem", "header": "theorem PartialPerm.le_of_eq_on_domain {α : Type u_1} {π : PartialPerm🔗<|PREMISE|>🔗 α} {π' : PartialPerm🔗<|PREMISE|>🔗 α} (h : π ≈ π') :π ≤ π'", "code": "theorem le_of_eq_on_domain (h : π ≈ π') : π ≤ π' :=\n  ⟨subset_of_eq h.1, h.2⟩\n", "additional_info": "", "used_premises": [645, 645], "def_path": "ConNF/Mathlib/Logic/Equiv/PartialPerm.lean", "pos": [505, 507], "informalization": "If two partial permutations `π` and `π'` are equal on their domains, then `π` is less than or equal to `π'`."}
{"full_name": "PartialPerm.apply_eq_of_le", "url": "ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm.apply_eq_of_le", "code_src": "con-nf", "ptype": "theorem", "header": "theorem PartialPerm.apply_eq_of_le {α : Type u_1} {π : PartialPerm🔗<|PREMISE|>🔗 α} {π' : PartialPerm🔗<|PREMISE|>🔗 α} (h : π ≤ π') {x : α} (hx : x ∈ π.domain) :π'.toFun x = π.toFun x", "code": "theorem apply_eq_of_le (h : π ≤ π') {x : α} (hx : x ∈ π.domain) : π' x = π x :=\n  (eqOn_domain_of_le h hx).symm\n", "additional_info": "", "used_premises": [645, 645], "def_path": "ConNF/Mathlib/Logic/Equiv/PartialPerm.lean", "pos": [508, 510], "informalization": "If `π ≤ π'` and `x ∈ π.domain`, then `π'.toFun x = π.toFun x`."}
{"full_name": "PartialPerm.piecewise_domain", "url": "ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm.piecewise_domain", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem PartialPerm.piecewise_domain {α : Type u_1} {π : PartialPerm🔗<|PREMISE|>🔗 α} {π' : PartialPerm🔗<|PREMISE|>🔗 α} [(j : α) → Decidable🔗<|PREMISE|>🔗 (j ∈ π.domain)] {h : Disjoint🔗<|PREMISE|>🔗 π.domain π'.domain} :(PartialPerm.piecewise🔗<|PREMISE|>🔗 π π' h).domain = π.domain ∪ π'.domain", "code": "theorem piecewise_domain : (piecewise π π' h).domain = π.domain ∪ π'.domain :=\n  rfl\n", "additional_info": "", "used_premises": [645, 645, 14, 757, 759], "def_path": "ConNF/Mathlib/Logic/Equiv/PartialPerm.lean", "pos": [551, 553], "informalization": "Function `PartialPerm.piecewise` takes two partial permutations `π` and `π'` with disjoint domains and returns a new partial permutation that coincides with `π` on `π.domain` and with `π'` on `π'.domain`. The domain of the resulting partial permutation is the union of the domains of `π` and `π'`."}
{"full_name": "Disjoint", "url": "Mathlib/Order/Disjoint.html#Disjoint", "code_src": "mathlib4", "ptype": "def", "header": "def Disjoint {α : Type u_1} [PartialOrder🔗<|PREMISE|>🔗 α] [OrderBot🔗<|PREMISE|>🔗 α] (a : α) (b : α) :Prop", "code": "def Disjoint (a b : α) : Prop :=\n  ∀ ⦃x⦄, x ≤ a → x ≤ b → x ≤ ⊥\n", "additional_info": "Two elements of a lattice are disjoint if their inf is the bottom element.\n(This generalizes disjoint sets, viewed as members of the subset lattice.)\nNote that we define this without reference to `⊓`, as this allows us to talk about orders where\nthe infimum is not unique, or where implementing `🗟Inf🗟🔗../.././Mathlib/Order/Notation.html#Inf🔗`  would require additional `🗟Decidable🗟🔗../.././Init/Prelude.html#Decidable🔗` \narguments.\nEquations\n* 🗟Disjoint🗟🔗../.././Mathlib/Order/Disjoint.html#Disjoint🔗  a b 🗟=🗟🔗../.././Init/Prelude.html#Eq🔗  ∀ ⦃x : α⦄, x 🗟≤🗟🔗../.././Init/Prelude.html#LE.le🔗  a → x 🗟≤🗟🔗../.././Init/Prelude.html#LE.le🔗  b → x 🗟≤🗟🔗../.././Init/Prelude.html#LE.le🔗  🗟⊥🗟🔗../.././Mathlib/Order/Notation.html#Bot.bot🔗\n\n", "used_premises": [3, 758], "def_path": "Mathlib/Order/Disjoint.lean", "pos": [41, 43], "informalization": "Function `Disjoint` checks if two elements `a` and `b` in a partially ordered set with a bottom element are disjoint, meaning any element `x` that is less than or equal to both `a` and `b` must also be less than or equal to the bottom element `⊥`."}
{"full_name": "OrderBot", "url": "Mathlib/Order/BoundedOrder.html#OrderBot", "code_src": "mathlib4", "ptype": "class", "header": "class OrderBot (α : Type u) [LE🔗<|PREMISE|>🔗 α] extends Bot🔗<|PREMISE|>🔗 :Type u\n | bot : α\n | bot_le : ∀ (a : α), ⊥  ≤  a", "code": "class OrderBot (α : Type u) [LE α] extends Bot α where\n  /-- `⊥` is the least element -/\n  bot_le : ∀ a : α, ⊥ ≤ a\n", "additional_info": "An order is an `🗟OrderBot🗟🔗../.././Mathlib/Order/BoundedOrder.html#OrderBot🔗`  if it has a least element.\nWe state this using a data mixin, holding the value of `⊥` and the least element constraint.\n- OrderBot.bot_le: `⊥` is the least element\n\n\n", "used_premises": [5, 547], "def_path": "Mathlib/Order/BoundedOrder.lean", "pos": [201, 204], "informalization": "Class `OrderBot` represents a type `α` with a least element `⊥` under a given less-equal relation, ensuring `⊥` is less than or equal to every element in `α`."}
{"full_name": "PartialPerm.piecewise", "url": "ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm.piecewise", "code_src": "con-nf", "ptype": "def", "header": "def PartialPerm.piecewise {α : Type u_1} (π : PartialPerm🔗<|PREMISE|>🔗 α) (π' : PartialPerm🔗<|PREMISE|>🔗 α) [(j : α) → Decidable🔗<|PREMISE|>🔗 (j ∈ π.domain)] (h : Disjoint🔗<|PREMISE|>🔗 π.domain π'.domain) :PartialPerm🔗<|PREMISE|>🔗 α", "code": "def piecewise (h : Disjoint π.domain π'.domain) : PartialPerm α\n    where\n  toFun := π.domain.piecewise π π'\n  invFun := π.domain.piecewise π.symm π'.symm\n  domain := π.domain ∪ π'.domain\n  toFun_domain' := by\n    rintro x (hx | hx)\n    · rw [piecewise_eqOn π.domain π π' hx]\n      exact Or.inl (π.map_domain hx)\n    · rw [piecewise_eqOn_compl π.domain π π' (disjoint_right.mp h hx)]\n      exact Or.inr (π'.map_domain hx)\n  invFun_domain' := by\n    rintro x (hx | hx)\n    · rw [piecewise_eqOn π.domain π.symm π'.symm hx]\n      exact Or.inl (π.symm.map_domain hx)\n    · rw [piecewise_eqOn_compl π.domain π.symm π'.symm (disjoint_right.mp h hx)]\n      exact Or.inr (π'.symm.map_domain hx)\n  left_inv' := by\n    rintro x (hx | hx)\n    · rw [piecewise_eqOn π.domain π π' hx,\n        piecewise_eqOn π.domain π.symm π'.symm (π.map_domain hx), π.left_inv hx]\n    · rw [piecewise_eqOn_compl π.domain π π' (disjoint_right.mp h hx),\n        piecewise_eqOn_compl π.domain π.symm π'.symm (disjoint_right.mp h (π'.map_domain hx)),\n        π'.left_inv hx]\n  right_inv' := by\n    rintro x (hx | hx)\n    · rw [piecewise_eqOn π.domain π.symm π'.symm hx,\n        piecewise_eqOn π.domain π π' (π.symm.map_domain hx), π.right_inv hx]\n    · rw [piecewise_eqOn_compl π.domain π.symm π'.symm (disjoint_right.mp h hx),\n        piecewise_eqOn_compl π.domain π π' (disjoint_right.mp h (π'.symm.map_domain hx)),\n        π'.right_inv hx]\n", "additional_info": "Construct a partial permutation from two partial permutations with disjoint domains.\nEquations\n* One or more equations did not get rendered due to their size.\n\n", "used_premises": [645, 645, 14, 757, 645], "def_path": "ConNF/Mathlib/Logic/Equiv/PartialPerm.lean", "pos": [516, 547], "informalization": "Function `PartialPerm.piecewise` takes two partial permutations `π` and `π'` with disjoint domains and returns a new partial permutation that coincides with `π` on `π.domain` and with `π'` on `π'.domain`."}
{"full_name": "PartialPerm.mem_piecewise_domain_left", "url": "ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm.mem_piecewise_domain_left", "code_src": "con-nf", "ptype": "theorem", "header": "theorem PartialPerm.mem_piecewise_domain_left {α : Type u_1} {π : PartialPerm🔗<|PREMISE|>🔗 α} {π' : PartialPerm🔗<|PREMISE|>🔗 α} [(j : α) → Decidable🔗<|PREMISE|>🔗 (j ∈ π.domain)] {h : Disjoint🔗<|PREMISE|>🔗 π.domain π'.domain} {x : α} (hx : x ∈ π.domain) :x ∈ (PartialPerm.piecewise🔗<|PREMISE|>🔗 π π' h).domain", "code": "theorem mem_piecewise_domain_left {x : α} (hx : x ∈ π.domain) : x ∈ (piecewise π π' h).domain :=\n  mem_union_left _ hx\n", "additional_info": "", "used_premises": [645, 645, 14, 757, 759], "def_path": "ConNF/Mathlib/Logic/Equiv/PartialPerm.lean", "pos": [554, 556], "informalization": "Given two partial permutations `π` and `π'` with disjoint domains, if `x` is in the domain of `π`, then `x` is also in the domain of the piecewise composition of `π` and `π'`."}
{"full_name": "PartialPerm.mem_piecewise_domain_right", "url": "ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm.mem_piecewise_domain_right", "code_src": "con-nf", "ptype": "theorem", "header": "theorem PartialPerm.mem_piecewise_domain_right {α : Type u_1} {π : PartialPerm🔗<|PREMISE|>🔗 α} {π' : PartialPerm🔗<|PREMISE|>🔗 α} [(j : α) → Decidable🔗<|PREMISE|>🔗 (j ∈ π.domain)] {h : Disjoint🔗<|PREMISE|>🔗 π.domain π'.domain} {x : α} (hx : x ∈ π'.domain) :x ∈ (PartialPerm.piecewise🔗<|PREMISE|>🔗 π π' h).domain", "code": "theorem mem_piecewise_domain_right {x : α} (hx : x ∈ π'.domain) : x ∈ (piecewise π π' h).domain :=\n  mem_union_right _ hx\n", "additional_info": "", "used_premises": [645, 645, 14, 757, 759], "def_path": "ConNF/Mathlib/Logic/Equiv/PartialPerm.lean", "pos": [557, 559], "informalization": "Given two partial permutations `π` and `π'` with disjoint domains, if `x` is in the domain of `π'`, then `x` is also in the domain of the piecewise composition of `π` and `π'`."}
{"full_name": "PartialPerm.piecewise_apply_eq_left", "url": "ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm.piecewise_apply_eq_left", "code_src": "con-nf", "ptype": "theorem", "header": "theorem PartialPerm.piecewise_apply_eq_left {α : Type u_1} {π : PartialPerm🔗<|PREMISE|>🔗 α} {π' : PartialPerm🔗<|PREMISE|>🔗 α} [(j : α) → Decidable🔗<|PREMISE|>🔗 (j ∈ π.domain)] {h : Disjoint🔗<|PREMISE|>🔗 π.domain π'.domain} {x : α} (hx : x ∈ π.domain) :(PartialPerm.piecewise🔗<|PREMISE|>🔗 π π' h).toFun x = π.toFun x", "code": "theorem piecewise_apply_eq_left {x : α} (hx : x ∈ π.domain) : piecewise π π' h x = π x :=\n  piecewise_eqOn _ _ _ hx\n", "additional_info": "", "used_premises": [645, 645, 14, 757, 759], "def_path": "ConNF/Mathlib/Logic/Equiv/PartialPerm.lean", "pos": [560, 562], "informalization": "Function `PartialPerm.piecewise` takes two partial permutations `π` and `π'` with disjoint domains and returns a new partial permutation that coincides with `π` on `π.domain` and with `π'` on `π'.domain`. The theorem `PartialPerm.piecewise_apply_eq_left` states that if `x` is in the domain of `π`, then applying the piecewise permutation to `x` yields the same result as applying `π` to `x`."}
{"full_name": "PartialPerm.piecewise_apply_eq_right", "url": "ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm.piecewise_apply_eq_right", "code_src": "con-nf", "ptype": "theorem", "header": "theorem PartialPerm.piecewise_apply_eq_right {α : Type u_1} {π : PartialPerm🔗<|PREMISE|>🔗 α} {π' : PartialPerm🔗<|PREMISE|>🔗 α} [(j : α) → Decidable🔗<|PREMISE|>🔗 (j ∈ π.domain)] {h : Disjoint🔗<|PREMISE|>🔗 π.domain π'.domain} {x : α} (hx : x ∈ π'.domain) :(PartialPerm.piecewise🔗<|PREMISE|>🔗 π π' h).toFun x = π'.toFun x", "code": "theorem piecewise_apply_eq_right {x : α} (hx : x ∈ π'.domain) : piecewise π π' h x = π' x :=\n  piecewise_eqOn_compl _ _ _ (disjoint_right.mp h hx)\n", "additional_info": "", "used_premises": [645, 645, 14, 757, 759], "def_path": "ConNF/Mathlib/Logic/Equiv/PartialPerm.lean", "pos": [563, 565], "informalization": "The function `PartialPerm.piecewise` takes two partial permutations `π` and `π'` with disjoint domains and returns a new partial permutation that coincides with `π` on `π.domain` and with `π'` on `π'.domain`. The theorem `PartialPerm.piecewise_apply_eq_right` states that for any element `x` in the domain of `π'`, the function `(PartialPerm.piecewise π π' h).toFun x` is equal to `π'.toFun x`."}
{"full_name": "PartialPerm.le_piecewise_left", "url": "ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm.le_piecewise_left", "code_src": "con-nf", "ptype": "theorem", "header": "theorem PartialPerm.le_piecewise_left {α : Type u_1} {π : PartialPerm🔗<|PREMISE|>🔗 α} {π' : PartialPerm🔗<|PREMISE|>🔗 α} [(j : α) → Decidable🔗<|PREMISE|>🔗 (j ∈ π.domain)] {h : Disjoint🔗<|PREMISE|>🔗 π.domain π'.domain} :π ≤ PartialPerm.piecewise🔗<|PREMISE|>🔗 π π' h", "code": "theorem le_piecewise_left : π ≤ piecewise π π' h :=\n  ⟨subset_union_left _ _, fun _ hx => (piecewise_apply_eq_left hx).symm⟩\n", "additional_info": "", "used_premises": [645, 645, 14, 757, 759], "def_path": "ConNF/Mathlib/Logic/Equiv/PartialPerm.lean", "pos": [566, 568], "informalization": "The theorem `le_piecewise_left` states that for any two partial permutations `π` and `π'` with disjoint domains, `π` is less than or equal to the piecewise composition of `π` and `π'`."}
{"full_name": "PartialPerm.le_piecewise_right", "url": "ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm.le_piecewise_right", "code_src": "con-nf", "ptype": "theorem", "header": "theorem PartialPerm.le_piecewise_right {α : Type u_1} {π : PartialPerm🔗<|PREMISE|>🔗 α} {π' : PartialPerm🔗<|PREMISE|>🔗 α} [(j : α) → Decidable🔗<|PREMISE|>🔗 (j ∈ π.domain)] {h : Disjoint🔗<|PREMISE|>🔗 π.domain π'.domain} :π' ≤ PartialPerm.piecewise🔗<|PREMISE|>🔗 π π' h", "code": "theorem le_piecewise_right : π' ≤ piecewise π π' h :=\n  ⟨subset_union_right _ _, fun _ hx => (piecewise_apply_eq_right hx).symm⟩\n", "additional_info": "", "used_premises": [645, 645, 14, 757, 759], "def_path": "ConNF/Mathlib/Logic/Equiv/PartialPerm.lean", "pos": [569, 571], "informalization": "Function `le_piecewise_right` states that for two partial permutations `π` and `π'` with disjoint domains, `π'` is less than or equal to the piecewise composition of `π` and `π'`."}
{"full_name": "Set.BijOn.toPartialPerm_toFun", "url": "ConNF/Mathlib/Logic/Equiv/PartialPerm.html#Set.BijOn.toPartialPerm_toFun", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem Set.BijOn.toPartialPerm_toFun {α : Type u_1} [Nonempty🔗<|PREMISE|>🔗 α] (f : α → α) (s : Set🔗<|PREMISE|>🔗 α) (hf : Set.BijOn🔗<|PREMISE|>🔗 f s s) :(Set.BijOn.toPartialPerm🔗<|PREMISE|>🔗 f s hf).toFun = f", "code": "@[simps (config := { fullyApplied := false })]\n", "additional_info": "", "used_premises": [212, 69, 665, 767], "def_path": "ConNF/Mathlib/Logic/Equiv/PartialPerm.lean", "pos": [580, 581], "informalization": "Function `Set.BijOn.toPartialPerm` converts a bijective function `f` between two sets `s` and `t` into a partial permutation on the type `α`. The resulting partial permutation has `f` as its forward function, the inverse function of `f` restricted to `s` as its inverse function, and `s` as its domain. The theorem `Set.BijOn.toPartialPerm_toFun` states that the forward function of the resulting partial permutation is indeed `f`."}
{"full_name": "Set.BijOn.toPartialPerm", "url": "ConNF/Mathlib/Logic/Equiv/PartialPerm.html#Set.BijOn.toPartialPerm", "code_src": "con-nf", "ptype": "noncomputable def", "header": "noncomputable def Set.BijOn.toPartialPerm {α : Type u_1} [Nonempty🔗<|PREMISE|>🔗 α] (f : α → α) (s : Set🔗<|PREMISE|>🔗 α) (hf : Set.BijOn🔗<|PREMISE|>🔗 f s s) :PartialPerm🔗<|PREMISE|>🔗 α", "code": "noncomputable def BijOn.toPartialPerm [Nonempty α] (f : α → α) (s : Set α) (hf : BijOn f s s) :\n    PartialPerm α where\n  toFun := f\n  invFun := invFunOn f s\n  domain := s\n  toFun_domain' := hf.mapsTo\n  invFun_domain' := hf.surjOn.mapsTo_invFunOn\n  left_inv' := hf.invOn_invFunOn.1\n  right_inv' := hf.invOn_invFunOn.2\n", "additional_info": "A bijection between two sets `s : 🗟Set🗟🔗../../../.././Mathlib/Init/Set.html#Set🔗  α` and `t : 🗟Set🗟🔗../../../.././Mathlib/Init/Set.html#Set🔗  α` provides a partial permutation on `α`.\nEquations\n* 🗟Set.BijOn.toPartialPerm🗟🔗../../../.././ConNF/Mathlib/Logic/Equiv/PartialPerm.html#Set.BijOn.toPartialPerm🔗  f s hf 🗟=🗟🔗../../../.././Init/Prelude.html#Eq🔗  { toFun := f, invFun := 🗟Function.invFunOn🗟🔗../../../.././Mathlib/Data/Set/Function.html#Function.invFunOn🔗  f s, domain := s, toFun_domain' := ⋯, invFun_domain' := ⋯, left_inv' := ⋯,\n right_inv' := ⋯ }\n\n", "used_premises": [212, 69, 665, 645], "def_path": "ConNF/Mathlib/Logic/Equiv/PartialPerm.lean", "pos": [581, 590], "informalization": "Function `Set.BijOn.toPartialPerm` converts a bijective function `f` between two sets `s` and `t` into a partial permutation on the type `α`. The resulting partial permutation has `f` as its forward function, the inverse function of `f` restricted to `s` as its inverse function, and `s` as its domain."}
{"full_name": "Set.BijOn.toPartialPerm_invFun", "url": "ConNF/Mathlib/Logic/Equiv/PartialPerm.html#Set.BijOn.toPartialPerm_invFun", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem Set.BijOn.toPartialPerm_invFun {α : Type u_1} [Nonempty🔗<|PREMISE|>🔗 α] (f : α → α) (s : Set🔗<|PREMISE|>🔗 α) (hf : Set.BijOn🔗<|PREMISE|>🔗 f s s) :(Set.BijOn.toPartialPerm🔗<|PREMISE|>🔗 f s hf).invFun = Function.invFunOn🔗<|PREMISE|>🔗 f s", "code": "@[simps (config := { fullyApplied := false })]\n", "additional_info": "", "used_premises": [212, 69, 665, 767, 769], "def_path": "ConNF/Mathlib/Logic/Equiv/PartialPerm.lean", "pos": [580, 581], "informalization": "The theorem `Set.BijOn.toPartialPerm_invFun` states that for a bijective function `f` on a set `s`, the inverse function of the partial permutation `Set.BijOn.toPartialPerm f s hf` is equal to the inverse function of `f` restricted to `s`."}
{"full_name": "Function.invFunOn", "url": "Mathlib/Data/Set/Function.html#Function.invFunOn", "code_src": "mathlib4", "ptype": "noncomputable def", "header": "noncomputable def Function.invFunOn {α : Type u_1} {β : Type u_2} [Nonempty🔗<|PREMISE|>🔗 α] (f : α → β) (s : Set🔗<|PREMISE|>🔗 α) (b : β) :α", "code": "noncomputable def invFunOn (f : α → β) (s : Set α) (b : β) : α :=\n  if h : ∃ a, a ∈ s ∧ f a = b then Classical.choose h else Classical.choice ‹Nonempty α›\n", "additional_info": "Construct the inverse for a function `f` on domain `s`. This function is a right inverse of `f`\non `f '' s`. For a computable version, see `Function.Embedding.invOfMemRange`.\nEquations\n* 🗟Function.invFunOn🗟🔗../../.././Mathlib/Data/Set/Function.html#Function.invFunOn🔗  f s b 🗟=🗟🔗../../.././Init/Prelude.html#Eq🔗  if h : ∃ a ∈ s, f a 🗟=🗟🔗../../.././Init/Prelude.html#Eq🔗  b then 🗟Classical.choose🗟🔗../../.././Init/Classical.html#Classical.choose🔗  h else 🗟Classical.choice🗟🔗../../.././Init/Prelude.html#Classical.choice🔗  inst\n\n", "used_premises": [212, 69], "def_path": "Mathlib/Data/Set/Function.lean", "pos": [1243, 1245], "informalization": "Function `Function.invFunOn` is a noncomputable function that, given a function `f : α → β`, a set `s : Set α`, and an element `b : β`, returns an element `a : α` such that `f a = b` and `a ∈ s`, if such an element exists. If no such element exists, it returns an arbitrary element of `α` using `Classical.choice`."}
{"full_name": "Set.BijOn.toPartialPerm_domain", "url": "ConNF/Mathlib/Logic/Equiv/PartialPerm.html#Set.BijOn.toPartialPerm_domain", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem Set.BijOn.toPartialPerm_domain {α : Type u_1} [Nonempty🔗<|PREMISE|>🔗 α] (f : α → α) (s : Set🔗<|PREMISE|>🔗 α) (hf : Set.BijOn🔗<|PREMISE|>🔗 f s s) :(Set.BijOn.toPartialPerm🔗<|PREMISE|>🔗 f s hf).domain = s", "code": "@[simps (config := { fullyApplied := false })]\n", "additional_info": "", "used_premises": [212, 69, 665, 767], "def_path": "ConNF/Mathlib/Logic/Equiv/PartialPerm.lean", "pos": [580, 581], "informalization": "The theorem `Set.BijOn.toPartialPerm_domain` states that the domain of the partial permutation `Set.BijOn.toPartialPerm f s hf` is equal to the set `s`."}
{"full_name": "Equiv.Perm.toPartialPerm_one", "url": "ConNF/Mathlib/Logic/Equiv/PartialPerm.html#Equiv.Perm.toPartialPerm_one", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem Equiv.Perm.toPartialPerm_one {α : Type u_1} :Equiv.Perm.toPartialPerm🔗<|PREMISE|>🔗 (Equiv.refl🔗<|PREMISE|>🔗 α) = PartialPerm.refl🔗<|PREMISE|>🔗 α", "code": "theorem toPartialPerm_one : toPartialPerm (Equiv.refl α) = PartialPerm.refl α :=\n  rfl\n", "additional_info": "", "used_premises": [772, 774, 720], "def_path": "ConNF/Mathlib/Logic/Equiv/PartialPerm.lean", "pos": [607, 609], "informalization": "The theorem `Equiv.Perm.toPartialPerm_one` states that converting the identity permutation on a type `α` to a partial permutation results in the identity partial permutation on `α`."}
{"full_name": "Equiv.Perm.toPartialPerm", "url": "ConNF/Mathlib/Logic/Equiv/PartialPerm.html#Equiv.Perm.toPartialPerm", "code_src": "con-nf", "ptype": "def", "header": "def Equiv.Perm.toPartialPerm {α : Type u_1} (π : Equiv.Perm🔗<|PREMISE|>🔗 α) :PartialPerm🔗<|PREMISE|>🔗 α", "code": "def Equiv.Perm.toPartialPerm (π : Equiv.Perm α) : PartialPerm α\n    where\n  toFun := π\n  invFun := π.symm\n  domain := univ\n  toFun_domain' _ _ := mem_univ _\n  invFun_domain' _ _ := mem_univ _\n  left_inv' x _ := π.left_inv x\n  right_inv' x _ := π.right_inv x\n", "additional_info": "A `Perm` gives rise to a `🗟PartialPerm🗟🔗../../../.././ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm🔗`  defined on the entire type.\nEquations\n* 🗟Equiv.Perm.toPartialPerm🗟🔗../../../.././ConNF/Mathlib/Logic/Equiv/PartialPerm.html#Equiv.Perm.toPartialPerm🔗  π 🗟=🗟🔗../../../.././Init/Prelude.html#Eq🔗  { toFun := ⇑π, invFun := ⇑π.symm, domain := Set.univ, toFun_domain' := ⋯, invFun_domain' := ⋯, left_inv' := ⋯,\n right_inv' := ⋯ }\n\n", "used_premises": [773, 645], "def_path": "ConNF/Mathlib/Logic/Equiv/PartialPerm.lean", "pos": [32, 41], "informalization": "Function `Equiv.Perm.toPartialPerm` converts a permutation of a type `α` into a partial permutation defined on the entire type `α`."}
{"full_name": "Equiv.Perm", "url": "Mathlib/Logic/Equiv/Defs.html#Equiv.Perm", "code_src": "mathlib4", "ptype": "def", "header": "@[reducible]def Equiv.Perm (α : Sort u_1) :Sort (max 1 u_1)", "code": "def Equiv.Perm (α : Sort*) :=\n  Equiv α α\n", "additional_info": "`🗟Perm🗟🔗../../.././Mathlib/Logic/Equiv/Defs.html#Equiv.Perm🔗  α` is the type of bijections from `α` to itself.\nEquations\n* 🗟Equiv.Perm🗟🔗../../.././Mathlib/Logic/Equiv/Defs.html#Equiv.Perm🔗  α 🗟=🗟🔗../../.././Init/Prelude.html#Eq🔗  (α 🗟≃🗟🔗../../.././Mathlib/Logic/Equiv/Defs.html#Equiv🔗  α)\n\n", "used_premises": [], "def_path": "Mathlib/Logic/Equiv/Defs.lean", "pos": [90, 92], "informalization": "`Equiv.Perm` defines the type of all bijective equivalences (permutations) from a type `α` to itself, representing the group of automorphisms on `α`."}
{"full_name": "Equiv.refl", "url": "Mathlib/Logic/Equiv/Defs.html#Equiv.refl", "code_src": "mathlib4", "ptype": "def", "header": "def Equiv.refl (α : Sort u_1) :α ≃ α", "code": "@[refl] protected def refl (α : Sort*) : α ≃ α := ⟨id, id, fun _ => rfl, fun _ => rfl⟩\n", "additional_info": "Any type is equivalent to itself.\nEquations\n* 🗟Equiv.refl🗟🔗../../.././Mathlib/Logic/Equiv/Defs.html#Equiv.refl🔗  α 🗟=🗟🔗../../.././Init/Prelude.html#Eq🔗  { toFun := id, invFun := id, left_inv := ⋯, right_inv := ⋯ }\n\n", "used_premises": [], "def_path": "Mathlib/Logic/Equiv/Defs.lean", "pos": [158, 159], "informalization": "Function `Equiv.refl` is the identity equivalence, which states that any type is equivalent to itself."}
{"full_name": "Equiv.Perm.toPartialPerm_inv", "url": "ConNF/Mathlib/Logic/Equiv/PartialPerm.html#Equiv.Perm.toPartialPerm_inv", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem Equiv.Perm.toPartialPerm_inv {α : Type u_1} (π : Equiv.Perm🔗<|PREMISE|>🔗 α) :Equiv.Perm.toPartialPerm🔗<|PREMISE|>🔗 π⁻¹ = PartialPerm.symm🔗<|PREMISE|>🔗 (Equiv.Perm.toPartialPerm🔗<|PREMISE|>🔗 π)", "code": "theorem toPartialPerm_inv : π⁻¹.toPartialPerm = π.toPartialPerm.symm :=\n  rfl\n", "additional_info": "", "used_premises": [773, 772, 644, 772], "def_path": "ConNF/Mathlib/Logic/Equiv/PartialPerm.lean", "pos": [611, 613], "informalization": "Function `Equiv.Perm.toPartialPerm_inv` states that the inverse of a permutation, when converted to a partial permutation, is equal to the inverse of the partial permutation obtained from the original permutation."}
{"full_name": "Equiv.Perm.toPartialEquiv_toPartialPerm", "url": "ConNF/Mathlib/Logic/Equiv/PartialPerm.html#Equiv.Perm.toPartialEquiv_toPartialPerm", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem Equiv.Perm.toPartialEquiv_toPartialPerm {α : Type u_1} (π : Equiv.Perm🔗<|PREMISE|>🔗 α) :PartialPerm.toPartialEquiv🔗<|PREMISE|>🔗 (Equiv.Perm.toPartialPerm🔗<|PREMISE|>🔗 π) = Equiv.toPartialEquiv🔗<|PREMISE|>🔗 π", "code": "theorem toPartialEquiv_toPartialPerm : π.toPartialPerm.toPartialEquiv = π.toPartialEquiv :=\n  rfl\n", "additional_info": "", "used_premises": [773, 733, 772, 777], "def_path": "ConNF/Mathlib/Logic/Equiv/PartialPerm.lean", "pos": [619, 621], "informalization": "The theorem `Equiv.Perm.toPartialEquiv_toPartialPerm` states that converting a permutation to a partial permutation and then back to a partial equivalence yields the same result as converting the permutation directly to a partial equivalence."}
{"full_name": "Equiv.toPartialEquiv", "url": "Mathlib/Logic/Equiv/PartialEquiv.html#Equiv.toPartialEquiv", "code_src": "mathlib4", "ptype": "def", "header": "def Equiv.toPartialEquiv {α : Type u_1} {β : Type u_2} (e : α ≃ β) :PartialEquiv🔗<|PREMISE|>🔗 α β", "code": "def Equiv.toPartialEquiv (e : α ≃ β) : PartialEquiv α β :=\n  e.toPartialEquivOfImageEq univ univ <| by rw [image_univ, e.surjective.range_eq]\n", "additional_info": "Associate a `🗟PartialEquiv🗟🔗../../.././Mathlib/Logic/Equiv/PartialEquiv.html#PartialEquiv🔗`  to an `🗟Equiv🗟🔗../../.././Mathlib/Logic/Equiv/Defs.html#Equiv🔗` .\nEquations\n* 🗟Equiv.toPartialEquiv🗟🔗../../.././Mathlib/Logic/Equiv/PartialEquiv.html#Equiv.toPartialEquiv🔗  e 🗟=🗟🔗../../.././Init/Prelude.html#Eq🔗  🗟Equiv.toPartialEquivOfImageEq🗟🔗../../.././Mathlib/Logic/Equiv/PartialEquiv.html#Equiv.toPartialEquivOfImageEq🔗  e Set.univ Set.univ ⋯\n\n", "used_premises": [734], "def_path": "Mathlib/Logic/Equiv/PartialEquiv.lean", "pos": [273, 275], "informalization": "Function `Equiv.toPartialEquiv` converts an `Equiv` object to a `PartialEquiv` object, which represents a partial equivalence between two types."}
{"full_name": "ConNF.StructApprox.completeAtomPerm_apply", "url": "ConNF/FOA/Result.html#ConNF.StructApprox.completeAtomPerm_apply", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.StructApprox.completeAtomPerm_apply [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.FOAAssumptions] {β : ConNF.Λ} [ConNF.LeLevel🔗<|PREMISE|>🔗 ↑β] [ConNF.StructApprox.FreedomOfActionHypothesis🔗<|PREMISE|>🔗 β] {π : ConNF.StructApprox🔗<|PREMISE|>🔗 ↑β} (hπf : ConNF.StructApprox.Free🔗<|PREMISE|>🔗 π) (A : ConNF.ExtendedIndex🔗<|PREMISE|>🔗 ↑β) (a : ConNF.Atom) :(ConNF.StructApprox.completeAtomPerm🔗<|PREMISE|>🔗 hπf A) a = ConNF.StructApprox.completeAtomMap🔗<|PREMISE|>🔗 π A a", "code": "theorem completeAtomPerm_apply (hπf : π.Free) (A : ExtendedIndex β) (a : Atom) :\n    completeAtomPerm hπf A a = π.completeAtomMap A a :=\n  rfl\n", "additional_info": "", "used_premises": [1, 402, 779, 781, 782, 61, 783, 784], "def_path": "ConNF/FOA/Result.lean", "pos": [21, 24], "informalization": "Function `ConNF.StructApprox.completeAtomPerm` defines a permutation on the set of atoms in the context of Constructive Ordinal Notation (ConNF), given a free `β`-structural approximation `π` and a `β`-extended index `A`. This permutation is constructed by applying the `β`-structural approximation to `A`, which results in a near-litter approximation, and then using this near-litter approximation to define a permutation on the set of atoms."}
{"full_name": "ConNF.StructApprox.FreedomOfActionHypothesis", "url": "ConNF/FOA/Complete/LitterCompletion.html#ConNF.StructApprox.FreedomOfActionHypothesis", "code_src": "con-nf", "ptype": "class", "header": "class ConNF.StructApprox.FreedomOfActionHypothesis [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.FOAAssumptions] (β : ConNF.Λ) [ConNF.LeLevel🔗<|PREMISE|>🔗 ↑β] :Prop\n | freedomOfAction_of_lt : ∀ γ < β, ∀ [inst : ConNF.LeLevel🔗<|PREMISE|>🔗  ↑γ], ConNF.StructApprox.FOAIh🔗<|PREMISE|>🔗  γ", "code": "class FreedomOfActionHypothesis (β : Λ) [LeLevel β] : Prop where\n  freedomOfAction_of_lt : ∀ γ < β, [LeLevel γ] → FOAIh γ\n", "additional_info": "", "used_premises": [1, 402, 402, 780], "def_path": "ConNF/FOA/Complete/LitterCompletion.lean", "pos": [23, 25], "informalization": "Class `FreedomOfActionHypothesis` is an inductive hypothesis used in the proof of freedom of action in Constructive Ordinal Notation (ConNF). It states that every free approximation exactly approximates some allowable permutation."}
{"full_name": "ConNF.StructApprox.FOAIh", "url": "ConNF/FOA/Complete/LitterCompletion.html#ConNF.StructApprox.FOAIh", "code_src": "con-nf", "ptype": "def", "header": "def ConNF.StructApprox.FOAIh [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.FOAAssumptions] (β : ConNF.Λ) [ConNF.LeLevel🔗<|PREMISE|>🔗 ↑β] :Prop", "code": "def FOAIh (β : Λ) [LeLevel β] : Prop :=\n  ∀ π₀ : StructApprox β, π₀.Free →\n  ∃ π : Allowable β, π₀.ExactlyApproximates (Allowable.toStructPerm π)\n", "additional_info": "The inductive hypothesis used for proving freedom of action:\nEvery free approximation exactly approximates some allowable permutation.\nEquations\n* One or more equations did not get rendered due to their size.\n\n", "used_premises": [1, 402], "def_path": "ConNF/FOA/Complete/LitterCompletion.lean", "pos": [19, 22], "informalization": "Function `ConNF.StructApprox.FOAIh` is an inductive hypothesis used in the proof of freedom of action in Constructive Ordinal Notation (ConNF). It states that every free approximation exactly approximates some allowable permutation."}
{"full_name": "ConNF.StructApprox", "url": "ConNF/FOA/Approximation/StructApprox.html#ConNF.StructApprox", "code_src": "con-nf", "ptype": "abbrev", "header": "@[inline, reducible]abbrev ConNF.StructApprox [ConNF.Params🔗<|PREMISE|>🔗 ] (α : ConNF.TypeIndex) :Type u", "code": "abbrev StructApprox :=\n  Tree NearLitterApprox\n", "additional_info": "A `β`-structural approximation is a product that assigns a near-litter approximation to each\n`β`-extended index.\nEquations\n* ConNF.StructApprox 🗟=🗟🔗../../.././Init/Prelude.html#Eq🔗  🗟ConNF.Tree🗟🔗../../.././ConNF/Structural/Tree.html#ConNF.Tree🔗  ConNF.NearLitterApprox\n\n", "used_premises": [1], "def_path": "ConNF/FOA/Approximation/StructApprox.lean", "pos": [18, 20], "informalization": "Function `ConNF.StructApprox` defines a `β`-structural approximation in the context of Constructive Ordinal Notation (ConNF), which is a product that assigns a near-litter approximation to each `β`-extended index."}
{"full_name": "ConNF.StructApprox.Free", "url": "ConNF/FOA/Approximation/StructApprox.html#ConNF.StructApprox.Free", "code_src": "con-nf", "ptype": "def", "header": "def ConNF.StructApprox.Free [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.FOAAssumptions] {β : ConNF.Λ} (π₀ : ConNF.StructApprox🔗<|PREMISE|>🔗 ↑β) :Prop", "code": "def Free {β : Λ} (π₀ : StructApprox β) : Prop :=\n  ∀ A, (π₀ A).Free A\n", "additional_info": "Equations\n* 🗟ConNF.StructApprox.Free🗟🔗../../.././ConNF/FOA/Approximation/StructApprox.html#ConNF.StructApprox.Free🔗  π₀ 🗟=🗟🔗../../.././Init/Prelude.html#Eq🔗  ∀ (A : 🗟ConNF.ExtendedIndex🗟🔗../../.././ConNF/Structural/Index.html#ConNF.ExtendedIndex🔗  ↑β), 🗟ConNF.NearLitterApprox.Free🗟🔗../../.././ConNF/FOA/Approximation/NearLitterApprox.html#ConNF.NearLitterApprox.Free🔗  (π₀ A) A\n\n", "used_premises": [1, 781], "def_path": "ConNF/FOA/Approximation/StructApprox.lean", "pos": [31, 33], "informalization": "Function `ConNF.StructApprox.Free` checks if a `β`-structural approximation `π₀` is free, meaning that for every `β`-extended index `A`, the near-litter approximation `(π₀ A)` is free with respect to `A`."}
{"full_name": "ConNF.StructApprox.completeAtomPerm", "url": "ConNF/FOA/Result.html#ConNF.StructApprox.completeAtomPerm", "code_src": "con-nf", "ptype": "noncomputable def", "header": "noncomputable def ConNF.StructApprox.completeAtomPerm [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.FOAAssumptions] {β : ConNF.Λ} [ConNF.LeLevel🔗<|PREMISE|>🔗 ↑β] [ConNF.StructApprox.FreedomOfActionHypothesis🔗<|PREMISE|>🔗 β] {π : ConNF.StructApprox🔗<|PREMISE|>🔗 ↑β} (hπf : ConNF.StructApprox.Free🔗<|PREMISE|>🔗 π) (A : ConNF.ExtendedIndex🔗<|PREMISE|>🔗 ↑β) :Equiv.Perm🔗<|PREMISE|>🔗 ConNF.Atom", "code": "noncomputable def completeAtomPerm (hπf : π.Free) (A : ExtendedIndex β) : Perm Atom :=\n  Equiv.ofBijective _ (completeAtomMap_bijective hπf A)\n", "additional_info": "Equations\n* 🗟ConNF.StructApprox.completeAtomPerm🗟🔗../.././ConNF/FOA/Result.html#ConNF.StructApprox.completeAtomPerm🔗  hπf A 🗟=🗟🔗../.././Init/Prelude.html#Eq🔗  🗟Equiv.ofBijective🗟🔗../.././Mathlib/Logic/Equiv/Defs.html#Equiv.ofBijective🔗  (🗟ConNF.StructApprox.completeAtomMap🗟🔗../.././ConNF/FOA/Complete/CompleteAction.html#ConNF.StructApprox.completeAtomMap🔗  π A) ⋯\n\n", "used_premises": [1, 402, 779, 781, 782, 61, 773], "def_path": "ConNF/FOA/Result.lean", "pos": [15, 17], "informalization": "Function `ConNF.StructApprox.completeAtomPerm` defines a permutation on the set of atoms in the context of Constructive Ordinal Notation (ConNF), given a free `β`-structural approximation `π` and a `β`-extended index `A`. This permutation is constructed by applying the `β`-structural approximation to `A`, which results in a near-litter approximation, and then using this near-litter approximation to define a permutation on the set of atoms."}
{"full_name": "ConNF.StructApprox.completeAtomMap", "url": "ConNF/FOA/Complete/CompleteAction.html#ConNF.StructApprox.completeAtomMap", "code_src": "con-nf", "ptype": "noncomputable def", "header": "noncomputable def ConNF.StructApprox.completeAtomMap [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.FOAAssumptions] {β : ConNF.Λ} [ConNF.LeLevel🔗<|PREMISE|>🔗 ↑β] [ConNF.StructApprox.FreedomOfActionHypothesis🔗<|PREMISE|>🔗 β] (π : ConNF.StructApprox🔗<|PREMISE|>🔗 ↑β) :ConNF.ExtendedIndex🔗<|PREMISE|>🔗 ↑β → ConNF.Atom → ConNF.Atom", "code": "noncomputable def completeAtomMap (π : StructApprox β) : ExtendedIndex β → Atom → Atom :=\n  HypAction.fixAtom π.atomCompletion π.nearLitterCompletion\n", "additional_info": "Equations\n* 🗟ConNF.StructApprox.completeAtomMap🗟🔗../../.././ConNF/FOA/Complete/CompleteAction.html#ConNF.StructApprox.completeAtomMap🔗  π 🗟=🗟🔗../../.././Init/Prelude.html#Eq🔗  🗟ConNF.HypAction.fixAtom🗟🔗../../.././ConNF/FOA/Complete/HypAction.html#ConNF.HypAction.fixAtom🔗  (🗟ConNF.StructApprox.atomCompletion🗟🔗../../.././ConNF/FOA/Complete/AtomCompletion.html#ConNF.StructApprox.atomCompletion🔗  π) (🗟ConNF.StructApprox.nearLitterCompletion🗟🔗../../.././ConNF/FOA/Complete/NearLitterCompletion.html#ConNF.StructApprox.nearLitterCompletion🔗  π)\n\n", "used_premises": [1, 402, 779, 781, 61], "def_path": "ConNF/FOA/Complete/CompleteAction.lean", "pos": [23, 25], "informalization": "Function `ConNF.StructApprox.completeAtomMap` is a noncomputable definition in the context of Constructive Ordinal Notation (ConNF). It takes a `β`-structural approximation `π` and returns a function that maps each `β`-extended index to an atom. This function is defined using the `ConNF.HypAction.fixAtom` function, which is part of the `ConNF.HypAction` class. The `ConNF.HypAction.fixAtom` function uses the `ConNF.StructApprox.atomCompletion` and `ConNF.StructApprox.nearLitterCompletion` components of the `β`-structural approximation `π`."}
{"full_name": "ConNF.StructApprox.completeLitterPerm_apply", "url": "ConNF/FOA/Result.html#ConNF.StructApprox.completeLitterPerm_apply", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.StructApprox.completeLitterPerm_apply [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.FOAAssumptions] {β : ConNF.Λ} [ConNF.LeLevel🔗<|PREMISE|>🔗 ↑β] [ConNF.StructApprox.FreedomOfActionHypothesis🔗<|PREMISE|>🔗 β] {π : ConNF.StructApprox🔗<|PREMISE|>🔗 ↑β} (hπf : ConNF.StructApprox.Free🔗<|PREMISE|>🔗 π) (A : ConNF.ExtendedIndex🔗<|PREMISE|>🔗 ↑β) (L : ConNF.Litter) :(ConNF.StructApprox.completeLitterPerm🔗<|PREMISE|>🔗 hπf A) L = ConNF.StructApprox.completeLitterMap🔗<|PREMISE|>🔗 π A L", "code": "theorem completeLitterPerm_apply (hπf : π.Free) (A : ExtendedIndex β) (L : Litter) :\n    completeLitterPerm hπf A L = π.completeLitterMap A L :=\n  rfl\n", "additional_info": "", "used_premises": [1, 402, 779, 781, 782, 61, 786, 787], "def_path": "ConNF/FOA/Result.lean", "pos": [25, 28], "informalization": "The theorem `ConNF.StructApprox.completeLitterPerm_apply` is a part of the construction of the natural numbers in the context of Constructive Ordinal Notation (ConNF). It defines a permutation on the litter type `ConNF.Litter` from a free `β`-structural approximation `π` and a `β`-extended index `A`. This permutation is derived from the `ConNF.StructApprox.completeLitterMap` function, which maps elements of `ConNF.Litter` to other elements of `ConNF.Litter` based on the approximation `π` and the index `A`."}
{"full_name": "ConNF.StructApprox.completeLitterPerm", "url": "ConNF/FOA/Result.html#ConNF.StructApprox.completeLitterPerm", "code_src": "con-nf", "ptype": "noncomputable def", "header": "noncomputable def ConNF.StructApprox.completeLitterPerm [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.FOAAssumptions] {β : ConNF.Λ} [ConNF.LeLevel🔗<|PREMISE|>🔗 ↑β] [ConNF.StructApprox.FreedomOfActionHypothesis🔗<|PREMISE|>🔗 β] {π : ConNF.StructApprox🔗<|PREMISE|>🔗 ↑β} (hπf : ConNF.StructApprox.Free🔗<|PREMISE|>🔗 π) (A : ConNF.ExtendedIndex🔗<|PREMISE|>🔗 ↑β) :Equiv.Perm🔗<|PREMISE|>🔗 ConNF.Litter", "code": "noncomputable def completeLitterPerm (hπf : π.Free) (A : ExtendedIndex β) : Perm Litter :=\n  Equiv.ofBijective _ (completeLitterMap_bijective hπf A)\n", "additional_info": "Equations\n* 🗟ConNF.StructApprox.completeLitterPerm🗟🔗../.././ConNF/FOA/Result.html#ConNF.StructApprox.completeLitterPerm🔗  hπf A 🗟=🗟🔗../.././Init/Prelude.html#Eq🔗  🗟Equiv.ofBijective🗟🔗../.././Mathlib/Logic/Equiv/Defs.html#Equiv.ofBijective🔗  (🗟ConNF.StructApprox.completeLitterMap🗟🔗../.././ConNF/FOA/Complete/CompleteAction.html#ConNF.StructApprox.completeLitterMap🔗  π A) ⋯\n\n", "used_premises": [1, 402, 779, 781, 782, 61, 773], "def_path": "ConNF/FOA/Result.lean", "pos": [18, 20], "informalization": "Function `ConNF.StructApprox.completeLitterPerm` constructs a permutation on the litter type `ConNF.Litter` from a free `β`-structural approximation `π` and a `β`-extended index `A`. This permutation is derived from the `ConNF.StructApprox.completeLitterMap` function, which maps elements of `ConNF.Litter` to other elements of `ConNF.Litter` based on the approximation `π` and the index `A`."}
{"full_name": "ConNF.StructApprox.completeLitterMap", "url": "ConNF/FOA/Complete/CompleteAction.html#ConNF.StructApprox.completeLitterMap", "code_src": "con-nf", "ptype": "noncomputable def", "header": "noncomputable def ConNF.StructApprox.completeLitterMap [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.FOAAssumptions] {β : ConNF.Λ} [ConNF.LeLevel🔗<|PREMISE|>🔗 ↑β] [ConNF.StructApprox.FreedomOfActionHypothesis🔗<|PREMISE|>🔗 β] (π : ConNF.StructApprox🔗<|PREMISE|>🔗 ↑β) (A : ConNF.ExtendedIndex🔗<|PREMISE|>🔗 ↑β) (L : ConNF.Litter) :ConNF.Litter", "code": "noncomputable def completeLitterMap (π : StructApprox β) (A : ExtendedIndex β) (L : Litter) :\n    Litter :=\n  (π.completeNearLitterMap A L.toNearLitter).1\n", "additional_info": "Equations\n* 🗟ConNF.StructApprox.completeLitterMap🗟🔗../../.././ConNF/FOA/Complete/CompleteAction.html#ConNF.StructApprox.completeLitterMap🔗  π A L 🗟=🗟🔗../../.././Init/Prelude.html#Eq🔗  (🗟ConNF.StructApprox.completeNearLitterMap🗟🔗../../.././ConNF/FOA/Complete/CompleteAction.html#ConNF.StructApprox.completeNearLitterMap🔗  π A (🗟ConNF.Litter.toNearLitter🗟🔗../../.././ConNF/BaseType/NearLitter.html#ConNF.Litter.toNearLitter🔗  L)).fst\n\n", "used_premises": [1, 402, 779, 781, 61], "def_path": "ConNF/FOA/Complete/CompleteAction.lean", "pos": [30, 33], "informalization": "Function `ConNF.StructApprox.completeLitterMap` takes a `β`-structural approximation `π`, a `β`-extended index `A`, and a litter `L`, and returns a litter. This function is part of the construction of the natural numbers in the context of Constructive Ordinal Notation (ConNF)."}
{"full_name": "ConNF.StructApprox.completeNearLitterPerm_smul_atom", "url": "ConNF/FOA/Result.html#ConNF.StructApprox.completeNearLitterPerm_smul_atom", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.StructApprox.completeNearLitterPerm_smul_atom [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.FOAAssumptions] {β : ConNF.Λ} [ConNF.LeLevel🔗<|PREMISE|>🔗 ↑β] [ConNF.StructApprox.FreedomOfActionHypothesis🔗<|PREMISE|>🔗 β] {π : ConNF.StructApprox🔗<|PREMISE|>🔗 ↑β} (hπf : ConNF.StructApprox.Free🔗<|PREMISE|>🔗 π) (A : ConNF.ExtendedIndex🔗<|PREMISE|>🔗 ↑β) (a : ConNF.Atom) :ConNF.StructApprox.completeNearLitterPerm🔗<|PREMISE|>🔗 hπf A • a = ConNF.StructApprox.completeAtomMap🔗<|PREMISE|>🔗 π A a", "code": "theorem completeNearLitterPerm_smul_atom (hπf : π.Free) (A : ExtendedIndex β) (a : Atom) :\n    completeNearLitterPerm hπf A • a = π.completeAtomMap A a :=\n  rfl\n", "additional_info": "", "used_premises": [1, 402, 779, 781, 782, 61, 789, 784], "def_path": "ConNF/FOA/Result.lean", "pos": [44, 47], "informalization": "In the context of Constructive Ordinal Notation (ConNF), given a free β-structural approximation π, the `ConNF.StructApprox.completeNearLitterPerm` function provides a near-litter permutation for each β-extended index A, and the `ConNF.StructApprox.completeAtomMap` function completes each atom. The theorem `ConNF.StructApprox.completeNearLitterPerm_smul_atom` proves that the action of the near-litter permutation on an atom is equal to the atom's completion by the β-structural approximation π."}
{"full_name": "ConNF.StructApprox.completeNearLitterPerm", "url": "ConNF/FOA/Result.html#ConNF.StructApprox.completeNearLitterPerm", "code_src": "con-nf", "ptype": "noncomputable def", "header": "noncomputable def ConNF.StructApprox.completeNearLitterPerm [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.FOAAssumptions] {β : ConNF.Λ} [ConNF.LeLevel🔗<|PREMISE|>🔗 ↑β] [ConNF.StructApprox.FreedomOfActionHypothesis🔗<|PREMISE|>🔗 β] {π : ConNF.StructApprox🔗<|PREMISE|>🔗 ↑β} (hπf : ConNF.StructApprox.Free🔗<|PREMISE|>🔗 π) (A : ConNF.ExtendedIndex🔗<|PREMISE|>🔗 ↑β) :ConNF.NearLitterPerm", "code": "noncomputable def completeNearLitterPerm (hπf : π.Free) (A : ExtendedIndex β) : NearLitterPerm\n    where\n  atomPerm := completeAtomPerm hπf A\n  litterPerm := completeLitterPerm hπf A\n  near := by\n    intro L s hs\n    have :\n      ↑(completeAtomPerm hπf A)⁻¹ ⁻¹' s =\n        (π.completeNearLitterMap A ⟨L, s, hs⟩ : Set Atom)\n    · simp only [completeNearLitterMap_coe hπf, toFun_as_coe, Perm.preimage_inv, NearLitter.coe_mk]\n      rfl\n    rw [this]\n    simp only [NearLitter.isNearLitter, completeNearLitterMap_fst_eq']\n    rfl\n", "additional_info": "Equations\n* 🗟ConNF.StructApprox.completeNearLitterPerm🗟🔗../.././ConNF/FOA/Result.html#ConNF.StructApprox.completeNearLitterPerm🔗  hπf A 🗟=🗟🔗../.././Init/Prelude.html#Eq🔗  { atomPerm := 🗟ConNF.StructApprox.completeAtomPerm🗟🔗../.././ConNF/FOA/Result.html#ConNF.StructApprox.completeAtomPerm🔗  hπf A, litterPerm := 🗟ConNF.StructApprox.completeLitterPerm🗟🔗../.././ConNF/FOA/Result.html#ConNF.StructApprox.completeLitterPerm🔗  hπf A,\n near := ⋯ }\n\n", "used_premises": [1, 402, 779, 781, 782, 61], "def_path": "ConNF/FOA/Result.lean", "pos": [29, 43], "informalization": "Function `ConNF.StructApprox.completeNearLitterPerm` takes a `β`-structural approximation `π` and a `β`-extended index `A`, and returns a `NearLitterPerm`. This `NearLitterPerm` consists of an `AtomPerm` and a `LitterPerm`, as well as a proof that the `AtomPerm` is near the `LitterPerm`."}
{"full_name": "ConNF.StructApprox.completeNearLitterPerm_smul_litter", "url": "ConNF/FOA/Result.html#ConNF.StructApprox.completeNearLitterPerm_smul_litter", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.StructApprox.completeNearLitterPerm_smul_litter [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.FOAAssumptions] {β : ConNF.Λ} [ConNF.LeLevel🔗<|PREMISE|>🔗 ↑β] [ConNF.StructApprox.FreedomOfActionHypothesis🔗<|PREMISE|>🔗 β] {π : ConNF.StructApprox🔗<|PREMISE|>🔗 ↑β} (hπf : ConNF.StructApprox.Free🔗<|PREMISE|>🔗 π) (A : ConNF.ExtendedIndex🔗<|PREMISE|>🔗 ↑β) (L : ConNF.Litter) :ConNF.StructApprox.completeNearLitterPerm🔗<|PREMISE|>🔗 hπf A • L = ConNF.StructApprox.completeLitterMap🔗<|PREMISE|>🔗 π A L", "code": "theorem completeNearLitterPerm_smul_litter (hπf : π.Free) (A : ExtendedIndex β) (L : Litter) :\n    completeNearLitterPerm hπf A • L = π.completeLitterMap A L :=\n  rfl\n", "additional_info": "", "used_premises": [1, 402, 779, 781, 782, 61, 789, 787], "def_path": "ConNF/FOA/Result.lean", "pos": [48, 51], "informalization": "In Constructive Ordinal Notation (ConNF), the theorem `ConNF.StructApprox.completeNearLitterPerm_smul_litter` asserts that the action of a `β`-structural approximation `π` on a litter `L`, when lifted to the `NearLitterPerm` level, is equivalent to the completion of the litter map for `π`, `A`, and `L`. This theorem demonstrates the consistency and commutativity of the `β`-structural approximation and its completion, ensuring that the construction of the natural numbers in ConNF is mathematically sound."}
{"full_name": "ConNF.StructApprox.completeNearLitterPerm_smul_nearLitter", "url": "ConNF/FOA/Result.html#ConNF.StructApprox.completeNearLitterPerm_smul_nearLitter", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.StructApprox.completeNearLitterPerm_smul_nearLitter [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.FOAAssumptions] {β : ConNF.Λ} [ConNF.LeLevel🔗<|PREMISE|>🔗 ↑β] [ConNF.StructApprox.FreedomOfActionHypothesis🔗<|PREMISE|>🔗 β] {π : ConNF.StructApprox🔗<|PREMISE|>🔗 ↑β} (hπf : ConNF.StructApprox.Free🔗<|PREMISE|>🔗 π) (A : ConNF.ExtendedIndex🔗<|PREMISE|>🔗 ↑β) (N : ConNF.NearLitter) :ConNF.StructApprox.completeNearLitterPerm🔗<|PREMISE|>🔗 hπf A • N = ConNF.StructApprox.completeNearLitterMap🔗<|PREMISE|>🔗 π A N", "code": "theorem completeNearLitterPerm_smul_nearLitter (hπf : π.Free) (A : ExtendedIndex β)\n    (N : NearLitter) : completeNearLitterPerm hπf A • N = π.completeNearLitterMap A N := by\n  refine' SetLike.coe_injective _\n  rw [completeNearLitterMap_coe hπf, NearLitterPerm.smul_nearLitter_coe]\n  rfl\n", "additional_info": "", "used_premises": [1, 402, 779, 781, 782, 61, 789, 792], "def_path": "ConNF/FOA/Result.lean", "pos": [52, 57], "informalization": "In the context of Constructive Ordinal Notation (ConNF), the theorem `ConNF.StructApprox.completeNearLitterPerm_smul_nearLitter` states that for any free `β`-structural approximation `π`, any `β`-extended index `A`, and any near-litter `N`, the action of the near-litter permutation `ConNF.StructApprox.completeNearLitterPerm hπf A` on `N` is equal to the near-litter map `ConNF.StructApprox.completeNearLitterMap π A N`."}
{"full_name": "ConNF.StructApprox.completeNearLitterMap", "url": "ConNF/FOA/Complete/CompleteAction.html#ConNF.StructApprox.completeNearLitterMap", "code_src": "con-nf", "ptype": "noncomputable def", "header": "noncomputable def ConNF.StructApprox.completeNearLitterMap [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.FOAAssumptions] {β : ConNF.Λ} [ConNF.LeLevel🔗<|PREMISE|>🔗 ↑β] [ConNF.StructApprox.FreedomOfActionHypothesis🔗<|PREMISE|>🔗 β] (π : ConNF.StructApprox🔗<|PREMISE|>🔗 ↑β) :ConNF.ExtendedIndex🔗<|PREMISE|>🔗 ↑β → ConNF.NearLitter → ConNF.NearLitter", "code": "noncomputable def completeNearLitterMap (π : StructApprox β) :\n    ExtendedIndex β → NearLitter → NearLitter :=\n  HypAction.fixNearLitter π.atomCompletion π.nearLitterCompletion\n", "additional_info": "Equations\n* 🗟ConNF.StructApprox.completeNearLitterMap🗟🔗../../.././ConNF/FOA/Complete/CompleteAction.html#ConNF.StructApprox.completeNearLitterMap🔗  π 🗟=🗟🔗../../.././Init/Prelude.html#Eq🔗  🗟ConNF.HypAction.fixNearLitter🗟🔗../../.././ConNF/FOA/Complete/HypAction.html#ConNF.HypAction.fixNearLitter🔗  (🗟ConNF.StructApprox.atomCompletion🗟🔗../../.././ConNF/FOA/Complete/AtomCompletion.html#ConNF.StructApprox.atomCompletion🔗  π) (🗟ConNF.StructApprox.nearLitterCompletion🗟🔗../../.././ConNF/FOA/Complete/NearLitterCompletion.html#ConNF.StructApprox.nearLitterCompletion🔗  π)\n\n", "used_premises": [1, 402, 779, 781, 61], "def_path": "ConNF/FOA/Complete/CompleteAction.lean", "pos": [26, 29], "informalization": "Function `ConNF.StructApprox.completeNearLitterMap` takes a `β`-structural approximation `π` and returns a function from `ConNF.ExtendedIndex β` to `ConNF.NearLitter` to `ConNF.NearLitter`. This function is used in the proof of freedom of action in Constructive Ordinal Notation (ConNF)."}
{"full_name": "ConNF.StructApprox.ofBot_toStructPerm", "url": "ConNF/FOA/Result.html#ConNF.StructApprox.ofBot_toStructPerm", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.StructApprox.ofBot_toStructPerm [ConNF.Params🔗<|PREMISE|>🔗 ] (π : ConNF.Allowable ⊥ ) :ConNF.Tree.ofBot (ConNF.Allowable.toStructPerm π) = π", "code": "theorem ofBot_toStructPerm (π : Allowable ⊥) : Tree.ofBot (Allowable.toStructPerm π) = π := by\n  rfl\n", "additional_info": "", "used_premises": [1], "def_path": "ConNF/FOA/Result.lean", "pos": [65, 67], "informalization": "In the context of Constructive Ordinal Notation (ConNF), the theorem `ConNF.StructApprox.ofBot_toStructPerm` states that the `ConNF.Tree.ofBot` function, when applied to the result of the `ConNF.Allowable.toStructPerm` function, returns the original `ConNF.Allowable` object."}
{"full_name": "ConNF.StructApprox.allowableBelow_bot", "url": "ConNF/FOA/Result.html#ConNF.StructApprox.allowableBelow_bot", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.StructApprox.allowableBelow_bot [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.FOAAssumptions] {β : ConNF.Λ} [ConNF.LeLevel🔗<|PREMISE|>🔗 ↑β] [ConNF.StructApprox.FreedomOfActionHypothesis🔗<|PREMISE|>🔗 β] {π : ConNF.StructApprox🔗<|PREMISE|>🔗 ↑β} (hπf : ConNF.StructApprox.Free🔗<|PREMISE|>🔗 π) (A : ConNF.ExtendedIndex🔗<|PREMISE|>🔗 ↑β) :ConNF.StructApprox.AllowableBelow🔗<|PREMISE|>🔗 hπf ⊥ A", "code": "theorem allowableBelow_bot (hπf : π.Free) (A : ExtendedIndex β) : AllowableBelow hπf ⊥ A := by\n  refine' ⟨completeNearLitterPerm hπf A, _⟩\n  intro B\n  obtain B | ⟨B, h⟩ := B\n  · rfl\n  · -- TODO: Make this a lemma.\n    cases le_bot_iff.mp (le_of_path B)\n    change (⊥ : TypeIndex) < ⊥ at h\n    simp only [lt_self_iff_false] at h\n", "additional_info": "", "used_premises": [1, 402, 779, 781, 782, 61, 795], "def_path": "ConNF/FOA/Result.lean", "pos": [68, 77], "informalization": "In the context of Constructive Ordinal Notation (ConNF), the theorem `ConNF.StructApprox.allowableBelow_bot` states that for any free `β`-structural approximation `π` and any `β`-extended index `A`, there exists an allowable permutation `ρ` such that for every `β`-extended index `B`, the complete near-litter permutation of `π` applied to `B` is equal to the composition of `B` with `ρ`."}
{"full_name": "ConNF.StructApprox.AllowableBelow", "url": "ConNF/FOA/Result.html#ConNF.StructApprox.AllowableBelow", "code_src": "con-nf", "ptype": "def", "header": "def ConNF.StructApprox.AllowableBelow [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.FOAAssumptions] {β : ConNF.Λ} [ConNF.LeLevel🔗<|PREMISE|>🔗 ↑β] [ConNF.StructApprox.FreedomOfActionHypothesis🔗<|PREMISE|>🔗 β] {π : ConNF.StructApprox🔗<|PREMISE|>🔗 ↑β} (hπf : ConNF.StructApprox.Free🔗<|PREMISE|>🔗 π) (γ : ConNF.TypeIndex) [ConNF.LeLevel🔗<|PREMISE|>🔗 γ] (A : Quiver.Path🔗<|PREMISE|>🔗 (↑β) γ) :Prop", "code": "def AllowableBelow (hπf : π.Free) (γ : TypeIndex) [LeLevel γ] (A : Path (β : TypeIndex) γ) : Prop :=\n  ∃ ρ : Allowable γ,\n    ∀ B : ExtendedIndex γ,\n      Tree.ofBot (Tree.comp B (Allowable.toStructPerm ρ)) =\n        completeNearLitterPerm hπf (A.comp B)\n", "additional_info": "Equations\n* One or more equations did not get rendered due to their size.\n\n", "used_premises": [1, 402, 779, 781, 782, 402, 76], "def_path": "ConNF/FOA/Result.lean", "pos": [58, 63], "informalization": "Function `ConNF.StructApprox.AllowableBelow` defines a condition for a `β`-structural approximation `π` to be allowable below a path `A` in the context of Constructive Ordinal Notation (ConNF). It states that there exists an allowable permutation `ρ` such that for every `β`-extended index `B`, the complete near-litter permutation of `π` applied to `B` is equal to the composition of `B` with `ρ`."}
{"full_name": "ConNF.StructApprox.exists_nil_cons_of_path'", "url": "ConNF/FOA/Result.html#ConNF.StructApprox.exists_nil_cons_of_path'", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.StructApprox.exists_nil_cons_of_path' [ConNF.Params🔗<|PREMISE|>🔗 ] {β : ConNF.TypeIndex} {γ : ConNF.TypeIndex} (A : Quiver.Path🔗<|PREMISE|>🔗 β γ) (hA : Quiver.Path.length🔗<|PREMISE|>🔗 A ≠ 0) :∃ (δ : ConNF.TypeIndex) (h : δ < β) (B : Quiver.Path🔗<|PREMISE|>🔗 δ γ), A = Quiver.Path.comp🔗<|PREMISE|>🔗 (Quiver.Path.cons🔗<|PREMISE|>🔗 Quiver.Path.nil h) B", "code": "theorem exists_nil_cons_of_path' {β γ : TypeIndex} (A : Path (β : TypeIndex) γ)\n    (hA : A.length ≠ 0) :\n    ∃ δ : TypeIndex,\n      ∃ h : (δ : TypeIndex) < β,\n        ∃ B : Path δ γ, A = ((Path.nil : Path (β : TypeIndex) β).cons h).comp B := by\n  set n := A.length with hn\n  clear_value n\n  induction' n with n ih generalizing γ\n  · cases hA rfl\n  cases' A with δ _ A hδ\n  · cases hn\n  simp only [Path.length_cons, Nat.succ_eq_add_one, add_left_inj] at hn\n  obtain _ | n := n\n  · cases Path.eq_of_length_zero A hn.symm\n    cases path_eq_nil A\n    exact ⟨γ, hδ, Path.nil, rfl⟩\n  · obtain ⟨ε, hε, B, rfl⟩ := ih A n.succ_ne_zero hn\n    exact ⟨ε, hε, B.cons hδ, rfl⟩\n", "additional_info": "", "used_premises": [1, 76, 137, 76, 135, 301], "def_path": "ConNF/FOA/Result.lean", "pos": [78, 96], "informalization": "The theorem `ConNF.StructApprox.exists_nil_cons_of_path'` states that for any non-trivial path `A` from vertex `β` to vertex `γ` in a quiver, there exists a vertex `δ` less than `β` and a path `B` from `δ` to `γ` such that `A` is the composition of a trivial path from `β` to `δ` and `B`."}
{"full_name": "ConNF.StructApprox.exists_nil_cons_of_path", "url": "ConNF/FOA/Result.html#ConNF.StructApprox.exists_nil_cons_of_path", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.StructApprox.exists_nil_cons_of_path [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] {β : ConNF.Λ} [ConNF.LeLevel🔗<|PREMISE|>🔗 ↑β] (A : ConNF.ExtendedIndex🔗<|PREMISE|>🔗 ↑β) :∃ (γ : ConNF.TypeIndex) (_ : ConNF.LtLevel🔗<|PREMISE|>🔗 γ) (h : γ < ↑β) (B : ConNF.ExtendedIndex🔗<|PREMISE|>🔗 γ), A = Quiver.Path.comp🔗<|PREMISE|>🔗 (Quiver.Path.cons🔗<|PREMISE|>🔗 Quiver.Path.nil h) B", "code": "theorem exists_nil_cons_of_path {β : Λ} [LeLevel β] (A : ExtendedIndex β) :\n    ∃ γ : TypeIndex, ∃ _ : LtLevel γ,\n      ∃ h : (γ : TypeIndex) < β,\n        ∃ B : ExtendedIndex γ, A = ((Path.nil : Path (β : TypeIndex) β).cons h).comp B := by\n  have := exists_nil_cons_of_path' A ?_\n  obtain ⟨γ, h, B, rfl⟩ := this\n  · refine' ⟨γ, _, h, B, rfl⟩\n    exact ⟨lt_of_lt_of_le h LeLevel.elim⟩\n  · intro h\n    cases Path.eq_of_length_zero A h\n", "additional_info": "", "used_premises": [1, 402, 61, 98, 61, 135, 301], "def_path": "ConNF/FOA/Result.lean", "pos": [97, 107], "informalization": "Given the `ConNF.Params` class and the `ConNF.Level` instance in the context of Constructive Ordinal Notation (ConNF), for any `β` which is less than or equal to the level `α`, and given a finite path `A` from `β` to the base type `⊥`, there exists a type index `γ` which is strictly less than `β`, and a finite path `B` from `γ` to `⊥` such that `A` can be decomposed into a single step from `β` to `γ` followed by the path `B`. This theorem is central to understanding the construction of natural numbers in the context of ConNF, as it shows how paths can be broken down into individual steps and combined to form larger paths."}
{"full_name": "ConNF.StructApprox.completeAllowable_comp", "url": "ConNF/FOA/Result.html#ConNF.StructApprox.completeAllowable_comp", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.StructApprox.completeAllowable_comp [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.FOAAssumptions] {β : ConNF.Λ} [ConNF.LeLevel🔗<|PREMISE|>🔗 ↑β] [ConNF.StructApprox.FreedomOfActionHypothesis🔗<|PREMISE|>🔗 β] {π : ConNF.StructApprox🔗<|PREMISE|>🔗 ↑β} (hπf : ConNF.StructApprox.Free🔗<|PREMISE|>🔗 π) :ConNF.Allowable.toStructPerm (ConNF.StructApprox.completeAllowable🔗<|PREMISE|>🔗 hπf) = ConNF.StructApprox.completeNearLitterPerm🔗<|PREMISE|>🔗 hπf", "code": "theorem completeAllowable_comp (hπf : π.Free) :\n    Allowable.toStructPerm (completeAllowable hπf) = completeNearLitterPerm hπf := by\n  funext A\n  have := (allowableBelow_all hπf β Path.nil).choose_spec A\n  rw [Path.nil_comp] at this\n  exact this\n", "additional_info": "", "used_premises": [1, 402, 779, 781, 782, 799, 789], "def_path": "ConNF/FOA/Result.lean", "pos": [217, 223], "informalization": "In the context of Constructive Ordinal Notation (ConNF), the theorem `ConNF.StructApprox.completeAllowable_comp` states that for any free `β`-structural approximation `π`, the `β`-allowable permutation `ConNF.Allowable.toStructPerm (ConNF.StructApprox.completeAllowable hπf)` is equal to the `β`-near-litter permutation `ConNF.StructApprox.completeNearLitterPerm hπf`."}
{"full_name": "ConNF.StructApprox.completeAllowable", "url": "ConNF/FOA/Result.html#ConNF.StructApprox.completeAllowable", "code_src": "con-nf", "ptype": "noncomputable def", "header": "noncomputable def ConNF.StructApprox.completeAllowable [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.FOAAssumptions] {β : ConNF.Λ} [ConNF.LeLevel🔗<|PREMISE|>🔗 ↑β] [ConNF.StructApprox.FreedomOfActionHypothesis🔗<|PREMISE|>🔗 β] {π : ConNF.StructApprox🔗<|PREMISE|>🔗 ↑β} (hπf : ConNF.StructApprox.Free🔗<|PREMISE|>🔗 π) :ConNF.Allowable ↑β", "code": "noncomputable def completeAllowable (hπf : π.Free) : Allowable β :=\n  (allowableBelow_all hπf β Path.nil).choose\n", "additional_info": "Equations\n* 🗟ConNF.StructApprox.completeAllowable🗟🔗../.././ConNF/FOA/Result.html#ConNF.StructApprox.completeAllowable🔗  hπf 🗟=🗟🔗../.././Init/Prelude.html#Eq🔗  🗟Exists.choose🗟🔗../.././Init/Classical.html#Exists.choose🔗  ⋯\n\n", "used_premises": [1, 402, 779, 781, 782], "def_path": "ConNF/FOA/Result.lean", "pos": [214, 216], "informalization": "Function `ConNF.StructApprox.completeAllowable` is a noncomputable definition in the context of Constructive Ordinal Notation (ConNF). It takes as input a `β`-structural approximation `π` and a proof that `π` is free, meaning that for every `β`-extended index `A`, the near-litter approximation `(π A)` is free with respect to `A`. The output is a `β`-allowable permutation, which is a product that assigns an allowable permutation to each `β`-extended index."}
{"full_name": "ConNF.StructApprox.complete_exception_mem", "url": "ConNF/FOA/Result.html#ConNF.StructApprox.complete_exception_mem", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.StructApprox.complete_exception_mem [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.FOAAssumptions] {β : ConNF.Λ} [ConNF.LeLevel🔗<|PREMISE|>🔗 ↑β] [ConNF.StructApprox.FreedomOfActionHypothesis🔗<|PREMISE|>🔗 β] {π : ConNF.StructApprox🔗<|PREMISE|>🔗 ↑β} (hπf : ConNF.StructApprox.Free🔗<|PREMISE|>🔗 π) (A : ConNF.ExtendedIndex🔗<|PREMISE|>🔗 ↑β) (a : ConNF.Atom) (ha : ConNF.NearLitterPerm.IsException🔗<|PREMISE|>🔗 (ConNF.StructApprox.completeNearLitterPerm🔗<|PREMISE|>🔗 hπf A) a) :a ∈ (π A).atomPerm.domain", "code": "theorem complete_exception_mem (hπf : π.Free) (A : ExtendedIndex β) (a : Atom)\n    (ha : (completeNearLitterPerm hπf A).IsException a) : a ∈ (π A).atomPerm.domain := by\n  unfold NearLitterPerm.IsException at ha\n  simp only [mem_litterSet, completeNearLitterPerm_smul_atom,\n    completeNearLitterPerm_smul_litter] at ha\n  obtain ha | ha := ha\n  · have := completeNearLitterMap_toNearLitter_eq (π := π) A a.1\n    rw [completeNearLitterMap_coe hπf, Set.ext_iff] at this\n    have := (this (π.completeAtomMap A a)).mp ⟨_, rfl, rfl⟩\n    obtain ha' | ⟨b, ⟨hb₁, hb₂⟩, hb₃⟩ := this\n    · cases ha ha'.1\n    dsimp only at hb₃\n    rw [← completeAtomMap_eq_of_mem_domain hb₂] at hb₃\n    cases completeAtomMap_injective hπf A hb₃\n    exact hb₂\n  · obtain ⟨a, rfl⟩ := completeAtomMap_surjective hπf A a\n    rw [eq_inv_smul_iff, ← completeNearLitterPerm_smul_atom hπf, inv_smul_smul] at ha\n    have := completeNearLitterMap_toNearLitter_eq (π := π) A a.1\n    rw [completeNearLitterMap_coe hπf, Set.ext_iff] at this\n    have := (this (π.completeAtomMap A a)).mp ⟨_, rfl, rfl⟩\n    obtain ha' | ⟨b, ⟨hb₁, hb₂⟩, hb₃⟩ := this\n    · cases ha ha'.1.symm\n    · dsimp only at hb₃\n      rw [← completeAtomMap_eq_of_mem_domain hb₂] at hb₃\n      cases completeAtomMap_injective hπf A hb₃\n      rw [completeAtomMap_eq_of_mem_domain hb₂]\n      exact (π A).atomPerm.map_domain hb₂\n", "additional_info": "", "used_premises": [1, 402, 779, 781, 782, 61, 801, 789], "def_path": "ConNF/FOA/Result.lean", "pos": [224, 251], "informalization": "The theorem `ConNF.StructApprox.complete_exception_mem` states that if `π` is a free `β`-structural approximation, `A` is a `β`-extended index, and `a` is an atom such that the near litter permutation `ConNF.StructApprox.completeNearLitterPerm hπf A` is an exception with respect to `a`, then `a` is a member of the domain of the atom permutation of `π A`."}
{"full_name": "ConNF.NearLitterPerm.IsException", "url": "ConNF/FOA/Approximation/NearLitterApprox.html#ConNF.NearLitterPerm.IsException", "code_src": "con-nf", "ptype": "def", "header": "def ConNF.NearLitterPerm.IsException [ConNF.Params🔗<|PREMISE|>🔗 ] (π : ConNF.NearLitterPerm) (a : ConNF.Atom) :Prop", "code": "def ConNF.NearLitterPerm.IsException (π : NearLitterPerm) (a : Atom) : Prop :=\n  π • a ∉ litterSet (π • a.1) ∨ π⁻¹ • a ∉ litterSet (π⁻¹ • a.1)\n", "additional_info": "Equations\n* 🗟ConNF.NearLitterPerm.IsException🗟🔗../../.././ConNF/FOA/Approximation/NearLitterApprox.html#ConNF.NearLitterPerm.IsException🔗  π a 🗟=🗟🔗../../.././Init/Prelude.html#Eq🔗  (π 🗟•🗟🔗../../.././Mathlib/Algebra/Group/Defs.html#HSMul.hSMul🔗  a ∉ 🗟ConNF.litterSet🗟🔗../../.././ConNF/BaseType/Atom.html#ConNF.litterSet🔗  (π 🗟•🗟🔗../../.././Mathlib/Algebra/Group/Defs.html#HSMul.hSMul🔗  a.1) 🗟∨🗟🔗../../.././Init/Prelude.html#Or🔗  π🗟⁻¹🗟🔗../../.././Mathlib/Algebra/Group/Defs.html#Inv.inv🔗  🗟•🗟🔗../../.././Mathlib/Algebra/Group/Defs.html#HSMul.hSMul🔗  a ∉ 🗟ConNF.litterSet🗟🔗../../.././ConNF/BaseType/Atom.html#ConNF.litterSet🔗  (π🗟⁻¹🗟🔗../../.././Mathlib/Algebra/Group/Defs.html#Inv.inv🔗  🗟•🗟🔗../../.././Mathlib/Algebra/Group/Defs.html#HSMul.hSMul🔗  a.1))\n\n", "used_premises": [1], "def_path": "ConNF/FOA/Approximation/NearLitterApprox.lean", "pos": [152, 154], "informalization": "Function `ConNF.NearLitterPerm.IsException` checks if a near litter permutation `π` is an exception with respect to an atom `a`. An exception occurs when either `π • a` or `π⁻¹ • a` is not in the corresponding litter set."}
{"full_name": "ConNF.StructApprox.completeAllowable_exactlyApproximates", "url": "ConNF/FOA/Result.html#ConNF.StructApprox.completeAllowable_exactlyApproximates", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.StructApprox.completeAllowable_exactlyApproximates [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.FOAAssumptions] {β : ConNF.Λ} [ConNF.LeLevel🔗<|PREMISE|>🔗 ↑β] [ConNF.StructApprox.FreedomOfActionHypothesis🔗<|PREMISE|>🔗 β] {π : ConNF.StructApprox🔗<|PREMISE|>🔗 ↑β} (hπf : ConNF.StructApprox.Free🔗<|PREMISE|>🔗 π) :ConNF.StructApprox.ExactlyApproximates🔗<|PREMISE|>🔗 π (ConNF.Allowable.toStructPerm (ConNF.StructApprox.completeAllowable🔗<|PREMISE|>🔗 hπf))", "code": "theorem completeAllowable_exactlyApproximates (hπf : π.Free) :\n    π.ExactlyApproximates (Allowable.toStructPerm <| completeAllowable hπf) := by\n  intro A\n  refine' ⟨⟨_, _⟩, _⟩\n  · intro a ha\n    rw [completeAllowable_comp, completeNearLitterPerm_smul_atom,\n      completeAtomMap_eq_of_mem_domain ha]\n  · intro L hL\n    rw [completeAllowable_comp, completeNearLitterPerm_smul_litter,\n      completeLitterMap_eq_of_flexible (hπf A L hL),\n      NearLitterApprox.flexibleCompletion_smul_of_mem_domain _ A L hL]\n    rfl\n  · intro a ha\n    rw [completeAllowable_comp] at ha\n    exact complete_exception_mem hπf A a ha\n", "additional_info": "", "used_premises": [1, 402, 779, 781, 782, 803, 799], "def_path": "ConNF/FOA/Result.lean", "pos": [252, 267], "informalization": "The theorem `ConNF.StructApprox.completeAllowable_exactlyApproximates` states that for any free `β`-structural approximation `π`, the `β`-allowable permutation `ConNF.Allowable.toStructPerm (ConNF.StructApprox.completeAllowable hπf)` exactly approximates `π`."}
{"full_name": "ConNF.StructApprox.ExactlyApproximates", "url": "ConNF/FOA/Approximation/StructApprox.html#ConNF.StructApprox.ExactlyApproximates", "code_src": "con-nf", "ptype": "def", "header": "def ConNF.StructApprox.ExactlyApproximates [ConNF.Params🔗<|PREMISE|>🔗 ] {β : ConNF.TypeIndex} (π₀ : ConNF.StructApprox🔗<|PREMISE|>🔗 β) (π : ConNF.StructPerm🔗<|PREMISE|>🔗 β) :Prop", "code": "def ExactlyApproximates {β : TypeIndex} (π₀ : StructApprox β) (π : StructPerm β) : Prop :=\n  ∀ A, (π₀ A).ExactlyApproximates (π A)\n", "additional_info": "Equations\n* 🗟ConNF.StructApprox.ExactlyApproximates🗟🔗../../.././ConNF/FOA/Approximation/StructApprox.html#ConNF.StructApprox.ExactlyApproximates🔗  π₀ π 🗟=🗟🔗../../.././Init/Prelude.html#Eq🔗  ∀ (A : 🗟ConNF.ExtendedIndex🗟🔗../../.././ConNF/Structural/Index.html#ConNF.ExtendedIndex🔗  β), 🗟ConNF.NearLitterApprox.ExactlyApproximates🗟🔗../../.././ConNF/FOA/Approximation/NearLitterApprox.html#ConNF.NearLitterApprox.ExactlyApproximates🔗  (π₀ A) (π A)\n\n", "used_premises": [1, 781, 55], "def_path": "ConNF/FOA/Approximation/StructApprox.lean", "pos": [26, 28], "informalization": "Function `ConNF.StructApprox.ExactlyApproximates` checks if a `β`-structural approximation `π₀` exactly approximates a `β`-structural permutation `π`, meaning that for every `β`-extended index `A`, the near-litter approximation `π₀ A` exactly approximates the near-litter permutation `π A`."}
{"full_name": "ConNF.StructApprox.freedom_of_action", "url": "ConNF/FOA/Result.html#ConNF.StructApprox.freedom_of_action", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.StructApprox.freedom_of_action [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.FOAAssumptions] {β : ConNF.Λ} [i : ConNF.LeLevel🔗<|PREMISE|>🔗 ↑β] (π₀ : ConNF.StructApprox🔗<|PREMISE|>🔗 ↑β) (h : ConNF.StructApprox.Free🔗<|PREMISE|>🔗 π₀) :∃ (π : ConNF.Allowable ↑β), ConNF.StructApprox.ExactlyApproximates🔗<|PREMISE|>🔗 π₀ (ConNF.Allowable.toStructPerm π)", "code": "theorem freedom_of_action {β : Λ} [i : LeLevel β] (π₀ : StructApprox β) (h : π₀.Free) :\n    ∃ π : Allowable β, π₀.ExactlyApproximates (Allowable.toStructPerm π) := by\n  revert i\n  have := WellFounded.induction\n    (C := fun β => ∀ (i : LeLevel β) (π₀ : StructApprox β),\n      Free π₀ → ∃ π : Allowable β,\n        ExactlyApproximates π₀ (@Allowable.toStructPerm _ _ FOAData.tangleData π))\n    (inferInstanceAs (IsWellFounded Λ (· < ·))).wf β\n  refine fun i => this ?_ i π₀ h\n  intro β ih _ π₀ h\n  have : FreedomOfActionHypothesis β\n  · constructor\n    intro γ hγ\n    exact ih γ hγ inferInstance\n  exact foa_extends π₀ h\n", "additional_info": "", "used_premises": [1, 402, 781, 782, 803], "def_path": "ConNF/FOA/Result.lean", "pos": [271, 286], "informalization": "Given a `β`-structural approximation `π₀` that is free, there exists a `β`-structural permutation `π` such that `π₀` exactly approximates `π`."}
{"full_name": "ConNF.NearLitterAction.approximates_iff", "url": "ConNF/FOA/Corollaries.html#ConNF.NearLitterAction.approximates_iff", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterAction.approximates_iff [ConNF.Params🔗<|PREMISE|>🔗 ] (ψ : ConNF.NearLitterAction) (π : ConNF.NearLitterPerm) :ConNF.NearLitterAction.Approximates🔗<|PREMISE|>🔗 ψ π ↔ (∀ (a : ConNF.Atom) (h : (ψ.atomMap a).Dom), π • a = (ψ.atomMap a).get h) ∧ ∀ (L : ConNF.Litter) (h : (ψ.litterMap L).Dom), π • ConNF.Litter.toNearLitter🔗<|PREMISE|>🔗 L = (ψ.litterMap L).get h", "code": "@[mk_iff]\n", "additional_info": "", "used_premises": [1, 806, 483], "def_path": "ConNF/FOA/Corollaries.lean", "pos": [16, 17], "informalization": "The theorem `ConNF.NearLitterAction.approximates_iff` states that a near-litter action `ψ` approximates a near-litter permutation `π` if and only if the action of `π` on atoms and litters is consistent with the mapping provided by `ψ`."}
{"full_name": "ConNF.NearLitterAction.Approximates", "url": "ConNF/FOA/Corollaries.html#ConNF.NearLitterAction.Approximates", "code_src": "con-nf", "ptype": "structure", "header": "structure ConNF.NearLitterAction.Approximates [ConNF.Params🔗<|PREMISE|>🔗 ] (ψ : ConNF.NearLitterAction) (π : ConNF.NearLitterPerm) :Prop\n | map_atom : ∀ (a : ConNF.Atom) (h : (ψ.atomMap a).Dom), π •  a =  (ψ.atomMap a).get h\n | map_litter : ∀ (L : ConNF.Litter) (h : (ψ.litterMap L).Dom), π •  ConNF.Litter.toNearLitter🔗<|PREMISE|>🔗  L =  (ψ.litterMap L).get h", "code": "structure NearLitterAction.Approximates (ψ : NearLitterAction) (π : NearLitterPerm) : Prop where\n  map_atom : ∀ a (h : (ψ.atomMap a).Dom), π • a = (ψ.atomMap a).get h\n  map_litter : ∀ L (h : (ψ.litterMap L).Dom), π • L.toNearLitter = (ψ.litterMap L).get h\n", "additional_info": "", "used_premises": [1, 483], "def_path": "ConNF/FOA/Corollaries.lean", "pos": [17, 20], "informalization": "Structure `ConNF.NearLitterAction.Approximates` represents a property of a near-litter action in the context of Constructive Ordinal Notation (ConNF). Given a near-litter action `ψ` and a near-litter permutation `π`, this structure ensures that the action of `π` on atoms and litters is consistent with the mapping provided by `ψ`."}
{"full_name": "ConNF.StructAction.foaMotive_atom", "url": "ConNF/FOA/Corollaries.html#ConNF.StructAction.foaMotive_atom", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.StructAction.foaMotive_atom [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.FOAAssumptions] {β : ConNF.Λ} [ConNF.LeLevel🔗<|PREMISE|>🔗 ↑β] (ψ : ConNF.StructAction🔗<|PREMISE|>🔗 ↑β) (h₁ : ConNF.StructAction.Lawful🔗<|PREMISE|>🔗 ψ) (ρ : ConNF.Allowable ↑β) (hρ : ConNF.StructApprox.ExactlyApproximates🔗<|PREMISE|>🔗 (ConNF.StructAction.rc🔗<|PREMISE|>🔗 ψ h₁) (ConNF.Allowable.toStructPerm ρ)) (A : ConNF.ExtendedIndex🔗<|PREMISE|>🔗 ↑β) (a : ConNF.Atom) (ha : ((ψ A).atomMap a).Dom) :ConNF.Allowable.toStructPerm ρ A • a = ((ψ A).atomMap a).get ha", "code": "theorem foaMotive_atom (ψ : StructAction β) (h₁ : ψ.Lawful)\n    (ρ : Allowable β) (hρ : (ψ.rc h₁).ExactlyApproximates (Allowable.toStructPerm ρ))\n    (A : ExtendedIndex β) (a : Atom)\n    (ha : ((ψ A).atomMap a).Dom) :\n    Allowable.toStructPerm ρ A • a = ((ψ A).atomMap a).get ha := by\n  have := (hρ A).map_atom a ?_\n  · rw [← this, rc_smul_atom_eq]\n  · exact Or.inl (Or.inl (Or.inl (Or.inl ha)))\n", "additional_info": "", "used_premises": [1, 402, 808, 809, 803, 810, 61], "def_path": "ConNF/FOA/Corollaries.lean", "pos": [87, 95], "informalization": "This theorem is a part of the Constructive Ordinal Notation (ConNF) project. It is used to prove that for any β-structural action ψ that is lawful, a β-structural approximation derived from ψ exactly approximates a β-structural permutation ρ if and only if for every β-extended index A, the near-litter approximation derived from ψ exactly approximates the near-litter permutation derived from ρ. A key step in this proof involves showing that for any atom a that is in the domain of the atom map of ψ at A, the application of ρ at A to a is equal to the value of the atom map of ψ at A at a."}
{"full_name": "ConNF.StructAction", "url": "ConNF/FOA/Action/StructAction.html#ConNF.StructAction", "code_src": "con-nf", "ptype": "abbrev", "header": "@[inline, reducible]abbrev ConNF.StructAction [ConNF.Params🔗<|PREMISE|>🔗 ] (α : ConNF.TypeIndex) :Type u", "code": "abbrev StructAction :=\n  Tree NearLitterAction\n", "additional_info": "A `β`-structural action is a product that assigns a near-litter action to each `β`-extended\nindex.\nEquations\n* ConNF.StructAction 🗟=🗟🔗../../.././Init/Prelude.html#Eq🔗  🗟ConNF.Tree🗟🔗../../.././ConNF/Structural/Tree.html#ConNF.Tree🔗  ConNF.NearLitterAction\n\n", "used_premises": [1], "def_path": "ConNF/FOA/Action/StructAction.lean", "pos": [20, 22], "informalization": "Function `ConNF.StructAction` defines a `β`-structural action as a product that assigns a near-litter action to each `β`-extended index."}
{"full_name": "ConNF.StructAction.Lawful", "url": "ConNF/FOA/Action/StructAction.html#ConNF.StructAction.Lawful", "code_src": "con-nf", "ptype": "def", "header": "def ConNF.StructAction.Lawful [ConNF.Params🔗<|PREMISE|>🔗 ] {β : ConNF.TypeIndex} (φ : ConNF.StructAction🔗<|PREMISE|>🔗 β) :Prop", "code": "def Lawful {β : TypeIndex} (φ : StructAction β) : Prop :=\n  ∀ B, (φ B).Lawful\n", "additional_info": "Equations\n* 🗟ConNF.StructAction.Lawful🗟🔗../../.././ConNF/FOA/Action/StructAction.html#ConNF.StructAction.Lawful🔗  φ 🗟=🗟🔗../../.././Init/Prelude.html#Eq🔗  ∀ (B : 🗟ConNF.ExtendedIndex🗟🔗../../.././ConNF/Structural/Index.html#ConNF.ExtendedIndex🔗  β), 🗟ConNF.NearLitterAction.Lawful🗟🔗../../.././ConNF/FOA/Action/NearLitterAction.html#ConNF.NearLitterAction.Lawful🔗  (φ B)\n\n", "used_premises": [1, 808], "def_path": "ConNF/FOA/Action/StructAction.lean", "pos": [25, 27], "informalization": "Function `ConNF.StructAction.Lawful` checks if a `β`-structural action `φ` satisfies the lawfulness condition for each `β`-extended index."}
{"full_name": "ConNF.StructAction.rc", "url": "ConNF/FOA/Action/Refine.html#ConNF.StructAction.rc", "code_src": "con-nf", "ptype": "noncomputable def", "header": "noncomputable def ConNF.StructAction.rc [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.FOAAssumptions] {β : ConNF.Λ} (φ : ConNF.StructAction🔗<|PREMISE|>🔗 ↑β) (h : ConNF.StructAction.Lawful🔗<|PREMISE|>🔗 φ) :ConNF.StructApprox🔗<|PREMISE|>🔗 ↑β", "code": "noncomputable def rc (φ : StructAction β) (h : φ.Lawful) : StructApprox β :=\n  (φ.refine h).complete refine_lawful\n", "additional_info": "Refine and complete this action into a structural approximation.\nEquations\n* 🗟ConNF.StructAction.rc🗟🔗../../.././ConNF/FOA/Action/Refine.html#ConNF.StructAction.rc🔗  φ h 🗟=🗟🔗../../.././Init/Prelude.html#Eq🔗  🗟ConNF.StructAction.complete🗟🔗../../.././ConNF/FOA/Action/StructAction.html#ConNF.StructAction.complete🔗  (🗟ConNF.StructAction.refine🗟🔗../../.././ConNF/FOA/Action/Refine.html#ConNF.StructAction.refine🔗  φ h) ⋯\n\n", "used_premises": [1, 808, 809, 781], "def_path": "ConNF/FOA/Action/Refine.lean", "pos": [92, 94], "informalization": "Function `ConNF.StructAction.rc` refines and completes a `β`-structural action into a `β`-structural approximation in the context of Constructive Ordinal Notation (ConNF)."}
{"full_name": "ConNF.StructAction.foaMotive_litter", "url": "ConNF/FOA/Corollaries.html#ConNF.StructAction.foaMotive_litter", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.StructAction.foaMotive_litter [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.FOAAssumptions] {β : ConNF.Λ} [ConNF.LeLevel🔗<|PREMISE|>🔗 ↑β] (ψ : ConNF.StructAction🔗<|PREMISE|>🔗 ↑β) (h₁ : ConNF.StructAction.Lawful🔗<|PREMISE|>🔗 ψ) (h₂ : ConNF.StructAction.Coherent🔗<|PREMISE|>🔗 ψ) (ρ : ConNF.Allowable ↑β) (hρ : ConNF.StructApprox.ExactlyApproximates🔗<|PREMISE|>🔗 (ConNF.StructAction.rc🔗<|PREMISE|>🔗 ψ h₁) (ConNF.Allowable.toStructPerm ρ)) (A : ConNF.ExtendedIndex🔗<|PREMISE|>🔗 ↑β) (L : ConNF.Litter) (ih : ∀ c < { path := A, value := Sum.inr🔗<|PREMISE|>🔗 (ConNF.Litter.toNearLitter🔗<|PREMISE|>🔗 L) }, ConNF.StructAction.FOAMotive🔗<|PREMISE|>🔗 ψ ρ c) (hL : ((ψ A).litterMap L).Dom) :ConNF.Allowable.toStructPerm ρ A • L = (((ψ A).litterMap L).get hL).fst", "code": "theorem foaMotive_litter (ψ : StructAction β) (h₁ : ψ.Lawful) (h₂ : ψ.Coherent)\n    (ρ : Allowable β) (hρ : (ψ.rc h₁).ExactlyApproximates (Allowable.toStructPerm ρ))\n    (A : ExtendedIndex β) (L : Litter)\n    (ih : ∀ (c : Address β), c < ⟨A, inr L.toNearLitter⟩ → FOAMotive ψ ρ c)\n    (hL : ((ψ A).litterMap L).Dom) :\n    Allowable.toStructPerm ρ A • L = (((ψ A).litterMap L).get hL).fst := by\n  obtain (hL' | ⟨⟨⟨γ, ε, hε, A, rfl⟩, a, rfl⟩⟩ |\n      ⟨⟨⟨γ, δ, ε, hδ, hε, hδε, A, rfl⟩, t, rfl⟩⟩) := flexible_cases' A L\n  · rw [← (hρ A).map_litter L (Or.inl (Or.inl ⟨hL, hL'⟩)), rc_smul_litter_eq,\n      NearLitterAction.flexibleLitterPartialPerm_apply_eq _ (by exact hL) hL',\n      NearLitterAction.roughLitterMapOrElse,\n      NearLitterAction.litterMapOrElse_of_dom]\n    rfl\n  · have := h₂.coherent_bot A hε hL (Allowable.comp A ρ) ?_\n    · rw [this]\n      simp only [Allowable.comp_comp_apply, Hom.comp_toPath, ofBot_smul,\n        Allowable.toStructPerm_apply]\n      rw [toStructPerm_smul_fuzz, comp_bot_smul_atom]\n    · have := ih ⟨A.cons (bot_lt_coe _), inl a⟩\n        (Relation.TransGen.single (Constrains.fuzz_bot hε A a))\n        (h₂.atom_bot_dom A hε hL)\n      simp only [Allowable.toStructPerm_comp, Tree.comp_apply, Hom.comp_toPath]\n      exact this.symm\n  · have := h₂.coherent_coe A hδ hε hδε hL (Allowable.comp A ρ) ?_ ?_ ?_\n    · rw [this, Allowable.comp_comp_apply, Hom.comp_toPath, toStructPerm_smul_fuzz]\n    · intro B a ha\n      have := ih ⟨(A.cons hδ).comp B, inl a⟩\n        (Relation.TransGen.single (Constrains.fuzz hδ hε hδε A t _ ha))\n        (h₂.atom_dom A hδ hε hδε ha hL)\n      simp only [Allowable.toStructPerm_comp, Tree.comp_apply, Hom.comp_toPath_comp]\n      exact this.symm\n    · intro B N hN\n      have := ih ⟨(A.cons hδ).comp B, inr N.1.toNearLitter⟩\n        (lt_nearLitter' (Relation.TransGen.single (Constrains.fuzz hδ hε hδε A t _ hN)))\n        (NearLitter.IsLitter.mk _) (h₂.nearLitter_dom A hδ hε hδε (N := N) hN hL)\n      simp only [Allowable.toStructPerm_comp, Tree.comp_apply, Hom.comp_toPath_comp]\n      exact this.symm\n    · intro B N a hN ha\n      have := ih ⟨(A.cons hδ).comp B, inl a⟩\n        ((Relation.TransGen.single (Constrains.symmDiff _ N a ha)).tail\n          (Constrains.fuzz hδ hε hδε A t _ hN))\n        (h₂.symmDiff_dom A hδ hε hδε hN ha hL)\n      simp only [Allowable.toStructPerm_comp, Tree.comp_apply, Hom.comp_toPath_comp]\n      exact this.symm\n", "additional_info": "", "used_premises": [1, 402, 808, 809, 812, 803, 810, 61, 65, 483, 816], "def_path": "ConNF/FOA/Corollaries.lean", "pos": [96, 140], "informalization": "In the context of Constructive Ordinal Notation (ConNF), given a `β`-structural action `ψ` that is lawful and coherent, an allowable `ρ`, and a `β`-extended index `A`, a litter `L`, and a proof `hL` that `L` is in the domain of the litter map of `ψ` applied to `A`, if `L` is a flexible litter, then `((ψ A).litterMap L).get hL` is also a flexible litter. Additionally, it provides conditions for the domains of the `atomMap` and `litterMap` functions of `ψ`, ensuring that these functions are defined for all necessary inputs."}
{"full_name": "ConNF.StructAction.Coherent", "url": "ConNF/FOA/Corollaries.html#ConNF.StructAction.Coherent", "code_src": "con-nf", "ptype": "structure", "header": "structure ConNF.StructAction.Coherent [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.FOAAssumptions] {β : ConNF.Λ} (ψ : ConNF.StructAction🔗<|PREMISE|>🔗 ↑β) extends ConNF.StructAction.CoherentDom🔗<|PREMISE|>🔗 :Prop\n | mapFlexible : ConNF.StructAction.MapFlexible🔗<|PREMISE|>🔗  ψ\n | atom_bot_dom : ∀ {γ : ConNF.Λ} [inst : ConNF.LeLevel🔗<|PREMISE|>🔗  ↑γ] (A : Quiver.Path🔗<|PREMISE|>🔗  ↑β ↑γ) {ε : ConNF.Λ} [inst : ConNF.LtLevel🔗<|PREMISE|>🔗  ↑ε] (hε : ↑ε <  ↑γ)\n {a : ConNF.Atom},\n ((ψ (Quiver.Path.cons🔗<|PREMISE|>🔗  (Quiver.Path.cons🔗<|PREMISE|>🔗  A hε) ⋯)).litterMap (ConNF.fuzz🔗<|PREMISE|>🔗  ⋯ a)).Dom →\n ((ψ (Quiver.Path.cons🔗<|PREMISE|>🔗  A ⋯)).atomMap a).Dom\n | atom_dom : ∀ {γ : ConNF.Λ} [inst : ConNF.LeLevel🔗<|PREMISE|>🔗  ↑γ] (A : Quiver.Path🔗<|PREMISE|>🔗  ↑β ↑γ) {δ : ConNF.Λ} [inst : ConNF.LtLevel🔗<|PREMISE|>🔗  ↑δ] {ε : ConNF.Λ}\n [inst_1 : ConNF.LtLevel🔗<|PREMISE|>🔗  ↑ε] (hδ : ↑δ <  ↑γ) (hε : ↑ε <  ↑γ) (hδε : ↑δ ≠  ↑ε) {t : ConNF.Tangle  ↑δ}\n {B : ConNF.ExtendedIndex🔗<|PREMISE|>🔗  ↑δ} {a : ConNF.Atom},\n { path := B, value := Sum.inl🔗<|PREMISE|>🔗  a } ∈  ConNF.TangleData.Tangle.support🔗<|PREMISE|>🔗  t →\n ((ψ (Quiver.Path.cons🔗<|PREMISE|>🔗  (Quiver.Path.cons🔗<|PREMISE|>🔗  A hε) ⋯)).litterMap (ConNF.fuzz🔗<|PREMISE|>🔗  hδε t)).Dom →\n ((ψ (Quiver.Path.comp🔗<|PREMISE|>🔗  (Quiver.Path.cons🔗<|PREMISE|>🔗  A hδ) B)).atomMap a).Dom\n | nearLitter_dom : ∀ {γ : ConNF.Λ} [inst : ConNF.LeLevel🔗<|PREMISE|>🔗  ↑γ] (A : Quiver.Path🔗<|PREMISE|>🔗  ↑β ↑γ) {δ : ConNF.Λ} [inst : ConNF.LtLevel🔗<|PREMISE|>🔗  ↑δ] {ε : ConNF.Λ}\n [inst_1 : ConNF.LtLevel🔗<|PREMISE|>🔗  ↑ε] (hδ : ↑δ <  ↑γ) (hε : ↑ε <  ↑γ) (hδε : ↑δ ≠  ↑ε) {t : ConNF.Tangle  ↑δ}\n {B : ConNF.ExtendedIndex🔗<|PREMISE|>🔗  ↑δ} {N : ConNF.NearLitter},\n { path := B, value := Sum.inr🔗<|PREMISE|>🔗  N } ∈  ConNF.TangleData.Tangle.support🔗<|PREMISE|>🔗  t →\n ((ψ (Quiver.Path.cons🔗<|PREMISE|>🔗  (Quiver.Path.cons🔗<|PREMISE|>🔗  A hε) ⋯)).litterMap (ConNF.fuzz🔗<|PREMISE|>🔗  hδε t)).Dom →\n ((ψ (Quiver.Path.comp🔗<|PREMISE|>🔗  (Quiver.Path.cons🔗<|PREMISE|>🔗  A hδ) B)).litterMap N.fst).Dom\n | symmDiff_dom : ∀ {γ : ConNF.Λ} [inst : ConNF.LeLevel🔗<|PREMISE|>🔗  ↑γ] (A : Quiver.Path🔗<|PREMISE|>🔗  ↑β ↑γ) {δ : ConNF.Λ} [inst : ConNF.LtLevel🔗<|PREMISE|>🔗  ↑δ] {ε : ConNF.Λ}\n [inst_1 : ConNF.LtLevel🔗<|PREMISE|>🔗  ↑ε] (hδ : ↑δ <  ↑γ) (hε : ↑ε <  ↑γ) (hδε : ↑δ ≠  ↑ε) {t : ConNF.Tangle  ↑δ}\n {B : ConNF.ExtendedIndex🔗<|PREMISE|>🔗  ↑δ} {N : ConNF.NearLitter} {a : ConNF.Atom},\n { path := B, value := Sum.inr🔗<|PREMISE|>🔗  N } ∈  ConNF.TangleData.Tangle.support🔗<|PREMISE|>🔗  t →\n a ∈  symmDiff🔗<|PREMISE|>🔗  (ConNF.litterSet🔗<|PREMISE|>🔗  N.fst) ↑N →\n ((ψ (Quiver.Path.cons🔗<|PREMISE|>🔗  (Quiver.Path.cons🔗<|PREMISE|>🔗  A hε) ⋯)).litterMap (ConNF.fuzz🔗<|PREMISE|>🔗  hδε t)).Dom →\n ((ψ (Quiver.Path.comp🔗<|PREMISE|>🔗  (Quiver.Path.cons🔗<|PREMISE|>🔗  A hδ) B)).atomMap a).Dom\n | coherent_coe : ∀ {γ : ConNF.Λ} [inst : ConNF.LeLevel🔗<|PREMISE|>🔗  ↑γ] (A : Quiver.Path🔗<|PREMISE|>🔗  ↑β ↑γ) {δ : ConNF.Λ} [inst_1 : ConNF.LtLevel🔗<|PREMISE|>🔗  ↑δ]\n {ε : ConNF.Λ} [inst_2 : ConNF.LtLevel🔗<|PREMISE|>🔗  ↑ε] (hδ : ↑δ <  ↑γ) (hε : ↑ε <  ↑γ) (hδε : ↑δ ≠  ↑ε) {t : ConNF.Tangle  ↑δ}\n (h : ((ψ (Quiver.Path.cons🔗<|PREMISE|>🔗  (Quiver.Path.cons🔗<|PREMISE|>🔗  A hε) ⋯)).litterMap (ConNF.fuzz🔗<|PREMISE|>🔗  hδε t)).Dom) (ρ : ConNF.Allowable  ↑γ),\n (∀ (B : ConNF.ExtendedIndex🔗<|PREMISE|>🔗  ↑δ) (a : ConNF.Atom)\n (ha : { path := B, value := Sum.inl🔗<|PREMISE|>🔗  a } ∈  ConNF.TangleData.Tangle.support🔗<|PREMISE|>🔗  t),\n ((ψ (Quiver.Path.comp🔗<|PREMISE|>🔗  (Quiver.Path.cons🔗<|PREMISE|>🔗  A hδ) B)).atomMap a).get ⋯ =  ConNF.Allowable.toStructPerm ρ (Quiver.Path.comp🔗<|PREMISE|>🔗  (Quiver.Hom.toPath🔗<|PREMISE|>🔗  hδ) B) •  a) →\n (∀ (B : ConNF.ExtendedIndex🔗<|PREMISE|>🔗  ↑δ) (N : ConNF.NearLitter)\n (ha : { path := B, value := Sum.inr🔗<|PREMISE|>🔗  N } ∈  ConNF.TangleData.Tangle.support🔗<|PREMISE|>🔗  t),\n ((ψ (Quiver.Path.comp🔗<|PREMISE|>🔗  (Quiver.Path.cons🔗<|PREMISE|>🔗  A hδ) B)).litterMap N.fst).get ⋯ =  ConNF.Allowable.toStructPerm ρ (Quiver.Path.comp🔗<|PREMISE|>🔗  (Quiver.Hom.toPath🔗<|PREMISE|>🔗  hδ) B) •  ConNF.Litter.toNearLitter🔗<|PREMISE|>🔗  N.fst) →\n (∀ (B : ConNF.ExtendedIndex🔗<|PREMISE|>🔗  ↑δ) (N : ConNF.NearLitter) (a : ConNF.Atom)\n (hN : { path := B, value := Sum.inr🔗<|PREMISE|>🔗  N } ∈  ConNF.TangleData.Tangle.support🔗<|PREMISE|>🔗  t)\n (ha : a ∈  symmDiff🔗<|PREMISE|>🔗  (ConNF.litterSet🔗<|PREMISE|>🔗  N.fst) ↑N),\n ((ψ (Quiver.Path.comp🔗<|PREMISE|>🔗  (Quiver.Path.cons🔗<|PREMISE|>🔗  A hδ) B)).atomMap a).get ⋯ =  ConNF.Allowable.toStructPerm ρ (Quiver.Path.comp🔗<|PREMISE|>🔗  (Quiver.Hom.toPath🔗<|PREMISE|>🔗  hδ) B) •  a) →\n (((ψ (Quiver.Path.cons🔗<|PREMISE|>🔗  (Quiver.Path.cons🔗<|PREMISE|>🔗  A hε) ⋯)).litterMap (ConNF.fuzz🔗<|PREMISE|>🔗  hδε t)).get h).fst =  ConNF.fuzz🔗<|PREMISE|>🔗  hδε ((ConNF.Allowable.comp🔗<|PREMISE|>🔗  (Quiver.Hom.toPath🔗<|PREMISE|>🔗  hδ)) ρ •  t)\n | coherent_bot : ∀ {γ : ConNF.Λ} [inst : ConNF.LeLevel🔗<|PREMISE|>🔗  ↑γ] (A : Quiver.Path🔗<|PREMISE|>🔗  ↑β ↑γ) {ε : ConNF.Λ} [inst_1 : ConNF.LtLevel🔗<|PREMISE|>🔗  ↑ε]\n (hε : ↑ε <  ↑γ) {a : ConNF.Atom}\n (h : ((ψ (Quiver.Path.cons🔗<|PREMISE|>🔗  (Quiver.Path.cons🔗<|PREMISE|>🔗  A hε) ⋯)).litterMap (ConNF.fuzz🔗<|PREMISE|>🔗  ⋯ a)).Dom) (ρ : ConNF.Allowable  ↑γ),\n ((ψ (Quiver.Path.cons🔗<|PREMISE|>🔗  A ⋯)).atomMap a).get ⋯ =  ConNF.Allowable.toStructPerm ρ (Quiver.Hom.toPath🔗<|PREMISE|>🔗  ⋯) •  a →\n (((ψ (Quiver.Path.cons🔗<|PREMISE|>🔗  (Quiver.Path.cons🔗<|PREMISE|>🔗  A hε) ⋯)).litterMap (ConNF.fuzz🔗<|PREMISE|>🔗  ⋯ a)).get h).fst =  ConNF.fuzz🔗<|PREMISE|>🔗  ⋯ ((ConNF.Allowable.comp🔗<|PREMISE|>🔗  (Quiver.Hom.toPath🔗<|PREMISE|>🔗  ⋯)) ρ •  a)", "code": "structure Coherent (ψ : StructAction β) extends CoherentDom ψ : Prop where\n  coherent_coe : ∀ {γ : Λ} [LeLevel γ] (A : Path (β : TypeIndex) γ)\n    {δ : Λ} [LtLevel δ] {ε : Λ} [LtLevel ε]\n    (hδ : (δ : TypeIndex) < γ) (hε : (ε : TypeIndex) < γ) (hδε : (δ : TypeIndex) ≠ ε) {t : Tangle δ}\n    (h : ((ψ ((A.cons hε).cons (bot_lt_coe _))).litterMap (fuzz hδε t)).Dom)\n    (ρ : Allowable γ),\n    (∀ (B : ExtendedIndex δ) (a : Atom) (ha : ⟨B, inl a⟩ ∈ t.support),\n      ((ψ ((A.cons hδ).comp B)).atomMap a).get (atom_dom A hδ hε hδε ha h) =\n      Allowable.toStructPerm ρ ((Hom.toPath hδ).comp B) • a) →\n    (∀ (B : ExtendedIndex δ) (N : NearLitter) (ha : ⟨B, inr N⟩ ∈ t.support),\n      ((ψ ((A.cons hδ).comp B)).litterMap N.1).get (nearLitter_dom A hδ hε hδε ha h) =\n      Allowable.toStructPerm ρ ((Hom.toPath hδ).comp B) • N.1.toNearLitter) →\n    (∀ (B : ExtendedIndex δ) (N : NearLitter) (a : Atom)\n      (hN : ⟨B, inr N⟩ ∈ t.support) (ha : a ∈ litterSet N.1 ∆ N),\n      ((ψ ((A.cons hδ).comp B)).atomMap a).get (symmDiff_dom A hδ hε hδε hN ha h) =\n      Allowable.toStructPerm ρ ((Hom.toPath hδ).comp B) • a) →\n    (((ψ ((A.cons hε).cons (bot_lt_coe _))).litterMap (fuzz hδε t)).get h).fst =\n      fuzz hδε (Allowable.comp (Hom.toPath hδ) ρ • t)\n  coherent_bot : ∀ {γ : Λ} [LeLevel γ] (A : Path (β : TypeIndex) γ) {ε : Λ} [LtLevel ε]\n    (hε : (ε : TypeIndex) < γ) {a : Atom}\n    (h : ((ψ ((A.cons hε).cons (bot_lt_coe _))).litterMap (fuzz bot_ne_coe a)).Dom)\n    (ρ : Allowable γ),\n    ((ψ (A.cons (bot_lt_coe _))).atomMap a).get (atom_bot_dom A hε h) =\n      Allowable.toStructPerm ρ (Hom.toPath (bot_lt_coe _)) • a →\n    (((ψ ((A.cons hε).cons (bot_lt_coe _))).litterMap (fuzz bot_ne_coe a)).get h).fst =\n      fuzz (bot_ne_coe (a := ε)) (Allowable.comp (Hom.toPath (bot_lt_coe _)) ρ • a)\n", "additional_info": "", "used_premises": [1, 808, 813, 814, 402, 76, 98, 301, 301, 78, 301, 402, 76, 98, 98, 61, 67, 395, 301, 301, 78, 135, 301, 402, 76, 98, 98, 61, 65, 395, 301, 301, 78, 135, 301, 402, 76, 98, 98, 61, 65, 395, 62, 467, 301, 301, 78, 135, 301, 402, 76, 98, 98, 301, 301, 78, 61, 67, 395, 135, 301, 135, 74, 61, 65, 395, 135, 301, 135, 74, 483, 61, 65, 395, 62, 467, 135, 301, 135, 74, 301, 301, 78, 78, 815, 74, 402, 76, 98, 301, 301, 78, 301, 74, 301, 301, 78, 78, 815, 74], "def_path": "ConNF/FOA/Corollaries.lean", "pos": [54, 80], "informalization": "The `ConNF.StructAction.Coherent` class in Lean 4 defines a property of a `β`-structural action `φ` in the context of Constructive Ordinal Notation (ConNF). It states that for any `β`-extended index `B`, any litter `L`, and any proof `hL` that `L` is in the domain of the litter map of `φ` applied to `B`, if `L` is a flexible litter, then `((φ B).litterMap L).get hL` is also a flexible litter. Additionally, it provides conditions for the domains of the `atomMap` and `litterMap` functions of `φ`, ensuring that these functions are defined for all necessary inputs."}
{"full_name": "ConNF.StructAction.CoherentDom", "url": "ConNF/FOA/Corollaries.html#ConNF.StructAction.CoherentDom", "code_src": "con-nf", "ptype": "structure", "header": "structure ConNF.StructAction.CoherentDom [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.FOAAssumptions] {β : ConNF.Λ} (ψ : ConNF.StructAction🔗<|PREMISE|>🔗 ↑β) :Prop\n | mapFlexible : ConNF.StructAction.MapFlexible🔗<|PREMISE|>🔗  ψ\n | atom_bot_dom : ∀ {γ : ConNF.Λ} [inst : ConNF.LeLevel🔗<|PREMISE|>🔗  ↑γ] (A : Quiver.Path🔗<|PREMISE|>🔗  ↑β ↑γ) {ε : ConNF.Λ} [inst : ConNF.LtLevel🔗<|PREMISE|>🔗  ↑ε] (hε : ↑ε <  ↑γ)\n {a : ConNF.Atom},\n ((ψ (Quiver.Path.cons🔗<|PREMISE|>🔗  (Quiver.Path.cons🔗<|PREMISE|>🔗  A hε) ⋯)).litterMap (ConNF.fuzz🔗<|PREMISE|>🔗  ⋯ a)).Dom →\n ((ψ (Quiver.Path.cons🔗<|PREMISE|>🔗  A ⋯)).atomMap a).Dom\n | atom_dom : ∀ {γ : ConNF.Λ} [inst : ConNF.LeLevel🔗<|PREMISE|>🔗  ↑γ] (A : Quiver.Path🔗<|PREMISE|>🔗  ↑β ↑γ) {δ : ConNF.Λ} [inst : ConNF.LtLevel🔗<|PREMISE|>🔗  ↑δ] {ε : ConNF.Λ}\n [inst_1 : ConNF.LtLevel🔗<|PREMISE|>🔗  ↑ε] (hδ : ↑δ <  ↑γ) (hε : ↑ε <  ↑γ) (hδε : ↑δ ≠  ↑ε) {t : ConNF.Tangle  ↑δ}\n {B : ConNF.ExtendedIndex🔗<|PREMISE|>🔗  ↑δ} {a : ConNF.Atom},\n { path := B, value := Sum.inl🔗<|PREMISE|>🔗  a } ∈  ConNF.TangleData.Tangle.support🔗<|PREMISE|>🔗  t →\n ((ψ (Quiver.Path.cons🔗<|PREMISE|>🔗  (Quiver.Path.cons🔗<|PREMISE|>🔗  A hε) ⋯)).litterMap (ConNF.fuzz🔗<|PREMISE|>🔗  hδε t)).Dom →\n ((ψ (Quiver.Path.comp🔗<|PREMISE|>🔗  (Quiver.Path.cons🔗<|PREMISE|>🔗  A hδ) B)).atomMap a).Dom\n | nearLitter_dom : ∀ {γ : ConNF.Λ} [inst : ConNF.LeLevel🔗<|PREMISE|>🔗  ↑γ] (A : Quiver.Path🔗<|PREMISE|>🔗  ↑β ↑γ) {δ : ConNF.Λ} [inst : ConNF.LtLevel🔗<|PREMISE|>🔗  ↑δ] {ε : ConNF.Λ}\n [inst_1 : ConNF.LtLevel🔗<|PREMISE|>🔗  ↑ε] (hδ : ↑δ <  ↑γ) (hε : ↑ε <  ↑γ) (hδε : ↑δ ≠  ↑ε) {t : ConNF.Tangle  ↑δ}\n {B : ConNF.ExtendedIndex🔗<|PREMISE|>🔗  ↑δ} {N : ConNF.NearLitter},\n { path := B, value := Sum.inr🔗<|PREMISE|>🔗  N } ∈  ConNF.TangleData.Tangle.support🔗<|PREMISE|>🔗  t →\n ((ψ (Quiver.Path.cons🔗<|PREMISE|>🔗  (Quiver.Path.cons🔗<|PREMISE|>🔗  A hε) ⋯)).litterMap (ConNF.fuzz🔗<|PREMISE|>🔗  hδε t)).Dom →\n ((ψ (Quiver.Path.comp🔗<|PREMISE|>🔗  (Quiver.Path.cons🔗<|PREMISE|>🔗  A hδ) B)).litterMap N.fst).Dom\n | symmDiff_dom : ∀ {γ : ConNF.Λ} [inst : ConNF.LeLevel🔗<|PREMISE|>🔗  ↑γ] (A : Quiver.Path🔗<|PREMISE|>🔗  ↑β ↑γ) {δ : ConNF.Λ} [inst : ConNF.LtLevel🔗<|PREMISE|>🔗  ↑δ] {ε : ConNF.Λ}\n [inst_1 : ConNF.LtLevel🔗<|PREMISE|>🔗  ↑ε] (hδ : ↑δ <  ↑γ) (hε : ↑ε <  ↑γ) (hδε : ↑δ ≠  ↑ε) {t : ConNF.Tangle  ↑δ}\n {B : ConNF.ExtendedIndex🔗<|PREMISE|>🔗  ↑δ} {N : ConNF.NearLitter} {a : ConNF.Atom},\n { path := B, value := Sum.inr🔗<|PREMISE|>🔗  N } ∈  ConNF.TangleData.Tangle.support🔗<|PREMISE|>🔗  t →\n a ∈  symmDiff🔗<|PREMISE|>🔗  (ConNF.litterSet🔗<|PREMISE|>🔗  N.fst) ↑N →\n ((ψ (Quiver.Path.cons🔗<|PREMISE|>🔗  (Quiver.Path.cons🔗<|PREMISE|>🔗  A hε) ⋯)).litterMap (ConNF.fuzz🔗<|PREMISE|>🔗  hδε t)).Dom →\n ((ψ (Quiver.Path.comp🔗<|PREMISE|>🔗  (Quiver.Path.cons🔗<|PREMISE|>🔗  A hδ) B)).atomMap a).Dom", "code": "structure CoherentDom (ψ : StructAction β) : Prop where\n  mapFlexible : ψ.MapFlexible\n  atom_bot_dom : ∀ {γ : Λ} [LeLevel γ] (A : Path (β : TypeIndex) γ) {ε : Λ} [LtLevel ε]\n    (hε : (ε : TypeIndex) < γ) {a : Atom},\n    ((ψ ((A.cons hε).cons (bot_lt_coe _))).litterMap (fuzz (bot_ne_coe (a := ε)) a)).Dom →\n    ((ψ (A.cons (bot_lt_coe _))).atomMap a).Dom\n  atom_dom : ∀ {γ : Λ} [LeLevel γ] (A : Path (β : TypeIndex) γ)\n    {δ : Λ} [LtLevel δ] {ε : Λ} [LtLevel ε]\n    (hδ : (δ : TypeIndex) < γ) (hε : (ε : TypeIndex) < γ) (hδε : (δ : TypeIndex) ≠ ε) {t : Tangle δ}\n    {B : ExtendedIndex δ} {a : Atom},\n    ⟨B, inl a⟩ ∈ t.support →\n    ((ψ ((A.cons hε).cons (bot_lt_coe _))).litterMap (fuzz hδε t)).Dom →\n    ((ψ ((A.cons hδ).comp B)).atomMap a).Dom\n  nearLitter_dom : ∀ {γ : Λ} [LeLevel γ] (A : Path (β : TypeIndex) γ)\n    {δ : Λ} [LtLevel δ] {ε : Λ} [LtLevel ε]\n    (hδ : (δ : TypeIndex) < γ) (hε : (ε : TypeIndex) < γ) (hδε : (δ : TypeIndex) ≠ ε) {t : Tangle δ}\n    {B : ExtendedIndex δ} {N : NearLitter},\n    ⟨B, inr N⟩ ∈ t.support →\n    ((ψ ((A.cons hε).cons (bot_lt_coe _))).litterMap (fuzz hδε t)).Dom →\n    ((ψ ((A.cons hδ).comp B)).litterMap N.fst).Dom\n  symmDiff_dom : ∀ {γ : Λ} [LeLevel γ] (A : Path (β : TypeIndex) γ)\n    {δ : Λ} [LtLevel δ] {ε : Λ} [LtLevel ε]\n    (hδ : (δ : TypeIndex) < γ) (hε : (ε : TypeIndex) < γ) (hδε : (δ : TypeIndex) ≠ ε) {t : Tangle δ}\n    {B : ExtendedIndex δ} {N : NearLitter} {a : Atom},\n    ⟨B, inr N⟩ ∈ t.support → a ∈ litterSet N.1 ∆ N →\n    ((ψ ((A.cons hε).cons (bot_lt_coe _))).litterMap (fuzz hδε t)).Dom →\n    ((ψ ((A.cons hδ).comp B)).atomMap a).Dom\n", "additional_info": "", "used_premises": [1, 808, 814, 402, 76, 98, 301, 301, 78, 301, 402, 76, 98, 98, 61, 67, 395, 301, 301, 78, 135, 301, 402, 76, 98, 98, 61, 65, 395, 301, 301, 78, 135, 301, 402, 76, 98, 98, 61, 65, 395, 62, 467, 301, 301, 78, 135, 301], "def_path": "ConNF/FOA/Corollaries.lean", "pos": [26, 53], "informalization": "The `ConNF.StructAction.CoherentDom` class in Lean 4 defines a property of a `β`-structural action `φ` in the context of Constructive Ordinal Notation (ConNF). It states that for any `β`-extended index `B`, any litter `L`, and any proof `hL` that `L` is in the domain of the litter map of `φ` applied to `B`, if `L` is a flexible litter, then `((φ B).litterMap L).get hL` is also a flexible litter. Additionally, it provides conditions for the domains of the `atomMap` and `litterMap` functions of `φ`, ensuring that these functions are defined for all necessary inputs."}
{"full_name": "ConNF.StructAction.MapFlexible", "url": "ConNF/FOA/Action/StructAction.html#ConNF.StructAction.MapFlexible", "code_src": "con-nf", "ptype": "def", "header": "def ConNF.StructAction.MapFlexible [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.FOAAssumptions] {β : ConNF.Λ} (φ : ConNF.StructAction🔗<|PREMISE|>🔗 ↑β) :Prop", "code": "def MapFlexible [Level] [FOAAssumptions] {β : Λ} (φ : StructAction β) :\n    Prop :=\n  ∀ (B) (L : Litter) (hL), Flexible B L → Flexible B (((φ B).litterMap L).get hL).1\n", "additional_info": "This structural action maps flexible litters to flexible litters.\nEquations\n* 🗟ConNF.StructAction.MapFlexible🗟🔗../../.././ConNF/FOA/Action/StructAction.html#ConNF.StructAction.MapFlexible🔗  φ 🗟=🗟🔗../../.././Init/Prelude.html#Eq🔗  ∀ (B : 🗟ConNF.ExtendedIndex🗟🔗../../.././ConNF/Structural/Index.html#ConNF.ExtendedIndex🔗  ↑β) (L : ConNF.Litter) (hL : ((φ B).litterMap L).Dom),\n 🗟ConNF.Flexible🗟🔗../../.././ConNF/FOA/Basic/Flexible.html#ConNF.Flexible🔗  B L → 🗟ConNF.Flexible🗟🔗../../.././ConNF/FOA/Basic/Flexible.html#ConNF.Flexible🔗  B (((φ B).litterMap L).get hL).fst\n\n", "used_premises": [1, 808], "def_path": "ConNF/FOA/Action/StructAction.lean", "pos": [29, 32], "informalization": "Function `ConNF.StructAction.MapFlexible` is a property of a `β`-structural action `φ` in the context of Constructive Ordinal Notation (ConNF). It states that for any `β`-extended index `B`, any litter `L`, and any proof `hL` that `L` is in the domain of the litter map of `φ` applied to `B`, if `L` is a flexible litter, then `((φ B).litterMap L).get hL` is also a flexible litter."}
{"full_name": "ConNF.Allowable.comp", "url": "ConNF/FOA/Basic/Hypotheses.html#ConNF.Allowable.comp", "code_src": "con-nf", "ptype": "def", "header": "def ConNF.Allowable.comp [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.FOAAssumptions] {β : ConNF.TypeIndex} {γ : ConNF.TypeIndex} [ConNF.LeLevel🔗<|PREMISE|>🔗 β] [ConNF.LeLevel🔗<|PREMISE|>🔗 γ] (A : Quiver.Path🔗<|PREMISE|>🔗 β γ) :ConNF.Allowable β →* ConNF.Allowable γ", "code": "def Allowable.comp {β γ : TypeIndex} [LeLevel β] [LeLevel γ] (A : Quiver.Path β γ) :\n    Allowable β →* Allowable γ :=\n  Allowable.comp' A\n", "additional_info": "Define the full derivative map on allowable permutations by recursion along paths.\nThis agrees with `Tree.🗟comp🗟🔗../../.././ConNF/FOA/Basic/Hypotheses.html#ConNF.Allowable.comp🔗` , but yields allowable permutations.\nNote that the `LeLevel γ` hypothesis is technically redundant, but is used to give us more\ndirect access to `Allowable γ`. In practice, we already have this assumption wherever we use\n`🗟Allowable.comp🗟🔗../../.././ConNF/FOA/Basic/Hypotheses.html#ConNF.Allowable.comp🔗` .\nEquations\n* 🗟ConNF.Allowable.comp🗟🔗../../.././ConNF/FOA/Basic/Hypotheses.html#ConNF.Allowable.comp🔗  A 🗟=🗟🔗../../.././Init/Prelude.html#Eq🔗  🗟ConNF.Allowable.comp'🗟🔗../../.././ConNF/FOA/Basic/Hypotheses.html#ConNF.Allowable.comp'🔗  A\n\n", "used_premises": [1, 402, 402, 76], "def_path": "ConNF/FOA/Basic/Hypotheses.lean", "pos": [134, 137], "informalization": "Function `ConNF.Allowable.comp` defines a monoid homomorphism from the set of allowable permutations at level `β` to the set of allowable permutations at level `γ`, where `β` and `γ` are type indices in the context of Constructive Ordinal Notation (ConNF), and `β` is less than or equal to `γ`. The function is defined recursively along a path `A` from `β` to `γ`."}
{"full_name": "ConNF.StructAction.FOAMotive", "url": "ConNF/FOA/Corollaries.html#ConNF.StructAction.FOAMotive", "code_src": "con-nf", "ptype": "def", "header": "def ConNF.StructAction.FOAMotive [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.FOAAssumptions] {β : ConNF.Λ} [ConNF.LeLevel🔗<|PREMISE|>🔗 ↑β] (ψ : ConNF.StructAction🔗<|PREMISE|>🔗 ↑β) (ρ : ConNF.Allowable ↑β) :ConNF.Address🔗<|PREMISE|>🔗 ↑β → Prop", "code": "def FOAMotive (ψ : StructAction β) (ρ : Allowable β) : Address β → Prop\n  | ⟨A, inl a⟩ => (ha : ((ψ A).atomMap a).Dom) →\n      Allowable.toStructPerm ρ A • a = ((ψ A).atomMap a).get ha\n  | ⟨A, inr N⟩ => N.IsLitter → (hL : ((ψ A).litterMap N.1).Dom) →\n      Allowable.toStructPerm ρ A • N = ((ψ A).litterMap N.1).get hL\n", "additional_info": "Equations\n* One or more equations did not get rendered due to their size.\n\n", "used_premises": [1, 402, 808, 60], "def_path": "ConNF/FOA/Corollaries.lean", "pos": [81, 86], "informalization": "Function `ConNF.StructAction.FOAMotive` defines a motive for the construction of the natural numbers in the context of Constructive Ordinal Notation (ConNF). Given a `β`-structural action `ψ` and an allowable `ρ`, it checks if an address in the base type (the atom or near-litter) together with the path detailing how we descend from type `α` to type `⊥` by looking at elements of elements and so on in the model satisfies the conditions specified for the `β`-structural action."}
{"full_name": "ConNF.StructAction.foaMotive_nearLitter", "url": "ConNF/FOA/Corollaries.html#ConNF.StructAction.foaMotive_nearLitter", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.StructAction.foaMotive_nearLitter [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.FOAAssumptions] {β : ConNF.Λ} [ConNF.LeLevel🔗<|PREMISE|>🔗 ↑β] (ψ : ConNF.StructAction🔗<|PREMISE|>🔗 ↑β) (h₁ : ConNF.StructAction.Lawful🔗<|PREMISE|>🔗 ψ) (h₂ : ConNF.StructAction.Coherent🔗<|PREMISE|>🔗 ψ) (ρ : ConNF.Allowable ↑β) (hρ : ConNF.StructApprox.ExactlyApproximates🔗<|PREMISE|>🔗 (ConNF.StructAction.rc🔗<|PREMISE|>🔗 ψ h₁) (ConNF.Allowable.toStructPerm ρ)) (A : ConNF.ExtendedIndex🔗<|PREMISE|>🔗 ↑β) (L : ConNF.Litter) (ih : ∀ c < { path := A, value := Sum.inr🔗<|PREMISE|>🔗 (ConNF.Litter.toNearLitter🔗<|PREMISE|>🔗 L) }, ConNF.StructAction.FOAMotive🔗<|PREMISE|>🔗 ψ ρ c) (hL : ((ψ A).litterMap L).Dom) :ConNF.Allowable.toStructPerm ρ A • ConNF.Litter.toNearLitter🔗<|PREMISE|>🔗 L = ((ψ A).litterMap L).get hL", "code": "theorem foaMotive_nearLitter (ψ : StructAction β) (h₁ : ψ.Lawful) (h₂ : ψ.Coherent)\n    (ρ : Allowable β) (hρ : (ψ.rc h₁).ExactlyApproximates (Allowable.toStructPerm ρ))\n    (A : ExtendedIndex β) (L : Litter)\n    (ih : ∀ (c : Address β), c < ⟨A, inr L.toNearLitter⟩ → FOAMotive ψ ρ c)\n    (hL : ((ψ A).litterMap L).Dom) :\n    Allowable.toStructPerm ρ A • L.toNearLitter = ((ψ A).litterMap L).get hL := by\n  refine NearLitter.ext ?_\n  rw [smul_nearLitter_eq_of_precise (ψ.refine h₁) refine_precise hρ\n    (by exact hL) (foaMotive_litter ψ h₁ h₂ ρ hρ A L ih hL)]\n  simp only [refine_apply, Litter.toNearLitter_fst, NearLitterAction.refine_litterMap,\n    Tree.comp_bot, Litter.coe_toNearLitter, symmDiff_self, bot_eq_empty, smul_set_empty,\n    symmDiff_empty]\n", "additional_info": "", "used_premises": [1, 402, 808, 809, 812, 803, 810, 61, 65, 483, 816, 483], "def_path": "ConNF/FOA/Corollaries.lean", "pos": [141, 153], "informalization": "The theorem `ConNF.StructAction.foaMotive_nearLitter` is a part of the formalization of Constructive Ordinal Notation (ConNF) in Lean 4. It states that for any `β`-structural action `ψ` that is lawful and coherent, any allowable `ρ`, any `β`-extended index `A`, any litter `L`, and any proof `hL` that `L` is in the domain of the litter map of `ψ` applied to `A`, if `L` is a flexible litter, then `((ψ A).litterMap L).get hL` is also a flexible litter. Additionally, it provides conditions for the domains of the `atomMap` and `litterMap` functions of `ψ`, ensuring that these functions are defined for all necessary inputs."}
{"full_name": "ConNF.StructAction.freedom_of_action", "url": "ConNF/FOA/Corollaries.html#ConNF.StructAction.freedom_of_action", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.StructAction.freedom_of_action [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.FOAAssumptions] {β : ConNF.Λ} [ConNF.LeLevel🔗<|PREMISE|>🔗 ↑β] (ψ : ConNF.StructAction🔗<|PREMISE|>🔗 ↑β) (h₁ : ConNF.StructAction.Lawful🔗<|PREMISE|>🔗 ψ) (h₂ : ConNF.StructAction.Coherent🔗<|PREMISE|>🔗 ψ) :∃ (ρ : ConNF.Allowable ↑β), ConNF.StructAction.Approximates🔗<|PREMISE|>🔗 ψ (ConNF.Allowable.toStructPerm ρ)", "code": "theorem freedom_of_action (ψ : StructAction β) (h₁ : ψ.Lawful) (h₂ : ψ.Coherent) :\n    ∃ ρ : Allowable β, ψ.Approximates (Allowable.toStructPerm ρ) := by\n  obtain ⟨ρ, hρ⟩ := (ψ.rc h₁).freedom_of_action (rc_free _ _ h₂.mapFlexible)\n  refine ⟨ρ, ?_⟩\n  have := fun c => WellFounded.induction (constrains_wf _).transGen (C := FOAMotive ψ ρ) c ?_\n  · intro A\n    constructor\n    · intro a ha\n      exact this ⟨A, inl a⟩ ha\n    · intro L hL\n      exact this ⟨A, inr L.toNearLitter⟩ (NearLitter.IsLitter.mk L) hL\n  · rintro ⟨A, a | N⟩ ih\n    · exact foaMotive_atom ψ h₁ ρ hρ A a\n    · intro hL h\n      obtain ⟨L, rfl⟩ := hL.exists_litter_eq\n      exact foaMotive_nearLitter ψ h₁ h₂ ρ hρ A L ih h\n", "additional_info": "", "used_premises": [1, 402, 808, 809, 812, 819], "def_path": "ConNF/FOA/Corollaries.lean", "pos": [155, 171], "informalization": "The theorem `ConNF.StructAction.freedom_of_action` asserts that, under the Constructive Ordinal Notation (ConNF) framework, given a `β`-structural action `ψ` and certain conditions such as lawfulness and coherence, there exists a `β`-allowable permutation `ρ` that approximates `ψ`. This theorem is a key step in proving the 'Freedom of Action' property, which is crucial for ConNF's construction of the natural numbers."}
{"full_name": "ConNF.StructAction.Approximates", "url": "ConNF/FOA/Corollaries.html#ConNF.StructAction.Approximates", "code_src": "con-nf", "ptype": "def", "header": "def ConNF.StructAction.Approximates [ConNF.Params🔗<|PREMISE|>🔗 ] {β : ConNF.Λ} (ψ : ConNF.StructAction🔗<|PREMISE|>🔗 ↑β) (π : ConNF.StructPerm🔗<|PREMISE|>🔗 ↑β) :Prop", "code": "def Approximates (ψ : StructAction β) (π : StructPerm β) : Prop :=\n  ∀ A, (ψ A).Approximates (π A)\n", "additional_info": "Equations\n* 🗟ConNF.StructAction.Approximates🗟🔗../.././ConNF/FOA/Corollaries.html#ConNF.StructAction.Approximates🔗  ψ π 🗟=🗟🔗../.././Init/Prelude.html#Eq🔗  ∀ (A : 🗟ConNF.ExtendedIndex🗟🔗../.././ConNF/Structural/Index.html#ConNF.ExtendedIndex🔗  ↑β), 🗟ConNF.NearLitterAction.Approximates🗟🔗../.././ConNF/FOA/Corollaries.html#ConNF.NearLitterAction.Approximates🔗  (ψ A) (π A)\n\n", "used_premises": [1, 808, 55], "def_path": "ConNF/FOA/Corollaries.lean", "pos": [23, 25], "informalization": "Function `ConNF.StructAction.Approximates` checks if a `β`-structural action `ψ` approximates a `β`-structural permutation `π`, meaning that for every `β`-extended index `A`, the near-litter action `ψ A` approximates the near-litter permutation `π A`."}
{"full_name": "ConNF.NearLitterBehaviour.approximates_iff", "url": "ConNF/FOA/Corollaries.html#ConNF.NearLitterBehaviour.approximates_iff", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterBehaviour.approximates_iff [ConNF.Params🔗<|PREMISE|>🔗 ] (ξ : ConNF.NearLitterBehaviour) (π : ConNF.NearLitterPerm) :ConNF.NearLitterBehaviour.Approximates🔗<|PREMISE|>🔗 ξ π ↔ (∀ (a : ConNF.Atom) (h : (ξ.atomMap a).Dom), π • a = (ξ.atomMap a).get h) ∧ ∀ (N : ConNF.NearLitter) (h : (ξ.nearLitterMap N).Dom), π • N = (ξ.nearLitterMap N).get h", "code": "@[mk_iff]\n", "additional_info": "", "used_premises": [1, 821], "def_path": "ConNF/FOA/Corollaries.lean", "pos": [174, 175], "informalization": "The theorem `ConNF.NearLitterBehaviour.approximates_iff` states that a `ConNF.NearLitterBehaviour` object `ξ` approximates a `ConNF.NearLitterPerm` object `π` if and only if for any `ConNF.Atom` `a` such that `ξ.atomMap a` is defined, the action of `π` on `a` is equal to the value of `ξ.atomMap a`, and for any `ConNF.NearLitter` `N` such that `ξ.nearLitterMap N` is defined, the action of `π` on `N` is equal to the value of `ξ.nearLitterMap N`."}
{"full_name": "ConNF.NearLitterBehaviour.Approximates", "url": "ConNF/FOA/Corollaries.html#ConNF.NearLitterBehaviour.Approximates", "code_src": "con-nf", "ptype": "structure", "header": "structure ConNF.NearLitterBehaviour.Approximates [ConNF.Params🔗<|PREMISE|>🔗 ] (ξ : ConNF.NearLitterBehaviour) (π : ConNF.NearLitterPerm) :Prop\n | map_atom : ∀ (a : ConNF.Atom) (h : (ξ.atomMap a).Dom), π •  a =  (ξ.atomMap a).get h\n | map_nearLitter : ∀ (N : ConNF.NearLitter) (h : (ξ.nearLitterMap N).Dom), π •  N =  (ξ.nearLitterMap N).get h", "code": "structure NearLitterBehaviour.Approximates\n    (ξ : NearLitterBehaviour) (π : NearLitterPerm) : Prop where\n  map_atom : ∀ a (h : (ξ.atomMap a).Dom), π • a = (ξ.atomMap a).get h\n  map_nearLitter : ∀ N (h : (ξ.nearLitterMap N).Dom), π • N = (ξ.nearLitterMap N).get h\n", "additional_info": "", "used_premises": [1], "def_path": "ConNF/FOA/Corollaries.lean", "pos": [175, 179], "informalization": "The `ConNF.NearLitterBehaviour.Approximates` structure in Lean 4 defines a relationship between a `ConNF.NearLitterBehaviour` object `ξ` and a `ConNF.NearLitterPerm` object `π`. It consists of two properties: `map_atom` and `map_nearLitter`. The `map_atom` property states that for any `ConNF.Atom` `a` such that `ξ.atomMap a` is defined, the action of `π` on `a` is equal to the value of `ξ.atomMap a`. Similarly, the `map_nearLitter` property states that for any `ConNF.NearLitter` `N` such that `ξ.nearLitterMap N` is defined, the action of `π` on `N` is equal to the value of `ξ.nearLitterMap N`."}
{"full_name": "ConNF.NearLitterBehaviour.action_lawful", "url": "ConNF/FOA/Corollaries.html#ConNF.NearLitterBehaviour.action_lawful", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterBehaviour.action_lawful [ConNF.Params🔗<|PREMISE|>🔗 ] (ξ : ConNF.NearLitterBehaviour) (hξ : ConNF.NearLitterBehaviour.Lawful🔗<|PREMISE|>🔗 ξ) :ConNF.NearLitterAction.Lawful🔗<|PREMISE|>🔗 (ConNF.NearLitterBehaviour.action🔗<|PREMISE|>🔗 ξ hξ)", "code": "theorem ConNF.NearLitterBehaviour.action_lawful\n    (ξ : NearLitterBehaviour) (hξ : ξ.Lawful) : (ξ.action hξ).Lawful := by\n  constructor\n  case atomMap_injective => exact (ξ.withLitters_lawful hξ).atomMap_injective\n  case litterMap_injective =>\n    rintro L₁ L₂ hL₁ hL₂ ⟨a, ha⟩\n    by_contra hL\n    obtain ⟨a, ha', rfl⟩ := (ξ.withLitters_lawful hξ).ran_of_mem_inter a (by exact hL) hL₁ hL₂ ha\n    simp only [NearLitterBehaviour.action, mem_inter_iff,\n      SetLike.mem_coe, (ξ.withLitters_lawful hξ).atom_mem_iff] at ha\n    exact hL (ha.1.symm.trans ha.2)\n  case atom_mem =>\n    intro a ha L hL\n    exact ((ξ.withLitters_lawful hξ).atom_mem_iff ha hL).symm\n", "additional_info": "", "used_premises": [1, 823, 825, 826], "def_path": "ConNF/FOA/Corollaries.lean", "pos": [244, 258], "informalization": "Given a lawful near-litter-behaviour in the context of Constructive Ordinal Notation (ConNF), the function `ConNF.NearLitterBehaviour.action` constructs a lawful near-litter-action, ensuring that the atom and litter maps are injective and that the images of atoms in litters are mapped to atoms inside the corresponding near-litters."}
{"full_name": "ConNF.NearLitterBehaviour.Lawful", "url": "ConNF/FOA/Behaviour/NearLitterBehaviour.html#ConNF.NearLitterBehaviour.Lawful", "code_src": "con-nf", "ptype": "structure", "header": "structure ConNF.NearLitterBehaviour.Lawful [ConNF.Params🔗<|PREMISE|>🔗 ] (ξ : ConNF.NearLitterBehaviour) :Prop\n | atomMap_injective : ∀ ⦃a b : ConNF.Atom⦄ (ha : (ξ.atomMap a).Dom) (hb : (ξ.atomMap b).Dom),\n (ξ.atomMap a).get ha =  (ξ.atomMap b).get hb → a =  b\n | atom_mem_iff : ∀ ⦃a : ConNF.Atom⦄ (ha : (ξ.atomMap a).Dom) ⦃N : ConNF.NearLitter⦄ (hN : (ξ.nearLitterMap N).Dom),\n (ξ.atomMap a).get ha ∈  (ξ.nearLitterMap N).get hN ↔  a ∈  N\n | dom_of_mem_symmDiff : ∀ (a : ConNF.Atom) ⦃N₁ N₂ : ConNF.NearLitter⦄,\n N₁.fst =  N₂.fst → (ξ.nearLitterMap N₁).Dom → (ξ.nearLitterMap N₂).Dom → a ∈  symmDiff🔗<|PREMISE|>🔗  ↑N₁ ↑N₂ → (ξ.atomMap a).Dom\n | dom_of_mem_inter : ∀ (a : ConNF.Atom) ⦃N₁ N₂ : ConNF.NearLitter⦄,\n N₁.fst ≠  N₂.fst → (ξ.nearLitterMap N₁).Dom → (ξ.nearLitterMap N₂).Dom → a ∈  ↑N₁ ∩  ↑N₂ → (ξ.atomMap a).Dom\n | ran_of_mem_symmDiff : ∀ (a : ConNF.Atom) ⦃N₁ N₂ : ConNF.NearLitter⦄,\n N₁.fst =  N₂.fst →\n ∀ (hN₁ : (ξ.nearLitterMap N₁).Dom) (hN₂ : (ξ.nearLitterMap N₂).Dom),\n a ∈  symmDiff🔗<|PREMISE|>🔗  ↑((ξ.nearLitterMap N₁).get hN₁) ↑((ξ.nearLitterMap N₂).get hN₂) → a ∈  PFun.ran🔗<|PREMISE|>🔗  ξ.atomMap\n | ran_of_mem_inter : ∀ (a : ConNF.Atom) ⦃N₁ N₂ : ConNF.NearLitter⦄,\n N₁.fst ≠  N₂.fst →\n ∀ (hN₁ : (ξ.nearLitterMap N₁).Dom) (hN₂ : (ξ.nearLitterMap N₂).Dom),\n a ∈  ↑((ξ.nearLitterMap N₁).get hN₁) ∩  ↑((ξ.nearLitterMap N₂).get hN₂) → a ∈  PFun.ran🔗<|PREMISE|>🔗  ξ.atomMap", "code": "structure Lawful (ξ : NearLitterBehaviour) : Prop where\n  atomMap_injective : ∀ ⦃a b : Atom⦄ (ha : (ξ.atomMap a).Dom) (hb : (ξ.atomMap b).Dom),\n    (ξ.atomMap a).get ha = (ξ.atomMap b).get hb → a = b\n  atom_mem_iff : ∀ ⦃a : Atom⦄ (ha : (ξ.atomMap a).Dom)\n    ⦃N : NearLitter⦄ (hN : (ξ.nearLitterMap N).Dom),\n    (ξ.atomMap a).get ha ∈ (ξ.nearLitterMap N).get hN ↔ a ∈ N\n  dom_of_mem_symmDiff : ∀ (a : Atom) ⦃N₁ N₂ : NearLitter⦄,\n    N₁.fst = N₂.fst → (ξ.nearLitterMap N₁).Dom → (ξ.nearLitterMap N₂).Dom →\n    a ∈ (N₁ : Set Atom) ∆ N₂ → (ξ.atomMap a).Dom\n  dom_of_mem_inter : ∀ (a : Atom) ⦃N₁ N₂ : NearLitter⦄,\n    N₁.fst ≠ N₂.fst → (ξ.nearLitterMap N₁).Dom → (ξ.nearLitterMap N₂).Dom →\n    a ∈ (N₁ : Set Atom) ∩ N₂ → (ξ.atomMap a).Dom\n  ran_of_mem_symmDiff : ∀ (a : Atom) ⦃N₁ N₂ : NearLitter⦄,\n    N₁.fst = N₂.fst → (hN₁ : (ξ.nearLitterMap N₁).Dom) → (hN₂ : (ξ.nearLitterMap N₂).Dom) →\n    a ∈ ((ξ.nearLitterMap N₁).get hN₁ : Set Atom) ∆ (ξ.nearLitterMap N₂).get hN₂ →\n    a ∈ ξ.atomMap.ran\n  ran_of_mem_inter : ∀ (a : Atom) ⦃N₁ N₂ : NearLitter⦄,\n    N₁.fst ≠ N₂.fst → (hN₁ : (ξ.nearLitterMap N₁).Dom) → (hN₂ : (ξ.nearLitterMap N₂).Dom) →\n    a ∈ ((ξ.nearLitterMap N₁).get hN₁ : Set Atom) ∩ (ξ.nearLitterMap N₂).get hN₂ →\n    a ∈ ξ.atomMap.ran\n", "additional_info": "", "used_premises": [1, 62, 62, 824, 824], "def_path": "ConNF/FOA/Behaviour/NearLitterBehaviour.lean", "pos": [21, 41], "informalization": "The structure `ConNF.NearLitterBehaviour.Lawful` defines the properties that a lawful near-litter-behaviour must satisfy, given the context of Constructive Ordinal Notation (ConNF) in Lean 4. It contains conditions for injectivity of the atom map, membership equivalence, domain and range conditions for the near-litter map, and properties related to symmetric differences and intersections."}
{"full_name": "PFun.ran", "url": "Mathlib/Data/PFun.html#PFun.ran", "code_src": "mathlib4", "ptype": "def", "header": "def PFun.ran {α : Type u_1} {β : Type u_2} (f : α →. β) :Set🔗<|PREMISE|>🔗 β", "code": "def ran (f : α →. β) : Set β :=\n  { b | ∃ a, b ∈ f a }\n", "additional_info": "The range of a partial function is the set of values\n`f x` where `x` is in the domain of `f`.\nEquations\n* 🗟PFun.ran🗟🔗../.././Mathlib/Data/PFun.html#PFun.ran🔗  f 🗟=🗟🔗../.././Init/Prelude.html#Eq🔗  {b : β | ∃ (a : α), b 🗟∈🗟🔗../.././Init/Prelude.html#Membership.mem🔗  f a}\n\n", "used_premises": [69], "def_path": "Mathlib/Data/PFun.lean", "pos": [169, 171], "informalization": "Function `PFun.ran` returns the range of a partial function `f : α →. β`, which is the set of values `f x` where `x` is in the domain of `f`."}
{"full_name": "ConNF.NearLitterAction.Lawful", "url": "ConNF/FOA/Action/NearLitterAction.html#ConNF.NearLitterAction.Lawful", "code_src": "con-nf", "ptype": "structure", "header": "structure ConNF.NearLitterAction.Lawful [ConNF.Params🔗<|PREMISE|>🔗 ] (φ : ConNF.NearLitterAction) :Prop\n | atomMap_injective : ∀ ⦃a b : ConNF.Atom⦄ (ha : (φ.atomMap a).Dom) (hb : (φ.atomMap b).Dom),\n (φ.atomMap a).get ha =  (φ.atomMap b).get hb → a =  b\n | litterMap_injective : ∀ ⦃L₁ L₂ : ConNF.Litter⦄ (hL₁ : (φ.litterMap L₁).Dom) (hL₂ : (φ.litterMap L₂).Dom),\n Set.Nonempty🔗<|PREMISE|>🔗  (↑((φ.litterMap L₁).get hL₁) ∩  ↑((φ.litterMap L₂).get hL₂)) → L₁ =  L₂\n | atom_mem : ∀ (a : ConNF.Atom) (ha : (φ.atomMap a).Dom) (L : ConNF.Litter) (hL : (φ.litterMap L).Dom),\n a.1 =  L ↔  (φ.atomMap a).get ha ∈  (φ.litterMap L).get hL", "code": "structure NearLitterAction.Lawful (φ : NearLitterAction) : Prop where\n  atomMap_injective : ∀ ⦃a b⦄ (ha hb),\n    (φ.atomMap a).get ha = (φ.atomMap b).get hb → a = b\n  litterMap_injective : ∀ ⦃L₁ L₂ : Litter⦄ (hL₁ hL₂),\n    (((φ.litterMap L₁).get hL₁ : Set Atom) ∩ (φ.litterMap L₂).get hL₂).Nonempty → L₁ = L₂\n  atom_mem : ∀ (a : Atom) (ha L hL), a.1 = L ↔ (φ.atomMap a).get ha ∈ (φ.litterMap L).get hL\n", "additional_info": "A near litter action in which the atom and litter maps are injective (in suitable senses) and\ncohere in the sense that images of atoms in litters are mapped to atoms inside the corresponding\nnear-litters.\n", "used_premises": [1, 83], "def_path": "ConNF/FOA/Action/NearLitterAction.lean", "pos": [45, 51], "informalization": "Structure `ConNF.NearLitterAction.Lawful` represents a lawful near litter action in the context of Constructive Ordinal Notation (ConNF), ensuring that the atom and litter maps are injective and that the images of atoms in litters are mapped to atoms inside the corresponding near-litters."}
{"full_name": "ConNF.NearLitterBehaviour.action", "url": "ConNF/FOA/Corollaries.html#ConNF.NearLitterBehaviour.action", "code_src": "con-nf", "ptype": "noncomputable def", "header": "noncomputable def ConNF.NearLitterBehaviour.action [ConNF.Params🔗<|PREMISE|>🔗 ] (ξ : ConNF.NearLitterBehaviour) (hξ : ConNF.NearLitterBehaviour.Lawful🔗<|PREMISE|>🔗 ξ) :ConNF.NearLitterAction", "code": "noncomputable def ConNF.NearLitterBehaviour.action\n    (ξ : NearLitterBehaviour) (hξ : ξ.Lawful) : NearLitterAction where\n  atomMap := (ξ.withLitters hξ).atomMap\n  litterMap L := (ξ.withLitters hξ).nearLitterMap L.toNearLitter\n  atomMap_dom_small := (ξ.withLitters hξ).atomMap_dom_small\n  litterMap_dom_small :=\n    (ξ.withLitters hξ).nearLitterMap_dom_small.image (f := fun N => N.1).mono\n      (fun L hL => by exact ⟨L.toNearLitter, hL, rfl⟩)\n", "additional_info": "Equations\n* One or more equations did not get rendered due to their size.\n\n", "used_premises": [1, 823], "def_path": "ConNF/FOA/Corollaries.lean", "pos": [232, 240], "informalization": "Function `ConNF.NearLitterBehaviour.action` constructs a lawful near-litter-action from a lawful near-litter-behaviour in the context of Constructive Ordinal Notation (ConNF)."}
{"full_name": "ConNF.StructBehaviour.action_lawful", "url": "ConNF/FOA/Corollaries.html#ConNF.StructBehaviour.action_lawful", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.StructBehaviour.action_lawful [ConNF.Params🔗<|PREMISE|>🔗 ] {β : ConNF.Λ} (ξ : ConNF.StructBehaviour🔗<|PREMISE|>🔗 ↑β) (hξ : ConNF.StructBehaviour.Lawful🔗<|PREMISE|>🔗 ξ) :ConNF.StructAction.Lawful🔗<|PREMISE|>🔗 (ConNF.StructBehaviour.action🔗<|PREMISE|>🔗 ξ hξ)", "code": "theorem action_lawful (ξ : StructBehaviour β) (hξ : ξ.Lawful) : (ξ.action hξ).Lawful :=\n  fun A => (ξ A).action_lawful (hξ A)\n", "additional_info": "", "used_premises": [1, 828, 829, 809, 830], "def_path": "ConNF/FOA/Corollaries.lean", "pos": [259, 261], "informalization": "The theorem `ConNF.StructBehaviour.action_lawful` states that if `ξ` is a lawful `β`-structural action, then the `β`-structural action `ConNF.StructBehaviour.action ξ hξ` is also lawful. A `β`-structural action is a product that assigns a near-litter action to each `β`-extended index. For `ξ` to be lawful, it must satisfy the condition that for every `β`-extended index `A`, the near-litter action assigned by `ξ` to `A` is lawful. A near-litter action is lawful if it satisfies certain properties, such as being order-preserving and respecting the structure of the near-litter."}
{"full_name": "ConNF.StructBehaviour", "url": "ConNF/FOA/Behaviour/StructBehaviour.html#ConNF.StructBehaviour", "code_src": "con-nf", "ptype": "abbrev", "header": "@[inline, reducible]abbrev ConNF.StructBehaviour [ConNF.Params🔗<|PREMISE|>🔗 ] (α : ConNF.TypeIndex) :Type u", "code": "abbrev StructBehaviour :=\n  Tree NearLitterBehaviour\n", "additional_info": "A `β`-structural action is a product that assigns a near-litter action to each `β`-extended\nindex.\nEquations\n* ConNF.StructBehaviour 🗟=🗟🔗../../.././Init/Prelude.html#Eq🔗  🗟ConNF.Tree🗟🔗../../.././ConNF/Structural/Tree.html#ConNF.Tree🔗  ConNF.NearLitterBehaviour\n\n", "used_premises": [1], "def_path": "ConNF/FOA/Behaviour/StructBehaviour.lean", "pos": [18, 20], "informalization": "A `β`-structural action is a product that assigns a near-litter action to each `β`-extended index."}
{"full_name": "ConNF.StructBehaviour.Lawful", "url": "ConNF/FOA/Behaviour/StructBehaviour.html#ConNF.StructBehaviour.Lawful", "code_src": "con-nf", "ptype": "def", "header": "def ConNF.StructBehaviour.Lawful [ConNF.Params🔗<|PREMISE|>🔗 ] {β : ConNF.TypeIndex} (ξ : ConNF.StructBehaviour🔗<|PREMISE|>🔗 β) :Prop", "code": "def Lawful (ξ : StructBehaviour β) : Prop :=\n  ∀ A, (ξ A).Lawful\n", "additional_info": "Equations\n* 🗟ConNF.StructBehaviour.Lawful🗟🔗../../.././ConNF/FOA/Behaviour/StructBehaviour.html#ConNF.StructBehaviour.Lawful🔗  ξ 🗟=🗟🔗../../.././Init/Prelude.html#Eq🔗  ∀ (A : 🗟ConNF.ExtendedIndex🗟🔗../../.././ConNF/Structural/Index.html#ConNF.ExtendedIndex🔗  β), 🗟ConNF.NearLitterBehaviour.Lawful🗟🔗../../.././ConNF/FOA/Behaviour/NearLitterBehaviour.html#ConNF.NearLitterBehaviour.Lawful🔗  (ξ A)\n\n", "used_premises": [1, 828], "def_path": "ConNF/FOA/Behaviour/StructBehaviour.lean", "pos": [23, 25], "informalization": "Function `ConNF.StructBehaviour.Lawful` checks if a `β`-structural action `ξ` is lawful. A `β`-structural action is a product that assigns a near-litter action to each `β`-extended index. For `ξ` to be lawful, it must satisfy the condition that for every `β`-extended index `A`, the near-litter action assigned by `ξ` to `A` is lawful. A near-litter action is lawful if it satisfies certain properties, such as being order-preserving and respecting the structure of the near-litter."}
{"full_name": "ConNF.StructBehaviour.action", "url": "ConNF/FOA/Corollaries.html#ConNF.StructBehaviour.action", "code_src": "con-nf", "ptype": "noncomputable def", "header": "noncomputable def ConNF.StructBehaviour.action [ConNF.Params🔗<|PREMISE|>🔗 ] {β : ConNF.Λ} (ξ : ConNF.StructBehaviour🔗<|PREMISE|>🔗 ↑β) (hξ : ConNF.StructBehaviour.Lawful🔗<|PREMISE|>🔗 ξ) :ConNF.StructAction🔗<|PREMISE|>🔗 ↑β", "code": "noncomputable def action (ξ : StructBehaviour β) (hξ : ξ.Lawful) : StructAction β :=\n  fun A => (ξ A).action (hξ A)\n", "additional_info": "Equations\n* 🗟ConNF.StructBehaviour.action🗟🔗../.././ConNF/FOA/Corollaries.html#ConNF.StructBehaviour.action🔗  ξ hξ A 🗟=🗟🔗../.././Init/Prelude.html#Eq🔗  🗟ConNF.NearLitterBehaviour.action🗟🔗../.././ConNF/FOA/Corollaries.html#ConNF.NearLitterBehaviour.action🔗  (ξ A) ⋯\n\n", "used_premises": [1, 828, 829, 808], "def_path": "ConNF/FOA/Corollaries.lean", "pos": [241, 243], "informalization": "Function `ConNF.StructBehaviour.action` defines a `β`-structural action as a product that assigns a near-litter action to each `β`-extended index. For `ξ` to be lawful, it must satisfy the condition that for every `β`-extended index `A`, the near-litter action assigned by `ξ` to `A` is lawful. A near-litter action is lawful if it satisfies certain properties, such as being order-preserving and respecting the structure of the near-litter."}
{"full_name": "ConNF.NearLitterBehaviour.action_atomMap", "url": "ConNF/FOA/Corollaries.html#ConNF.NearLitterBehaviour.action_atomMap", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.NearLitterBehaviour.action_atomMap [ConNF.Params🔗<|PREMISE|>🔗 ] (ξ : ConNF.NearLitterBehaviour) (hξ : ConNF.NearLitterBehaviour.Lawful🔗<|PREMISE|>🔗 ξ) :(ConNF.NearLitterBehaviour.action🔗<|PREMISE|>🔗 ξ hξ).atomMap = (ConNF.NearLitterBehaviour.withLitters🔗<|PREMISE|>🔗 ξ hξ).atomMap", "code": "theorem ConNF.NearLitterBehaviour.action_atomMap\n    (ξ : NearLitterBehaviour) (hξ : ξ.Lawful) :\n    (ξ.action hξ).atomMap = (ξ.withLitters hξ).atomMap :=\n  rfl\n", "additional_info": "", "used_premises": [1, 823, 826, 832], "def_path": "ConNF/FOA/Corollaries.lean", "pos": [263, 267], "informalization": "The theorem `ConNF.NearLitterBehaviour.action_atomMap` states that the atom map of the lawful near-litter-action `ConNF.NearLitterBehaviour.action ξ hξ` is equal to the atom map of the modified near-litter-behaviour `ConNF.NearLitterBehaviour.withLitters ξ hξ`."}
{"full_name": "ConNF.NearLitterBehaviour.withLitters", "url": "ConNF/FOA/Behaviour/NearLitterBehaviour.html#ConNF.NearLitterBehaviour.withLitters", "code_src": "con-nf", "ptype": "noncomputable def", "header": "noncomputable def ConNF.NearLitterBehaviour.withLitters [ConNF.Params🔗<|PREMISE|>🔗 ] (ξ : ConNF.NearLitterBehaviour) (hξ : ConNF.NearLitterBehaviour.Lawful🔗<|PREMISE|>🔗 ξ) :ConNF.NearLitterBehaviour", "code": "noncomputable def withLitters (ξ : NearLitterBehaviour) (hξ : ξ.Lawful) : NearLitterBehaviour where\n  atomMap := ξ.extraAtomMap hξ\n  nearLitterMap N := ⟨(ξ.nearLitterMap N).Dom ∨ (N.IsLitter ∧ ξ.LitterPresent N.1),\n    fun h => h.elim'\n      (ξ.nearLitterMap N).get\n      (fun h => ξ.extraLitterMap hξ h.2.choose h.2.choose_spec.1)⟩\n  atomMap_dom_small := ξ.extraAtomMap_dom_small hξ\n  nearLitterMap_dom_small := Small.union ξ.nearLitterMap_dom_small ξ.litterPresent_small'\n", "additional_info": "Equations\n* One or more equations did not get rendered due to their size.\n\n", "used_premises": [1, 823], "def_path": "ConNF/FOA/Behaviour/NearLitterBehaviour.lean", "pos": [681, 689], "informalization": "`ConNF.NearLitterBehaviour.withLitters` is a function that takes a `ConNF.NearLitterBehaviour` and a proof that it is lawful, and returns a modified version of the near-litter-behaviour. The modification involves changing the codomain of the atom map and the definition of the near-litter map to include the possibility of mapping onto the extra litter, if it exists. The function also ensures that the domain of the atom map and the near-litter map are small subsets of the relevant types."}
{"full_name": "ConNF.NearLitterBehaviour.action_litterMap", "url": "ConNF/FOA/Corollaries.html#ConNF.NearLitterBehaviour.action_litterMap", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.NearLitterBehaviour.action_litterMap [ConNF.Params🔗<|PREMISE|>🔗 ] (ξ : ConNF.NearLitterBehaviour) (hξ : ConNF.NearLitterBehaviour.Lawful🔗<|PREMISE|>🔗 ξ) :(ConNF.NearLitterBehaviour.action🔗<|PREMISE|>🔗 ξ hξ).litterMap = fun (L : ConNF.Litter) => (ConNF.NearLitterBehaviour.withLitters🔗<|PREMISE|>🔗 ξ hξ).nearLitterMap (ConNF.Litter.toNearLitter🔗<|PREMISE|>🔗 L)", "code": "theorem ConNF.NearLitterBehaviour.action_litterMap\n    (ξ : NearLitterBehaviour) (hξ : ξ.Lawful) :\n    (ξ.action hξ).litterMap = fun L => (ξ.withLitters hξ).nearLitterMap L.toNearLitter :=\n  rfl\n", "additional_info": "", "used_premises": [1, 823, 826, 832, 483], "def_path": "ConNF/FOA/Corollaries.lean", "pos": [269, 273], "informalization": "The `ConNF.NearLitterBehaviour.action_litterMap` theorem states that the litter map of the lawful near-litter-action constructed from a lawful near-litter-behaviour `ξ` is equal to the near-litter map of the modified near-litter-behaviour `ConNF.NearLitterBehaviour.withLitters ξ hξ` applied to the near-litter formed by wrapping a litter `L` with its own litter set."}
{"full_name": "ConNF.NearLitterBehaviour.action_approximates", "url": "ConNF/FOA/Corollaries.html#ConNF.NearLitterBehaviour.action_approximates", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterBehaviour.action_approximates [ConNF.Params🔗<|PREMISE|>🔗 ] (ξ : ConNF.NearLitterBehaviour) (hξ : ConNF.NearLitterBehaviour.Lawful🔗<|PREMISE|>🔗 ξ) (π : ConNF.NearLitterPerm) (h : ConNF.NearLitterAction.Approximates🔗<|PREMISE|>🔗 (ConNF.NearLitterBehaviour.action🔗<|PREMISE|>🔗 ξ hξ) π) :ConNF.NearLitterBehaviour.Approximates🔗<|PREMISE|>🔗 ξ π", "code": "theorem ConNF.NearLitterBehaviour.action_approximates\n    (ξ : NearLitterBehaviour) (hξ : ξ.Lawful) (π : NearLitterPerm)\n    (h : (ξ.action hξ).Approximates π) : ξ.Approximates π := by\n  constructor\n  · intro a ha\n    simp only [h.map_atom a (Or.inl ha), NearLitterBehaviour.action_atomMap,\n      NearLitterBehaviour.withLitters, NearLitterBehaviour.extraAtomMap_eq_of_dom a ha]\n  · intro N hN\n    refine NearLitter.ext ?_\n    rw [NearLitterPerm.smul_nearLitter_eq_smul_symmDiff_smul,\n      h.map_litter _ (Or.inr ⟨⟨_⟩, N, hN, rfl⟩)]\n    rw [← symmDiff_right_inj, symmDiff_symmDiff_cancel_left]\n    ext a\n    simp only [NearLitterBehaviour.action_litterMap,\n      NearLitterBehaviour.withLitters_nearLitterMap_fst hξ hN, NearLitterBehaviour.extraLitterMap,\n      NearLitterBehaviour.extraLitterMap', NearLitter.coe_mk, symmDiff_symmDiff_self', mem_iUnion,\n      mem_singleton_iff]\n    constructor <;>\n    · rintro ⟨a, ha, rfl⟩\n      refine ⟨a, ha, ?_⟩\n      dsimp only\n      rw [h.map_atom]\n      rfl\n", "additional_info": "", "used_premises": [1, 823, 806, 826, 821], "def_path": "ConNF/FOA/Corollaries.lean", "pos": [284, 307], "informalization": "The theorem `ConNF.NearLitterBehaviour.action_approximates` states that if `ξ` is a lawful near-litter-behaviour and `π` is a near-litter-permutation that approximates the near-litter-action derived from `ξ`, then `ξ` approximates `π` in the sense that the action of `π` on atoms and litters is consistent with the mapping provided by `ξ`."}
{"full_name": "ConNF.StructBehaviour.action_approximates", "url": "ConNF/FOA/Corollaries.html#ConNF.StructBehaviour.action_approximates", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.StructBehaviour.action_approximates [ConNF.Params🔗<|PREMISE|>🔗 ] {β : ConNF.Λ} (ξ : ConNF.StructBehaviour🔗<|PREMISE|>🔗 ↑β) (hξ : ConNF.StructBehaviour.Lawful🔗<|PREMISE|>🔗 ξ) (π : ConNF.StructPerm🔗<|PREMISE|>🔗 ↑β) (h : ConNF.StructAction.Approximates🔗<|PREMISE|>🔗 (ConNF.StructBehaviour.action🔗<|PREMISE|>🔗 ξ hξ) π) :ConNF.StructBehaviour.Approximates🔗<|PREMISE|>🔗 ξ π", "code": "theorem action_approximates (ξ : StructBehaviour β) (hξ : ξ.Lawful) (π : StructPerm β)\n    (h : (ξ.action hξ).Approximates π) : ξ.Approximates π :=\n  fun A => (ξ A).action_approximates (hξ A) (π A) (h A)\n", "additional_info": "", "used_premises": [1, 828, 829, 55, 819, 830, 836], "def_path": "ConNF/FOA/Corollaries.lean", "pos": [308, 311], "informalization": "In the context of Constructive Ordinal Notation (ConNF), a `β`-structural action `ξ` *approximates* a `β`-structural permutation `π` if, for every `β`-extended index `A`, the `β`-extended near-litter action `ξ A` approximates the `β`-extended near-litter permutation `π A`. This approximation is defined by the `ConNF.NearLitterBehaviour.Approximates` relation between near-litter actions and permutations."}
{"full_name": "ConNF.StructBehaviour.Approximates", "url": "ConNF/FOA/Corollaries.html#ConNF.StructBehaviour.Approximates", "code_src": "con-nf", "ptype": "def", "header": "def ConNF.StructBehaviour.Approximates [ConNF.Params🔗<|PREMISE|>🔗 ] {β : ConNF.Λ} (ξ : ConNF.StructBehaviour🔗<|PREMISE|>🔗 ↑β) (π : ConNF.StructPerm🔗<|PREMISE|>🔗 ↑β) :Prop", "code": "def Approximates (ξ : StructBehaviour β) (π : StructPerm β) : Prop :=\n  ∀ A, (ξ A).Approximates (π A)\n", "additional_info": "Equations\n* 🗟ConNF.StructBehaviour.Approximates🗟🔗../.././ConNF/FOA/Corollaries.html#ConNF.StructBehaviour.Approximates🔗  ξ π 🗟=🗟🔗../.././Init/Prelude.html#Eq🔗  ∀ (A : 🗟ConNF.ExtendedIndex🗟🔗../.././ConNF/Structural/Index.html#ConNF.ExtendedIndex🔗  ↑β), 🗟ConNF.NearLitterBehaviour.Approximates🗟🔗../.././ConNF/FOA/Corollaries.html#ConNF.NearLitterBehaviour.Approximates🔗  (ξ A) (π A)\n\n", "used_premises": [1, 828, 55], "def_path": "ConNF/FOA/Corollaries.lean", "pos": [182, 184], "informalization": "In the context of Constructive Ordinal Notation (ConNF), a `β`-structural action `ξ` *approximates* a `β`-structural permutation `π` if, for every `β`-extended index `A`, the `β`-extended near-litter action `ξ A` approximates the `β`-extended near-litter permutation `π A`. This approximation is defined by the `ConNF.NearLitterBehaviour.Approximates` relation between near-litter actions and permutations."}
{"full_name": "ConNF.NearLitterBehaviour.litterPresent_of_dom", "url": "ConNF/FOA/Corollaries.html#ConNF.NearLitterBehaviour.litterPresent_of_dom", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterBehaviour.litterPresent_of_dom [ConNF.Params🔗<|PREMISE|>🔗 ] {ξ : ConNF.NearLitterBehaviour} (hξ : ConNF.NearLitterBehaviour.Lawful🔗<|PREMISE|>🔗 ξ) {L : ConNF.Litter} (h : ((ConNF.NearLitterBehaviour.withLitters🔗<|PREMISE|>🔗 ξ hξ).nearLitterMap (ConNF.Litter.toNearLitter🔗<|PREMISE|>🔗 L)).Dom) :ConNF.NearLitterBehaviour.LitterPresent🔗<|PREMISE|>🔗 ξ L", "code": "theorem ConNF.NearLitterBehaviour.litterPresent_of_dom\n    {ξ : NearLitterBehaviour} (hξ : ξ.Lawful)\n    {L : Litter} (h : ((ξ.withLitters hξ).nearLitterMap L.toNearLitter).Dom) :\n    ξ.LitterPresent L := by\n  obtain (hL | hL) := h\n  · exact ⟨L.toNearLitter, hL, rfl⟩\n  · exact hL.2\n", "additional_info": "", "used_premises": [1, 823, 832, 483, 838], "def_path": "ConNF/FOA/Corollaries.lean", "pos": [312, 319], "informalization": "The theorem `ConNF.NearLitterBehaviour.litterPresent_of_dom` states that if there exists a near-litter `N` such that the near-litter map `ξ.nearLitterMap N` is defined and the first component of `N` is equal to the given litter `L`, then there exists a near-litter `N` such that the near-litter map `ξ.nearLitterMap N` is defined and the first component of `N` is equal to the given litter `L`."}
{"full_name": "ConNF.NearLitterBehaviour.LitterPresent", "url": "ConNF/FOA/Behaviour/NearLitterBehaviour.html#ConNF.NearLitterBehaviour.LitterPresent", "code_src": "con-nf", "ptype": "def", "header": "def ConNF.NearLitterBehaviour.LitterPresent [ConNF.Params🔗<|PREMISE|>🔗 ] (ξ : ConNF.NearLitterBehaviour) (L : ConNF.Litter) :Prop", "code": "def LitterPresent (ξ : NearLitterBehaviour) (L : Litter) : Prop :=\n  ∃ N : NearLitter, (ξ.nearLitterMap N).Dom ∧ N.1 = L\n", "additional_info": "Equations\n* 🗟ConNF.NearLitterBehaviour.LitterPresent🗟🔗../../.././ConNF/FOA/Behaviour/NearLitterBehaviour.html#ConNF.NearLitterBehaviour.LitterPresent🔗  ξ L 🗟=🗟🔗../../.././Init/Prelude.html#Eq🔗  ∃ (N : ConNF.NearLitter), (ξ.nearLitterMap N).Dom 🗟∧🗟🔗../../.././Init/Prelude.html#And🔗  N.fst 🗟=🗟🔗../../.././Init/Prelude.html#Eq🔗  L\n\n", "used_premises": [1], "def_path": "ConNF/FOA/Behaviour/NearLitterBehaviour.lean", "pos": [147, 149], "informalization": "Function `ConNF.NearLitterBehaviour.LitterPresent` checks if there exists a near litter `N` such that the near litter map `ξ.nearLitterMap N` is defined and the first component of `N` is equal to the given litter `L`."}
{"full_name": "ConNF.StructBehaviour.action_coherentDom", "url": "ConNF/FOA/Corollaries.html#ConNF.StructBehaviour.action_coherentDom", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.StructBehaviour.action_coherentDom [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.FOAAssumptions] {β : ConNF.Λ} (ξ : ConNF.StructBehaviour🔗<|PREMISE|>🔗 ↑β) (h₁ : ConNF.StructBehaviour.Lawful🔗<|PREMISE|>🔗 ξ) (h₂ : ConNF.StructBehaviour.Coherent🔗<|PREMISE|>🔗 ξ) :ConNF.StructAction.CoherentDom🔗<|PREMISE|>🔗 (ConNF.StructBehaviour.action🔗<|PREMISE|>🔗 ξ h₁)", "code": "theorem action_coherentDom (ξ : StructBehaviour β) (h₁ : ξ.Lawful) (h₂ : ξ.Coherent) :\n    (ξ.action h₁).CoherentDom := by\n  constructor\n  case mapFlexible =>\n    intro A L hL₁ hL₂\n    obtain ⟨N, hN, rfl⟩ := (ξ A).litterPresent_of_dom (h₁ A) hL₁\n    have := (NearLitterBehaviour.map_nearLitter_fst (ξ.withLitters_lawful h₁ A)\n      (Or.inl hN) (Or.inr ⟨⟨_⟩, N, hN, rfl⟩)).mp rfl\n    erw [← this]\n    simp only [withLitters, NearLitterBehaviour.withLitters_nearLitterMap_of_dom _ hN]\n    exact h₂.mapFlexible A N hN hL₂\n  case atom_bot_dom =>\n    intro γ _ A ε _ hε a ha\n    obtain ⟨Nt, hNt₁, hNt₂⟩ := (ξ _).litterPresent_of_dom (h₁ _) ha\n    exact Or.inl (h₂.atom_bot_dom A hε hNt₂ hNt₁)\n  case atom_dom =>\n    intro γ _ A δ _ ε _ hδ hε hδε t B a hc ht\n    obtain ⟨Nt, hNt₁, hNt₂⟩ := (ξ _).litterPresent_of_dom (h₁ _) ht\n    exact Or.inl (h₂.atom_dom A hδ hε hδε hNt₂ hc hNt₁)\n  case nearLitter_dom =>\n    intro γ _ A δ _ ε _ hδ hε hδε t B a hc ht\n    obtain ⟨Nt, hNt₁, hNt₂⟩ := (ξ _).litterPresent_of_dom (h₁ _) ht\n    exact Or.inr ⟨⟨_⟩, _, h₂.nearLitter_dom A hδ hε hδε hNt₂ hc hNt₁, rfl⟩\n  case symmDiff_dom =>\n    intro γ _ A δ _ ε _ hδ hε hδε t B N a hc ha ht\n    obtain ⟨Nt, hNt₁, hNt₂⟩ := (ξ _).litterPresent_of_dom (h₁ _) ht\n    simp only [action_atomMap, NearLitterBehaviour.withLitters]\n    have := h₂.nearLitter_dom A hδ hε hδε hNt₂ hc hNt₁\n    exact NearLitterBehaviour.extraAtomMap_dom_of_mem_symmDiff (h₁ _) this ha\n", "additional_info": "", "used_premises": [1, 828, 829, 840, 813, 830], "def_path": "ConNF/FOA/Corollaries.lean", "pos": [342, 371], "informalization": "In the context of Constructive Ordinal Notation (ConNF), a `β`-structural action is a product that assigns a near-litter action to each `β`-extended index. For a `β`-structural action `ξ` to be lawful, it must satisfy the condition that for every `β`-extended index `A`, the near-litter action assigned by `ξ` to `A` is lawful. A near-litter action is lawful if it satisfies certain properties, such as being order-preserving and respecting the structure of the near-litter. Additionally, a `β`-structural action is coherent if it satisfies certain conditions that ensure the construction of the natural numbers in ConNF is well-defined and consistent. The theorem `ConNF.StructBehaviour.action_coherentDom` states that if `ξ` is a lawful and coherent `β`-structural action, then the `β`-structural action `ConNF.StructBehaviour.action ξ h₁` is also coherent."}
{"full_name": "ConNF.StructBehaviour.Coherent", "url": "ConNF/FOA/Corollaries.html#ConNF.StructBehaviour.Coherent", "code_src": "con-nf", "ptype": "structure", "header": "structure ConNF.StructBehaviour.Coherent [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.FOAAssumptions] {β : ConNF.Λ} (ξ : ConNF.StructBehaviour🔗<|PREMISE|>🔗 ↑β) extends ConNF.StructBehaviour.CoherentDom🔗<|PREMISE|>🔗 :Prop\n | mapFlexible : ∀ (A : ConNF.ExtendedIndex🔗<|PREMISE|>🔗  ↑β) (N : ConNF.NearLitter) (hN : ((ξ A).nearLitterMap N).Dom),\n ConNF.Flexible🔗<|PREMISE|>🔗  A N.fst → ConNF.Flexible🔗<|PREMISE|>🔗  A (((ξ A).nearLitterMap N).get hN).fst\n | atom_bot_dom : ∀ {γ : ConNF.Λ} [inst : ConNF.LeLevel🔗<|PREMISE|>🔗  ↑γ] (A : Quiver.Path🔗<|PREMISE|>🔗  ↑β ↑γ) {ε : ConNF.Λ} [inst : ConNF.LtLevel🔗<|PREMISE|>🔗  ↑ε] (hε : ↑ε <  ↑γ)\n {a : ConNF.Atom} {Nt : ConNF.NearLitter},\n Nt.fst =  ConNF.fuzz🔗<|PREMISE|>🔗  ⋯ a →\n ((ξ (Quiver.Path.cons🔗<|PREMISE|>🔗  (Quiver.Path.cons🔗<|PREMISE|>🔗  A hε) ⋯)).nearLitterMap Nt).Dom → ((ξ (Quiver.Path.cons🔗<|PREMISE|>🔗  A ⋯)).atomMap a).Dom\n | atom_dom : ∀ {γ : ConNF.Λ} [inst : ConNF.LeLevel🔗<|PREMISE|>🔗  ↑γ] (A : Quiver.Path🔗<|PREMISE|>🔗  ↑β ↑γ) {δ : ConNF.Λ} [inst : ConNF.LtLevel🔗<|PREMISE|>🔗  ↑δ] {ε : ConNF.Λ}\n [inst_1 : ConNF.LtLevel🔗<|PREMISE|>🔗  ↑ε] (hδ : ↑δ <  ↑γ) (hε : ↑ε <  ↑γ) (hδε : ↑δ ≠  ↑ε) {t : ConNF.Tangle  ↑δ}\n {B : ConNF.ExtendedIndex🔗<|PREMISE|>🔗  ↑δ} {a : ConNF.Atom} {Nt : ConNF.NearLitter},\n Nt.fst =  ConNF.fuzz🔗<|PREMISE|>🔗  hδε t →\n { path := B, value := Sum.inl🔗<|PREMISE|>🔗  a } ∈  ConNF.TangleData.Tangle.support🔗<|PREMISE|>🔗  t →\n ((ξ (Quiver.Path.cons🔗<|PREMISE|>🔗  (Quiver.Path.cons🔗<|PREMISE|>🔗  A hε) ⋯)).nearLitterMap Nt).Dom →\n ((ξ (Quiver.Path.comp🔗<|PREMISE|>🔗  (Quiver.Path.cons🔗<|PREMISE|>🔗  A hδ) B)).atomMap a).Dom\n | nearLitter_dom : ∀ {γ : ConNF.Λ} [inst : ConNF.LeLevel🔗<|PREMISE|>🔗  ↑γ] (A : Quiver.Path🔗<|PREMISE|>🔗  ↑β ↑γ) {δ : ConNF.Λ} [inst : ConNF.LtLevel🔗<|PREMISE|>🔗  ↑δ] {ε : ConNF.Λ}\n [inst_1 : ConNF.LtLevel🔗<|PREMISE|>🔗  ↑ε] (hδ : ↑δ <  ↑γ) (hε : ↑ε <  ↑γ) (hδε : ↑δ ≠  ↑ε) {t : ConNF.Tangle  ↑δ}\n {B : ConNF.ExtendedIndex🔗<|PREMISE|>🔗  ↑δ} {N Nt : ConNF.NearLitter},\n Nt.fst =  ConNF.fuzz🔗<|PREMISE|>🔗  hδε t →\n { path := B, value := Sum.inr🔗<|PREMISE|>🔗  N } ∈  ConNF.TangleData.Tangle.support🔗<|PREMISE|>🔗  t →\n ((ξ (Quiver.Path.cons🔗<|PREMISE|>🔗  (Quiver.Path.cons🔗<|PREMISE|>🔗  A hε) ⋯)).nearLitterMap Nt).Dom →\n ((ξ (Quiver.Path.comp🔗<|PREMISE|>🔗  (Quiver.Path.cons🔗<|PREMISE|>🔗  A hδ) B)).nearLitterMap N).Dom\n | coherent_coe : ∀ {γ : ConNF.Λ} [inst : ConNF.LeLevel🔗<|PREMISE|>🔗  ↑γ] (A : Quiver.Path🔗<|PREMISE|>🔗  ↑β ↑γ) {δ : ConNF.Λ} [inst_1 : ConNF.LtLevel🔗<|PREMISE|>🔗  ↑δ]\n {ε : ConNF.Λ} [inst_2 : ConNF.LtLevel🔗<|PREMISE|>🔗  ↑ε] (hδ : ↑δ <  ↑γ) (hε : ↑ε <  ↑γ) (hδε : ↑δ ≠  ↑ε) {t : ConNF.Tangle  ↑δ}\n {Nt : ConNF.NearLitter} (hNt : Nt.fst =  ConNF.fuzz🔗<|PREMISE|>🔗  hδε t)\n (h : ((ξ (Quiver.Path.cons🔗<|PREMISE|>🔗  (Quiver.Path.cons🔗<|PREMISE|>🔗  A hε) ⋯)).nearLitterMap Nt).Dom) (ρ : ConNF.Allowable  ↑γ),\n (∀ (B : ConNF.ExtendedIndex🔗<|PREMISE|>🔗  ↑δ) (a : ConNF.Atom)\n (ha : { path := B, value := Sum.inl🔗<|PREMISE|>🔗  a } ∈  ConNF.TangleData.Tangle.support🔗<|PREMISE|>🔗  t),\n ((ξ (Quiver.Path.comp🔗<|PREMISE|>🔗  (Quiver.Path.cons🔗<|PREMISE|>🔗  A hδ) B)).atomMap a).get ⋯ =  ConNF.Allowable.toStructPerm ρ (Quiver.Path.comp🔗<|PREMISE|>🔗  (Quiver.Hom.toPath🔗<|PREMISE|>🔗  hδ) B) •  a) →\n (∀ (B : ConNF.ExtendedIndex🔗<|PREMISE|>🔗  ↑δ) (N : ConNF.NearLitter)\n (ha : { path := B, value := Sum.inr🔗<|PREMISE|>🔗  N } ∈  ConNF.TangleData.Tangle.support🔗<|PREMISE|>🔗  t),\n ((ξ (Quiver.Path.comp🔗<|PREMISE|>🔗  (Quiver.Path.cons🔗<|PREMISE|>🔗  A hδ) B)).nearLitterMap N).get ⋯ =  ConNF.Allowable.toStructPerm ρ (Quiver.Path.comp🔗<|PREMISE|>🔗  (Quiver.Hom.toPath🔗<|PREMISE|>🔗  hδ) B) •  N) →\n (((ξ (Quiver.Path.cons🔗<|PREMISE|>🔗  (Quiver.Path.cons🔗<|PREMISE|>🔗  A hε) ⋯)).nearLitterMap Nt).get h).fst =  ConNF.fuzz🔗<|PREMISE|>🔗  hδε ((ConNF.Allowable.comp🔗<|PREMISE|>🔗  (Quiver.Hom.toPath🔗<|PREMISE|>🔗  hδ)) ρ •  t)\n | coherent_bot : ∀ {γ : ConNF.Λ} [inst : ConNF.LeLevel🔗<|PREMISE|>🔗  ↑γ] (A : Quiver.Path🔗<|PREMISE|>🔗  ↑β ↑γ) {ε : ConNF.Λ} [inst_1 : ConNF.LtLevel🔗<|PREMISE|>🔗  ↑ε]\n (hε : ↑ε <  ↑γ) {a : ConNF.Atom} {Nt : ConNF.NearLitter} (hNt : Nt.fst =  ConNF.fuzz🔗<|PREMISE|>🔗  ⋯ a)\n (h : ((ξ (Quiver.Path.cons🔗<|PREMISE|>🔗  (Quiver.Path.cons🔗<|PREMISE|>🔗  A hε) ⋯)).nearLitterMap Nt).Dom) (ρ : ConNF.Allowable  ↑γ),\n ((ξ (Quiver.Path.cons🔗<|PREMISE|>🔗  A ⋯)).atomMap a).get ⋯ =  ConNF.Allowable.toStructPerm ρ (Quiver.Hom.toPath🔗<|PREMISE|>🔗  ⋯) •  a →\n (((ξ (Quiver.Path.cons🔗<|PREMISE|>🔗  (Quiver.Path.cons🔗<|PREMISE|>🔗  A hε) ⋯)).nearLitterMap Nt).get h).fst =  ConNF.fuzz🔗<|PREMISE|>🔗  ⋯ ((ConNF.Allowable.comp🔗<|PREMISE|>🔗  (Quiver.Hom.toPath🔗<|PREMISE|>🔗  ⋯)) ρ •  a)", "code": "structure Coherent (ξ : StructBehaviour β) extends CoherentDom ξ : Prop where\n  coherent_coe : ∀ {γ : Λ} [LeLevel γ] (A : Path (β : TypeIndex) γ)\n    {δ : Λ} [LtLevel δ] {ε : Λ} [LtLevel ε]\n    (hδ : (δ : TypeIndex) < γ) (hε : (ε : TypeIndex) < γ) (hδε : (δ : TypeIndex) ≠ ε) {t : Tangle δ}\n    {Nt : NearLitter} (hNt : Nt.1 = fuzz hδε t)\n    (h : ((ξ ((A.cons hε).cons (bot_lt_coe _))).nearLitterMap Nt).Dom)\n    (ρ : Allowable γ),\n    (∀ (B : ExtendedIndex δ) (a : Atom) (ha : ⟨B, inl a⟩ ∈ t.support),\n      ((ξ ((A.cons hδ).comp B)).atomMap a).get (atom_dom A hδ hε hδε hNt ha h) =\n      Allowable.toStructPerm ρ ((Hom.toPath hδ).comp B) • a) →\n    (∀ (B : ExtendedIndex δ) (N : NearLitter) (ha : ⟨B, inr N⟩ ∈ t.support),\n      ((ξ ((A.cons hδ).comp B)).nearLitterMap N).get (nearLitter_dom A hδ hε hδε hNt ha h) =\n      Allowable.toStructPerm ρ ((Hom.toPath hδ).comp B) • N) →\n    (((ξ ((A.cons hε).cons (bot_lt_coe _))).nearLitterMap Nt).get h).fst =\n      fuzz hδε (Allowable.comp (Hom.toPath hδ) ρ • t)\n  coherent_bot : ∀ {γ : Λ} [LeLevel γ] (A : Path (β : TypeIndex) γ) {ε : Λ} [LtLevel ε]\n    (hε : (ε : TypeIndex) < γ) {a : Atom} {Nt : NearLitter} (hNt : Nt.1 = fuzz bot_ne_coe a)\n    (h : ((ξ ((A.cons hε).cons (bot_lt_coe _))).nearLitterMap Nt).Dom)\n    (ρ : Allowable γ),\n    ((ξ (A.cons (bot_lt_coe _))).atomMap a).get (atom_bot_dom A hε hNt h) =\n      Allowable.toStructPerm ρ (Hom.toPath (bot_lt_coe _)) • a →\n    (((ξ ((A.cons hε).cons (bot_lt_coe _))).nearLitterMap Nt).get h).fst =\n      fuzz (bot_ne_coe (a := ε)) (Allowable.comp (Hom.toPath (bot_lt_coe _)) ρ • a)\n", "additional_info": "", "used_premises": [1, 828, 841, 61, 842, 842, 402, 76, 98, 78, 301, 301, 301, 402, 76, 98, 98, 61, 78, 67, 395, 301, 301, 135, 301, 402, 76, 98, 98, 61, 78, 65, 395, 301, 301, 135, 301, 402, 76, 98, 98, 78, 301, 301, 61, 67, 395, 135, 301, 135, 74, 61, 65, 395, 135, 301, 135, 74, 301, 301, 78, 815, 74, 402, 76, 98, 78, 301, 301, 301, 74, 301, 301, 78, 815, 74], "def_path": "ConNF/FOA/Corollaries.lean", "pos": [208, 231], "informalization": "The `ConNF.StructBehaviour.Coherent` class in Lean 4 represents the condition that a `β`-structural action is *coherent* in the context of Constructive Ordinal Notation (ConNF). This condition ensures that the construction of the natural numbers in ConNF is well-defined and consistent."}
{"full_name": "ConNF.StructBehaviour.CoherentDom", "url": "ConNF/FOA/Corollaries.html#ConNF.StructBehaviour.CoherentDom", "code_src": "con-nf", "ptype": "structure", "header": "structure ConNF.StructBehaviour.CoherentDom [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.FOAAssumptions] {β : ConNF.Λ} (ξ : ConNF.StructBehaviour🔗<|PREMISE|>🔗 ↑β) :Prop\n | mapFlexible : ∀ (A : ConNF.ExtendedIndex🔗<|PREMISE|>🔗  ↑β) (N : ConNF.NearLitter) (hN : ((ξ A).nearLitterMap N).Dom),\n ConNF.Flexible🔗<|PREMISE|>🔗  A N.fst → ConNF.Flexible🔗<|PREMISE|>🔗  A (((ξ A).nearLitterMap N).get hN).fst\n | atom_bot_dom : ∀ {γ : ConNF.Λ} [inst : ConNF.LeLevel🔗<|PREMISE|>🔗  ↑γ] (A : Quiver.Path🔗<|PREMISE|>🔗  ↑β ↑γ) {ε : ConNF.Λ} [inst : ConNF.LtLevel🔗<|PREMISE|>🔗  ↑ε] (hε : ↑ε <  ↑γ)\n {a : ConNF.Atom} {Nt : ConNF.NearLitter},\n Nt.fst =  ConNF.fuzz🔗<|PREMISE|>🔗  ⋯ a →\n ((ξ (Quiver.Path.cons🔗<|PREMISE|>🔗  (Quiver.Path.cons🔗<|PREMISE|>🔗  A hε) ⋯)).nearLitterMap Nt).Dom → ((ξ (Quiver.Path.cons🔗<|PREMISE|>🔗  A ⋯)).atomMap a).Dom\n | atom_dom : ∀ {γ : ConNF.Λ} [inst : ConNF.LeLevel🔗<|PREMISE|>🔗  ↑γ] (A : Quiver.Path🔗<|PREMISE|>🔗  ↑β ↑γ) {δ : ConNF.Λ} [inst : ConNF.LtLevel🔗<|PREMISE|>🔗  ↑δ] {ε : ConNF.Λ}\n [inst_1 : ConNF.LtLevel🔗<|PREMISE|>🔗  ↑ε] (hδ : ↑δ <  ↑γ) (hε : ↑ε <  ↑γ) (hδε : ↑δ ≠  ↑ε) {t : ConNF.Tangle  ↑δ}\n {B : ConNF.ExtendedIndex🔗<|PREMISE|>🔗  ↑δ} {a : ConNF.Atom} {Nt : ConNF.NearLitter},\n Nt.fst =  ConNF.fuzz🔗<|PREMISE|>🔗  hδε t →\n { path := B, value := Sum.inl🔗<|PREMISE|>🔗  a } ∈  ConNF.TangleData.Tangle.support🔗<|PREMISE|>🔗  t →\n ((ξ (Quiver.Path.cons🔗<|PREMISE|>🔗  (Quiver.Path.cons🔗<|PREMISE|>🔗  A hε) ⋯)).nearLitterMap Nt).Dom →\n ((ξ (Quiver.Path.comp🔗<|PREMISE|>🔗  (Quiver.Path.cons🔗<|PREMISE|>🔗  A hδ) B)).atomMap a).Dom\n | nearLitter_dom : ∀ {γ : ConNF.Λ} [inst : ConNF.LeLevel🔗<|PREMISE|>🔗  ↑γ] (A : Quiver.Path🔗<|PREMISE|>🔗  ↑β ↑γ) {δ : ConNF.Λ} [inst : ConNF.LtLevel🔗<|PREMISE|>🔗  ↑δ] {ε : ConNF.Λ}\n [inst_1 : ConNF.LtLevel🔗<|PREMISE|>🔗  ↑ε] (hδ : ↑δ <  ↑γ) (hε : ↑ε <  ↑γ) (hδε : ↑δ ≠  ↑ε) {t : ConNF.Tangle  ↑δ}\n {B : ConNF.ExtendedIndex🔗<|PREMISE|>🔗  ↑δ} {N Nt : ConNF.NearLitter},\n Nt.fst =  ConNF.fuzz🔗<|PREMISE|>🔗  hδε t →\n { path := B, value := Sum.inr🔗<|PREMISE|>🔗  N } ∈  ConNF.TangleData.Tangle.support🔗<|PREMISE|>🔗  t →\n ((ξ (Quiver.Path.cons🔗<|PREMISE|>🔗  (Quiver.Path.cons🔗<|PREMISE|>🔗  A hε) ⋯)).nearLitterMap Nt).Dom →\n ((ξ (Quiver.Path.comp🔗<|PREMISE|>🔗  (Quiver.Path.cons🔗<|PREMISE|>🔗  A hδ) B)).nearLitterMap N).Dom", "code": "structure CoherentDom (ξ : StructBehaviour β) : Prop where\n  mapFlexible : ∀ (A : ExtendedIndex β) (N : NearLitter) (hN : ((ξ A).nearLitterMap N).Dom),\n    Flexible A N.1 → Flexible A (((ξ A).nearLitterMap N).get hN).1\n  atom_bot_dom : ∀ {γ : Λ} [LeLevel γ] (A : Path (β : TypeIndex) γ) {ε : Λ} [LtLevel ε]\n    (hε : (ε : TypeIndex) < γ) {a : Atom} {Nt : NearLitter},\n    Nt.1 = fuzz (bot_ne_coe (a := ε)) a →\n    ((ξ ((A.cons hε).cons (bot_lt_coe _))).nearLitterMap Nt).Dom →\n    ((ξ (A.cons (bot_lt_coe _))).atomMap a).Dom\n  atom_dom : ∀ {γ : Λ} [LeLevel γ] (A : Path (β : TypeIndex) γ)\n    {δ : Λ} [LtLevel δ] {ε : Λ} [LtLevel ε]\n    (hδ : (δ : TypeIndex) < γ) (hε : (ε : TypeIndex) < γ) (hδε : (δ : TypeIndex) ≠ ε) {t : Tangle δ}\n    {B : ExtendedIndex δ} {a : Atom} {Nt : NearLitter},\n    Nt.1 = fuzz hδε t → ⟨B, inl a⟩ ∈ t.support →\n    ((ξ ((A.cons hε).cons (bot_lt_coe _))).nearLitterMap Nt).Dom →\n    ((ξ ((A.cons hδ).comp B)).atomMap a).Dom\n  nearLitter_dom : ∀ {γ : Λ} [LeLevel γ] (A : Path (β : TypeIndex) γ)\n    {δ : Λ} [LtLevel δ] {ε : Λ} [LtLevel ε]\n    (hδ : (δ : TypeIndex) < γ) (hε : (ε : TypeIndex) < γ) (hδε : (δ : TypeIndex) ≠ ε) {t : Tangle δ}\n    {B : ExtendedIndex δ} {N Nt : NearLitter},\n    Nt.1 = fuzz hδε t → ⟨B, inr N⟩ ∈ t.support →\n    ((ξ ((A.cons hε).cons (bot_lt_coe _))).nearLitterMap Nt).Dom →\n    ((ξ ((A.cons hδ).comp B)).nearLitterMap N).Dom\n", "additional_info": "", "used_premises": [1, 828, 61, 842, 842, 402, 76, 98, 78, 301, 301, 301, 402, 76, 98, 98, 61, 78, 67, 395, 301, 301, 135, 301, 402, 76, 98, 98, 61, 78, 65, 395, 301, 301, 135, 301], "def_path": "ConNF/FOA/Corollaries.lean", "pos": [185, 207], "informalization": "The `ConNF.StructBehaviour.CoherentDom` class in Lean 4 represents the condition that a `β`-structural action is *coherent* in the context of Constructive Ordinal Notation (ConNF). This condition ensures that the construction of the natural numbers in ConNF is well-defined and consistent."}
{"full_name": "ConNF.Flexible", "url": "ConNF/FOA/Basic/Flexible.html#ConNF.Flexible", "code_src": "con-nf", "ptype": "def", "header": "def ConNF.Flexible [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.FOAAssumptions] {β : ConNF.TypeIndex} (A : ConNF.ExtendedIndex🔗<|PREMISE|>🔗 β) (L : ConNF.Litter) :Prop", "code": "def Flexible (A : ExtendedIndex β) (L : Litter) : Prop :=\n  ¬Inflexible A L\n", "additional_info": "A litter is *flexible* if it is not the image of any f-map.\nEquations\n* 🗟ConNF.Flexible🗟🔗../../.././ConNF/FOA/Basic/Flexible.html#ConNF.Flexible🔗  A L 🗟=🗟🔗../../.././Init/Prelude.html#Eq🔗  🗟¬🗟🔗../../.././Init/Prelude.html#Not🔗 🗟ConNF.Inflexible🗟🔗../../.././ConNF/FOA/Basic/Flexible.html#ConNF.Inflexible🔗  A L\n\n", "used_premises": [1, 61], "def_path": "ConNF/FOA/Basic/Flexible.lean", "pos": [24, 26], "informalization": "Function `ConNF.Flexible` checks if a given litter `L` is *flexible* in the context of Constructive Ordinal Notation (ConNF). A litter is considered *flexible* if it is not the image of any f-map. This property is crucial in ensuring that the construction of the natural numbers in ConNF is well-defined and consistent."}
{"full_name": "ConNF.StructBehaviour.action_coherent", "url": "ConNF/FOA/Corollaries.html#ConNF.StructBehaviour.action_coherent", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.StructBehaviour.action_coherent [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.FOAAssumptions] {β : ConNF.Λ} (ξ : ConNF.StructBehaviour🔗<|PREMISE|>🔗 ↑β) (h₁ : ConNF.StructBehaviour.Lawful🔗<|PREMISE|>🔗 ξ) (h₂ : ConNF.StructBehaviour.Coherent🔗<|PREMISE|>🔗 ξ) :ConNF.StructAction.Coherent🔗<|PREMISE|>🔗 (ConNF.StructBehaviour.action🔗<|PREMISE|>🔗 ξ h₁)", "code": "theorem action_coherent (ξ : StructBehaviour β) (h₁ : ξ.Lawful) (h₂ : ξ.Coherent) :\n    (ξ.action h₁).Coherent := by\n  constructor\n  case toCoherentDom => exact action_coherentDom ξ h₁ h₂\n  case coherent_coe =>\n    intro γ _ A δ _ ε _ hδ hε hδε t ht ρ hta htN hts\n    obtain ⟨Nt, hNt₁, hNt₂⟩ := (ξ _).litterPresent_of_dom (h₁ _) ht\n    have := h₂.coherent_coe A hδ hε hδε hNt₂ hNt₁ ρ ?_ ?_\n    · simp only [← this, action_litterMap, ← hNt₂,\n        NearLitterBehaviour.withLitters_nearLitterMap_fst _ hNt₁]\n      rfl\n    · intro B a ha\n      simp only [← hta B a ha, action_atomMap, NearLitterBehaviour.withLitters]\n      rw [NearLitterBehaviour.extraAtomMap_eq_of_dom]\n    · intro B N hN\n      refine NearLitter.ext ?_\n      rw [NearLitterPerm.smul_nearLitter_eq_smul_symmDiff_smul, ← htN B N hN,\n        ← symmDiff_right_inj, symmDiff_symmDiff_cancel_left]\n      have hN' := (action_coherentDom ξ h₁ h₂).nearLitter_dom A hδ hε hδε hN\n        (Or.inr ⟨⟨_⟩, Nt, hNt₁, hNt₂⟩)\n      have hN'' := h₂.nearLitter_dom A hδ hε hδε hNt₂ hN hNt₁\n      refine Eq.trans ?_ ((NearLitterBehaviour.symmDiff\n          ((ξ _).withLitters_lawful (h₁ _)) (by exact rfl) hN' (Or.inl hN'')).trans ?_)\n      · simp only [action_litterMap, symmDiff_right_inj, SetLike.coe_set_eq]\n        rw [NearLitterBehaviour.withLitters_nearLitterMap_of_dom]\n      · ext a\n        constructor\n        · simp only [Litter.coe_toNearLitter, mem_iUnion, mem_singleton_iff, forall_exists_index]\n          rintro a ha rfl\n          refine ⟨a, ha, ?_⟩\n          dsimp only\n          rw [← hts _ N a hN ha]\n          rfl\n        · simp only [Litter.coe_toNearLitter, mem_iUnion, mem_singleton_iff]\n          rintro ⟨a, ha, rfl⟩\n          refine ⟨a, ha, ?_⟩\n          dsimp only\n          rw [← hts _ N a hN ha]\n          rfl\n  case coherent_bot =>\n    intro γ _ A ε _ hδ a ha ρ hρa\n    obtain ⟨Nt, hNt₁, hNt₂⟩ := (ξ _).litterPresent_of_dom (h₁ _) ha\n    have := h₂.coherent_bot A hδ hNt₂ hNt₁ ρ ?_\n    · simp only [← hNt₂, action_litterMap, ← this]\n      rw [NearLitterBehaviour.withLitters_nearLitterMap_fst]\n      rfl\n    · rw [← hρa]\n      simp only [action_atomMap, NearLitterBehaviour.withLitters]\n      rw [NearLitterBehaviour.extraAtomMap_eq_of_dom]\n", "additional_info": "", "used_premises": [1, 828, 829, 840, 812, 830], "def_path": "ConNF/FOA/Corollaries.lean", "pos": [372, 421], "informalization": "The theorem `ConNF.StructBehaviour.action_coherent` states that if `ξ` is a `β`-structural action that is lawful and coherent, then the `β`-structural action `ConNF.StructBehaviour.action ξ h₁` is also coherent."}
{"full_name": "ConNF.StructBehaviour.freedom_of_action", "url": "ConNF/FOA/Corollaries.html#ConNF.StructBehaviour.freedom_of_action", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.StructBehaviour.freedom_of_action [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.FOAAssumptions] {β : ConNF.Λ} [ConNF.LeLevel🔗<|PREMISE|>🔗 ↑β] (ξ : ConNF.StructBehaviour🔗<|PREMISE|>🔗 ↑β) (h₁ : ConNF.StructBehaviour.Lawful🔗<|PREMISE|>🔗 ξ) (h₂ : ConNF.StructBehaviour.Coherent🔗<|PREMISE|>🔗 ξ) :∃ (ρ : ConNF.Allowable ↑β), ConNF.StructBehaviour.Approximates🔗<|PREMISE|>🔗 ξ (ConNF.Allowable.toStructPerm ρ)", "code": "theorem freedom_of_action (ξ : StructBehaviour β) (h₁ : ξ.Lawful) (h₂ : ξ.Coherent) :\n    ∃ ρ : Allowable β, ξ.Approximates (Allowable.toStructPerm ρ) := by\n  obtain ⟨ρ, hρ⟩ := (ξ.action h₁).freedom_of_action (ξ.action_lawful h₁) (ξ.action_coherent h₁ h₂)\n  exact ⟨ρ, ξ.action_approximates h₁ _ hρ⟩\n", "additional_info": "", "used_premises": [1, 402, 828, 829, 840, 836], "def_path": "ConNF/FOA/Corollaries.lean", "pos": [422, 426], "informalization": "This is the theorem that establishes the \"Freedom of Action\" in the context of Constructive Ordinal Notation (ConNF). It states that for any lawful $\\beta$-structural action $\\xi$, there exists a $\\beta$-allowable $\\beta$-structural permutation $\\rho$ such that $\\xi$ approximates $\\rho$. This theorem is crucial in ensuring the consistency and well-definedness of the construction of natural numbers in ConNF."}
{"full_name": "ConNF.Allowable.comp_nil", "url": "ConNF/FOA/Basic/Hypotheses.html#ConNF.Allowable.comp_nil", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.Allowable.comp_nil [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.FOAAssumptions] {β : ConNF.TypeIndex} [ConNF.LeLevel🔗<|PREMISE|>🔗 β] :ConNF.Allowable.comp🔗<|PREMISE|>🔗 Quiver.Path.nil = MonoidHom.id🔗<|PREMISE|>🔗 (ConNF.Allowable β)", "code": "theorem Allowable.comp_nil {β : TypeIndex} [LeLevel β] :\n    Allowable.comp (Quiver.Path.nil : Quiver.Path β β) = MonoidHom.id _ :=\n  rfl\n", "additional_info": "", "used_premises": [1, 402, 815, 846], "def_path": "ConNF/FOA/Basic/Hypotheses.lean", "pos": [142, 145], "informalization": "Function `ConNF.Allowable.comp` defines a monoid homomorphism from the set of allowable permutations at level `β` to the set of allowable permutations at level `γ`, where `β` and `γ` are type indices in the context of Constructive Ordinal Notation (ConNF), and `β` is less than or equal to `γ`. The function is defined recursively along a path `A` from `β` to `γ`. When the path `A` is empty (i.e., `Quiver.Path.nil`), the function `ConNF.Allowable.comp` simplifies to the identity monoid homomorphism `MonoidHom.id`, which maps each element to itself."}
{"full_name": "MonoidHom.id", "url": "Mathlib/Algebra/Group/Hom/Defs.html#MonoidHom.id", "code_src": "mathlib4", "ptype": "def", "header": "def MonoidHom.id (M : Type u_10) [MulOneClass🔗<|PREMISE|>🔗 M] :M →* M", "code": "def MonoidHom.id (M : Type*) [MulOneClass M] : M →* M where\n  toFun x := x\n  map_one' := rfl\n  map_mul' _ _ := rfl\n", "additional_info": "The identity map from a monoid to itself.\nEquations\n* 🗟MonoidHom.id🗟🔗../../../.././Mathlib/Algebra/Group/Hom/Defs.html#MonoidHom.id🔗  M 🗟=🗟🔗../../../.././Init/Prelude.html#Eq🔗  { toOneHom := { toFun := fun (x : M) => x, map_one' := ⋯ }, map_mul' := ⋯ }\n\n", "used_premises": [847], "def_path": "Mathlib/Algebra/Group/Hom/Defs.lean", "pos": [881, 885], "informalization": "Function `MonoidHom.id` is a monoid homomorphism from a monoid `M` to itself, which maps each element to itself."}
{"full_name": "MulOneClass", "url": "Mathlib/Algebra/Group/Defs.html#MulOneClass", "code_src": "mathlib4", "ptype": "class", "header": "class MulOneClass (M : Type u) extends One🔗<|PREMISE|>🔗 , Mul🔗<|PREMISE|>🔗 :Type u\n | one : M\n | mul : M → M → M\n | one_mul : ∀ (a : M), 1 *  a =  a\n | mul_one : ∀ (a : M), a *  1 =  a", "code": "class MulOneClass (M : Type u) extends One M, Mul M where\n  /-- One is a left neutral element for multiplication -/\n  protected one_mul : ∀ a : M, 1 * a = a\n  /-- One is a right neutral element for multiplication -/\n  protected mul_one : ∀ a : M, a * 1 = a\n", "additional_info": "Typeclass for expressing that a type `M` with multiplication and a one satisfies\n`1 * a = a` and `a * 1 = a` for all `a : M`.\n- MulOneClass.one_mul: One is a left neutral element for multiplication\n\n\n- MulOneClass.mul_one: One is a right neutral element for multiplication\n\n\n", "used_premises": [45, 44], "def_path": "Mathlib/Algebra/Group/Defs.lean", "pos": [440, 445], "informalization": "Class `MulOneClass` represents the concept of a type `M` that has both a multiplicative identity element (denoted as `1`) and a multiplication operation. This algebraic structure ensures that for any element `a` in `M`, the identity element `1` acts as a neutral element for multiplication, meaning `1 * a = a` and `a * 1 = a`. This is formalized through the properties `one_mul` and `mul_one`, which respectively assert that `1` is a left and right neutral element for multiplication. In essence, `MulOneClass` defines a type where multiplication is unital, i.e., it has an identity element that does not change the value of any element when multiplied by it, either on the left or the right. This class is foundational for many algebraic structures that require a multiplicative identity, such as monoids, groups, and rings."}
{"full_name": "ConNF.Allowable.comp_eq", "url": "ConNF/FOA/Basic/Hypotheses.html#ConNF.Allowable.comp_eq", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.Allowable.comp_eq [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.FOAAssumptions] {β : ConNF.TypeIndex} {γ : ConNF.TypeIndex} [ConNF.LeLevel🔗<|PREMISE|>🔗 β] [ConNF.LeLevel🔗<|PREMISE|>🔗 γ] (h : γ < β) :ConNF.allowableCons h = ConNF.Allowable.comp🔗<|PREMISE|>🔗 (Quiver.Path.cons🔗<|PREMISE|>🔗 Quiver.Path.nil h)", "code": "theorem Allowable.comp_eq {β γ : TypeIndex} [LeLevel β] [LeLevel γ] (h : γ < β) :\n    allowableCons h = Allowable.comp (Quiver.Path.nil.cons h) :=\n  rfl\n", "additional_info": "", "used_premises": [1, 402, 402, 815, 301], "def_path": "ConNF/FOA/Basic/Hypotheses.lean", "pos": [147, 150], "informalization": "Function `ConNF.Allowable.comp` defines a monoid homomorphism from the set of allowable permutations at level `β` to the set of allowable permutations at level `γ`, where `β` and `γ` are type indices in the context of Constructive Ordinal Notation (ConNF), and `β` is less than or equal to `γ`. The function is defined recursively along a path `A` from `β` to `γ`. The theorem `ConNF.Allowable.comp_eq` states that when `γ < β`, the function `ConNF.allowableCons` is equal to `ConNF.Allowable.comp` applied to the path consisting of a single arrow from `γ` to `β`."}
{"full_name": "ConNF.Allowable.comp_cons", "url": "ConNF/FOA/Basic/Hypotheses.html#ConNF.Allowable.comp_cons", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.Allowable.comp_cons [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.FOAAssumptions] {β : ConNF.TypeIndex} {γ : ConNF.TypeIndex} {δ : ConNF.TypeIndex} [ConNF.LeLevel🔗<|PREMISE|>🔗 β] [ConNF.LeLevel🔗<|PREMISE|>🔗 γ] [ConNF.LeLevel🔗<|PREMISE|>🔗 δ] (A : Quiver.Path🔗<|PREMISE|>🔗 β γ) (h : δ < γ) :MonoidHom.comp🔗<|PREMISE|>🔗 (ConNF.allowableCons h) (ConNF.Allowable.comp🔗<|PREMISE|>🔗 A) = ConNF.Allowable.comp🔗<|PREMISE|>🔗 (Quiver.Path.cons🔗<|PREMISE|>🔗 A h)", "code": "theorem Allowable.comp_cons {β γ δ : TypeIndex} [LeLevel β] [LeLevel γ] [LeLevel δ]\n    (A : Quiver.Path β γ) (h : δ < γ) :\n    (allowableCons h).comp (Allowable.comp A) = Allowable.comp (A.cons h) :=\n  rfl\n", "additional_info": "", "used_premises": [1, 402, 402, 402, 76, 850, 815, 815, 301], "def_path": "ConNF/FOA/Basic/Hypotheses.lean", "pos": [152, 156], "informalization": "In the context of Constructive Ordinal Notation (ConNF), the function `ConNF.Allowable.comp` defines a monoid homomorphism from the set of allowable permutations at level `β` to the set of allowable permutations at level `γ`, where `β` and `γ` are type indices in the context of ConNF, and `β` is less than or equal to `γ`. This function is defined recursively along a path `A` from `β` to `γ`. The theorem `ConNF.Allowable.comp_cons` states that the composition of the monoid homomorphism `ConNF.Allowable.comp` with the monoid homomorphism `ConNF.allowableCons` is equal to the monoid homomorphism `ConNF.Allowable.comp` applied to the path `A` extended by the arrow `h`."}
{"full_name": "MonoidHom.comp", "url": "Mathlib/Algebra/Group/Hom/Defs.html#MonoidHom.comp", "code_src": "mathlib4", "ptype": "def", "header": "def MonoidHom.comp {M : Type u_4} {N : Type u_5} {P : Type u_6} [MulOneClass🔗<|PREMISE|>🔗 M] [MulOneClass🔗<|PREMISE|>🔗 N] [MulOneClass🔗<|PREMISE|>🔗 P] (hnp : N →* P) (hmn : M →* N) :M →* P", "code": "def MonoidHom.comp [MulOneClass M] [MulOneClass N] [MulOneClass P] (hnp : N →* P) (hmn : M →* N) :\n    M →* P where\n  toFun := hnp ∘ hmn\n  map_one' := by simp\n  map_mul' := by simp\n", "additional_info": "Composition of monoid morphisms as a monoid morphism.\nEquations\n* 🗟MonoidHom.comp🗟🔗../../../.././Mathlib/Algebra/Group/Hom/Defs.html#MonoidHom.comp🔗  hnp hmn 🗟=🗟🔗../../../.././Init/Prelude.html#Eq🔗  { toOneHom := { toFun := ⇑hnp 🗟∘🗟🔗../../../.././Init/Prelude.html#Function.comp🔗  ⇑hmn, map_one' := ⋯ }, map_mul' := ⋯ }\n\n", "used_premises": [847, 847, 847], "def_path": "Mathlib/Algebra/Group/Hom/Defs.lean", "pos": [908, 913], "informalization": "Function `MonoidHom.comp` defines the composition of two monoid homomorphisms. Given two monoid homomorphisms `hnp : N →* P` and `hmn : M →* N`, the composition `hnp.comp hmn` is a monoid homomorphism from `M` to `P`."}
{"full_name": "ConNF.Allowable.comp_cons_apply", "url": "ConNF/FOA/Basic/Hypotheses.html#ConNF.Allowable.comp_cons_apply", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.Allowable.comp_cons_apply [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.FOAAssumptions] {β : ConNF.TypeIndex} {γ : ConNF.TypeIndex} {δ : ConNF.TypeIndex} [ConNF.LeLevel🔗<|PREMISE|>🔗 β] [ConNF.LeLevel🔗<|PREMISE|>🔗 γ] [ConNF.LeLevel🔗<|PREMISE|>🔗 δ] (A : Quiver.Path🔗<|PREMISE|>🔗 β γ) (h : δ < γ) (π : ConNF.Allowable β) :(ConNF.allowableCons h) ((ConNF.Allowable.comp🔗<|PREMISE|>🔗 A) π) = (ConNF.Allowable.comp🔗<|PREMISE|>🔗 (Quiver.Path.cons🔗<|PREMISE|>🔗 A h)) π", "code": "theorem Allowable.comp_cons_apply {β γ δ : TypeIndex} [LeLevel β] [LeLevel γ] [LeLevel δ]\n    (A : Quiver.Path β γ) (h : δ < γ) (π : Allowable β) :\n    allowableCons h (Allowable.comp A π) = Allowable.comp (A.cons h) π :=\n  rfl\n", "additional_info": "", "used_premises": [1, 402, 402, 402, 76, 815, 815, 301], "def_path": "ConNF/FOA/Basic/Hypotheses.lean", "pos": [158, 162], "informalization": "The function `ConNF.Allowable.comp` defines a monoid homomorphism from the set of allowable permutations at level `β` to the set of allowable permutations at level `γ`, where `β` and `γ` are type indices in the context of Constructive Ordinal Notation (ConNF), and `β` is less than or equal to `γ`. The function is defined recursively along a path `A` from `β` to `γ`. The theorem `ConNF.Allowable.comp_cons_apply` states that for a path `A` from `β` to `γ` and an arrow `h` from `γ` to `δ`, the composition of `ConNF.Allowable.comp A` with `ConNF.Allowable.cons h` is equal to `ConNF.Allowable.comp (Quiver.Path.cons A h)`."}
{"full_name": "ConNF.Allowable.comp_comp_apply", "url": "ConNF/FOA/Basic/Hypotheses.html#ConNF.Allowable.comp_comp_apply", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.Allowable.comp_comp_apply [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.FOAAssumptions] {β : ConNF.TypeIndex} {γ : ConNF.TypeIndex} {δ : ConNF.TypeIndex} [ConNF.LeLevel🔗<|PREMISE|>🔗 β] [ConNF.LeLevel🔗<|PREMISE|>🔗 γ] [i : ConNF.LeLevel🔗<|PREMISE|>🔗 δ] (A : Quiver.Path🔗<|PREMISE|>🔗 β γ) (B : Quiver.Path🔗<|PREMISE|>🔗 γ δ) (π : ConNF.Allowable β) :(ConNF.Allowable.comp🔗<|PREMISE|>🔗 B) ((ConNF.Allowable.comp🔗<|PREMISE|>🔗 A) π) = (ConNF.Allowable.comp🔗<|PREMISE|>🔗 (Quiver.Path.comp🔗<|PREMISE|>🔗 A B)) π", "code": "theorem Allowable.comp_comp_apply {β γ δ : TypeIndex} [LeLevel β] [LeLevel γ] [i : LeLevel δ]\n    (A : Quiver.Path β γ) (B : Quiver.Path γ δ) (π : Allowable β) :\n    Allowable.comp B (Allowable.comp A π) = Allowable.comp (A.comp B) π := by\n  revert i\n  induction B with\n  | nil =>\n      intro\n      rfl\n  | cons B h ih =>\n      intro\n      have : LeLevel _ := ⟨(le_of_path B).trans LeLevel.elim⟩\n      simp_rw [Quiver.Path.comp_cons, ← comp_cons_apply (A.comp B) h, ← ih]\n      rfl\n", "additional_info": "", "used_premises": [1, 402, 402, 402, 76, 76, 815, 815, 815, 135], "def_path": "ConNF/FOA/Basic/Hypotheses.lean", "pos": [164, 177], "informalization": "Function `ConNF.Allowable.comp` defines a monoid homomorphism from the set of allowable permutations at level `β` to the set of allowable permutations at level `γ`, where `β` and `γ` are type indices in the context of Constructive Ordinal Notation (ConNF), and `β` is less than or equal to `γ`. The function is defined recursively along a path `A` from `β` to `γ`. The theorem `ConNF.Allowable.comp_comp_apply` states that the composition of two such homomorphisms, corresponding to paths `A` and `B` respectively, is equal to the homomorphism corresponding to the composition of the paths `A` and `B`."}
{"full_name": "ConNF.Allowable.toStructPerm_comp", "url": "ConNF/FOA/Basic/Hypotheses.html#ConNF.Allowable.toStructPerm_comp", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.Allowable.toStructPerm_comp [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.FOAAssumptions] {β : ConNF.TypeIndex} {γ : ConNF.TypeIndex} [ConNF.LeLevel🔗<|PREMISE|>🔗 β] [i : ConNF.LeLevel🔗<|PREMISE|>🔗 γ] (A : Quiver.Path🔗<|PREMISE|>🔗 β γ) (π : ConNF.Allowable β) :ConNF.Allowable.toStructPerm ((ConNF.Allowable.comp🔗<|PREMISE|>🔗 A) π) = ConNF.Tree.comp🔗<|PREMISE|>🔗 A (ConNF.Allowable.toStructPerm π)", "code": "theorem Allowable.toStructPerm_comp {β γ : TypeIndex} [LeLevel β] [i : LeLevel γ]\n    (A : Quiver.Path β γ) (π : Allowable β) :\n    Allowable.toStructPerm (Allowable.comp A π) = Tree.comp A (Allowable.toStructPerm π) := by\n  revert i\n  induction A with\n  | nil =>\n      intro i\n      rw [Tree.comp_nil, Allowable.comp_nil, MonoidHom.id_apply]\n  | cons A h ih =>\n      intro i\n      have : LeLevel _ := ⟨(le_of_path A).trans LeLevel.elim⟩\n      change toStructPerm (allowableCons _ (comp _ π)) = _\n      rw [Tree.comp_cons, ← allowableCons_eq, ih]\n      rfl\n", "additional_info": "", "used_premises": [1, 402, 402, 76, 815, 304], "def_path": "ConNF/FOA/Basic/Hypotheses.lean", "pos": [179, 193], "informalization": "Function `ConNF.Allowable.comp` defines a monoid homomorphism from the set of allowable permutations at level `β` to the set of allowable permutations at level `γ`, where `β` and `γ` are type indices in the context of Constructive Ordinal Notation (ConNF), and `β` is less than or equal to `γ`. The function is defined recursively along a path `A` from `β` to `γ`. Given a path `A` from type index `β` to type index `γ` and an `α`-tree `a` of type `τ`, it returns a `β`-tree of type `τ` by applying `a` to the composition of `A` with any `β`-extended type index `B`."}
{"full_name": "ConNF.Allowable.toStructPerm_apply", "url": "ConNF/FOA/Basic/Hypotheses.html#ConNF.Allowable.toStructPerm_apply", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.Allowable.toStructPerm_apply [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.FOAAssumptions] {β : ConNF.TypeIndex} [ConNF.LeLevel🔗<|PREMISE|>🔗 β] (A : Quiver.Path🔗<|PREMISE|>🔗 β ⊥ ) (π : ConNF.Allowable β) :NearLitterPerm.ofBot ((ConNF.Allowable.comp🔗<|PREMISE|>🔗 A) π) = ConNF.Allowable.toStructPerm π A", "code": "theorem Allowable.toStructPerm_apply {β : TypeIndex} [LeLevel β]\n    (A : Quiver.Path β ⊥) (π : Allowable β) :\n    NearLitterPerm.ofBot (Allowable.comp A π) = Allowable.toStructPerm π A :=\n  congr_fun (Allowable.toStructPerm_comp A π) Quiver.Path.nil\n", "additional_info": "", "used_premises": [1, 402, 76, 815], "def_path": "ConNF/FOA/Basic/Hypotheses.lean", "pos": [195, 199], "informalization": "The function `ConNF.Allowable.comp` defines a monoid homomorphism from the set of allowable permutations at level `β` to the set of allowable permutations at level `γ`, where `β` and `γ` are type indices in the context of Constructive Ordinal Notation (ConNF), and `β` is less than or equal to `γ`. The function is defined recursively along a path `A` from `β` to `γ`. The theorem `ConNF.Allowable.toStructPerm_apply` states that the application of the function `ConNF.Allowable.comp` to an allowable permutation `π` at level `β` and a path `A` from `β` to `γ` is equal to the application of the function `ConNF.Allowable.toStructPerm` to `π` and `A`."}
{"full_name": "ConNF.Allowable.comp_bot", "url": "ConNF/FOA/Basic/Hypotheses.html#ConNF.Allowable.comp_bot", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.Allowable.comp_bot [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.FOAAssumptions] {β : ConNF.TypeIndex} [ConNF.LeLevel🔗<|PREMISE|>🔗 β] (A : Quiver.Path🔗<|PREMISE|>🔗 β ⊥ ) (ρ : ConNF.Allowable β) :(ConNF.Allowable.comp🔗<|PREMISE|>🔗 A) ρ = ConNF.Allowable.toStructPerm ρ A", "code": "theorem Allowable.comp_bot {β : TypeIndex} [LeLevel β] (A : Quiver.Path β ⊥) (ρ : Allowable β) :\n    Allowable.comp A ρ = Allowable.toStructPerm ρ A := by\n  refine NearLitterPerm.ext ?_\n  ext a : 1\n  change NearLitterPerm.ofBot (Allowable.comp A ρ) • a = Allowable.toStructPerm ρ A • a\n  simp only [Allowable.toStructPerm_apply]\n", "additional_info": "", "used_premises": [1, 402, 76, 815], "def_path": "ConNF/FOA/Basic/Hypotheses.lean", "pos": [200, 206], "informalization": "Function `ConNF.Allowable.comp` defines a monoid homomorphism from the set of allowable permutations at level `β` to the set of allowable permutations at level `γ`, where `β` and `γ` are type indices in the context of Constructive Ordinal Notation (ConNF), and `β` is less than or equal to `γ`. The function is defined recursively along a path `A` from `β` to `γ`. The theorem `ConNF.Allowable.comp_bot` states that for a path `A` from `β` to the bottom level `⊥`, the function `ConNF.Allowable.comp A` applied to an allowable permutation `ρ` at level `β` is equal to the structure permutation of `ρ` along the path `A`."}
{"full_name": "ConNF.smul_mem_support", "url": "ConNF/FOA/Basic/Hypotheses.html#ConNF.smul_mem_support", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.smul_mem_support [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.FOAAssumptions] {β : ConNF.Λ} [ConNF.LtLevel🔗<|PREMISE|>🔗 ↑β] {c : ConNF.Address🔗<|PREMISE|>🔗 ↑β} {t : ConNF.Tangle ↑β} (h : c ∈ ConNF.TangleData.Tangle.support🔗<|PREMISE|>🔗 t) (π : ConNF.Allowable ↑β) :π • c ∈ ConNF.TangleData.Tangle.support🔗<|PREMISE|>🔗 (π • t)", "code": "theorem smul_mem_support {β : Λ} [LtLevel β] {c : Address β} {t : Tangle β}\n    (h : c ∈ t.support) (π : Allowable β) : π • c ∈ (π • t).support := by\n  rw [smul_support]\n  simp only [Support.mem_iff, Allowable.smul_support_f, smul_left_cancel_iff,\n    Allowable.smul_support_max] at h ⊢\n  exact h\n", "additional_info": "", "used_premises": [1, 98, 60, 395, 395], "def_path": "ConNF/FOA/Basic/Hypotheses.lean", "pos": [207, 213], "informalization": "The theorem `ConNF.smul_mem_support` is a result in the context of Constructive Ordinal Notation (ConNF), which represents a specific type of ordinal notation. It states that if an element `c` is in the support of a tangle `t`, then applying a permutation `π` to both `c` and `t` results in the permuted element being in the support of the permuted tangle. This theorem is crucial for ensuring that the set of addresses being enumerated by each tangle is closed under permutations, which is a key property for proving the correctness of the ConNF system."}
{"full_name": "ConNF.NearLitterPerm.ofBot_comp'", "url": "ConNF/FOA/Basic/Hypotheses.html#ConNF.NearLitterPerm.ofBot_comp'", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.NearLitterPerm.ofBot_comp' [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.FOAAssumptions] {β : ConNF.TypeIndex} [ConNF.LeLevel🔗<|PREMISE|>🔗 β] {hβ : ⊥ < β} {ρ : ConNF.Allowable β} :NearLitterPerm.ofBot ((ConNF.allowableCons hβ) ρ) = ConNF.Allowable.toStructPerm ρ (Quiver.Hom.toPath🔗<|PREMISE|>🔗 hβ)", "code": "theorem NearLitterPerm.ofBot_comp' {β : TypeIndex} [LeLevel β] {hβ : ⊥ < β} {ρ : Allowable β} :\n    NearLitterPerm.ofBot (allowableCons hβ ρ) = Allowable.toStructPerm ρ (Quiver.Hom.toPath hβ) :=\n  (congr_fun (allowableCons_eq β ⊥ hβ ρ) Quiver.Path.nil).symm\n", "additional_info": "", "used_premises": [1, 402, 74], "def_path": "ConNF/FOA/Basic/Hypotheses.lean", "pos": [215, 218], "informalization": "Function `ConNF.NearLitterPerm.ofBot_comp'` simplifies the composition of `ConNF.NearLitterPerm.ofBot` with `ConNF.Allowable.toStructPerm` and `Quiver.Hom.toPath` in the context of Constructive Ordinal Notation (ConNF)."}
{"full_name": "ConNF.exists_cons_of_length_ne_zero", "url": "ConNF/FOA/Basic/Hypotheses.html#ConNF.exists_cons_of_length_ne_zero", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.exists_cons_of_length_ne_zero {V : Type u_1} [Quiver🔗<|PREMISE|>🔗 V] {x : V} {y : V} (p : Quiver.Path🔗<|PREMISE|>🔗 x y) (h : Quiver.Path.length🔗<|PREMISE|>🔗 p ≠ 0) :∃ (t : V) (q : Quiver.Path🔗<|PREMISE|>🔗 x t) (e : t ⟶ y), p = Quiver.Path.cons🔗<|PREMISE|>🔗 q e", "code": "theorem exists_cons_of_length_ne_zero {V : Type _} [Quiver V] {x y : V}\n    (p : Quiver.Path x y) (h : p.length ≠ 0) :\n    ∃ t : V, ∃ q : Quiver.Path x t, ∃ e : t ⟶ y, p = q.cons e := by\n  cases p\n  · cases h rfl\n  · exact ⟨_, _, _, rfl⟩\n", "additional_info": "", "used_premises": [75, 76, 137, 76, 301], "def_path": "ConNF/FOA/Basic/Hypotheses.lean", "pos": [219, 225], "informalization": "Given a path `p` from `x` to `y` in a quiver `V`, if the length of `p` is not zero, then there exists a vertex `t`, a path `q` from `x` to `t`, and an arrow `e` from `t` to `y` such that `p` is the concatenation of `q` and `e`."}
{"full_name": "ConNF.ofBot_smul", "url": "ConNF/FOA/Basic/Hypotheses.html#ConNF.ofBot_smul", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.ofBot_smul [ConNF.Params🔗<|PREMISE|>🔗 ] {X : Type u_1} [MulAction🔗<|PREMISE|>🔗 ConNF.NearLitterPerm X] (π : ConNF.Allowable ⊥ ) (x : X) :π • x = NearLitterPerm.ofBot π • x", "code": "theorem ofBot_smul {X : Type _} [MulAction NearLitterPerm X] (π : Allowable ⊥) (x : X) :\n    π • x = NearLitterPerm.ofBot π • x :=\n  rfl\n", "additional_info": "", "used_premises": [1, 56], "def_path": "ConNF/FOA/Basic/Hypotheses.lean", "pos": [227, 230], "informalization": "The theorem `ConNF.ofBot_smul` states that in the context of Constructive Ordinal Notation (ConNF), the action of a `ConNF.Allowable` element `π` on an element `x` of a type `X` that is a `MulAction` of `ConNF.NearLitterPerm` is equivalent to the action of `NearLitterPerm.ofBot π` on `x`."}
{"full_name": "ConNF.Sublitter.mk_S_eq_κ", "url": "ConNF/FOA/Basic/Sublitter.html#ConNF.Sublitter.mk_S_eq_κ", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.Sublitter.mk_S_eq_κ [ConNF.Params🔗<|PREMISE|>🔗 ] (S : ConNF.Sublitter) :Cardinal.mk🔗<|PREMISE|>🔗 ↑S.carrier = Cardinal.mk🔗<|PREMISE|>🔗 ConNF.κ", "code": "theorem mk_S_eq_κ (S : Sublitter) : #S.carrier = #κ := by\n  have := mk_le_mk_of_subset S.subset\n  rw [mk_litterSet] at this\n  obtain (h | h) := lt_or_eq_of_le this\n  · have := mk_diff_add_mk S.subset\n    rw [mk_litterSet] at this\n    cases (add_lt_of_lt Params.κ_isRegular.aleph0_le S.diff_small h).ne this\n  · exact h\n", "additional_info": "Use sublitter.mk_eq_κ instead if possible.", "used_premises": [1, 29, 29], "def_path": "ConNF/FOA/Basic/Sublitter.lean", "pos": [24, 32], "informalization": "The theorem `ConNF.Sublitter.mk_S_eq_κ` states that for any sublitter `S` in the context of Constructive Ordinal Notation (ConNF), the cardinality of the set `S.carrier` is equal to the cardinality of the type `ConNF.κ`."}
{"full_name": "ConNF.Sublitter.mk_eq_κ", "url": "ConNF/FOA/Basic/Sublitter.html#ConNF.Sublitter.mk_eq_κ", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.Sublitter.mk_eq_κ [ConNF.Params🔗<|PREMISE|>🔗 ] (S : ConNF.Sublitter) :Cardinal.mk🔗<|PREMISE|>🔗 ↥S = Cardinal.mk🔗<|PREMISE|>🔗 ConNF.κ", "code": "theorem mk_eq_κ (S : Sublitter) : #S = #κ :=\n  S.mk_S_eq_κ\n", "additional_info": "", "used_premises": [1, 29, 29], "def_path": "ConNF/FOA/Basic/Sublitter.lean", "pos": [46, 48], "informalization": "In the context of Constructive Ordinal Notation (ConNF), given a sublitter `S`, the cardinality of `S` is equal to the cardinality of `κ`."}
{"full_name": "ConNF.Sublitter.mk_eq_κ'", "url": "ConNF/FOA/Basic/Sublitter.html#ConNF.Sublitter.mk_eq_κ'", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.Sublitter.mk_eq_κ' [ConNF.Params🔗<|PREMISE|>🔗 ] (S : ConNF.Sublitter) :Cardinal.mk🔗<|PREMISE|>🔗 ↑↑S = Cardinal.mk🔗<|PREMISE|>🔗 ConNF.κ", "code": "theorem mk_eq_κ' (S : Sublitter) : #(S : Set Atom) = #κ :=\n  S.mk_S_eq_κ\n", "additional_info": "", "used_premises": [1, 29, 29], "def_path": "ConNF/FOA/Basic/Sublitter.lean", "pos": [50, 52], "informalization": "The theorem `ConNF.Sublitter.mk_eq_κ'` states that the cardinality of any sublitter `S` in the context of Constructive Ordinal Notation (ConNF) is equal to the cardinality of the type `ConNF.κ`."}
{"full_name": "ConNF.Sublitter.carrier_eq_coe", "url": "ConNF/FOA/Basic/Sublitter.html#ConNF.Sublitter.carrier_eq_coe", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.Sublitter.carrier_eq_coe [ConNF.Params🔗<|PREMISE|>🔗 ] {S : ConNF.Sublitter} :S.carrier = ↑S", "code": "theorem carrier_eq_coe {S : Sublitter} : S.carrier = S :=\n  rfl\n", "additional_info": "", "used_premises": [1], "def_path": "ConNF/FOA/Basic/Sublitter.lean", "pos": [54, 56], "informalization": "The `ConNF.Params` class in Lean 4 defines a set of parameters that are used in the construction of the natural numbers in the context of Constructive Ordinal Notation (ConNF). These parameters include the types `Λ`, `κ`, and `μ`, along with various properties and relationships between these types, such as linear orders, well-orders, zero elements, successor orders, and subtraction operations. Additionally, there are conditions on the cardinalities of these types and their cofinalities. The theorem `ConNF.Sublitter.carrier_eq_coe` states that the carrier of a sublitter `S` is equal to the coercion of `S`."}
{"full_name": "ConNF.Sublitter.ext", "url": "ConNF/FOA/Basic/Sublitter.html#ConNF.Sublitter.ext", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.Sublitter.ext [ConNF.Params🔗<|PREMISE|>🔗 ] {S₁ : ConNF.Sublitter} {S₂ : ConNF.Sublitter} (h : ↑S₁ = ↑S₂) :S₁ = S₂", "code": "theorem ext (h : (S₁ : Set Atom) = S₂) : S₁ = S₂ :=\n  SetLike.coe_injective h\n", "additional_info": "", "used_premises": [1], "def_path": "ConNF/FOA/Basic/Sublitter.lean", "pos": [63, 65], "informalization": "Function `ConNF.Sublitter.ext` is an extensionality theorem for the `ConNF.Sublitter` structure in Lean 4. It states that two `ConNF.Sublitter` objects are equal if their underlying sets are equal."}
{"full_name": "ConNF.Sublitter.fst_eq_of_mem", "url": "ConNF/FOA/Basic/Sublitter.html#ConNF.Sublitter.fst_eq_of_mem", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.Sublitter.fst_eq_of_mem [ConNF.Params🔗<|PREMISE|>🔗 ] {S : ConNF.Sublitter} {a : ConNF.Atom} (h : a ∈ S) :a.1 = S.litter", "code": "theorem fst_eq_of_mem {a : Atom} (h : a ∈ S) : a.1 = S.litter :=\n  S.subset h\n", "additional_info": "", "used_premises": [1], "def_path": "ConNF/FOA/Basic/Sublitter.lean", "pos": [66, 68], "informalization": "In the context of Constructive Ordinal Notation (ConNF), given a sublitter `S` and an atom `a` that belongs to `S`, the first component of `a` is equal to the litter of `S`."}
{"full_name": "ConNF.Sublitter.mem_litterSet_of_mem", "url": "ConNF/FOA/Basic/Sublitter.html#ConNF.Sublitter.mem_litterSet_of_mem", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.Sublitter.mem_litterSet_of_mem [ConNF.Params🔗<|PREMISE|>🔗 ] {S : ConNF.Sublitter} {a : ConNF.Atom} (h : a ∈ S) :a ∈ ConNF.litterSet🔗<|PREMISE|>🔗 S.litter", "code": "theorem mem_litterSet_of_mem {a : Atom} (h : a ∈ S) : a ∈ litterSet S.litter :=\n  S.subset h\n", "additional_info": "", "used_premises": [1, 467], "def_path": "ConNF/FOA/Basic/Sublitter.lean", "pos": [69, 71], "informalization": "The theorem `ConNF.Sublitter.mem_litterSet_of_mem` states that if an atom `a` belongs to a sublitter `S`, then `a` also belongs to the litter set of `S`."}
{"full_name": "ConNF.Sublitter.litter_diff_eq", "url": "ConNF/FOA/Basic/Sublitter.html#ConNF.Sublitter.litter_diff_eq", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.Sublitter.litter_diff_eq [ConNF.Params🔗<|PREMISE|>🔗 ] (S : ConNF.Sublitter) :↑S \\ ConNF.litterSet🔗<|PREMISE|>🔗 S.litter = ∅", "code": "theorem litter_diff_eq (S : Sublitter) : (S : Set Atom) \\ litterSet S.litter = ∅ :=\n  Set.eq_empty_of_forall_not_mem fun _ ha => ha.2 (S.subset ha.1)\n", "additional_info": "", "used_premises": [1, 467], "def_path": "ConNF/FOA/Basic/Sublitter.lean", "pos": [78, 80], "informalization": "The theorem `ConNF.Sublitter.litter_diff_eq` states that for any sublitter `S` in the context of Constructive Ordinal Notation (ConNF), the set difference between `S` and the litter set corresponding to `S`'s litter is the empty set."}
{"full_name": "ConNF.Sublitter.isNearLitter", "url": "ConNF/FOA/Basic/Sublitter.html#ConNF.Sublitter.isNearLitter", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.Sublitter.isNearLitter [ConNF.Params🔗<|PREMISE|>🔗 ] (S : ConNF.Sublitter) :ConNF.IsNearLitter🔗<|PREMISE|>🔗 S.litter ↑S", "code": "theorem isNearLitter (S : Sublitter) : IsNearLitter S.litter S := by\n  refine Small.union S.diff_small ?_\n  rw [litter_diff_eq]\n  exact small_empty\n", "additional_info": "", "used_premises": [1, 466], "def_path": "ConNF/FOA/Basic/Sublitter.lean", "pos": [81, 85], "informalization": "The theorem `ConNF.Sublitter.isNearLitter` states that for any sublitter `S` in the context of Constructive Ordinal Notation (ConNF), the set `S` is near the litter `S.litter`. This means that the set `S` has a small symmetric difference with the litter set of `S.litter`."}
{"full_name": "ConNF.Sublitter.toNearLitter_litter", "url": "ConNF/FOA/Basic/Sublitter.html#ConNF.Sublitter.toNearLitter_litter", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.Sublitter.toNearLitter_litter [ConNF.Params🔗<|PREMISE|>🔗 ] (S : ConNF.Sublitter) :(ConNF.Sublitter.toNearLitter🔗<|PREMISE|>🔗 S).fst = S.litter", "code": "theorem toNearLitter_litter (S : Sublitter) : S.toNearLitter.1 = S.litter :=\n  rfl\n", "additional_info": "", "used_premises": [1, 870], "def_path": "ConNF/FOA/Basic/Sublitter.lean", "pos": [90, 92], "informalization": "The function `ConNF.Sublitter.toNearLitter` converts a `ConNF.Sublitter` to a `ConNF.NearLitter`. A `ConNF.Sublitter` represents a subset of a `ConNF.Litter`, and a `ConNF.NearLitter` is a pair consisting of a `ConNF.Litter` and a `ConNF.Sublitter` such that the `ConNF.Sublitter` is near the `ConNF.Litter`. The theorem `ConNF.Sublitter.toNearLitter_litter` states that the `ConNF.Litter` component of the resulting `ConNF.NearLitter` is equal to the `ConNF.Litter` component of the original `ConNF.Sublitter`."}
{"full_name": "ConNF.Sublitter.toNearLitter", "url": "ConNF/FOA/Basic/Sublitter.html#ConNF.Sublitter.toNearLitter", "code_src": "con-nf", "ptype": "def", "header": "def ConNF.Sublitter.toNearLitter [ConNF.Params🔗<|PREMISE|>🔗 ] (S : ConNF.Sublitter) :ConNF.NearLitter", "code": "def toNearLitter (S : Sublitter) : NearLitter :=\n  ⟨S.litter, S, S.isNearLitter⟩\n", "additional_info": "Equations\n* 🗟ConNF.Sublitter.toNearLitter🗟🔗../../.././ConNF/FOA/Basic/Sublitter.html#ConNF.Sublitter.toNearLitter🔗  S 🗟=🗟🔗../../.././Init/Prelude.html#Eq🔗  { fst := S.litter, snd := { val := ↑S, property := ⋯ } }\n\n", "used_premises": [1], "def_path": "ConNF/FOA/Basic/Sublitter.lean", "pos": [86, 88], "informalization": "Function `ConNF.Sublitter.toNearLitter` converts a `ConNF.Sublitter` to a `ConNF.NearLitter`. A `ConNF.Sublitter` represents a subset of a `ConNF.Litter`, and a `ConNF.NearLitter` is a pair consisting of a `ConNF.Litter` and a `ConNF.Sublitter` such that the `ConNF.Sublitter` is near the `ConNF.Litter`."}
{"full_name": "ConNF.Sublitter.mem_toNearLitter", "url": "ConNF/FOA/Basic/Sublitter.html#ConNF.Sublitter.mem_toNearLitter", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.Sublitter.mem_toNearLitter [ConNF.Params🔗<|PREMISE|>🔗 ] {S : ConNF.Sublitter} (a : ConNF.Atom) :a ∈ ConNF.Sublitter.toNearLitter🔗<|PREMISE|>🔗 S ↔ a ∈ S", "code": "theorem mem_toNearLitter (a : Atom) : a ∈ S.toNearLitter ↔ a ∈ S :=\n  Iff.rfl\n", "additional_info": "", "used_premises": [1, 870], "def_path": "ConNF/FOA/Basic/Sublitter.lean", "pos": [98, 100], "informalization": "Function `ConNF.Sublitter.toNearLitter` converts a `ConNF.Sublitter` to a `ConNF.NearLitter`. A `ConNF.Sublitter` represents a subset of a `ConNF.Litter`, and a `ConNF.NearLitter` is a pair consisting of a `ConNF.Litter` and a `ConNF.Sublitter` such that the `ConNF.Sublitter` is near the `ConNF.Litter`. The theorem `ConNF.Sublitter.mem_toNearLitter` states that for any `ConNF.Atom` `a`, `a` is an element of `ConNF.Sublitter.toNearLitter S` if and only if `a` is an element of `S`."}
{"full_name": "ConNF.Litter.litter_toSublitter", "url": "ConNF/FOA/Basic/Sublitter.html#ConNF.Litter.litter_toSublitter", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.Litter.litter_toSublitter [ConNF.Params🔗<|PREMISE|>🔗 ] (L : ConNF.Litter) :(ConNF.Litter.toSublitter🔗<|PREMISE|>🔗 L).litter = L", "code": "theorem Litter.litter_toSublitter (L : Litter) : L.toSublitter.litter = L :=\n  rfl\n", "additional_info": "", "used_premises": [1, 873], "def_path": "ConNF/FOA/Basic/Sublitter.lean", "pos": [123, 125], "informalization": "Function `ConNF.Litter.toSublitter` converts a `ConNF.Litter` object `L` into a `ConNF.Sublitter` object, which represents a subset of a `ConNF.Litter`. The resulting `ConNF.Sublitter` has `L` as its `litter` field."}
{"full_name": "ConNF.Litter.toSublitter", "url": "ConNF/FOA/Basic/Sublitter.html#ConNF.Litter.toSublitter", "code_src": "con-nf", "ptype": "def", "header": "def ConNF.Litter.toSublitter [ConNF.Params🔗<|PREMISE|>🔗 ] (L : ConNF.Litter) :ConNF.Sublitter", "code": "def Litter.toSublitter (L : Litter) : Sublitter :=\n  ⟨L, litterSet L, subset_rfl, by\n    rw [sdiff_self]\n    exact small_empty⟩\n", "additional_info": "Equations\n* 🗟ConNF.Litter.toSublitter🗟🔗../../.././ConNF/FOA/Basic/Sublitter.html#ConNF.Litter.toSublitter🔗  L 🗟=🗟🔗../../.././Init/Prelude.html#Eq🔗  { litter := L, carrier := 🗟ConNF.litterSet🗟🔗../../.././ConNF/BaseType/Atom.html#ConNF.litterSet🔗  L, subset := ⋯, diff_small := ⋯ }\n\n", "used_premises": [1], "def_path": "ConNF/FOA/Basic/Sublitter.lean", "pos": [117, 121], "informalization": "Function `ConNF.Litter.toSublitter` converts a `ConNF.Litter` object `L` into a `ConNF.Sublitter` object, which represents a subset of a `ConNF.Litter`. The resulting `ConNF.Sublitter` has `L` as its `litter` field, `ConNF.litterSet L` as its `carrier` field, and proofs that the `carrier` is a subset of the `litter` and that the difference between the `litter` and the `carrier` is a small set."}
{"full_name": "ConNF.Litter.coe_toSublitter", "url": "ConNF/FOA/Basic/Sublitter.html#ConNF.Litter.coe_toSublitter", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.Litter.coe_toSublitter [ConNF.Params🔗<|PREMISE|>🔗 ] (L : ConNF.Litter) :↑(ConNF.Litter.toSublitter🔗<|PREMISE|>🔗 L) = ConNF.litterSet🔗<|PREMISE|>🔗 L", "code": "theorem Litter.coe_toSublitter (L : Litter) : (L.toSublitter : Set Atom) = litterSet L :=\n  rfl\n", "additional_info": "", "used_premises": [1, 873, 467], "def_path": "ConNF/FOA/Basic/Sublitter.lean", "pos": [127, 129], "informalization": "Function `ConNF.Litter.coe_toSublitter` converts a `ConNF.Litter` object `L` into a `ConNF.Sublitter` object, which represents a subset of a `ConNF.Litter`. The resulting `ConNF.Sublitter` has `L` as its `litter` field, `ConNF.litterSet L` as its `carrier` field, and proofs that the `carrier` is a subset of the `litter` and that the difference between the `litter` and the `carrier` is a small set. The function `ConNF.litterSet` defines a set corresponding to a given litter `L` in the context of Constructive Ordinal Notation (ConNF). This set contains all atoms `a` such that the first projection of `a` is equal to `L`."}
{"full_name": "ConNF.Sublitter.equiv_apply_mem", "url": "ConNF/FOA/Basic/Sublitter.html#ConNF.Sublitter.equiv_apply_mem", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.Sublitter.equiv_apply_mem [ConNF.Params🔗<|PREMISE|>🔗 ] {S : ConNF.Sublitter} {T : ConNF.Sublitter} (a : ↥S) :↑((ConNF.Sublitter.equiv🔗<|PREMISE|>🔗 S T) a) ∈ T", "code": "theorem equiv_apply_mem {S T : Sublitter} (a : S) : (S.equiv T a : Atom) ∈ T :=\n  (S.equiv T a).prop\n", "additional_info": "", "used_premises": [1, 876], "def_path": "ConNF/FOA/Basic/Sublitter.lean", "pos": [140, 142], "informalization": "Function `ConNF.Sublitter.equiv` establishes an equivalence between any two sublitters in the context of Constructive Ordinal Notation. The theorem `ConNF.Sublitter.equiv_apply_mem` states that if `a` is an element of sublitter `S`, then the image of `a` under the equivalence `ConNF.Sublitter.equiv S T` is indeed an element of sublitter `T`."}
{"full_name": "ConNF.Sublitter.equiv", "url": "ConNF/FOA/Basic/Sublitter.html#ConNF.Sublitter.equiv", "code_src": "con-nf", "ptype": "noncomputable def", "header": "noncomputable def ConNF.Sublitter.equiv [ConNF.Params🔗<|PREMISE|>🔗 ] (S : ConNF.Sublitter) (T : ConNF.Sublitter) :↥S ≃ ↥T", "code": "noncomputable def equiv (S T : Sublitter) : S ≃ T :=\n  S.equivκ.trans T.equivκ.symm\n", "additional_info": "There is an equivalence between any two sublitters.\nEquations\n* 🗟ConNF.Sublitter.equiv🗟🔗../../.././ConNF/FOA/Basic/Sublitter.html#ConNF.Sublitter.equiv🔗  S T 🗟=🗟🔗../../.././Init/Prelude.html#Eq🔗  (🗟ConNF.Sublitter.equivκ🗟🔗../../.././ConNF/FOA/Basic/Sublitter.html#ConNF.Sublitter.equivκ🔗  S).trans (🗟ConNF.Sublitter.equivκ🗟🔗../../.././ConNF/FOA/Basic/Sublitter.html#ConNF.Sublitter.equivκ🔗  T).symm\n\n", "used_premises": [1], "def_path": "ConNF/FOA/Basic/Sublitter.lean", "pos": [136, 138], "informalization": "Function `ConNF.Sublitter.equiv` establishes an equivalence between any two sublitters in the context of Constructive Ordinal Notation."}
{"full_name": "ConNF.Sublitter.equiv_symm_apply_mem", "url": "ConNF/FOA/Basic/Sublitter.html#ConNF.Sublitter.equiv_symm_apply_mem", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.Sublitter.equiv_symm_apply_mem [ConNF.Params🔗<|PREMISE|>🔗 ] {S : ConNF.Sublitter} {T : ConNF.Sublitter} (a : ↥T) :↑((ConNF.Sublitter.equiv🔗<|PREMISE|>🔗 S T).symm a) ∈ S", "code": "theorem equiv_symm_apply_mem {S T : Sublitter} (a : T) : ((S.equiv T).symm a : Atom) ∈ S :=\n  ((S.equiv T).symm a).prop\n", "additional_info": "", "used_premises": [1, 876], "def_path": "ConNF/FOA/Basic/Sublitter.lean", "pos": [144, 146], "informalization": "The theorem `ConNF.Sublitter.equiv_symm_apply_mem` states that for any two sublitters `S` and `T` in the context of Constructive Ordinal Notation, the inverse of the equivalence `ConNF.Sublitter.equiv S T` maps any element of `T` to an element of `S`."}
{"full_name": "ConNF.flexible_cases", "url": "ConNF/FOA/Basic/Flexible.html#ConNF.flexible_cases", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.flexible_cases [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.FOAAssumptions] {β : ConNF.TypeIndex} (A : ConNF.ExtendedIndex🔗<|PREMISE|>🔗 β) (L : ConNF.Litter) :ConNF.Inflexible🔗<|PREMISE|>🔗 A L ∨ ConNF.Flexible🔗<|PREMISE|>🔗 A L", "code": "theorem flexible_cases (A : ExtendedIndex β) (L : Litter) : Inflexible A L ∨ Flexible A L :=\n  or_not\n", "additional_info": "", "used_premises": [1, 61, 879, 842], "def_path": "ConNF/FOA/Basic/Flexible.lean", "pos": [27, 29], "informalization": "In the context of Constructive Ordinal Notation (ConNF), given a finite path `A` from a type `β` to the base type `⊥`, and a litter `L`, the theorem `ConNF.flexible_cases` states that `L` is either inflexible (the image of an f-map) or flexible (not the image of any f-map)."}
{"full_name": "ConNF.Inflexible", "url": "ConNF/FOA/Basic/Flexible.html#ConNF.Inflexible", "code_src": "con-nf", "ptype": "inductive", "header": "inductive ConNF.Inflexible [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.FOAAssumptions] {β : ConNF.TypeIndex} :ConNF.ExtendedIndex🔗<|PREMISE|>🔗 β → ConNF.Litter → Prop", "code": "inductive Inflexible : ExtendedIndex β → Litter → Prop\n  | mk_coe ⦃γ : Λ⦄ [LeLevel γ] ⦃δ : Λ⦄ [LtLevel δ] ⦃ε : Λ⦄ [LtLevel ε]\n    (hδ : (δ : TypeIndex) < γ) (hε : (ε : TypeIndex) < γ) (hδε : (δ : TypeIndex) ≠ ε)\n    (A : Quiver.Path (β : TypeIndex) γ) (t : Tangle δ) :\n    Inflexible ((A.cons hε).cons (bot_lt_coe _)) (fuzz hδε t)\n  | mk_bot ⦃γ : Λ⦄ [LeLevel γ] ⦃ε : Λ⦄ [LtLevel ε] (hε : (ε : TypeIndex) < γ)\n    (A : Quiver.Path (β : TypeIndex) γ) (a : Atom) :\n    Inflexible ((A.cons hε).cons (bot_lt_coe _)) (fuzz (bot_ne_coe (a := ε)) a)\n", "additional_info": "A litter is *inflexible* if it is the image of some f-map.\n", "used_premises": [1, 61], "def_path": "ConNF/FOA/Basic/Flexible.lean", "pos": [14, 22], "informalization": "The `Inflexible` inductive type in the context of Constructive Ordinal Notation (ConNF) represents a property of litters that are derived from the f-maps. These litters are considered inflexible because they are images of f-maps, which are used to define the structure of the ConNF natural numbers and other related ordinals."}
{"full_name": "ConNF.not_constrains_flexible", "url": "ConNF/FOA/Basic/Flexible.html#ConNF.not_constrains_flexible", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.not_constrains_flexible [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.FOAAssumptions] {β : ConNF.Λ} (c : ConNF.Address🔗<|PREMISE|>🔗 ↑β) {A : ConNF.ExtendedIndex🔗<|PREMISE|>🔗 ↑β} {L : ConNF.Litter} (hL : ConNF.Flexible🔗<|PREMISE|>🔗 A L) :¬ c ≺ { path := A, value := Sum.inr🔗<|PREMISE|>🔗 (ConNF.Litter.toNearLitter🔗<|PREMISE|>🔗 L) }", "code": "theorem not_constrains_flexible {β : Λ} (c : Address β)\n    {A : ExtendedIndex β} {L : Litter} (hL : Flexible A L) :\n    ¬c ≺ ⟨A, inr L.toNearLitter⟩ := by\n  rintro (⟨A, a⟩ | ⟨A, N, hN⟩ | ⟨A, N, a, ha⟩ | ⟨hδ, hε, hδε, A, t, c, hc⟩ | ⟨hε, A, a⟩)\n  · exact hN (NearLitter.IsLitter.mk _)\n  · obtain (ha | ha) := ha\n    · cases ha.2 ha.1\n    · cases ha.2 ha.1\n  · exact hL (Inflexible.mk_coe hδ hε hδε _ _)\n  · exact hL (Inflexible.mk_bot hε _ _)\n", "additional_info": "", "used_premises": [1, 60, 61, 842, 65, 483], "def_path": "ConNF/FOA/Basic/Flexible.lean", "pos": [30, 40], "informalization": "In Constructive Ordinal Notation (ConNF), `ConNF.not_constrains_flexible` is a theorem that states that a ConNF address `c` does not constrain a flexible litter `L` to be in its near-litter. This theorem is crucial for ensuring the consistency of the ConNF construction of natural numbers, where flexibility ensures that no two elements of a given litter are considered equal."}
{"full_name": "ConNF.not_transConstrains_flexible", "url": "ConNF/FOA/Basic/Flexible.html#ConNF.not_transConstrains_flexible", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.not_transConstrains_flexible [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.FOAAssumptions] {β : ConNF.Λ} (c : ConNF.Address🔗<|PREMISE|>🔗 ↑β) {A : ConNF.ExtendedIndex🔗<|PREMISE|>🔗 ↑β} {L : ConNF.Litter} (hL : ConNF.Flexible🔗<|PREMISE|>🔗 A L) :¬ c < { path := A, value := Sum.inr🔗<|PREMISE|>🔗 (ConNF.Litter.toNearLitter🔗<|PREMISE|>🔗 L) }", "code": "theorem not_transConstrains_flexible {β : Λ} (c : Address β)\n    {A : ExtendedIndex β} {L : Litter} (hL : Flexible A L) :\n    ¬c < ⟨A, inr L.toNearLitter⟩ := by\n  intro h\n  obtain ⟨d, _, hd⟩ := Relation.TransGen.tail'_iff.mp h\n  exact not_constrains_flexible d hL hd\n", "additional_info": "", "used_premises": [1, 60, 61, 842, 65, 483], "def_path": "ConNF/FOA/Basic/Flexible.lean", "pos": [41, 47], "informalization": "The theorem `ConNF.not_transConstrains_flexible` states that in the context of Constructive Ordinal Notation (ConNF), for a given address `c` and an extended index `A`, if `L` is a *flexible* litter, then `c` does not transitively constrain the near-litter formed by wrapping `L` with its litter set. This property is crucial in ensuring that the construction of the natural numbers in ConNF is well-defined and consistent."}
{"full_name": "ConNF.mk_flexible", "url": "ConNF/FOA/Basic/Flexible.html#ConNF.mk_flexible", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.mk_flexible [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.FOAAssumptions] {β : ConNF.TypeIndex} (A : ConNF.ExtendedIndex🔗<|PREMISE|>🔗 β) :Cardinal.mk🔗<|PREMISE|>🔗 ↑{L : ConNF.Litter | ConNF.Flexible🔗<|PREMISE|>🔗 A L} = Cardinal.mk🔗<|PREMISE|>🔗 ConNF.μ", "code": "theorem mk_flexible (A : ExtendedIndex β) : #{L | Flexible A L} = #μ := by\n  refine le_antisymm ((Cardinal.mk_subtype_le _).trans mk_litter.le) ?_\n  refine ⟨⟨fun ν => ⟨⟨ν, ⊥, α, bot_ne_coe⟩, ?_⟩, ?_⟩⟩\n  · intro h\n    rw [inflexible_iff] at h\n    obtain ⟨γ, _, δ, _, ε, _, _, hε, hδε, A, t, rfl, h⟩ | ⟨γ, _, ε, _, hε, A, t, rfl, h⟩ := h\n    all_goals\n      apply_fun Litter.γ at h\n      rw [fuzz_γ _ _] at h\n      exact ne_of_lt (coe_lt_coe.mp LtLevel.elim) h.symm\n  · intro ν₁ ν₂ h\n    simp only [coe_setOf, mem_setOf_eq, Subtype.mk.injEq, Litter.mk.injEq, and_self, and_true] at h\n    exact h\n", "additional_info": "", "used_premises": [1, 61, 29, 842, 29], "def_path": "ConNF/FOA/Basic/Flexible.lean", "pos": [48, 61], "informalization": "The theorem `ConNF.mk_flexible` states that in the context of Constructive Ordinal Notation (ConNF), the cardinality of the set of all *flexible* litters (litters that are not the image of any f-map) is equal to the cardinality of the base type `μ`. This result is crucial in ensuring that the construction of the natural numbers in ConNF is well-defined and consistent."}
{"full_name": "ConNF.Inflexible.comp", "url": "ConNF/FOA/Basic/Flexible.html#ConNF.Inflexible.comp", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.Inflexible.comp [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.FOAAssumptions] {β : ConNF.TypeIndex} {γ : ConNF.TypeIndex} {L : ConNF.Litter} {A : ConNF.ExtendedIndex🔗<|PREMISE|>🔗 γ} (h : ConNF.Inflexible🔗<|PREMISE|>🔗 A L) (B : Quiver.Path🔗<|PREMISE|>🔗 β γ) :ConNF.Inflexible🔗<|PREMISE|>🔗 (Quiver.Path.comp🔗<|PREMISE|>🔗 B A) L", "code": "theorem Inflexible.comp {γ : TypeIndex} {L : Litter} {A : ExtendedIndex γ} (h : Inflexible A L)\n    (B : Quiver.Path β γ) : Inflexible (B.comp A) L := by\n  induction h with\n  | mk_coe => exact Inflexible.mk_coe ‹_› ‹_› ‹_› _ _\n  | mk_bot => exact Inflexible.mk_bot ‹_› _ _\n", "additional_info": "", "used_premises": [1, 61, 879, 76, 879, 135], "def_path": "ConNF/FOA/Basic/Flexible.lean", "pos": [62, 67], "informalization": "The `ConNF.Inflexible.comp` theorem in the context of Constructive Ordinal Notation (ConNF) states that if a litter `L` is inflexible with respect to an extended index `A`, and `B` is a path from a type `β` to a type `γ`, then `L` is also inflexible with respect to the composition of `B` and `A`."}
{"full_name": "ConNF.not_flexible_iff", "url": "ConNF/FOA/Basic/Flexible.html#ConNF.not_flexible_iff", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.not_flexible_iff [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.FOAAssumptions] {β : ConNF.TypeIndex} {L : ConNF.Litter} {A : ConNF.ExtendedIndex🔗<|PREMISE|>🔗 β} :¬ ConNF.Flexible🔗<|PREMISE|>🔗 A L ↔ ConNF.Inflexible🔗<|PREMISE|>🔗 A L", "code": "theorem not_flexible_iff {L : Litter} {A : ExtendedIndex β} : ¬Flexible A L ↔ Inflexible A L :=\n  Classical.not_not\n", "additional_info": "", "used_premises": [1, 61, 842, 879], "def_path": "ConNF/FOA/Basic/Flexible.lean", "pos": [69, 71], "informalization": "The theorem `ConNF.not_flexible_iff` states that in the context of Constructive Ordinal Notation (ConNF), a litter `L` is not *flexible* (i.e., not the image of any f-map) if and only if it is *inflexible* (i.e., an image of an f-map)."}
{"full_name": "ConNF.flexible_of_comp_flexible", "url": "ConNF/FOA/Basic/Flexible.html#ConNF.flexible_of_comp_flexible", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.flexible_of_comp_flexible [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.FOAAssumptions] {β : ConNF.TypeIndex} {γ : ConNF.TypeIndex} {L : ConNF.Litter} {A : ConNF.ExtendedIndex🔗<|PREMISE|>🔗 γ} {B : Quiver.Path🔗<|PREMISE|>🔗 β γ} (h : ConNF.Flexible🔗<|PREMISE|>🔗 (Quiver.Path.comp🔗<|PREMISE|>🔗 B A) L) :ConNF.Flexible🔗<|PREMISE|>🔗 A L", "code": "theorem flexible_of_comp_flexible {γ : TypeIndex} {L : Litter} {A : ExtendedIndex γ}\n    {B : Quiver.Path β γ} (h : Flexible (B.comp A) L) : Flexible A L := fun h' => h (h'.comp B)\n", "additional_info": "", "used_premises": [1, 61, 76, 842, 135, 842], "def_path": "ConNF/FOA/Basic/Flexible.lean", "pos": [72, 74], "informalization": "To prove that if a litter `L` is *flexible* with respect to a composition of paths `B.comp A`, then `L` is also *flexible* with respect to `A`, we can use the `ConNF.flexible_of_comp_flexible` theorem in the context of Constructive Ordinal Notation (ConNF). This theorem is a key result in the ConNF project that ensures the well-definedness and consistency of the construction of the natural numbers, crucial for establishing the power of ConNF as a system of ordinal notation."}
{"full_name": "ConNF.inflexibleBot_inflexibleCoe", "url": "ConNF/FOA/Basic/Flexible.html#ConNF.inflexibleBot_inflexibleCoe", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.inflexibleBot_inflexibleCoe [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.FOAAssumptions] {β : ConNF.Λ} {A : ConNF.ExtendedIndex🔗<|PREMISE|>🔗 ↑β} {L : ConNF.Litter} :ConNF.InflexibleBot🔗<|PREMISE|>🔗 A L → ConNF.InflexibleCoe🔗<|PREMISE|>🔗 A L → False🔗<|PREMISE|>🔗", "code": "theorem inflexibleBot_inflexibleCoe {β : Λ} {A : ExtendedIndex β} {L : Litter} :\n    InflexibleBot A L → InflexibleCoe A L → False := by\n  rintro ⟨⟨γ₁, ε₁, hε₁, B₁, rfl⟩, a₁, rfl⟩ ⟨⟨_, δ₂, ε₂, _, _, hδε₂, _, _⟩, t₂, hL₂⟩\n  cases fuzz_congr_β hL₂\n", "additional_info": "", "used_premises": [1, 61, 887, 889, 891], "def_path": "ConNF/FOA/Basic/Flexible.lean", "pos": [133, 137], "informalization": "In the context of Constructive Ordinal Notation (ConNF), the theorem `ConNF.inflexibleBot_inflexibleCoe` states that if `L` is `A`-inflexible when `δ = ⊥` (denoted as `ConNF.InflexibleBot A L`), and `L` is also `A`-inflexible when `ε ≠ ⊥` (denoted as `ConNF.InflexibleCoe A L`), then there is a contradiction, represented by the type `False`. This theorem is used to handle the case where a type index is equal to another type index due to extensionality, ensuring that the path retains its inflexibility and validity."}
{"full_name": "ConNF.InflexibleBot", "url": "ConNF/FOA/Basic/Flexible.html#ConNF.InflexibleBot", "code_src": "con-nf", "ptype": "structure", "header": "structure ConNF.InflexibleBot [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.FOAAssumptions] {β : ConNF.Λ} (A : ConNF.ExtendedIndex🔗<|PREMISE|>🔗 ↑β) (L : ConNF.Litter) :Type u\n | path : ConNF.InflexibleBotPath🔗<|PREMISE|>🔗  A\n | a : ConNF.Atom\n | hL : L =  ConNF.fuzz🔗<|PREMISE|>🔗  ⋯ self.a", "code": "structure InflexibleBot {β : Λ} (A : ExtendedIndex β) (L : Litter) where\n  path : InflexibleBotPath A\n  a : Atom\n  hL : L = fuzz (bot_ne_coe (a := path.ε)) a\n", "additional_info": "A proof-relevant statement that `L` is `A`-inflexible, where `🗟δ🗟🔗../../.././ConNF/FOA/Basic/Flexible.html#ConNF.InflexibleCoePath.δ🔗  = ⊥`.\n", "used_premises": [1, 61, 888, 78], "def_path": "ConNF/FOA/Basic/Flexible.lean", "pos": [108, 112], "informalization": "The structure `ConNF.InflexibleBot` represents a proof-relevant statement that `L` is `A`-inflexible, where `δ = ⊥`."}
{"full_name": "ConNF.InflexibleBotPath", "url": "ConNF/FOA/Basic/Flexible.html#ConNF.InflexibleBotPath", "code_src": "con-nf", "ptype": "structure", "header": "structure ConNF.InflexibleBotPath [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] {β : ConNF.Λ} (A : ConNF.ExtendedIndex🔗<|PREMISE|>🔗 ↑β) :Type u\n | γ : ConNF.Λ\n | ε : ConNF.Λ\n | inst_γ : ConNF.LeLevel🔗<|PREMISE|>🔗  ↑self.γ\n | inst_ε : ConNF.LtLevel🔗<|PREMISE|>🔗  ↑self.ε\n | hε : ↑self.ε <  ↑self.γ\n | B : Quiver.Path🔗<|PREMISE|>🔗  ↑β ↑self.γ\n | hA : A =  Quiver.Path.cons🔗<|PREMISE|>🔗  (Quiver.Path.cons🔗<|PREMISE|>🔗  self.B ⋯) ⋯", "code": "structure InflexibleBotPath {β : Λ} (A : ExtendedIndex β) where\n  (γ ε : Λ)\n  [inst_γ : LeLevel γ]\n  [inst_ε : LtLevel ε]\n  hε : (ε : TypeIndex) < γ\n  B : Quiver.Path (β : TypeIndex) γ\n  hA : A = (B.cons hε).cons (bot_lt_coe _)\n", "additional_info": "", "used_premises": [1, 61, 402, 98, 76, 301, 301], "def_path": "ConNF/FOA/Basic/Flexible.lean", "pos": [96, 103], "informalization": "The `ConNF.InflexibleBotPath` structure in Lean 4 represents a finite path from a type index `β` to the base type `⊥` in the context of Constructive Ordinal Notation (ConNF). This path is constructed by iteratively descending to lower types in the hierarchy until reaching the base type. Since `Λ` is well-ordered, there are no infinite descending paths."}
{"full_name": "ConNF.InflexibleCoe", "url": "ConNF/FOA/Basic/Flexible.html#ConNF.InflexibleCoe", "code_src": "con-nf", "ptype": "structure", "header": "structure ConNF.InflexibleCoe [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.FOAAssumptions] {β : ConNF.Λ} (A : ConNF.ExtendedIndex🔗<|PREMISE|>🔗 ↑β) (L : ConNF.Litter) :Type u\n | path : ConNF.InflexibleCoePath🔗<|PREMISE|>🔗  A\n | t : ConNF.Tangle  ↑self.path.δ\n | hL : L =  ConNF.fuzz🔗<|PREMISE|>🔗  ⋯ self.t", "code": "structure InflexibleCoe {β : Λ} (A : ExtendedIndex β) (L : Litter) where\n  path : InflexibleCoePath A\n  t : Tangle path.δ\n  hL : L = fuzz path.hδε t\n", "additional_info": "A proof-relevant statement that `L` is `A`-inflexible (excluding `🗟ε🗟🔗../../.././ConNF/FOA/Basic/Flexible.html#ConNF.InflexibleCoePath.ε🔗  = ⊥`).\n", "used_premises": [1, 61, 890, 78], "def_path": "ConNF/FOA/Basic/Flexible.lean", "pos": [91, 95], "informalization": "The structure `ConNF.InflexibleCoe` represents a proof-relevant statement that `L` is `A`-inflexible (excluding `ε = ⊥`). This structure is used in the context of Constructive Ordinal Notation (ConNF) to handle cases where a type index is equal to another type index due to extensionality, ensuring that the path retains its inflexibility and validity."}
{"full_name": "ConNF.InflexibleCoePath", "url": "ConNF/FOA/Basic/Flexible.html#ConNF.InflexibleCoePath", "code_src": "con-nf", "ptype": "structure", "header": "structure ConNF.InflexibleCoePath [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] {β : ConNF.Λ} (A : ConNF.ExtendedIndex🔗<|PREMISE|>🔗 ↑β) :Type u\n | γ : ConNF.Λ\n | δ : ConNF.Λ\n | ε : ConNF.Λ\n | inst_γ : ConNF.LeLevel🔗<|PREMISE|>🔗  ↑self.γ\n | inst_δ : ConNF.LtLevel🔗<|PREMISE|>🔗  ↑self.δ\n | inst_ε : ConNF.LtLevel🔗<|PREMISE|>🔗  ↑self.ε\n | hδ : ↑self.δ <  ↑self.γ\n | hε : ↑self.ε <  ↑self.γ\n | hδε : ↑self.δ ≠  ↑self.ε\n | B : Quiver.Path🔗<|PREMISE|>🔗  ↑β ↑self.γ\n | hA : A =  Quiver.Path.cons🔗<|PREMISE|>🔗  (Quiver.Path.cons🔗<|PREMISE|>🔗  self.B ⋯) ⋯", "code": "structure InflexibleCoePath {β : Λ} (A : ExtendedIndex β) where\n  (γ δ ε : Λ)\n  [inst_γ : LeLevel γ]\n  [inst_δ : LtLevel δ]\n  [inst_ε : LtLevel ε]\n  hδ : (δ : TypeIndex) < γ\n  hε : (ε : TypeIndex) < γ\n  hδε : (δ : TypeIndex) ≠ ε\n  B : Quiver.Path (β : TypeIndex) γ\n  hA : A = (B.cons hε).cons (bot_lt_coe _)\n", "additional_info": "", "used_premises": [1, 61, 402, 98, 98, 76, 301, 301], "def_path": "ConNF/FOA/Basic/Flexible.lean", "pos": [75, 85], "informalization": "The `InflexibleCoePath` structure represents a finite path from a higher type index to the base type index in the context of Constructive Ordinal Notation (ConNF). This path is specifically designed to handle cases where a type index is equal to another type index due to extensionality, such as `β = γ`, by ensuring that the path retains its inflexibility and validity. The structure includes several properties and conditions related to the type indices involved, such as their linear and well-orders, and subtraction operations. The `Quiver.Path` used in the structure represents a path in a quiver, and is used here to track the descent of type indices in the context of ConNF. The `InflexibleCoePath` structure ensures that the path is well-defined and valid, adhering to the principles of Constructive Ordinal Notation."}
{"full_name": "False", "url": "Init/Prelude.html#False", "code_src": "lean4", "ptype": "inductive", "header": "inductive False :Prop", "code": "inductive False : Prop\n", "additional_info": "`🗟False🗟🔗.././Init/Prelude.html#False🔗`  is the empty proposition. Thus, it has no introduction rules.\nIt represents a contradiction. `🗟False🗟🔗.././Init/Prelude.html#False🔗`  elimination rule, `🗟False.rec🗟🔗.././Init/Prelude.html#False.rec🔗` ,\nexpresses the fact that anything follows from a contradiction.\nThis rule is sometimes called ex falso (short for ex falso sequitur quodlibet),\nor the principle of explosion.\nFor more information: 🗟Propositional Logic🗟🔗https://lean-lang.org/theorem_proving_in_lean4/propositions_and_proofs.html#propositional-logic🔗 \n", "used_premises": [], "def_path": "Init/Prelude.lean", "pos": [201, 202], "informalization": "Type `False` represents the logical contradiction, having no introduction rules and serving as a basis for the principle of explosion, stating that anything can be derived from a contradiction."}
{"full_name": "ConNF.InflexibleCoePath.δ_lt_β", "url": "ConNF/FOA/Basic/Flexible.html#ConNF.InflexibleCoePath.δ_lt_β", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.InflexibleCoePath.δ_lt_β [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] {β : ConNF.Λ} {A : ConNF.ExtendedIndex🔗<|PREMISE|>🔗 ↑β} (h : ConNF.InflexibleCoePath🔗<|PREMISE|>🔗 A) :↑h.δ < ↑β", "code": "theorem InflexibleCoePath.δ_lt_β {β : Λ} {A : ExtendedIndex β}\n    (h : InflexibleCoePath A) : (h.δ : TypeIndex) < β :=\n  h.hδ.trans_le (le_of_path h.B)\n", "additional_info": "", "used_premises": [1, 61, 890], "def_path": "ConNF/FOA/Basic/Flexible.lean", "pos": [138, 141], "informalization": "The theorem `ConNF.InflexibleCoePath.δ_lt_β` states that in the context of Constructive Ordinal Notation (ConNF), if `A` is an `InflexibleCoePath` from a type index `β` to the base type index `⊥`, then the type index `δ` in the path is strictly less than `β`."}
{"full_name": "ConNF.InflexibleCoe.δ_lt_β", "url": "ConNF/FOA/Basic/Flexible.html#ConNF.InflexibleCoe.δ_lt_β", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.InflexibleCoe.δ_lt_β [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.FOAAssumptions] {β : ConNF.Λ} {A : ConNF.ExtendedIndex🔗<|PREMISE|>🔗 ↑β} {L : ConNF.Litter} (h : ConNF.InflexibleCoe🔗<|PREMISE|>🔗 A L) :↑h.path.δ < ↑β", "code": "theorem InflexibleCoe.δ_lt_β {β : Λ} {A : ExtendedIndex β} {L : Litter}\n    (h : InflexibleCoe A L) : (h.path.δ : TypeIndex) < β :=\n  h.path.δ_lt_β\n", "additional_info": "", "used_premises": [1, 61, 889], "def_path": "ConNF/FOA/Basic/Flexible.lean", "pos": [142, 145], "informalization": "The theorem `ConNF.InflexibleCoe.δ_lt_β` states that in the context of Constructive Ordinal Notation (ConNF), if `L` is `A`-inflexible (excluding `ε = ⊥`), then the `δ` of the path `h.path` is strictly less than `β`."}
{"full_name": "ConNF.inflexible_of_inflexibleBot", "url": "ConNF/FOA/Basic/Flexible.html#ConNF.inflexible_of_inflexibleBot", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.inflexible_of_inflexibleBot [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.FOAAssumptions] {β : ConNF.Λ} {A : ConNF.ExtendedIndex🔗<|PREMISE|>🔗 ↑β} {L : ConNF.Litter} (h : ConNF.InflexibleBot🔗<|PREMISE|>🔗 A L) :ConNF.Inflexible🔗<|PREMISE|>🔗 A L", "code": "theorem inflexible_of_inflexibleBot {β : Λ} {A : ExtendedIndex β} {L : Litter}\n    (h : InflexibleBot A L) : Inflexible A L := by\n  have := Inflexible.mk_bot h.path.hε h.path.B h.a\n  rw [← h.hL, ← h.path.hA] at this\n  exact this\n", "additional_info": "", "used_premises": [1, 61, 887, 879], "def_path": "ConNF/FOA/Basic/Flexible.lean", "pos": [239, 244], "informalization": "The theorem states that if L is A-inflexible at the bottom, then L is A-inflexible. This is a result of the fact that A-inflexibility at the bottom implies A-inflexibility at all levels, due to the well-founded nature of the ConNF hierarchy and the properties of the f-maps."}
{"full_name": "ConNF.inflexible_of_inflexibleCoe", "url": "ConNF/FOA/Basic/Flexible.html#ConNF.inflexible_of_inflexibleCoe", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.inflexible_of_inflexibleCoe [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.FOAAssumptions] {β : ConNF.Λ} {A : ConNF.ExtendedIndex🔗<|PREMISE|>🔗 ↑β} {L : ConNF.Litter} (h : ConNF.InflexibleCoe🔗<|PREMISE|>🔗 A L) :ConNF.Inflexible🔗<|PREMISE|>🔗 A L", "code": "theorem inflexible_of_inflexibleCoe {β : Λ} {A : ExtendedIndex β} {L : Litter}\n    (h : InflexibleCoe A L) : Inflexible A L := by\n  have := Inflexible.mk_coe h.path.hδ h.path.hε h.path.hδε h.path.B h.t\n  rw [← h.hL, ← h.path.hA] at this\n  exact this\n", "additional_info": "", "used_premises": [1, 61, 889, 879], "def_path": "ConNF/FOA/Basic/Flexible.lean", "pos": [246, 251], "informalization": "The theorem `ConNF.inflexible_of_inflexibleCoe` states that if `L` is `A`-inflexible (excluding `ε = ⊥`), then `L` is inflexible. This theorem is used in the context of Constructive Ordinal Notation (ConNF) to handle cases where a type index is equal to another type index due to extensionality, ensuring that the path retains its inflexibility and validity."}
{"full_name": "ConNF.inflexibleBot_or_inflexibleCoe_of_inflexible", "url": "ConNF/FOA/Basic/Flexible.html#ConNF.inflexibleBot_or_inflexibleCoe_of_inflexible", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.inflexibleBot_or_inflexibleCoe_of_inflexible [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.FOAAssumptions] {β : ConNF.Λ} {A : ConNF.ExtendedIndex🔗<|PREMISE|>🔗 ↑β} {L : ConNF.Litter} (h : ConNF.Inflexible🔗<|PREMISE|>🔗 A L) :Nonempty🔗<|PREMISE|>🔗 (ConNF.InflexibleBot🔗<|PREMISE|>🔗 A L) ∨ Nonempty🔗<|PREMISE|>🔗 (ConNF.InflexibleCoe🔗<|PREMISE|>🔗 A L)", "code": "theorem inflexibleBot_or_inflexibleCoe_of_inflexible {β : Λ} {A : ExtendedIndex β} {L : Litter}\n    (h : Inflexible A L) : Nonempty (InflexibleBot A L) ∨ Nonempty (InflexibleCoe A L) := by\n  obtain ⟨hδ, hε, hδε, B, t⟩ | ⟨hε, B, a⟩ := h\n  · exact Or.inr ⟨⟨⟨_, _, _, hδ, hε, hδε, _, rfl⟩, t, rfl⟩⟩\n  · exact Or.inl ⟨⟨⟨_, _, hε, _, rfl⟩, a, rfl⟩⟩\n", "additional_info": "", "used_premises": [1, 61, 879, 212, 887, 212, 889], "def_path": "ConNF/FOA/Basic/Flexible.lean", "pos": [252, 257], "informalization": "Given a litter `L` and an extended index `A` in the context of Constructive Ordinal Notation (ConNF), if `L` is `A`-inflexible, then either `L` is `A`-inflexible at the bottom (i.e., when `δ = ⊥`) or `L` is `A`-inflexible through coe (i.e., excluding `ε = ⊥`)."}
{"full_name": "ConNF.inflexible_iff_inflexibleBot_or_inflexibleCoe", "url": "ConNF/FOA/Basic/Flexible.html#ConNF.inflexible_iff_inflexibleBot_or_inflexibleCoe", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.inflexible_iff_inflexibleBot_or_inflexibleCoe [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.FOAAssumptions] {β : ConNF.Λ} {A : ConNF.ExtendedIndex🔗<|PREMISE|>🔗 ↑β} {L : ConNF.Litter} :ConNF.Inflexible🔗<|PREMISE|>🔗 A L ↔ Nonempty🔗<|PREMISE|>🔗 (ConNF.InflexibleBot🔗<|PREMISE|>🔗 A L) ∨ Nonempty🔗<|PREMISE|>🔗 (ConNF.InflexibleCoe🔗<|PREMISE|>🔗 A L)", "code": "theorem inflexible_iff_inflexibleBot_or_inflexibleCoe {β : Λ} {A : ExtendedIndex β}\n    {L : Litter} :\n    Inflexible A L ↔ Nonempty (InflexibleBot A L) ∨ Nonempty (InflexibleCoe A L) := by\n  constructor\n  exact inflexibleBot_or_inflexibleCoe_of_inflexible\n  rintro (⟨⟨h⟩⟩ | ⟨⟨h⟩⟩)\n  exact inflexible_of_inflexibleBot h\n  exact inflexible_of_inflexibleCoe h\n", "additional_info": "", "used_premises": [1, 61, 879, 212, 887, 212, 889], "def_path": "ConNF/FOA/Basic/Flexible.lean", "pos": [258, 266], "informalization": "The theorem `ConNF.inflexible_iff_inflexibleBot_or_inflexibleCoe` in Lean 4 states that a litter `L` is `A`-inflexible if and only if there exists a proof that `L` is `A`-inflexible at the bottom of the hierarchy (`ConNF.InflexibleBot A L`) or there exists a proof that `L` is `A`-inflexible at the coe level (`ConNF.InflexibleCoe A L`). This theorem is crucial in the context of Constructive Ordinal Notation (ConNF) to ensure that the path from a type `α` to the base type `⊥` retains its inflexibility throughout the construction."}
{"full_name": "ConNF.flexible_iff_not_inflexibleBot_inflexibleCoe", "url": "ConNF/FOA/Basic/Flexible.html#ConNF.flexible_iff_not_inflexibleBot_inflexibleCoe", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.flexible_iff_not_inflexibleBot_inflexibleCoe [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.FOAAssumptions] {β : ConNF.Λ} {A : ConNF.ExtendedIndex🔗<|PREMISE|>🔗 ↑β} {L : ConNF.Litter} :ConNF.Flexible🔗<|PREMISE|>🔗 A L ↔ IsEmpty🔗<|PREMISE|>🔗 (ConNF.InflexibleBot🔗<|PREMISE|>🔗 A L) ∧ IsEmpty🔗<|PREMISE|>🔗 (ConNF.InflexibleCoe🔗<|PREMISE|>🔗 A L)", "code": "theorem flexible_iff_not_inflexibleBot_inflexibleCoe {β : Λ} {A : ExtendedIndex β}\n    {L : Litter} :\n    Flexible A L ↔ IsEmpty (InflexibleBot A L) ∧ IsEmpty (InflexibleCoe A L) := by\n  constructor\n  · intro h\n    exact ⟨⟨fun h' => h (inflexible_of_inflexibleBot h')⟩,\n      ⟨fun h' => h (inflexible_of_inflexibleCoe h')⟩⟩\n  · intro h₁ h₂\n    obtain h | h := inflexibleBot_or_inflexibleCoe_of_inflexible h₂\n    · exact h₁.1.false h.some\n    · exact h₁.2.false h.some\n", "additional_info": "", "used_premises": [1, 61, 842, 899, 887, 899, 889], "def_path": "ConNF/FOA/Basic/Flexible.lean", "pos": [268, 279], "informalization": "In the context of Constructive Ordinal Notation (ConNF), a litter `L` is considered *flexible* if it is not the image of any f-map. This property is crucial in ensuring that the construction of the natural numbers in ConNF is well-defined and consistent. The theorem `ConNF.flexible_iff_not_inflexibleBot_inflexibleCoe` states that a litter `L` is *flexible* if and only if it is not `A`-inflexible at the base type (`ConNF.InflexibleBot A L`) and it is not `A`-inflexible at any other type (`ConNF.InflexibleCoe A L`)."}
{"full_name": "IsEmpty", "url": "Mathlib/Logic/IsEmpty.html#IsEmpty", "code_src": "mathlib4", "ptype": "class", "header": "class IsEmpty (α : Sort u_4) :Prop\n | false : α → False🔗<|PREMISE|>🔗 ", "code": "class IsEmpty (α : Sort*) : Prop where\n  protected false : α → False\n", "additional_info": "`🗟IsEmpty🗟🔗../.././Mathlib/Logic/IsEmpty.html#IsEmpty🔗  α` expresses that `α` is empty.\n", "used_premises": [891], "def_path": "Mathlib/Logic/IsEmpty.lean", "pos": [25, 27], "informalization": "Class `IsEmpty` represents the property that a type `α` has no elements, meaning any attempt to construct an element of `α` leads to a logical contradiction (`False`)."}
{"full_name": "ConNF.flexible_cases'", "url": "ConNF/FOA/Basic/Flexible.html#ConNF.flexible_cases'", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.flexible_cases' [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.FOAAssumptions] {β : ConNF.Λ} (A : ConNF.ExtendedIndex🔗<|PREMISE|>🔗 ↑β) (L : ConNF.Litter) :ConNF.Flexible🔗<|PREMISE|>🔗 A L ∨ Nonempty🔗<|PREMISE|>🔗 (ConNF.InflexibleBot🔗<|PREMISE|>🔗 A L) ∨ Nonempty🔗<|PREMISE|>🔗 (ConNF.InflexibleCoe🔗<|PREMISE|>🔗 A L)", "code": "theorem flexible_cases' {β : Λ} (A : ExtendedIndex β) (L : Litter) :\n    Flexible A L ∨ Nonempty (InflexibleBot A L) ∨ Nonempty (InflexibleCoe A L) := by\n  rw [← inflexible_iff_inflexibleBot_or_inflexibleCoe, or_comm]\n  exact flexible_cases A L\n", "additional_info": "", "used_premises": [1, 61, 842, 212, 887, 212, 889], "def_path": "ConNF/FOA/Basic/Flexible.lean", "pos": [280, 284], "informalization": "For a given type index `β` in the context of Constructive Ordinal Notation (ConNF), and a litter `L`, there are three cases to consider when determining the flexibility of `L` relative to `A`, an extended index of `β`: either `L` is flexible, `L` is inflexible due to `δ = ⊥`, or `L` is inflexible due to `δ` being equal to another type index due to extensionality. This theorem establishes that one of these cases must be true, indicating the overall flexibility of `L` in the context provided by `A`."}
{"full_name": "ConNF.inflexibleCoe_smul", "url": "ConNF/FOA/Basic/Flexible.html#ConNF.inflexibleCoe_smul", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.inflexibleCoe_smul [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.FOAAssumptions] {β : ConNF.Λ} [ConNF.LeLevel🔗<|PREMISE|>🔗 ↑β] {A : ConNF.ExtendedIndex🔗<|PREMISE|>🔗 ↑β} {L : ConNF.Litter} {ρ : ConNF.Allowable ↑β} :Nonempty🔗<|PREMISE|>🔗 (ConNF.InflexibleCoe🔗<|PREMISE|>🔗 A (ConNF.Allowable.toStructPerm ρ A • L)) ↔ Nonempty🔗<|PREMISE|>🔗 (ConNF.InflexibleCoe🔗<|PREMISE|>🔗 A L)", "code": "theorem inflexibleCoe_smul {β : Λ} [LeLevel β]\n    {A : ExtendedIndex β} {L : Litter} {ρ : Allowable β} :\n    Nonempty (InflexibleCoe A (Allowable.toStructPerm ρ A • L)) ↔ Nonempty (InflexibleCoe A L) := by\n  constructor\n  · rintro ⟨h⟩\n    have := h.smul ρ⁻¹\n    simp only [map_inv, Tree.inv_apply, inv_smul_smul] at this\n    exact ⟨this⟩\n  · rintro ⟨h⟩\n    exact ⟨h.smul ρ⟩\n", "additional_info": "", "used_premises": [1, 402, 61, 212, 889, 212, 889], "def_path": "ConNF/FOA/Basic/Flexible.lean", "pos": [294, 304], "informalization": "In the context of Constructive Ordinal Notation (ConNF), the theorem `ConNF.inflexibleCoe_smul` states that if `L` is `A`-inflexible (excluding `ε = ⊥`), then `ConNF.Allowable.toStructPerm ρ A • L` is also `A`-inflexible, where `ConNF.Allowable.toStructPerm ρ A • L` represents the action of the permutation `ConNF.Allowable.toStructPerm ρ A` on `L`."}
{"full_name": "ConNF.inflexibleBot_smul", "url": "ConNF/FOA/Basic/Flexible.html#ConNF.inflexibleBot_smul", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.inflexibleBot_smul [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.FOAAssumptions] {β : ConNF.Λ} [ConNF.LeLevel🔗<|PREMISE|>🔗 ↑β] {A : ConNF.ExtendedIndex🔗<|PREMISE|>🔗 ↑β} {L : ConNF.Litter} {ρ : ConNF.Allowable ↑β} :Nonempty🔗<|PREMISE|>🔗 (ConNF.InflexibleBot🔗<|PREMISE|>🔗 A (ConNF.Allowable.toStructPerm ρ A • L)) ↔ Nonempty🔗<|PREMISE|>🔗 (ConNF.InflexibleBot🔗<|PREMISE|>🔗 A L)", "code": "theorem inflexibleBot_smul {β : Λ} [LeLevel β]\n    {A : ExtendedIndex β} {L : Litter} {ρ : Allowable β} :\n    Nonempty (InflexibleBot A (Allowable.toStructPerm ρ A • L)) ↔ Nonempty (InflexibleBot A L) := by\n  constructor\n  · rintro ⟨h⟩\n    have := h.smul ρ⁻¹\n    simp only [map_inv, Tree.inv_apply, inv_smul_smul] at this\n    exact ⟨this⟩\n  · rintro ⟨h⟩\n    exact ⟨h.smul ρ⟩\n", "additional_info": "", "used_premises": [1, 402, 61, 212, 887, 212, 887], "def_path": "ConNF/FOA/Basic/Flexible.lean", "pos": [314, 324], "informalization": "The theorem `ConNF.inflexibleBot_smul` is a result in the context of Constructive Ordinal Notation (ConNF), which is a formalization of an extension of the Constructive Ordinals by allowing for 'literals' and 'structures' that can be manipulated under a carefully defined set of rules. The theorem states that if `L` is inflexible with respect to `A` and `ρ` is a permutation of `L` that respects the `A`-inflexibility of `L`, then the permutation `ρ` applied to `L` results in another inflexible structure with respect to `A`. This result is crucial in establishing the recursive properties of the ConNF system."}
{"full_name": "ConNF.Flexible.smul", "url": "ConNF/FOA/Basic/Flexible.html#ConNF.Flexible.smul", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.Flexible.smul [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.FOAAssumptions] {β : ConNF.Λ} [ConNF.LeLevel🔗<|PREMISE|>🔗 ↑β] {A : ConNF.ExtendedIndex🔗<|PREMISE|>🔗 ↑β} {L : ConNF.Litter} (h : ConNF.Flexible🔗<|PREMISE|>🔗 A L) (ρ : ConNF.Allowable ↑β) :ConNF.Flexible🔗<|PREMISE|>🔗 A (ConNF.Allowable.toStructPerm ρ A • L)", "code": "theorem Flexible.smul {β : Λ} [LeLevel β] {A : ExtendedIndex β} {L : Litter}\n    (h : Flexible A L) (ρ : Allowable β) :\n    Flexible A (Allowable.toStructPerm ρ A • L) := by\n  rw [flexible_iff_not_inflexibleBot_inflexibleCoe, ← not_nonempty_iff, ← not_nonempty_iff,\n    inflexibleBot_smul, inflexibleCoe_smul, not_nonempty_iff, not_nonempty_iff,\n    ← flexible_iff_not_inflexibleBot_inflexibleCoe]\n  exact h\n", "additional_info": "", "used_premises": [1, 402, 61, 842, 842], "def_path": "ConNF/FOA/Basic/Flexible.lean", "pos": [325, 332], "informalization": "In the context of Constructive Ordinal Notation (ConNF), a litter `L` is considered *flexible* if it is not the image of any f-map. This property is crucial in ensuring that the construction of the natural numbers in ConNF is well-defined and consistent. The theorem `ConNF.Flexible.smul` states that if `L` is a *flexible* litter and `ρ` is an allowable permutation, then the action of `ρ` on `L` results in another *flexible* litter."}
{"full_name": "ConNF.flexible_smul", "url": "ConNF/FOA/Basic/Flexible.html#ConNF.flexible_smul", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.flexible_smul [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.FOAAssumptions] {β : ConNF.Λ} [ConNF.LeLevel🔗<|PREMISE|>🔗 ↑β] {A : ConNF.ExtendedIndex🔗<|PREMISE|>🔗 ↑β} {L : ConNF.Litter} {ρ : ConNF.Allowable ↑β} :ConNF.Flexible🔗<|PREMISE|>🔗 A (ConNF.Allowable.toStructPerm ρ A • L) ↔ ConNF.Flexible🔗<|PREMISE|>🔗 A L", "code": "theorem flexible_smul {β : Λ} [LeLevel β]\n    {A : ExtendedIndex β} {L : Litter} {ρ : Allowable β} :\n    Flexible A (Allowable.toStructPerm ρ A • L) ↔ Flexible A L :=\n  by simp only [flexible_iff_not_inflexibleBot_inflexibleCoe, ← not_nonempty_iff,\n    inflexibleBot_smul, inflexibleCoe_smul]\n", "additional_info": "", "used_premises": [1, 402, 61, 842, 842], "def_path": "ConNF/FOA/Basic/Flexible.lean", "pos": [334, 339], "informalization": "The theorem `ConNF.flexible_smul` states that in the context of Constructive Ordinal Notation (ConNF), a litter `L` is *flexible* if and only if its image under the action of any allowable permutation is also *flexible*. This property is crucial in ensuring that the construction of the natural numbers in ConNF is well-defined and consistent."}
{"full_name": "ConNF.inflexibleCoe_smul_path", "url": "ConNF/FOA/Basic/Flexible.html#ConNF.inflexibleCoe_smul_path", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.inflexibleCoe_smul_path [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.FOAAssumptions] {β : ConNF.Λ} [ConNF.LeLevel🔗<|PREMISE|>🔗 ↑β] {A : ConNF.ExtendedIndex🔗<|PREMISE|>🔗 ↑β} {L : ConNF.Litter} {ρ : ConNF.Allowable ↑β} (h : ConNF.InflexibleCoe🔗<|PREMISE|>🔗 A L) :(ConNF.InflexibleCoe.smul🔗<|PREMISE|>🔗 h ρ).path = h.path", "code": "theorem inflexibleCoe_smul_path {β : Λ} [LeLevel β]\n    {A : ExtendedIndex β} {L : Litter} {ρ : Allowable β} (h : InflexibleCoe A L) :\n    (h.smul ρ).path = h.path :=\n  rfl\n", "additional_info": "", "used_premises": [1, 402, 61, 889, 906], "def_path": "ConNF/FOA/Basic/Flexible.lean", "pos": [341, 345], "informalization": "In the context of Constructive Ordinal Notation (ConNF), the theorem `ConNF.inflexibleCoe_smul_path` states that the path of a proof-relevant statement that `L` is `A`-inflexible (excluding `ε = ⊥`) remains unchanged after applying the `ConNF.InflexibleCoe.smul` method. This method is used to handle cases where a type index is equal to another type index due to extensionality, ensuring that the path retains its inflexibility and validity."}
{"full_name": "ConNF.InflexibleCoe.smul", "url": "ConNF/FOA/Basic/Flexible.html#ConNF.InflexibleCoe.smul", "code_src": "con-nf", "ptype": "def", "header": "def ConNF.InflexibleCoe.smul [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.FOAAssumptions] {β : ConNF.Λ} [ConNF.LeLevel🔗<|PREMISE|>🔗 ↑β] {A : ConNF.ExtendedIndex🔗<|PREMISE|>🔗 ↑β} {L : ConNF.Litter} (h : ConNF.InflexibleCoe🔗<|PREMISE|>🔗 A L) (ρ : ConNF.Allowable ↑β) :ConNF.InflexibleCoe🔗<|PREMISE|>🔗 A (ConNF.Allowable.toStructPerm ρ A • L)", "code": "def InflexibleCoe.smul {β : Λ} [LeLevel β] {A : ExtendedIndex β} {L : Litter}\n    (h : InflexibleCoe A L) (ρ : Allowable β) :\n    InflexibleCoe A (Allowable.toStructPerm ρ A • L) :=\n  ⟨h.path,\n    Allowable.comp (h.path.B.cons h.path.hδ) ρ • h.t, by\n      rw [← toStructPerm_smul_fuzz h.path.hδ h.path.hε]\n      simp only [h.path.hA, h.hL]⟩\n", "additional_info": "Equations\n* 🗟ConNF.InflexibleCoe.smul🗟🔗../../.././ConNF/FOA/Basic/Flexible.html#ConNF.InflexibleCoe.smul🔗  h ρ 🗟=🗟🔗../../.././Init/Prelude.html#Eq🔗  { path := h.path, t := (🗟ConNF.Allowable.comp🗟🔗../../.././ConNF/FOA/Basic/Hypotheses.html#ConNF.Allowable.comp🔗  (🗟Quiver.Path.cons🗟🔗../../.././Mathlib/Combinatorics/Quiver/Path.html#Quiver.Path.cons🔗  h.path.B ⋯)) ρ 🗟•🗟🔗../../.././Mathlib/Algebra/Group/Defs.html#HSMul.hSMul🔗  h.t, hL := ⋯ }\n\n", "used_premises": [1, 402, 61, 889, 889], "def_path": "ConNF/FOA/Basic/Flexible.lean", "pos": [285, 292], "informalization": "Function `ConNF.InflexibleCoe.smul` is a method in the `ConNF.InflexibleCoe` structure, which represents a proof-relevant statement that `L` is `A`-inflexible (excluding `ε = ⊥`). This structure is used in the context of Constructive Ordinal Notation (ConNF) to handle cases where a type index is equal to another type index due to extensionality, ensuring that the path retains its inflexibility and validity."}
{"full_name": "ConNF.inflexibleBot_smul_path", "url": "ConNF/FOA/Basic/Flexible.html#ConNF.inflexibleBot_smul_path", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.inflexibleBot_smul_path [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.FOAAssumptions] {β : ConNF.Λ} [ConNF.LeLevel🔗<|PREMISE|>🔗 ↑β] {A : ConNF.ExtendedIndex🔗<|PREMISE|>🔗 ↑β} {L : ConNF.Litter} {ρ : ConNF.Allowable ↑β} (h : ConNF.InflexibleBot🔗<|PREMISE|>🔗 A L) :(ConNF.InflexibleBot.smul🔗<|PREMISE|>🔗 h ρ).path = h.path", "code": "theorem inflexibleBot_smul_path {β : Λ} [LeLevel β]\n    {A : ExtendedIndex β} {L : Litter} {ρ : Allowable β} (h : InflexibleBot A L) :\n    (h.smul ρ).path = h.path :=\n  rfl\n", "additional_info": "", "used_premises": [1, 402, 61, 887, 908], "def_path": "ConNF/FOA/Basic/Flexible.lean", "pos": [353, 357], "informalization": "The theorem `ConNF.inflexibleBot_smul_path` states that if `L` is `A`-inflexible and `ρ` is an allowable permutation, then the path of `ρ • L` is the same as the path of `L`."}
{"full_name": "ConNF.InflexibleBot.smul", "url": "ConNF/FOA/Basic/Flexible.html#ConNF.InflexibleBot.smul", "code_src": "con-nf", "ptype": "def", "header": "def ConNF.InflexibleBot.smul [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.FOAAssumptions] {β : ConNF.Λ} [ConNF.LeLevel🔗<|PREMISE|>🔗 ↑β] {A : ConNF.ExtendedIndex🔗<|PREMISE|>🔗 ↑β} {L : ConNF.Litter} (h : ConNF.InflexibleBot🔗<|PREMISE|>🔗 A L) (ρ : ConNF.Allowable ↑β) :ConNF.InflexibleBot🔗<|PREMISE|>🔗 A (ConNF.Allowable.toStructPerm ρ A • L)", "code": "def InflexibleBot.smul {β : Λ} [LeLevel β] {A : ExtendedIndex β} {L : Litter}\n    (h : InflexibleBot A L) (ρ : Allowable β) :\n    InflexibleBot A (Allowable.toStructPerm ρ A • L) :=\n  ⟨h.path,\n    Allowable.comp (h.path.B.cons (bot_lt_coe _)) ρ • h.a, by\n      rw [← toStructPerm_smul_fuzz (bot_lt_coe _) h.path.hε]\n      simp only [h.path.hA, h.hL]⟩\n", "additional_info": "Equations\n* 🗟ConNF.InflexibleBot.smul🗟🔗../../.././ConNF/FOA/Basic/Flexible.html#ConNF.InflexibleBot.smul🔗  h ρ 🗟=🗟🔗../../.././Init/Prelude.html#Eq🔗  { path := h.path, a := (🗟ConNF.Allowable.comp🗟🔗../../.././ConNF/FOA/Basic/Hypotheses.html#ConNF.Allowable.comp🔗  (🗟Quiver.Path.cons🗟🔗../../.././Mathlib/Combinatorics/Quiver/Path.html#Quiver.Path.cons🔗  h.path.B ⋯)) ρ 🗟•🗟🔗../../.././Mathlib/Algebra/Group/Defs.html#HSMul.hSMul🔗  h.a, hL := ⋯ }\n\n", "used_premises": [1, 402, 61, 887, 887], "def_path": "ConNF/FOA/Basic/Flexible.lean", "pos": [305, 312], "informalization": "Function `ConNF.InflexibleBot.smul` proves that if `L` is `A`-inflexible and `ρ` is an allowable permutation, then `ρ • L` is also `A`-inflexible in the context of Constructive Ordinal Notation."}
{"full_name": "ConNF.hasPosition_subsingleton", "url": "ConNF/FOA/Basic/Constrains.html#ConNF.hasPosition_subsingleton", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.hasPosition_subsingleton [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.FOAAssumptions] {L : ConNF.Litter} {ν₁ : ConNF.μ} {ν₂ : ConNF.μ} (h₁ : ConNF.HasPosition🔗<|PREMISE|>🔗 L ν₁) (h₂ : ConNF.HasPosition🔗<|PREMISE|>🔗 L ν₂) :ν₁ = ν₂", "code": "theorem hasPosition_subsingleton {L : Litter} {ν₁ ν₂ : μ}\n    (h₁ : HasPosition L ν₁) (h₂ : HasPosition L ν₂) : ν₁ = ν₂ := by\n  rw [hasPosition_iff] at h₁ h₂\n  cases h₁ with\n  | inl h₁ =>\n      obtain ⟨δ, _, ε, _, hδε, t, rfl, rfl⟩ := h₁\n      cases h₂ with\n      | inl h₂ =>\n          obtain ⟨_, _, _, _, _, t, ht, rfl⟩ := h₂\n          cases fuzz_congr_β ht\n          cases fuzz_congr_γ ht\n          cases fuzz_injective _ ht\n          rfl\n      | inr h₂ =>\n          obtain ⟨_, _, a, ha, rfl⟩ := h₂\n          cases fuzz_congr_β ha\n  | inr h₁ =>\n      obtain ⟨_, _, a, rfl, rfl⟩ := h₁\n      cases h₂ with\n      | inl h₂ =>\n          obtain ⟨_, _, _, _, _, t, ht, rfl⟩ := h₂\n          cases fuzz_congr_β ht\n      | inr h₂ =>\n          obtain ⟨_, _, a, ha, rfl⟩ := h₂\n          cases fuzz_congr_γ ha\n          cases fuzz_injective _ ha\n          rfl\n", "additional_info": "", "used_premises": [1, 910, 910], "def_path": "ConNF/FOA/Basic/Constrains.lean", "pos": [74, 101], "informalization": "In the context of Constructive Ordinal Notation (ConNF), given a `ConNF.Litter` `L` and two `ConNF.μ` elements `ν₁` and `ν₂`, if both `ν₁` and `ν₂` are related to `L` by the `ConNF.HasPosition` relation, then `ν₁` and `ν₂` must be equal. This means that for a given `ConNF.Litter`, there is at most one `ConNF.μ` element that can be related to it by the `ConNF.HasPosition` relation."}
{"full_name": "ConNF.HasPosition", "url": "ConNF/FOA/Basic/Constrains.html#ConNF.HasPosition", "code_src": "con-nf", "ptype": "inductive", "header": "inductive ConNF.HasPosition [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.FOAAssumptions] :ConNF.Litter → ConNF.μ → Prop", "code": "inductive HasPosition : Litter → μ → Prop\n  | fuzz ⦃δ : Λ⦄ [LtLevel δ] ⦃ε : Λ⦄ [LtLevel ε] (hδε : (δ : TypeIndex) ≠ ε) (t : Tangle δ) :\n    HasPosition (fuzz hδε t) (pos t)\n  | fuzz_bot ⦃ε : Λ⦄ [LtLevel ε] (a : Atom) :\n    HasPosition (fuzz (bot_ne_coe (a := ε)) a) (pos a)\n", "additional_info": "", "used_premises": [1], "def_path": "ConNF/FOA/Basic/Constrains.lean", "pos": [68, 73], "informalization": "Type `ConNF.HasPosition` represents the relation between a `ConNF.Litter` and an element of `ConNF.μ`. It is defined inductively, with two constructors: `fuzz` and `fuzz_bot`. The `fuzz` constructor relates a `ConNF.Litter` of the form `fuzz hδε t` to the `ConNF.μ` element `pos t`, where `t` is a `ConNF.Tangle`. The `fuzz_bot` constructor relates a `ConNF.Litter` of the form `fuzz (bot_ne_coe (a := ε)) a` to the `ConNF.μ` element `pos a`, where `a` is a `ConNF.Atom`."}
{"full_name": "ConNF.hasPosition_of_litterConstrains", "url": "ConNF/FOA/Basic/Constrains.html#ConNF.hasPosition_of_litterConstrains", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.hasPosition_of_litterConstrains [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.FOAAssumptions] {L₁ : ConNF.Litter} {L₂ : ConNF.Litter} (h : ConNF.LitterConstrains🔗<|PREMISE|>🔗 L₁ L₂) :∃ (ν : ConNF.μ), ConNF.HasPosition🔗<|PREMISE|>🔗 L₂ ν", "code": "theorem hasPosition_of_litterConstrains {L₁ L₂ : Litter} (h : LitterConstrains L₁ L₂) :\n    ∃ ν, HasPosition L₂ ν := by\n  cases h\n  · exact ⟨_, HasPosition.fuzz _ _⟩\n  · exact ⟨_, HasPosition.fuzz _ _⟩\n  · exact ⟨_, HasPosition.fuzz_bot _⟩\n", "additional_info": "", "used_premises": [1, 912, 910], "def_path": "ConNF/FOA/Basic/Constrains.lean", "pos": [102, 108], "informalization": "The theorem `ConNF.hasPosition_of_litterConstrains` states that for any two `ConNF.Litter` objects `L₁` and `L₂`, if `L₁` constrains `L₂`, then there exists a `ConNF.μ` element `ν` such that `L₂` has position `ν`."}
{"full_name": "ConNF.LitterConstrains", "url": "ConNF/FOA/Basic/Constrains.html#ConNF.LitterConstrains", "code_src": "con-nf", "ptype": "inductive", "header": "inductive ConNF.LitterConstrains [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.FOAAssumptions] :ConNF.Litter → ConNF.Litter → Prop", "code": "inductive LitterConstrains : Litter → Litter → Prop\n  | fuzz_atom ⦃δ : Λ⦄ [LtLevel δ] ⦃ε : Λ⦄ [LtLevel ε] (hδε : (δ : TypeIndex) ≠ ε)\n    (t : Tangle δ) {B : ExtendedIndex δ} {a : Atom} : ⟨B, inl a⟩ ∈ t.support →\n    LitterConstrains a.1 (fuzz hδε t)\n  | fuzz_nearLitter ⦃δ : Λ⦄ [LtLevel δ] ⦃ε : Λ⦄ [LtLevel ε] (hδε : (δ : TypeIndex) ≠ ε)\n    (t : Tangle δ) {B : ExtendedIndex δ} {N : NearLitter} (h : ⟨B, inr N⟩ ∈ t.support)\n    {a : Atom} (ha : a ∈ N) :\n    LitterConstrains a.1 (fuzz hδε t)\n  | fuzz_bot ⦃ε : Λ⦄ [LtLevel ε] (a : Atom) :\n    LitterConstrains a.1 (fuzz (bot_ne_coe (a := ε)) a)\n", "additional_info": "", "used_premises": [1], "def_path": "ConNF/FOA/Basic/Constrains.lean", "pos": [56, 66], "informalization": "In the context of Constructive Ordinal Notation (ConNF), the `ConNF.LitterConstrains` relation is an inductively defined relation on `ConNF.Litter` objects. It is used to express the constraints that one `Litter` object imposes on another. The relation is defined by three constructors: `fuzz_atom`, `fuzz_nearLitter`, and `fuzz_bot`. Each constructor represents a different way in which a `Litter` object can be constrained by another."}
{"full_name": "ConNF.hasPosition_lt_of_litterConstrains", "url": "ConNF/FOA/Basic/Constrains.html#ConNF.hasPosition_lt_of_litterConstrains", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.hasPosition_lt_of_litterConstrains [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.FOAAssumptions] {L₁ : ConNF.Litter} {L₂ : ConNF.Litter} (h : ConNF.LitterConstrains🔗<|PREMISE|>🔗 L₁ L₂) {ν₁ : ConNF.μ} {ν₂ : ConNF.μ} (h₁ : ConNF.HasPosition🔗<|PREMISE|>🔗 L₁ ν₁) (h₂ : ConNF.HasPosition🔗<|PREMISE|>🔗 L₂ ν₂) :ν₁ < ν₂", "code": "theorem hasPosition_lt_of_litterConstrains {L₁ L₂ : Litter} (h : LitterConstrains L₁ L₂)\n    {ν₁ ν₂ : μ} (h₁ : HasPosition L₁ ν₁) (h₂ : HasPosition L₂ ν₂) :\n    ν₁ < ν₂ := by\n  rw [hasPosition_iff] at h₁ h₂\n  cases h with\n  | fuzz_atom hδε t ht =>\n      cases h₂ with\n      | inr h =>\n          obtain ⟨_, _, _, h, rfl⟩ := h\n          cases fuzz_congr_β h\n      | inl h =>\n          obtain ⟨δ, _, ε, _, _, t', ht', rfl⟩ := h\n          cases fuzz_congr_β ht'\n          cases fuzz_congr_γ ht'\n          cases fuzz_injective _ ht'\n          cases h₁ with\n          | inl h =>\n              obtain ⟨δ, _, ε, _, hδε, t', ht', rfl⟩ := h\n              exact pos_lt_pos_atom t ht t' hδε ht'\n          | inr h =>\n              obtain ⟨ε, _, a, h, rfl⟩ := h\n              exact pos_lt_pos_atom t ht (show Tangle ⊥ from a) bot_ne_coe h\n  | fuzz_nearLitter hδε t ht ha =>\n      cases h₂ with\n      | inr h =>\n          obtain ⟨_, _, _, h, rfl⟩ := h\n          cases fuzz_congr_β h\n      | inl h =>\n          obtain ⟨δ, _, ε, _, _, t', ht', rfl⟩ := h\n          cases fuzz_congr_β ht'\n          cases fuzz_congr_γ ht'\n          cases fuzz_injective _ ht'\n          cases h₁ with\n          | inl h =>\n              obtain ⟨δ, _, ε, _, hδε, t', ht', rfl⟩ := h\n              exact pos_lt_pos_nearLitter t ht t' hδε ⟨_, ha, ht'⟩\n          | inr h =>\n              obtain ⟨ε, _, a, h, rfl⟩ := h\n              exact pos_lt_pos_nearLitter t ht (show Tangle ⊥ from a) bot_ne_coe ⟨_, ha, h⟩\n  | fuzz_bot a =>\n      cases h₂ with\n      | inl h =>\n          obtain ⟨_, _, _, _, _, _, h, rfl⟩ := h\n          cases fuzz_congr_β h\n      | inr h =>\n          obtain ⟨ε, _, a, ha, rfl⟩ := h\n          cases fuzz_congr_γ ha\n          cases fuzz_injective _ ha\n          cases h₁ with\n          | inl h =>\n              obtain ⟨δ, _, ε, _, hδε, t', ht', rfl⟩ := h\n              exact pos_lt_pos_fuzz _ t' a ht'\n          | inr h =>\n              obtain ⟨ε, _, a', ha', rfl⟩ := h\n              exact pos_lt_pos_fuzz _ (show Tangle ⊥ from a') a ha'\n", "additional_info": "", "used_premises": [1, 912, 910, 910], "def_path": "ConNF/FOA/Basic/Constrains.lean", "pos": [109, 164], "informalization": "In Constructive Ordinal Notation (ConNF), the `ConNF.LitterConstrains` relation is used to express the constraints that one `Litter` object imposes on another. The `ConNF.HasPosition` relation describes the position of a `Litter` object within the `ConNF.μ` type. The theorem `ConNF.hasPosition_lt_of_litterConstrains` states that if `L₁` is constrained by `L₂` and both have positions in `ConNF.μ`, then the position of `L₁` is less than the position of `L₂` in `ConNF.μ`."}
{"full_name": "ConNF.litterConstrains_subrelation", "url": "ConNF/FOA/Basic/Constrains.html#ConNF.litterConstrains_subrelation", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.litterConstrains_subrelation [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.FOAAssumptions] :Subrelation🔗<|PREMISE|>🔗 ConNF.LitterConstrains (InvImage🔗<|PREMISE|>🔗 (fun (x x_1 : WithBot🔗<|PREMISE|>🔗 ConNF.μ) => x < x_1) ConNF.positionOrBot)", "code": "theorem litterConstrains_subrelation :\n    Subrelation LitterConstrains (InvImage (· < ·) positionOrBot) := by\n  intro L₁ L₂ h\n  obtain ⟨ν₂, hν₂⟩ := hasPosition_of_litterConstrains h\n  by_cases h₁ : ∃ ν₁, HasPosition L₁ ν₁\n  · obtain ⟨ν₁, hν₁⟩ := h₁\n    rw [InvImage, positionOrBot, positionOrBot, dif_pos ⟨ν₁, hν₁⟩, dif_pos ⟨ν₂, hν₂⟩,\n      hasPosition_subsingleton (Exists.choose_spec ⟨ν₁, hν₁⟩) hν₁,\n      hasPosition_subsingleton (Exists.choose_spec ⟨ν₂, hν₂⟩) hν₂]\n    exact WithBot.coe_lt_coe.mpr (hasPosition_lt_of_litterConstrains h hν₁ hν₂)\n  · rw [InvImage, positionOrBot, positionOrBot, dif_neg h₁, dif_pos ⟨ν₂, hν₂⟩]\n    exact bot_lt_coe _\n", "additional_info": "", "used_premises": [1, 122, 96, 915], "def_path": "ConNF/FOA/Basic/Constrains.lean", "pos": [169, 181], "informalization": "The theorem `ConNF.litterConstrains_subrelation` states that the relation `ConNF.LitterConstrains` is a subrelation of the relation `InvImage (fun (x x_1 : WithBot ConNF.μ) => x < x_1) ConNF.positionOrBot`. This means that if `ConNF.LitterConstrains` holds between two elements, then so does `InvImage (fun (x x_1 : WithBot ConNF.μ) => x < x_1) ConNF.positionOrBot`."}
{"full_name": "WithBot", "url": "Mathlib/Order/WithBot.html#WithBot", "code_src": "mathlib4", "ptype": "def", "header": "def WithBot (α : Type u_5) :Type u_5", "code": "def WithBot (α : Type*) :=\n  Option α\n", "additional_info": "Attach `⊥` to a type.\nEquations\n* 🗟WithBot🗟🔗../.././Mathlib/Order/WithBot.html#WithBot🔗  α 🗟=🗟🔗../.././Init/Prelude.html#Eq🔗  🗟Option🗟🔗../.././Init/Prelude.html#Option🔗  α\n\n", "used_premises": [], "def_path": "Mathlib/Order/WithBot.lean", "pos": [28, 30], "informalization": "Function `WithBot` augments a type `α` with an additional element `⊥` (representing \"bottom\"), effectively forming a new type where each element is either `⊥` or an element of `α`."}
{"full_name": "ConNF.litterConstrains_wf", "url": "ConNF/FOA/Basic/Constrains.html#ConNF.litterConstrains_wf", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.litterConstrains_wf [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.FOAAssumptions] :WellFounded🔗<|PREMISE|>🔗 ConNF.LitterConstrains", "code": "theorem litterConstrains_wf : WellFounded LitterConstrains :=\n  Subrelation.wf litterConstrains_subrelation IsWellFounded.wf\n", "additional_info": "", "used_premises": [1, 19], "def_path": "ConNF/FOA/Basic/Constrains.lean", "pos": [182, 184], "informalization": "The theorem `ConNF.litterConstrains_wf` states that the relation `ConNF.LitterConstrains` is well-founded. This means that every non-empty set of `ConNF.Litter`s has a minimal element with respect to the relation `ConNF.LitterConstrains`."}
{"full_name": "ConNF.constrains_atom", "url": "ConNF/FOA/Basic/Constrains.html#ConNF.constrains_atom", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.constrains_atom [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.FOAAssumptions] {β : ConNF.Λ} {c : ConNF.Address🔗<|PREMISE|>🔗 ↑β} {A : ConNF.ExtendedIndex🔗<|PREMISE|>🔗 ↑β} {a : ConNF.Atom} :c ≺ { path := A, value := Sum.inl🔗<|PREMISE|>🔗 a } ↔ c = { path := A, value := Sum.inr🔗<|PREMISE|>🔗 (ConNF.Litter.toNearLitter🔗<|PREMISE|>🔗 a.1) }", "code": "theorem constrains_atom {c : Address β} {A : ExtendedIndex β} {a : Atom} :\n    c ≺ ⟨A, inl a⟩ ↔ c = ⟨A, inr a.1.toNearLitter⟩ := by\n  constructor\n  · rintro ⟨⟩\n    rfl\n  · rintro rfl\n    exact Constrains.atom A a\n", "additional_info": "", "used_premises": [1, 60, 61, 67, 65, 483], "def_path": "ConNF/FOA/Basic/Constrains.lean", "pos": [186, 193], "informalization": "The theorem `ConNF.constrains_atom` states that in the context of Constructive Ordinal Notation (ConNF), for a given address `c` and an extended index `A`, the condition `c ≺ { path := A, value := Sum.inl a }` holds if and only if `c` is equal to `{ path := A, value := Sum.inr (ConNF.Litter.toNearLitter a.1) }`, where `a` is an atom and `ConNF.Litter.toNearLitter` converts a litter to its corresponding near-litter."}
{"full_name": "ConNF.constrains_nearLitter", "url": "ConNF/FOA/Basic/Constrains.html#ConNF.constrains_nearLitter", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.constrains_nearLitter [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.FOAAssumptions] {β : ConNF.Λ} {c : ConNF.Address🔗<|PREMISE|>🔗 ↑β} {A : ConNF.ExtendedIndex🔗<|PREMISE|>🔗 ↑β} {N : ConNF.NearLitter} (hN : ¬ ConNF.NearLitter.IsLitter🔗<|PREMISE|>🔗 N) :c ≺ { path := A, value := Sum.inr🔗<|PREMISE|>🔗 N } ↔ c = { path := A, value := Sum.inr🔗<|PREMISE|>🔗 (ConNF.Litter.toNearLitter🔗<|PREMISE|>🔗 N.fst) } ∨ ∃ a ∈ symmDiff🔗<|PREMISE|>🔗 (ConNF.litterSet🔗<|PREMISE|>🔗 N.fst) ↑N.snd, c = { path := A, value := Sum.inl🔗<|PREMISE|>🔗 a }", "code": "theorem constrains_nearLitter {c : Address β} {A : ExtendedIndex β}\n    {N : NearLitter} (hN : ¬N.IsLitter) :\n    c ≺ ⟨A, inr N⟩ ↔ c = ⟨A, inr N.1.toNearLitter⟩ ∨\n      ∃ a ∈ litterSet N.fst ∆ N.snd, c = ⟨A, inl a⟩ := by\n  constructor\n  · intro h\n    rw [constrains_iff] at h\n    obtain ⟨A, a, rfl, hc⟩ | ⟨A, N, hN, rfl, hc⟩ | ⟨A, N, a, ha, rfl, hc⟩ |\n        ⟨γ, _, δ, _, ε, _, hδ, hε, hδε, A, t, c, _, rfl, hc'⟩ |\n        ⟨γ, _, ε, _, hγ, A, a, rfl, hc⟩ := h\n    · cases hc\n    · cases hc\n      exact Or.inl rfl\n    · cases hc\n      exact Or.inr ⟨a, ha, rfl⟩\n    · cases hc'\n      cases hN (NearLitter.IsLitter.mk _)\n    · cases hc\n      cases hN (NearLitter.IsLitter.mk _)\n  · rintro (rfl | ⟨a, ha, rfl⟩)\n    · exact Constrains.nearLitter A N hN\n    · exact Constrains.symmDiff A N a ha\n", "additional_info": "", "used_premises": [1, 60, 61, 495, 65, 65, 483, 62, 467, 67], "def_path": "ConNF/FOA/Basic/Constrains.lean", "pos": [194, 216], "informalization": "The theorem `ConNF.constrains_nearLitter` in Constructive Ordinal Notation (ConNF) formalism, specifically defined for proving the consistency of `AD^+` using the determinacy of games on the ordinals, provides a condition for a constraint imposed by a near-litter that is not a litter. It states that for a constraint `c` to be less than a near-litter `N` that is not a litter, either `c` must be equal to the near-litter formed from the litter part of `N`, or `c` must be an atom that is an element of the symmetric difference between the litter set of `N` and the subset of the litter set that forms `N`. This theorem is crucial for understanding the relationship between constraints and near-litters in the context of ConNF."}
{"full_name": "ConNF.acc_atom", "url": "ConNF/FOA/Basic/Constrains.html#ConNF.acc_atom", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.acc_atom [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.FOAAssumptions] {β : ConNF.Λ} {a : ConNF.Atom} {A : ConNF.ExtendedIndex🔗<|PREMISE|>🔗 ↑β} (h : Acc🔗<|PREMISE|>🔗 (fun (x x_1 : ConNF.Address🔗<|PREMISE|>🔗 ↑β) => x ≺ x_1) { path := A, value := Sum.inr🔗<|PREMISE|>🔗 (ConNF.Litter.toNearLitter🔗<|PREMISE|>🔗 a.1) }) :Acc🔗<|PREMISE|>🔗 (fun (x x_1 : ConNF.Address🔗<|PREMISE|>🔗 ↑β) => x ≺ x_1) { path := A, value := Sum.inl🔗<|PREMISE|>🔗 a }", "code": "theorem acc_atom {a : Atom} {A : ExtendedIndex β}\n    (h : Acc ((· ≺ ·) : Address β → _ → Prop) ⟨A, inr a.1.toNearLitter⟩) :\n    Acc ((· ≺ ·) : Address β → _ → Prop) ⟨A, inl a⟩ := by\n  constructor\n  intro c\n  rw [constrains_atom]\n  rintro rfl\n  exact h\n", "additional_info": "", "used_premises": [1, 61, 920, 60, 65, 483, 920, 60, 67], "def_path": "ConNF/FOA/Basic/Constrains.lean", "pos": [217, 225], "informalization": "The theorem `ConNF.acc_atom` is a part of the Constructive Ordinal Notation (ConNF) formalization in Lean 4. It states that if a certain relation `≺` (which represents a well-founded relation in the context of ConNF) is accessible for a specific element of type `ConNF.Address ↑β` that has a `Sum.inr` constructor (which means it represents a near-litter), then the relation `≺` is also accessible for a similar element but with a `Sum.inl` constructor (which represents an atom). This result is crucial for proving the well-foundedness of the relation `≺` in the context of ConNF, which is essential for the correctness of the model of ordinals and cardinals in the formalization."}
{"full_name": "Acc", "url": "Init/WF.html#Acc", "code_src": "lean4", "ptype": "inductive", "header": "inductive Acc {α : Sort u} (r : α → α → Prop ) :α → Prop", "code": "inductive Acc {α : Sort u} (r : α → α → Prop) : α → Prop where\n  | intro (x : α) (h : (y : α) → r y x → Acc r y) : Acc r x\n", "additional_info": "", "used_premises": [], "def_path": "Init/WF.lean", "pos": [11, 13], "informalization": "Type `Acc` represents the accessibility of an element in a well-founded relation. It is used to define well-founded induction and recursion."}
{"full_name": "ConNF.acc_nearLitter", "url": "ConNF/FOA/Basic/Constrains.html#ConNF.acc_nearLitter", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.acc_nearLitter [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.FOAAssumptions] {β : ConNF.Λ} {N : ConNF.NearLitter} {A : ConNF.ExtendedIndex🔗<|PREMISE|>🔗 ↑β} (h : ∀ a ∈ N, Acc🔗<|PREMISE|>🔗 (fun (x x_1 : ConNF.Address🔗<|PREMISE|>🔗 ↑β) => x ≺ x_1) { path := A, value := Sum.inr🔗<|PREMISE|>🔗 (ConNF.Litter.toNearLitter🔗<|PREMISE|>🔗 a.1) }) :Acc🔗<|PREMISE|>🔗 (fun (x x_1 : ConNF.Address🔗<|PREMISE|>🔗 ↑β) => x ≺ x_1) { path := A, value := Sum.inr🔗<|PREMISE|>🔗 N }", "code": "theorem acc_nearLitter {N : NearLitter} {A : ExtendedIndex β}\n    (h : ∀ a ∈ N, Acc ((· ≺ ·) : Address β → _ → Prop) ⟨A, inr a.1.toNearLitter⟩) :\n    Acc ((· ≺ ·) : Address β → _ → Prop) ⟨A, inr N⟩ := by\n  by_cases hN : N.IsLitter\n  · obtain ⟨L, rfl⟩ := hN.exists_litter_eq\n    obtain ⟨⟨a, rfl⟩⟩ := litterSet_nonempty L\n    exact h _ rfl\n  constructor\n  intro d hd\n  rw [constrains_nearLitter hN] at hd\n  obtain (rfl | ⟨a, ha, rfl⟩) := hd\n  · obtain ⟨a, ha⟩ := NearLitter.inter_nonempty_of_fst_eq_fst (N₁ := N) (N₂ := N.1.toNearLitter) rfl\n    have := h a ha.1\n    rw [ha.2] at this\n    exact this\n  · refine acc_atom ?_\n    obtain (ha | ha) := ha\n    · obtain ⟨b, hb⟩ := NearLitter.inter_nonempty_of_fst_eq_fst (N₁ := N) (N₂ := N.1.toNearLitter) rfl\n      have := h b hb.1\n      rw [hb.2, ← ha.1] at this\n      exact this\n    · exact h a ha.1\n", "additional_info": "", "used_premises": [1, 61, 920, 60, 65, 483, 920, 60, 65], "def_path": "ConNF/FOA/Basic/Constrains.lean", "pos": [226, 248], "informalization": "In the context of Constructive Ordinal Notation (ConNF), the theorem `ConNF.acc_nearLitter` states that if for every element `a` in a near-litter `N`, the address `{ path := A, value := Sum.inr (ConNF.Litter.toNearLitter a.1) }` is accessible under the relation `≺`, then the address `{ path := A, value := Sum.inr N }` is also accessible under the same relation."}
{"full_name": "ConNF.constrains_wf", "url": "ConNF/FOA/Basic/Constrains.html#ConNF.constrains_wf", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.constrains_wf [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.FOAAssumptions] (β : ConNF.Λ) :WellFounded🔗<|PREMISE|>🔗 fun (x x_1 : ConNF.Address🔗<|PREMISE|>🔗 ↑β) => x ≺ x_1", "code": "theorem constrains_wf (β : Λ) : WellFounded ((· ≺ ·) : Address β → _ → Prop) := by\n  have : ∀ L : Litter, ∀ A : ExtendedIndex β,\n      Acc ((· ≺ ·) : Address β → _ → Prop) ⟨A, inr L.toNearLitter⟩\n  · intro L\n    refine litterConstrains_wf.induction\n      (C := fun L => ∀ A : ExtendedIndex β, Acc (· ≺ ·) ⟨A, inr L.toNearLitter⟩) L ?_\n    clear L\n    intro L ih A\n    constructor\n    intro c hc\n    rw [constrains_iff] at hc\n    obtain ⟨A, a, rfl, hc⟩ | ⟨A, N, hN, rfl, hc⟩ | ⟨A, N, a, ha, rfl, hc⟩ |\n        ⟨γ, _, δ, _, ε, _, hδ, hε, hδε, A, t, c, hc, rfl, hc'⟩ |\n        ⟨γ, _, ε, _, hγ, A, a, rfl, hc⟩ := hc\n    · cases hc\n    · cases hc\n      cases hN (NearLitter.IsLitter.mk _)\n    · cases hc\n      cases ha with\n      | inl ha => cases ha.2 ha.1\n      | inr ha => cases ha.2 ha.1\n    · simp only [Address.mk.injEq, inr.injEq, Litter.toNearLitter_injective.eq_iff] at hc'\n      cases hc'.1\n      cases hc'.2\n      obtain ⟨B, a | N⟩ := c\n      · exact acc_atom (ih a.1 (LitterConstrains.fuzz_atom _ _ hc) _)\n      · refine acc_nearLitter ?_\n        intro a ha\n        exact ih _ (LitterConstrains.fuzz_nearLitter hδε t hc ha) _\n    · simp only [Address.mk.injEq, inr.injEq, Litter.toNearLitter_injective.eq_iff] at hc\n      cases hc.1\n      cases hc.2\n      refine acc_atom (ih _ (LitterConstrains.fuzz_bot _) _)\n  constructor\n  intro c\n  obtain ⟨B, a | N⟩ := c\n  · exact acc_atom (this _ _)\n  · exact acc_nearLitter (fun _ _ => this _ _)\n", "additional_info": "The `≺` relation is well-founded.", "used_premises": [1, 19, 60], "def_path": "ConNF/FOA/Basic/Constrains.lean", "pos": [250, 288], "informalization": "Function `ConNF.constrains_wf` proves that the `≺` relation on `ConNF.Address` is well-founded. This means that every non-empty subset of `ConNF.Address` has a minimal element with respect to the relation `≺`."}
{"full_name": "ConNF.Address.le_iff", "url": "ConNF/FOA/Basic/Constrains.html#ConNF.Address.le_iff", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.Address.le_iff [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.FOAAssumptions] {β : ConNF.Λ} {c : ConNF.Address🔗<|PREMISE|>🔗 ↑β} {d : ConNF.Address🔗<|PREMISE|>🔗 ↑β} :c ≤ d ↔ Relation.ReflTransGen🔗<|PREMISE|>🔗 (fun (x x_1 : ConNF.Address🔗<|PREMISE|>🔗 ↑β) => x ≺ x_1) c d", "code": "theorem Address.le_iff {c d : Address β} :\n    c ≤ d ↔ Relation.ReflTransGen (· ≺ ·) c d :=\n  Iff.rfl\n", "additional_info": "", "used_premises": [1, 60, 60, 924, 60], "def_path": "ConNF/FOA/Basic/Constrains.lean", "pos": [330, 333], "informalization": "The theorem `ConNF.Address.le_iff` in Lean 4 states that for two addresses `c` and `d` in the same level `β`, `c` is less than or equal to `d` if and only if `c` is related to `d` by the reflexive transitive closure of the relation `≺`."}
{"full_name": "Relation.ReflTransGen", "url": "Mathlib/Logic/Relation.html#Relation.ReflTransGen", "code_src": "mathlib4", "ptype": "inductive", "header": "inductive Relation.ReflTransGen {α : Type u_1} (r : α → α → Prop ) (a : α) :α → Prop", "code": "inductive ReflTransGen (r : α → α → Prop) (a : α) : α → Prop\n  | refl : ReflTransGen r a a\n  | tail {b c} : ReflTransGen r a b → r b c → ReflTransGen r a c\n", "additional_info": "`🗟ReflTransGen🗟🔗../.././Mathlib/Logic/Relation.html#Relation.ReflTransGen🔗  r`: reflexive transitive closure of `r`\n", "used_premises": [], "def_path": "Mathlib/Logic/Relation.lean", "pos": [249, 252], "informalization": "Type `Relation.ReflTransGen` represents the reflexive transitive closure of a relation `r`, meaning it is the smallest relation that includes `r` and is both reflexive and transitive."}
{"full_name": "ConNF.Address.lt_iff", "url": "ConNF/FOA/Basic/Constrains.html#ConNF.Address.lt_iff", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.Address.lt_iff [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.FOAAssumptions] {β : ConNF.Λ} {c : ConNF.Address🔗<|PREMISE|>🔗 ↑β} {d : ConNF.Address🔗<|PREMISE|>🔗 ↑β} :c < d ↔ Relation.TransGen🔗<|PREMISE|>🔗 (fun (x x_1 : ConNF.Address🔗<|PREMISE|>🔗 ↑β) => x ≺ x_1) c d", "code": "theorem Address.lt_iff {c d : Address β} :\n    c < d ↔ Relation.TransGen (· ≺ ·) c d :=\n  Iff.rfl\n", "additional_info": "", "used_premises": [1, 60, 60, 926, 60], "def_path": "ConNF/FOA/Basic/Constrains.lean", "pos": [334, 337], "informalization": "The theorem `ConNF.Address.lt_iff` in Lean 4 states that for two addresses `c` and `d` in the context of Constructive Ordinal Notation (ConNF), `c` is less than `d` if and only if `c` is related to `d` by the transitive closure of the relation `≺`."}
{"full_name": "Relation.TransGen", "url": "Mathlib/Logic/Relation.html#Relation.TransGen", "code_src": "mathlib4", "ptype": "inductive", "header": "inductive Relation.TransGen {α : Type u_1} (r : α → α → Prop ) (a : α) :α → Prop", "code": "inductive TransGen (r : α → α → Prop) (a : α) : α → Prop\n  | single {b} : r a b → TransGen r a b\n  | tail {b c} : TransGen r a b → r b c → TransGen r a c\n", "additional_info": "`🗟TransGen🗟🔗../.././Mathlib/Logic/Relation.html#Relation.TransGen🔗  r`: transitive closure of `r`\n", "used_premises": [], "def_path": "Mathlib/Logic/Relation.lean", "pos": [267, 270], "informalization": "Type `Relation.TransGen` represents the transitive closure of a relation `r`, which is the smallest transitive relation containing `r`."}
{"full_name": "ConNF.le_nearLitter", "url": "ConNF/FOA/Basic/Constrains.html#ConNF.le_nearLitter", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.le_nearLitter [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.FOAAssumptions] {β : ConNF.Λ} {N : ConNF.NearLitter} {B : ConNF.ExtendedIndex🔗<|PREMISE|>🔗 ↑β} {c : ConNF.Address🔗<|PREMISE|>🔗 ↑β} (h : { path := B, value := Sum.inr🔗<|PREMISE|>🔗 N } ≤ c) :{ path := B, value := Sum.inr🔗<|PREMISE|>🔗 (ConNF.Litter.toNearLitter🔗<|PREMISE|>🔗 N.fst) } ≤ c", "code": "theorem le_nearLitter {β : Λ} {N : NearLitter} {B : ExtendedIndex β}\n    {c : Address β} (h : ⟨B, inr N⟩ ≤ c) : ⟨B, inr N.1.toNearLitter⟩ ≤ c := by\n  by_cases h' : N.IsLitter\n  · obtain ⟨L, rfl⟩ := h'.exists_litter_eq\n    exact h\n  · exact Relation.ReflTransGen.head (Constrains.nearLitter B N h') h\n", "additional_info": "", "used_premises": [1, 61, 60, 65, 65, 483], "def_path": "ConNF/FOA/Basic/Constrains.lean", "pos": [352, 358], "informalization": "`ConNF.le_nearLitter` is a theorem in Constructive Ordinal Notation (ConNF) that states that if a near-litter `N` (a pair consisting of a litter and a subset of that litter) is less than or equal to an address `c` in the context of a parameter `β` of the ConNF hierarchy, then the near-litter formed by wrapping the litter of `N` with its litter set is also less than or equal to `c`. This theorem is crucial to establishing the well-foundedness of the ConNF hierarchy and proving the consistency of the natural numbers with the ZFC axioms."}
{"full_name": "ConNF.lt_nearLitter", "url": "ConNF/FOA/Basic/Constrains.html#ConNF.lt_nearLitter", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.lt_nearLitter [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.FOAAssumptions] {β : ConNF.Λ} {N : ConNF.NearLitter} {B : ConNF.ExtendedIndex🔗<|PREMISE|>🔗 ↑β} {c : ConNF.Address🔗<|PREMISE|>🔗 ↑β} (h : c < { path := B, value := Sum.inr🔗<|PREMISE|>🔗 (ConNF.Litter.toNearLitter🔗<|PREMISE|>🔗 N.fst) }) :c < { path := B, value := Sum.inr🔗<|PREMISE|>🔗 N }", "code": "theorem lt_nearLitter {β : Λ} {N : NearLitter} {B : ExtendedIndex β}\n    {c : Address β} (h : c < ⟨B, inr N.1.toNearLitter⟩) : c < ⟨B, inr N⟩ := by\n  by_cases h' : N.IsLitter\n  · obtain ⟨L, rfl⟩ := h'.exists_litter_eq\n    exact h\n  · exact Relation.TransGen.tail h (Constrains.nearLitter B N h')\n", "additional_info": "", "used_premises": [1, 61, 60, 65, 483, 65], "def_path": "ConNF/FOA/Basic/Constrains.lean", "pos": [359, 365], "informalization": "The theorem `ConNF.lt_nearLitter` states that if `c` is an address in the near-litter of `N`, and `c` is less than an address that points to the near-litter of `N`, then `c` is also less than the near-litter of `N` itself. This makes sense because the near-litter of `N` is a more specific address than the near-litter of `N`, and thus any address less than the near-litter of `N` will also be less than the near-litter of `N`."}
{"full_name": "ConNF.lt_nearLitter'", "url": "ConNF/FOA/Basic/Constrains.html#ConNF.lt_nearLitter'", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.lt_nearLitter' [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.FOAAssumptions] {β : ConNF.Λ} {N : ConNF.NearLitter} {B : ConNF.ExtendedIndex🔗<|PREMISE|>🔗 ↑β} {c : ConNF.Address🔗<|PREMISE|>🔗 ↑β} (h : { path := B, value := Sum.inr🔗<|PREMISE|>🔗 N } < c) :{ path := B, value := Sum.inr🔗<|PREMISE|>🔗 (ConNF.Litter.toNearLitter🔗<|PREMISE|>🔗 N.fst) } < c", "code": "theorem lt_nearLitter' {β : Λ} {N : NearLitter} {B : ExtendedIndex β}\n    {c : Address β} (h : ⟨B, inr N⟩ < c) : ⟨B, inr N.1.toNearLitter⟩ < c := by\n  by_cases h' : N.IsLitter\n  · obtain ⟨L, rfl⟩ := h'.exists_litter_eq\n    exact h\n  · exact Relation.TransGen.head (Constrains.nearLitter B N h') h\n", "additional_info": "", "used_premises": [1, 61, 60, 65, 65, 483], "def_path": "ConNF/FOA/Basic/Constrains.lean", "pos": [366, 372], "informalization": "`ConNF.lt_nearLitter'` is a theorem that helps one prove that if a certain element is less than another element in the context of Constructive Ordinal Notation (ConNF), then another related element is also less than the second element. This theorem is used in the proof of `ConNF.lt_base` to establish the fact that the base type is well-ordered, which is a crucial property for constructing the natural numbers in the ConNF context."}
{"full_name": "ConNF.small_constrains", "url": "ConNF/FOA/Basic/Constrains.html#ConNF.small_constrains", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.small_constrains [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.FOAAssumptions] {β : ConNF.Λ} (c : ConNF.Address🔗<|PREMISE|>🔗 ↑β) :ConNF.Small🔗<|PREMISE|>🔗 {d : ConNF.Address🔗<|PREMISE|>🔗 ↑β | d ≺ c}", "code": "theorem small_constrains {β : Λ} (c : Address β) : Small {d | d ≺ c} := by\n  obtain ⟨A, a | N⟩ := c\n  · simp only [constrains_atom, setOf_eq_eq_singleton, small_singleton]\n  simp_rw [constrains_iff]\n  refine Small.union ?_ (Small.union ?_ (Small.union ?_ (Small.union ?_ ?_))) <;>\n    rw [small_setOf]\n  · change Small {c | ∃ b B, _ ∧ _ = _}\n    simp only [Address.mk.injEq, false_and, and_false, exists_false,\n      setOf_false, small_empty]\n  · change Small {c | ∃ B N', _}\n    refine Set.Subsingleton.small ?_\n    rintro c ⟨_, _, _, ⟨rfl, rfl⟩, h₁⟩ d ⟨_, _, _, ⟨rfl, rfl⟩, h₂⟩\n    cases h₁\n    cases h₂\n    rfl\n  · change Small {c | ∃ B N' a, _}\n    convert (show Small (litterSet N.fst ∆ N) from N.2.prop).image\n      (f := fun a : Atom => (⟨A, inl a⟩ : Address β)) using 1\n    ext c : 1\n    simp only [mem_setOf_eq, mem_image]\n    constructor\n    · rintro ⟨B, N', a, h₁, h₂, h₃⟩\n      cases h₃\n      exact ⟨a, h₁, h₂.symm⟩\n    · rintro ⟨a, h₁, h₂⟩\n      exact ⟨A, N, a, h₁, h₂.symm, rfl⟩\n  · by_cases h :\n      ∃ (γ : Λ) (_ : LeLevel γ) (δ : Λ) (_ : LtLevel δ) (ε : Λ) (_ : LtLevel ε)\n        (_ : (δ : TypeIndex) < γ) (hε : (ε : TypeIndex) < γ) (hδε : (δ : TypeIndex) ≠ ε)\n        (B : Path (β : TypeIndex) γ) (t : Tangle δ),\n        N = (fuzz hδε t).toNearLitter ∧ A = (B.cons hε).cons (bot_lt_coe _)\n    · obtain ⟨γ, _, δ, _, ε, _, hδ, hε, hδε, B, t, rfl, rfl⟩ := h\n      refine lt_of_le_of_lt ?_ t.support.small\n      suffices\n        #{a : Address β | ∃ c : (t.support : Set (Address δ)),\n            a = ⟨(B.cons hδ).comp c.val.path, c.val.value⟩} ≤\n          #(t.support : Set (Address δ)) by\n        refine le_trans (Cardinal.mk_subtype_le_of_subset ?_) this\n        rintro x ⟨_, _, _, _, _, _, _, _, _, _, _, c, hc, rfl, h⟩\n        rw [Address.mk.injEq] at h\n        simp only [inr.injEq, Litter.toNearLitter_injective.eq_iff] at h\n        cases WithBot.coe_injective (fuzz_congr_β h.2)\n        cases fuzz_congr_γ h.2\n        cases fuzz_injective _ h.2\n        cases coe_inj.mp (Path.obj_eq_of_cons_eq_cons (Path.heq_of_cons_eq_cons h.1).eq)\n        cases (Path.heq_of_cons_eq_cons (Path.heq_of_cons_eq_cons h.1).eq).eq\n        exact ⟨⟨c, hc⟩, rfl⟩\n      refine ⟨⟨fun a => a.prop.choose, ?_⟩⟩\n      intro a b h\n      refine Subtype.coe_inj.mp ?_\n      rw [a.prop.choose_spec, b.prop.choose_spec]\n      simp only [h]\n    · refine small_of_forall_not_mem ?_\n      rintro x ⟨γ, _, δ, _, ε, _, hδ, hε, hδε, B, t, c, _, rfl, hA⟩\n      rw [Address.mk.injEq] at hA\n      simp only [inr.injEq] at hA\n      exact h ⟨γ, inferInstance, δ, inferInstance, ε, inferInstance, hδ, hε, hδε, B, t, hA.2, hA.1⟩\n  · refine Set.Subsingleton.small ?_\n    rintro ⟨c, C⟩ ⟨γ, _, ε, _, hε, C', a, hc₁, hc₂⟩ ⟨d, D⟩ ⟨γ, _, ε, _, hε, D', b, hd₁, hd₂⟩\n    rw [Address.mk.injEq] at hc₁ hc₂ hd₁ hd₂\n    simp only [inr.injEq] at hc₂ hd₂\n    rw [hc₁.1, hc₁.2, hd₁.1, hd₁.2]\n    rw [hc₂.1, hc₂.2, Litter.toNearLitter_injective.eq_iff] at hd₂\n    cases coe_inj.mp (Path.obj_eq_of_cons_eq_cons hd₂.1)\n    cases coe_inj.mp (Path.obj_eq_of_cons_eq_cons (Path.heq_of_cons_eq_cons hd₂.1).eq)\n    cases (Path.heq_of_cons_eq_cons (Path.heq_of_cons_eq_cons hd₂.1).eq).eq\n    rw [(fuzz_injective bot_ne_coe).eq_iff] at hd₂\n    cases hd₂.2\n    rfl\n", "additional_info": "", "used_premises": [1, 60, 233, 60], "def_path": "ConNF/FOA/Basic/Constrains.lean", "pos": [373, 442], "informalization": "In the context of Constructive Ordinal Notation (ConNF), the theorem `ConNF.small_constrains` asserts that for any address `c` in the base type `β`, the set of addresses `d` that are constrained by `c` (denoted as `d ≺ c`) has a cardinality that is strictly less than the cardinality of the type `ConNF.κ`. This theorem is crucial for establishing the well-foundedness of the `≺` relation on addresses within the ConNF framework."}
{"full_name": "ConNF.reduced_iff", "url": "ConNF/FOA/Basic/Reduction.html#ConNF.reduced_iff", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.reduced_iff [ConNF.Params🔗<|PREMISE|>🔗 ] :∀ (a : ConNF.Atom ⊕ ConNF.NearLitter), ConNF.Reduced🔗<|PREMISE|>🔗 a ↔ (∃ (a_1 : ConNF.Atom), a = Sum.inl🔗<|PREMISE|>🔗 a_1) ∨ ∃ (L : ConNF.Litter), a = Sum.inr🔗<|PREMISE|>🔗 (ConNF.Litter.toNearLitter🔗<|PREMISE|>🔗 L)", "code": "@[mk_iff]\n", "additional_info": "", "used_premises": [1, 932, 67, 65, 483], "def_path": "ConNF/FOA/Basic/Reduction.lean", "pos": [31, 32], "informalization": "The theorem `ConNF.reduced_iff` states that an address in Constructive Ordinal Notation (ConNF) is reduced (either an atom or a litter) if and only if it is either the left injection of an atom or the right injection of a litter."}
{"full_name": "ConNF.Reduced", "url": "ConNF/FOA/Basic/Reduction.html#ConNF.Reduced", "code_src": "con-nf", "ptype": "inductive", "header": "inductive ConNF.Reduced [ConNF.Params🔗<|PREMISE|>🔗 ] :ConNF.Atom ⊕ ConNF.NearLitter → Prop", "code": "inductive Reduced : Atom ⊕ NearLitter → Prop\n  | mkAtom (a : Atom) : Reduced (inl a)\n  | mkLitter (L : Litter) : Reduced (inr L.toNearLitter)\n", "additional_info": "An address is *reduced* if it is an atom or a litter.\n", "used_premises": [1], "def_path": "ConNF/FOA/Basic/Reduction.lean", "pos": [32, 35], "informalization": "Type `ConNF.Reduced` represents the property that an address in Constructive Ordinal Notation (ConNF) is reduced, meaning it is either an atom or a litter."}
{"full_name": "ConNF.isLitter_of_reduced", "url": "ConNF/FOA/Basic/Reduction.html#ConNF.isLitter_of_reduced", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.isLitter_of_reduced [ConNF.Params🔗<|PREMISE|>🔗 ] {N : ConNF.NearLitter} (h : ConNF.Reduced🔗<|PREMISE|>🔗 (Sum.inr🔗<|PREMISE|>🔗 N)) :ConNF.NearLitter.IsLitter🔗<|PREMISE|>🔗 N", "code": "theorem isLitter_of_reduced {N : NearLitter} (h : Reduced (inr N)) : N.IsLitter := by\n  cases h\n  exact NearLitter.IsLitter.mk _\n", "additional_info": "", "used_premises": [1, 932, 65, 495], "def_path": "ConNF/FOA/Basic/Reduction.lean", "pos": [36, 39], "informalization": "The theorem `ConNF.isLitter_of_reduced` states that if a near-litter `N` is reduced in the context of Constructive Ordinal Notation (ConNF), then `N` is of the form `L.toNearLitter` for some litter `L`."}
{"full_name": "ConNF.mem_reflTransClosure_of_mem", "url": "ConNF/FOA/Basic/Reduction.html#ConNF.mem_reflTransClosure_of_mem", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.mem_reflTransClosure_of_mem [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.FOAAssumptions] {β : ConNF.Λ} (S : Set🔗<|PREMISE|>🔗 (ConNF.Address🔗<|PREMISE|>🔗 ↑β)) (c : ConNF.Address🔗<|PREMISE|>🔗 ↑β) (hc : c ∈ S) :c ∈ ConNF.reflTransClosure🔗<|PREMISE|>🔗 S", "code": "theorem mem_reflTransClosure_of_mem (S : Set (Address β)) (c : Address β)\n    (hc : c ∈ S) : c ∈ reflTransClosure S :=\n  ⟨c, hc, Relation.ReflTransGen.refl⟩\n", "additional_info": "", "used_premises": [1, 69, 60, 60, 935], "def_path": "ConNF/FOA/Basic/Reduction.lean", "pos": [44, 47], "informalization": "The theorem `ConNF.mem_reflTransClosure_of_mem` states that if `c` is an element of a set `S` of addresses in the context of Constructive Ordinal Notation (ConNF), then `c` is also an element of the reflexive transitive closure of `S`. This means that `c` can be reached from the addresses in `S` through a finite series of descents."}
{"full_name": "ConNF.reflTransClosure", "url": "ConNF/FOA/Basic/Reduction.html#ConNF.reflTransClosure", "code_src": "con-nf", "ptype": "def", "header": "def ConNF.reflTransClosure [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.FOAAssumptions] {β : ConNF.Λ} (S : Set🔗<|PREMISE|>🔗 (ConNF.Address🔗<|PREMISE|>🔗 ↑β)) :Set🔗<|PREMISE|>🔗 (ConNF.Address🔗<|PREMISE|>🔗 ↑β)", "code": "def reflTransClosure (S : Set (Address β)) : Set (Address β) :=\n  {c | ∃ d ∈ S, c ≤ d}\n", "additional_info": "The reflexive transitive closure of a set of addresses.\nEquations\n* 🗟ConNF.reflTransClosure🗟🔗../../.././ConNF/FOA/Basic/Reduction.html#ConNF.reflTransClosure🔗  S 🗟=🗟🔗../../.././Init/Prelude.html#Eq🔗  {c : 🗟ConNF.Address🗟🔗../../.././ConNF/Structural/Support.html#ConNF.Address🔗  ↑β | ∃ d ∈ S, c 🗟≤🗟🔗../../.././Init/Prelude.html#LE.le🔗  d}\n\n", "used_premises": [1, 69, 60, 69, 60], "def_path": "ConNF/FOA/Basic/Reduction.lean", "pos": [41, 43], "informalization": "Function `ConNF.reflTransClosure` computes the reflexive transitive closure of a set of addresses in the context of Constructive Ordinal Notation (ConNF). The reflexive transitive closure of a set `S` of addresses is the set of all addresses `c` such that there exists an address `d` in `S` for which `c` is less than or equal to `d`. This function is crucial in the context of ConNF because it allows us to determine the set of all addresses that can be reached from the addresses in `S` through a finite series of descents."}
{"full_name": "ConNF.mem_reduction_of_reduced", "url": "ConNF/FOA/Basic/Reduction.html#ConNF.mem_reduction_of_reduced", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.mem_reduction_of_reduced [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.FOAAssumptions] {β : ConNF.Λ} (S : Set🔗<|PREMISE|>🔗 (ConNF.Address🔗<|PREMISE|>🔗 ↑β)) (c : ConNF.Address🔗<|PREMISE|>🔗 ↑β) (hc₁ : ConNF.Reduced🔗<|PREMISE|>🔗 c.value) (hc₂ : c ∈ S) :c ∈ ConNF.reduction🔗<|PREMISE|>🔗 S", "code": "theorem mem_reduction_of_reduced (S : Set (Address β)) (c : Address β)\n    (hc₁ : Reduced c.value) (hc₂ : c ∈ S) : c ∈ reduction S :=\n  ⟨mem_reflTransClosure_of_mem S c hc₂, hc₁⟩\n", "additional_info": "", "used_premises": [1, 69, 60, 60, 932, 937], "def_path": "ConNF/FOA/Basic/Reduction.lean", "pos": [57, 60], "informalization": "The theorem `mem_reduction_of_reduced` in Constructive Ordinal Notation (ConNF) states that if an address `c` is reduced and belongs to a set of addresses `S`, then `c` also belongs to the reduction of `S`. The reduction of a set of addresses is the intersection of the reflexive transitive closure of the set under the constraints relation and the set of reduced conditions."}
{"full_name": "ConNF.reduction", "url": "ConNF/FOA/Basic/Reduction.html#ConNF.reduction", "code_src": "con-nf", "ptype": "def", "header": "def ConNF.reduction [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.FOAAssumptions] {β : ConNF.Λ} (S : Set🔗<|PREMISE|>🔗 (ConNF.Address🔗<|PREMISE|>🔗 ↑β)) :Set🔗<|PREMISE|>🔗 (ConNF.Address🔗<|PREMISE|>🔗 ↑β)", "code": "def reduction (S : Set (Address β)) : Set (Address β) :=\n  reflTransClosure S ∩ {c | Reduced c.value}\n", "additional_info": "The *reduction* of a set of addresses is the downward closure of the set under\nthe constrains relation, but we only keep reduced conditions.\nEquations\n* 🗟ConNF.reduction🗟🔗../../.././ConNF/FOA/Basic/Reduction.html#ConNF.reduction🔗  S 🗟=🗟🔗../../.././Init/Prelude.html#Eq🔗  🗟ConNF.reflTransClosure🗟🔗../../.././ConNF/FOA/Basic/Reduction.html#ConNF.reflTransClosure🔗  S 🗟∩🗟🔗../../.././Init/Core.html#Inter.inter🔗  {c : 🗟ConNF.Address🗟🔗../../.././ConNF/Structural/Support.html#ConNF.Address🔗  ↑β | 🗟ConNF.Reduced🗟🔗../../.././ConNF/FOA/Basic/Reduction.html#ConNF.Reduced🔗  c.value}\n\n", "used_premises": [1, 69, 60, 69, 60], "def_path": "ConNF/FOA/Basic/Reduction.lean", "pos": [54, 56], "informalization": "Function `ConNF.reduction` computes the reduction of a set of addresses, which is the intersection of the reflexive transitive closure of the set under the constraints relation and the set of reduced conditions."}
{"full_name": "ConNF.mem_reduction_of_reduced_constrains", "url": "ConNF/FOA/Basic/Reduction.html#ConNF.mem_reduction_of_reduced_constrains", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.mem_reduction_of_reduced_constrains [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.FOAAssumptions] {β : ConNF.Λ} (S : Set🔗<|PREMISE|>🔗 (ConNF.Address🔗<|PREMISE|>🔗 ↑β)) (c : ConNF.Address🔗<|PREMISE|>🔗 ↑β) (d : ConNF.Address🔗<|PREMISE|>🔗 ↑β) (hc : ConNF.Reduced🔗<|PREMISE|>🔗 c.value) (hcd : c ≺ d) (hd : d ∈ S) :c ∈ ConNF.reduction🔗<|PREMISE|>🔗 S", "code": "theorem mem_reduction_of_reduced_constrains (S : Set (Address β))\n    (c d : Address β) (hc : Reduced c.value) (hcd : c ≺ d) (hd : d ∈ S) :\n    c ∈ reduction S :=\n  ⟨⟨d, hd, Relation.ReflTransGen.single hcd⟩, hc⟩\n", "additional_info": "", "used_premises": [1, 69, 60, 60, 60, 932, 937], "def_path": "ConNF/FOA/Basic/Reduction.lean", "pos": [61, 65], "informalization": "The theorem `mem_reduction_of_reduced_constrains` in Constructive Ordinal Notation (ConNF) states that if `c` is a reduced condition, `c` is constrained by `d`, and `d` is in the set `S`, then `c` is in the reduction of `S`."}
{"full_name": "ConNF.small_nthReduction", "url": "ConNF/FOA/Basic/Reduction.html#ConNF.small_nthReduction", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.small_nthReduction [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.FOAAssumptions] {β : ConNF.Λ} {S : Set🔗<|PREMISE|>🔗 (ConNF.Address🔗<|PREMISE|>🔗 ↑β)} {n : ℕ } (h : ConNF.Small🔗<|PREMISE|>🔗 S) :ConNF.Small🔗<|PREMISE|>🔗 (ConNF.nthClosure🔗<|PREMISE|>🔗 S n)", "code": "theorem small_nthReduction {S : Set (Address β)} {n : ℕ} (h : Small S) :\n    Small (nthClosure S n) := by\n  induction' n with n hn\n  exact h\n  rw [nthClosure]\n  simp_rw [← exists_prop, Subtype.exists', setOf_exists]\n  refine' small_iUnion hn _\n  rintro ⟨c, _⟩\n  exact small_constrains c\n", "additional_info": "The `🗟nthClosure🗟🔗../../.././ConNF/FOA/Basic/Reduction.html#ConNF.nthClosure🔗`  of a small set is small.", "used_premises": [1, 69, 60, 233, 233, 940], "def_path": "ConNF/FOA/Basic/Reduction.lean", "pos": [72, 81], "informalization": "The `nthClosure` of a small set is small."}
{"full_name": "ConNF.nthClosure", "url": "ConNF/FOA/Basic/Reduction.html#ConNF.nthClosure", "code_src": "con-nf", "ptype": "def", "header": "def ConNF.nthClosure [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.FOAAssumptions] {β : ConNF.Λ} (S : Set🔗<|PREMISE|>🔗 (ConNF.Address🔗<|PREMISE|>🔗 ↑β)) :ℕ → Set🔗<|PREMISE|>🔗 (ConNF.Address🔗<|PREMISE|>🔗 ↑β)", "code": "def nthClosure (S : Set (Address β)) : ℕ → Set (Address β)\n  | 0 => S\n  | n + 1 => {c | ∃ d, d ∈ nthClosure S n ∧ c ≺ d}\n", "additional_info": "Gadget that helps us prove that the `🗟reflTransClosure🗟🔗../../.././ConNF/FOA/Basic/Reduction.html#ConNF.reflTransClosure🔗`  of a small set is small.\nEquations\n* 🗟ConNF.nthClosure🗟🔗../../.././ConNF/FOA/Basic/Reduction.html#ConNF.nthClosure🔗  S 0 🗟=🗟🔗../../.././Init/Prelude.html#Eq🔗  S\n* 🗟ConNF.nthClosure🗟🔗../../.././ConNF/FOA/Basic/Reduction.html#ConNF.nthClosure🔗  S (🗟Nat.succ🗟🔗../../.././Init/Prelude.html#Nat.succ🔗  n) 🗟=🗟🔗../../.././Init/Prelude.html#Eq🔗  {c : 🗟ConNF.Address🗟🔗../../.././ConNF/Structural/Support.html#ConNF.Address🔗  ↑β | ∃ d ∈ 🗟ConNF.nthClosure🗟🔗../../.././ConNF/FOA/Basic/Reduction.html#ConNF.nthClosure🔗  S n, c 🗟≺🗟🔗../../.././ConNF/FOA/Basic/Constrains.html#ConNF.Constrains🔗  d}\n\n", "used_premises": [1, 69, 60, 69, 60], "def_path": "ConNF/FOA/Basic/Reduction.lean", "pos": [67, 70], "informalization": "Function `ConNF.nthClosure` is a gadget used in the context of Constructive Ordinal Notation (ConNF) to prove that the reflexive transitive closure of a small set is small. It takes a set `S` of `ConNF.Address` objects and a natural number `n`, and returns the set of all `ConNF.Address` objects that can be reached from `S` in at most `n` steps using the `≺` relation, which represents a descent in the ConNF model."}
{"full_name": "ConNF.reflTransClosure_eq_iUnion_nthClosure", "url": "ConNF/FOA/Basic/Reduction.html#ConNF.reflTransClosure_eq_iUnion_nthClosure", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.reflTransClosure_eq_iUnion_nthClosure [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.FOAAssumptions] {β : ConNF.Λ} {S : Set🔗<|PREMISE|>🔗 (ConNF.Address🔗<|PREMISE|>🔗 ↑β)} :ConNF.reflTransClosure🔗<|PREMISE|>🔗 S = ⋃ (n : ℕ ), ConNF.nthClosure🔗<|PREMISE|>🔗 S n", "code": "theorem reflTransClosure_eq_iUnion_nthClosure {S : Set (Address β)} :\n    reflTransClosure S = ⋃ n, nthClosure S n := by\n  refine' subset_antisymm _ _\n  · rintro c ⟨d, hdS, hd⟩\n    obtain ⟨l, hl, rfl⟩ := List.exists_chain_of_relationReflTransGen hd\n    rw [mem_iUnion]\n    refine' ⟨l.length, _⟩\n    rw [mem_nthClosure_iff]\n    refine' ⟨l, hl, rfl, hdS⟩\n  · intro c hc\n    rw [mem_iUnion] at hc\n    obtain ⟨i, hc⟩ := hc\n    rw [mem_nthClosure_iff] at hc\n    obtain ⟨l, hl₁, _hl₂, hl₃⟩ := hc\n    exact\n      ⟨(c::l).getLast (List.cons_ne_nil _ _), hl₃,\n        List.relationReflTransGen_of_exists_chain l hl₁ rfl⟩\n", "additional_info": "The `🗟reflTransClosure🗟🔗../../.././ConNF/FOA/Basic/Reduction.html#ConNF.reflTransClosure🔗`  of a set is the `ℕ`-indexed union of the `n`th closures.", "used_premises": [1, 69, 60, 935, 940], "def_path": "ConNF/FOA/Basic/Reduction.lean", "pos": [111, 128], "informalization": "Function `ConNF.reflTransClosure` computes the reflexive transitive closure of a set of addresses in the context of Constructive Ordinal Notation (ConNF). The reflexive transitive closure of a set `S` of addresses is the set of all addresses `c` such that there exists an address `d` in `S` for which `c` is less than or equal to `d`. This function is crucial in the context of ConNF because it allows us to determine the set of all addresses that can be reached from the addresses in `S` through a finite series of descents. The theorem `ConNF.reflTransClosure_eq_iUnion_nthClosure` states that the reflexive transitive closure of a set `S` is equal to the `ℕ`-indexed union of the `n`th closures of `S`."}
{"full_name": "ConNF.reflTransClosure_small", "url": "ConNF/FOA/Basic/Reduction.html#ConNF.reflTransClosure_small", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.reflTransClosure_small [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.FOAAssumptions] {β : ConNF.Λ} {S : Set🔗<|PREMISE|>🔗 (ConNF.Address🔗<|PREMISE|>🔗 ↑β)} (h : ConNF.Small🔗<|PREMISE|>🔗 S) :ConNF.Small🔗<|PREMISE|>🔗 (ConNF.reflTransClosure🔗<|PREMISE|>🔗 S)", "code": "theorem reflTransClosure_small {S : Set (Address β)} (h : Small S) :\n    Small (reflTransClosure S) := by\n  rw [reflTransClosure_eq_iUnion_nthClosure]\n  have : Small (⋃ n : ULift ℕ, nthClosure S n.down)\n  · refine' small_iUnion _ fun _ => small_nthReduction h\n    rw [Cardinal.mk_denumerable]\n    exact aleph0_le_mk_Λ.trans_lt Params.Λ_lt_κ\n  convert this using 1\n  ext x : 1\n  simp only [mem_iUnion, ULift.exists]\n", "additional_info": "The `🗟reflTransClosure🗟🔗../../.././ConNF/FOA/Basic/Reduction.html#ConNF.reflTransClosure🔗`  of a small set is small.", "used_premises": [1, 69, 60, 233, 233, 935], "def_path": "ConNF/FOA/Basic/Reduction.lean", "pos": [130, 140], "informalization": "The theorem `ConNF.reflTransClosure_small` states that the reflexive transitive closure of a small set of addresses in the context of Constructive Ordinal Notation (ConNF) is also small. This result is crucial because it ensures that the set of all addresses that can be reached from a small set of addresses through a finite series of descents remains small."}
{"full_name": "ConNF.transClosure_small", "url": "ConNF/FOA/Basic/Reduction.html#ConNF.transClosure_small", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.transClosure_small [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.FOAAssumptions] {β : ConNF.Λ} {S : Set🔗<|PREMISE|>🔗 (ConNF.Address🔗<|PREMISE|>🔗 ↑β)} (h : ConNF.Small🔗<|PREMISE|>🔗 S) :ConNF.Small🔗<|PREMISE|>🔗 (ConNF.transClosure🔗<|PREMISE|>🔗 S)", "code": "theorem transClosure_small {S : Set (Address β)} (h : Small S) :\n    Small (transClosure S) := by\n  refine' lt_of_le_of_lt (Cardinal.mk_le_mk_of_subset _) (reflTransClosure_small h)\n  rintro c ⟨d, hd₁, hd₂⟩\n  exact ⟨d, hd₁, hd₂.to_reflTransGen⟩\n", "additional_info": "The `🗟transClosure🗟🔗../../.././ConNF/FOA/Basic/Reduction.html#ConNF.transClosure🔗`  of a small set is small.", "used_premises": [1, 69, 60, 233, 233, 944], "def_path": "ConNF/FOA/Basic/Reduction.lean", "pos": [142, 147], "informalization": "In the context of Constructive Ordinal Notation (ConNF), the transitive closure of a small set is also small."}
{"full_name": "ConNF.transClosure", "url": "ConNF/FOA/Basic/Reduction.html#ConNF.transClosure", "code_src": "con-nf", "ptype": "def", "header": "def ConNF.transClosure [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.FOAAssumptions] {β : ConNF.Λ} (S : Set🔗<|PREMISE|>🔗 (ConNF.Address🔗<|PREMISE|>🔗 ↑β)) :Set🔗<|PREMISE|>🔗 (ConNF.Address🔗<|PREMISE|>🔗 ↑β)", "code": "def transClosure (S : Set (Address β)) : Set (Address β) :=\n  {c | ∃ d ∈ S, c < d}\n", "additional_info": "The transitive closure of a set of addresses.\nEquations\n* 🗟ConNF.transClosure🗟🔗../../.././ConNF/FOA/Basic/Reduction.html#ConNF.transClosure🔗  S 🗟=🗟🔗../../.././Init/Prelude.html#Eq🔗  {c : 🗟ConNF.Address🗟🔗../../.././ConNF/Structural/Support.html#ConNF.Address🔗  ↑β | ∃ d ∈ S, c 🗟<🗟🔗../../.././Init/Prelude.html#LT.lt🔗  d}\n\n", "used_premises": [1, 69, 60, 69, 60], "def_path": "ConNF/FOA/Basic/Reduction.lean", "pos": [49, 51], "informalization": "Function `ConNF.transClosure` computes the transitive closure of a set of addresses in the context of Constructive Ordinal Notation (ConNF). The transitive closure of a set `S` is the set of all addresses that are strictly less than some address in `S`."}
{"full_name": "ConNF.reduction_small", "url": "ConNF/FOA/Basic/Reduction.html#ConNF.reduction_small", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.reduction_small [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.FOAAssumptions] {β : ConNF.Λ} {S : Set🔗<|PREMISE|>🔗 (ConNF.Address🔗<|PREMISE|>🔗 ↑β)} (h : ConNF.Small🔗<|PREMISE|>🔗 S) :ConNF.Small🔗<|PREMISE|>🔗 (ConNF.reduction🔗<|PREMISE|>🔗 S)", "code": "theorem reduction_small {S : Set (Address β)} (h : Small S) : Small (reduction S) :=\n  lt_of_le_of_lt (Cardinal.mk_subtype_le_of_subset fun _c hc => hc.1) (reflTransClosure_small h)\n", "additional_info": "The `🗟reduction🗟🔗../../.././ConNF/FOA/Basic/Reduction.html#ConNF.reduction🔗`  of a small set is small.", "used_premises": [1, 69, 60, 233, 233, 937], "def_path": "ConNF/FOA/Basic/Reduction.lean", "pos": [149, 151], "informalization": "Function `ConNF.reduction_small` proves that the reduction of a small set is also small in the context of Constructive Ordinal Notation (ConNF)."}
{"full_name": "ConNF.reduction_supports", "url": "ConNF/FOA/Basic/Reduction.html#ConNF.reduction_supports", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.reduction_supports [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.FOAAssumptions] {β : ConNF.Λ} (S : Set🔗<|PREMISE|>🔗 (ConNF.Address🔗<|PREMISE|>🔗 ↑β)) (c : ConNF.Address🔗<|PREMISE|>🔗 ↑β) (hc : c ∈ S) :MulAction.Supports🔗<|PREMISE|>🔗 (ConNF.StructPerm🔗<|PREMISE|>🔗 ↑β) (ConNF.reduction🔗<|PREMISE|>🔗 S) c", "code": "theorem reduction_supports (S : Set (Address β)) (c : Address β) (hc : c ∈ S) :\n    Supports (StructPerm β) (reduction S) c := by\n  intro π hc'\n  obtain ⟨B, a | N⟩ := c\n  · exact hc' (mem_reduction_of_reduced _ _ (Reduced.mkAtom a) hc)\n  by_cases h : N.IsLitter\n  · obtain ⟨L, rfl⟩ := h.exists_litter_eq\n    exact hc' (mem_reduction_of_reduced _ _ (Reduced.mkLitter L) hc)\n  simp only [StructPerm.smul_address_eq_iff, smul_inr, inr.injEq] at hc' ⊢\n  have h₃ := hc' (mem_reduction_of_reduced_constrains _ ⟨B, inr N.fst.toNearLitter⟩ _\n    (Reduced.mkLitter N.fst) (Constrains.nearLitter B N h) hc)\n  have h₄ := fun a ha => hc' (mem_reduction_of_reduced_constrains _ ⟨B, inl a⟩ _\n    (Reduced.mkAtom a) (Constrains.symmDiff B N a ha) hc)\n  simp only [smul_inr, inr.injEq, smul_inl, inl.injEq] at h₃ h₄\n  refine' SetLike.coe_injective _\n  refine' (NearLitterPerm.smul_nearLitter_eq_smul_symmDiff_smul _ N).trans _\n  rw [h₃]\n  refine' Eq.trans _ (symmDiff_symmDiff_cancel_left (litterSet N.fst) _)\n  refine' congr_arg _ _\n  ext a : 1\n  constructor\n  · rintro ⟨b, hb, rfl⟩\n    dsimp only\n    rw [h₄ b hb]\n    exact hb\n  · intro ha\n    refine' ⟨a, ha, _⟩\n    exact h₄ a ha\n", "additional_info": "The reduction of a set supports every element in its domain under the action of structural\npermutations.", "used_premises": [1, 69, 60, 60, 68, 55, 937], "def_path": "ConNF/FOA/Basic/Reduction.lean", "pos": [154, 182], "informalization": "Given the Lean 4 object `ConNF.reduction_supports`, which is a theorem in the context of Constructive Ordinal Notation (ConNF) in Lean 4, it states that the reduction of a set of addresses supports every element in its domain under the action of structural permutations. This theorem is useful in proving the existence of a permutation that normalizes the addresses within the set."}
{"full_name": "ConNF.reduction_support_supports", "url": "ConNF/FOA/Basic/Reduction.html#ConNF.reduction_support_supports", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.reduction_support_supports [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.FOAAssumptions] {β : ConNF.Λ} [ConNF.TangleData🔗<|PREMISE|>🔗 ↑β] (t : ConNF.Tangle ↑β) :MulAction.Supports🔗<|PREMISE|>🔗 (ConNF.Allowable ↑β) (ConNF.reduction🔗<|PREMISE|>🔗 (ConNF.Enumeration.carrier🔗<|PREMISE|>🔗 (ConNF.TangleData.Tangle.support🔗<|PREMISE|>🔗 t).enum)) t", "code": "theorem reduction_support_supports [TangleData β] (t : Tangle β) :\n    Supports (Allowable β) (reduction (t.support : Set (Address β))) t := by\n  intro ρ h\n  refine support_supports t ρ ?_\n  intros c hc'\n  exact reduction_supports t.support c hc' (Allowable.toStructPerm ρ) h\n", "additional_info": "", "used_premises": [1, 39, 68, 937, 70, 395], "def_path": "ConNF/FOA/Basic/Reduction.lean", "pos": [183, 189], "informalization": "In the context of Constructive Ordinal Notation (ConNF), the theorem `ConNF.reduction_support_supports` asserts that for any tangle `t` at level `β`, the reduction of the carrier set of the small support of `t` supports `t` under the action of the allowable permutations at level `β`. This means that if an allowable permutation acts trivially on every element in the reduction of the small support of `t`, then it also acts trivially on `t`."}
{"full_name": "PartialPerm.exists_sandbox_subset", "url": "ConNF/FOA/Basic/CompleteOrbit.html#PartialPerm.exists_sandbox_subset", "code_src": "con-nf", "ptype": "theorem", "header": "theorem PartialPerm.exists_sandbox_subset {α : Type u_1} {f : α → α} {s : Set🔗<|PREMISE|>🔗 α} {t : Set🔗<|PREMISE|>🔗 α} (hs : Cardinal.mk🔗<|PREMISE|>🔗 ↑(symmDiff🔗<|PREMISE|>🔗 s (f '' s)) ≤ Cardinal.mk🔗<|PREMISE|>🔗 ↑t) (ht : Cardinal.aleph0🔗<|PREMISE|>🔗 ≤ Cardinal.mk🔗<|PREMISE|>🔗 ↑t) :Cardinal.mk🔗<|PREMISE|>🔗 (ℕ × ↑(s \\ f '' s) ⊕ ℕ × ↑(f '' s \\ s)) ≤ Cardinal.mk🔗<|PREMISE|>🔗 ↑t", "code": "theorem exists_sandbox_subset (hs : #(s ∆ (f '' s) : Set α) ≤ #t) (ht : ℵ₀ ≤ #t) :\n    #((ℕ × (s \\ f '' s : Set α)) ⊕ (ℕ × (f '' s \\ s : Set α))) ≤ #t := by\n  rw [Set.symmDiff_def, mk_union_of_disjoint] at hs\n  · simp only [mk_sum, mk_prod, mk_denumerable, lift_aleph0, lift_uzero, lift_id, ← mul_add] at hs ⊢\n    exact le_trans (mul_le_max_of_aleph0_le_left le_rfl) (max_le ht hs)\n  · rw [disjoint_iff_inter_eq_empty, eq_empty_iff_forall_not_mem]\n    exact fun x hx => hx.1.2 hx.2.1\n", "additional_info": "", "used_premises": [69, 69, 29, 62, 29, 510, 29, 29, 29], "def_path": "ConNF/FOA/Basic/CompleteOrbit.lean", "pos": [31, 38], "informalization": "Given a type α and a function f : α → α, the symmetric difference of two sets s and f '' s is defined as the union of the relative complements s \\ f '' s and f '' s \\ s. This theorem states that if the cardinality of this symmetric difference is at most the cardinality of a set t (hypothesis hs), and the set t has at least the cardinality of the natural numbers (hypothesis ht), then the cardinality of the disjoint union of the natural numbers and the relative complements s \\ f '' s and f '' s \\ s is also at most the cardinality of the set t."}
{"full_name": "PartialPerm.sandboxSubset_subset", "url": "ConNF/FOA/Basic/CompleteOrbit.html#PartialPerm.sandboxSubset_subset", "code_src": "con-nf", "ptype": "theorem", "header": "theorem PartialPerm.sandboxSubset_subset {α : Type u_1} {f : α → α} {s : Set🔗<|PREMISE|>🔗 α} {t : Set🔗<|PREMISE|>🔗 α} (hs : Cardinal.mk🔗<|PREMISE|>🔗 ↑(symmDiff🔗<|PREMISE|>🔗 s (f '' s)) ≤ Cardinal.mk🔗<|PREMISE|>🔗 ↑t) (ht : Cardinal.aleph0🔗<|PREMISE|>🔗 ≤ Cardinal.mk🔗<|PREMISE|>🔗 ↑t) :PartialPerm.sandboxSubset🔗<|PREMISE|>🔗 hs ht ⊆ t", "code": "theorem sandboxSubset_subset : sandboxSubset hs ht ⊆ t :=\n  (le_mk_iff_exists_subset.mp <| exists_sandbox_subset hs ht).choose_spec.1\n", "additional_info": "", "used_premises": [69, 69, 29, 62, 29, 510, 29, 950], "def_path": "ConNF/FOA/Basic/CompleteOrbit.lean", "pos": [43, 45], "informalization": "`PartialPerm.sandboxSubset_subset` is a theorem stating that if the symmetric difference of a set `s` and its image under a function `f` is at most as large as a set `t`, and `t` has at least the cardinality of the natural numbers (denoted as `ℵ₀`), then the sandbox subset of `t` created by `PartialPerm.sandboxSubset` is a subset of `t`."}
{"full_name": "PartialPerm.sandboxSubset", "url": "ConNF/FOA/Basic/CompleteOrbit.html#PartialPerm.sandboxSubset", "code_src": "con-nf", "ptype": "def", "header": "def PartialPerm.sandboxSubset {α : Type u_1} {f : α → α} {s : Set🔗<|PREMISE|>🔗 α} {t : Set🔗<|PREMISE|>🔗 α} (hs : Cardinal.mk🔗<|PREMISE|>🔗 ↑(symmDiff🔗<|PREMISE|>🔗 s (f '' s)) ≤ Cardinal.mk🔗<|PREMISE|>🔗 ↑t) (ht : Cardinal.aleph0🔗<|PREMISE|>🔗 ≤ Cardinal.mk🔗<|PREMISE|>🔗 ↑t) :Set🔗<|PREMISE|>🔗 α", "code": "def sandboxSubset : Set α :=\n  (le_mk_iff_exists_subset.mp <| exists_sandbox_subset hs ht).choose\n", "additional_info": "Creates a \"sandbox\" subset of `t` on which we will define an extension of `f`.\nEquations\n* 🗟PartialPerm.sandboxSubset🗟🔗../../.././ConNF/FOA/Basic/CompleteOrbit.html#PartialPerm.sandboxSubset🔗  hs ht 🗟=🗟🔗../../.././Init/Prelude.html#Eq🔗  🗟Exists.choose🗟🔗../../.././Init/Classical.html#Exists.choose🔗  ⋯\n\n", "used_premises": [69, 69, 29, 62, 29, 510, 29, 69], "def_path": "ConNF/FOA/Basic/CompleteOrbit.lean", "pos": [40, 42], "informalization": "Function `PartialPerm.sandboxSubset` creates a \"sandbox\" subset of `t` on which we will define an extension of `f`."}
{"full_name": "PartialPerm.completeToFun_domain", "url": "ConNF/FOA/Basic/CompleteOrbit.html#PartialPerm.completeToFun_domain", "code_src": "con-nf", "ptype": "theorem", "header": "theorem PartialPerm.completeToFun_domain {α : Type u_1} {f : α → α} {s : Set🔗<|PREMISE|>🔗 α} {t : Set🔗<|PREMISE|>🔗 α} (hs : Cardinal.mk🔗<|PREMISE|>🔗 ↑(symmDiff🔗<|PREMISE|>🔗 s (f '' s)) ≤ Cardinal.mk🔗<|PREMISE|>🔗 ↑t) (ht : Cardinal.aleph0🔗<|PREMISE|>🔗 ≤ Cardinal.mk🔗<|PREMISE|>🔗 ↑t) (x : α) (h : x ∈ PartialPerm.completeDomain🔗<|PREMISE|>🔗 hs ht) :PartialPerm.completeToFun🔗<|PREMISE|>🔗 hs ht x ∈ PartialPerm.completeDomain🔗<|PREMISE|>🔗 hs ht", "code": "theorem completeToFun_domain (x : α) (h : x ∈ completeDomain hs ht) :\n    completeToFun hs ht x ∈ completeDomain hs ht := by\n  unfold completeToFun completeDomain\n  split_ifs with h₁ h₂\n  case pos =>\n    cases sandboxSubsetEquiv hs ht ⟨x, h₁⟩ with\n    | inl val =>\n      obtain ⟨_ | n, x⟩ := val\n      · exact Or.inl (Or.inl x.prop.1)\n      · exact Or.inr ((sandboxSubsetEquiv hs ht).symm _).prop\n    | inr val =>\n      obtain ⟨n, x⟩ := val\n      exact Or.inr ((sandboxSubsetEquiv hs ht).symm _).prop\n  case pos =>\n    exact Or.inr ((sandboxSubsetEquiv hs ht).symm _).prop\n  case neg =>\n    rw [mem_diff, not_and_or, Classical.not_not] at h₂\n    refine Or.inl (Or.inr ⟨x, ?_, rfl⟩)\n    obtain (h₂ | h₂) := h₂\n    · obtain (h | h) | h := h\n      exact h\n      cases h₂ h\n      cases h₁ h\n    · exact h₂\n", "additional_info": "", "used_premises": [69, 69, 29, 62, 29, 510, 29, 952, 953, 952], "def_path": "ConNF/FOA/Basic/CompleteOrbit.lean", "pos": [84, 108], "informalization": "Function `CompleteToFun` is an internal implementation detail used in the `Equiv` construction to complete a permutation. It is used only as a stepping stone to complete the permutation by placing the remaining elements in their correct positions. The final result of this function is a permutation that extends the given partial permutation to a full permutation, and hence is not relevant for a high-level understanding of the mathematical concepts involved. Instead, one should focus on the lemmas and theorems surrounding `Complete`, which are the actual mathematical components of the `PartialPerm` theory."}
{"full_name": "PartialPerm.completeDomain", "url": "ConNF/FOA/Basic/CompleteOrbit.html#PartialPerm.completeDomain", "code_src": "con-nf", "ptype": "def", "header": "def PartialPerm.completeDomain {α : Type u_1} {f : α → α} {s : Set🔗<|PREMISE|>🔗 α} {t : Set🔗<|PREMISE|>🔗 α} (hs : Cardinal.mk🔗<|PREMISE|>🔗 ↑(symmDiff🔗<|PREMISE|>🔗 s (f '' s)) ≤ Cardinal.mk🔗<|PREMISE|>🔗 ↑t) (ht : Cardinal.aleph0🔗<|PREMISE|>🔗 ≤ Cardinal.mk🔗<|PREMISE|>🔗 ↑t) :Set🔗<|PREMISE|>🔗 α", "code": "def completeDomain : Set α :=\n  s ∪ f '' s ∪ sandboxSubset hs ht\n", "additional_info": "The domain on which we will define the completion of a function to a local permutation.\nEquations\n* 🗟PartialPerm.completeDomain🗟🔗../../.././ConNF/FOA/Basic/CompleteOrbit.html#PartialPerm.completeDomain🔗  hs ht 🗟=🗟🔗../../.././Init/Prelude.html#Eq🔗  s 🗟∪🗟🔗../../.././Init/Core.html#Union.union🔗  f 🗟''🗟🔗../../.././Mathlib/Init/Set.html#Set.image🔗  s 🗟∪🗟🔗../../.././Init/Core.html#Union.union🔗  🗟PartialPerm.sandboxSubset🗟🔗../../.././ConNF/FOA/Basic/CompleteOrbit.html#PartialPerm.sandboxSubset🔗  hs ht\n\n", "used_premises": [69, 69, 29, 62, 29, 510, 29, 69], "def_path": "ConNF/FOA/Basic/CompleteOrbit.lean", "pos": [81, 83], "informalization": "Function `PartialPerm.completeDomain` defines the domain on which we will define the completion of a function to a local permutation. This domain is the union of three sets: the original set `s`, the image of `s` under the function `f`, and an additional set `sandboxSubset hs ht` which depends on the given conditions `hs` and `ht`."}
{"full_name": "PartialPerm.completeToFun", "url": "ConNF/FOA/Basic/CompleteOrbit.html#PartialPerm.completeToFun", "code_src": "con-nf", "ptype": "noncomputable def", "header": "noncomputable def PartialPerm.completeToFun {α : Type u_1} {f : α → α} {s : Set🔗<|PREMISE|>🔗 α} {t : Set🔗<|PREMISE|>🔗 α} (hs : Cardinal.mk🔗<|PREMISE|>🔗 ↑(symmDiff🔗<|PREMISE|>🔗 s (f '' s)) ≤ Cardinal.mk🔗<|PREMISE|>🔗 ↑t) (ht : Cardinal.aleph0🔗<|PREMISE|>🔗 ≤ Cardinal.mk🔗<|PREMISE|>🔗 ↑t) (a : α) :α", "code": "noncomputable def completeToFun (a : α) : α :=\n  if h : a ∈ sandboxSubset hs ht then\n    shiftRight hs ht (sandboxSubsetEquiv hs ht ⟨a, h⟩)\n  else if h : a ∈ f '' s \\ s then\n    (sandboxSubsetEquiv hs ht).symm (Sum.inr ⟨0, a, h⟩)\n  else\n    f a\n", "additional_info": "Considered an implementation detail; use lemmas about `🗟complete🗟🔗../../.././ConNF/FOA/Basic/CompleteOrbit.html#PartialPerm.complete🔗`  instead.\nEquations\n* One or more equations did not get rendered due to their size.\n\n", "used_premises": [69, 69, 29, 62, 29, 510, 29], "def_path": "ConNF/FOA/Basic/CompleteOrbit.lean", "pos": [57, 64], "informalization": "Function `CompleteToFun` is an internal implementation detail used in the `Equiv` construction to complete a permutation. It is used only as a stepping stone to complete the permutation by placing the remaining elements in their correct positions. The final result of this function is a permutation that extends the given partial permutation to a full permutation, and hence is not relevant for a high-level understanding of the mathematical concepts involved. Instead, one should focus on the lemmas and theorems surrounding `Complete`, which are the actual mathematical components of the `PartialPerm` theory."}
{"full_name": "PartialPerm.completeInvFun_domain", "url": "ConNF/FOA/Basic/CompleteOrbit.html#PartialPerm.completeInvFun_domain", "code_src": "con-nf", "ptype": "theorem", "header": "theorem PartialPerm.completeInvFun_domain {α : Type u_1} {f : α → α} {s : Set🔗<|PREMISE|>🔗 α} {t : Set🔗<|PREMISE|>🔗 α} (hs : Cardinal.mk🔗<|PREMISE|>🔗 ↑(symmDiff🔗<|PREMISE|>🔗 s (f '' s)) ≤ Cardinal.mk🔗<|PREMISE|>🔗 ↑t) (ht : Cardinal.aleph0🔗<|PREMISE|>🔗 ≤ Cardinal.mk🔗<|PREMISE|>🔗 ↑t) [Nonempty🔗<|PREMISE|>🔗 α] (x : α) (h : x ∈ PartialPerm.completeDomain🔗<|PREMISE|>🔗 hs ht) :PartialPerm.completeInvFun🔗<|PREMISE|>🔗 hs ht x ∈ PartialPerm.completeDomain🔗<|PREMISE|>🔗 hs ht", "code": "theorem completeInvFun_domain [Nonempty α] (x : α) (h : x ∈ completeDomain hs ht) :\n    completeInvFun hs ht x ∈ completeDomain hs ht := by\n  unfold completeInvFun completeDomain\n  split_ifs with h₁ h₂\n  case pos =>\n    cases sandboxSubsetEquiv hs ht ⟨x, h₁⟩ with\n    | inl val =>\n      obtain ⟨n, x⟩ := val\n      exact Or.inr ((sandboxSubsetEquiv hs ht).symm _).prop\n    | inr val =>\n      obtain ⟨_ | n, x⟩ := val\n      · exact Or.inl (Or.inr x.prop.1)\n      · exact Or.inr ((sandboxSubsetEquiv hs ht).symm _).prop\n  case pos =>\n    exact Or.inr ((sandboxSubsetEquiv hs ht).symm _).prop\n  case neg =>\n    rw [mem_diff, not_and_or, Classical.not_not] at h₂\n    obtain (h₂ | h₂) := h₂\n    · rw [completeDomain] at h\n      obtain (h | h) | h := h\n      cases h₂ h\n      · refine Or.inl (Or.inl ?_)\n        simp only [mem_image] at h\n        exact invFunOn_mem h\n      cases h₁ h\n    simp only [mem_image] at h₂\n    exact Or.inl (Or.inl (invFunOn_mem h₂))\n", "additional_info": "", "used_premises": [69, 69, 29, 62, 29, 510, 29, 212, 952, 955, 952], "def_path": "ConNF/FOA/Basic/CompleteOrbit.lean", "pos": [109, 136], "informalization": "Function `PartialPerm.completeInvFun` is a noncomputable function that completes the inverse of a partial permutation `f` defined on a subset `s` of a type `α`, where `s` and `t` are subsets of `α` such that the symmetric difference of `s` and the image of `s` under `f` has a cardinality less than or equal to the cardinality of `t`, and `t` has a cardinality greater than or equal to the smallest infinite cardinal number `ℵ₀`. The function returns an element of `α` based on the conditions provided."}
{"full_name": "PartialPerm.completeInvFun", "url": "ConNF/FOA/Basic/CompleteOrbit.html#PartialPerm.completeInvFun", "code_src": "con-nf", "ptype": "noncomputable def", "header": "noncomputable def PartialPerm.completeInvFun {α : Type u_1} {f : α → α} {s : Set🔗<|PREMISE|>🔗 α} {t : Set🔗<|PREMISE|>🔗 α} (hs : Cardinal.mk🔗<|PREMISE|>🔗 ↑(symmDiff🔗<|PREMISE|>🔗 s (f '' s)) ≤ Cardinal.mk🔗<|PREMISE|>🔗 ↑t) (ht : Cardinal.aleph0🔗<|PREMISE|>🔗 ≤ Cardinal.mk🔗<|PREMISE|>🔗 ↑t) [Nonempty🔗<|PREMISE|>🔗 α] (a : α) :α", "code": "noncomputable def completeInvFun [Nonempty α] (a : α) : α :=\n  if h : a ∈ sandboxSubset hs ht then\n    shiftLeft hs ht (sandboxSubsetEquiv hs ht ⟨a, h⟩)\n  else if h : a ∈ s \\ f '' s then\n    (sandboxSubsetEquiv hs ht).symm (Sum.inl ⟨0, a, h⟩)\n  else\n    invFunOn f s a\n", "additional_info": "Considered an implementation detail; use lemmas about `🗟complete🗟🔗../../.././ConNF/FOA/Basic/CompleteOrbit.html#PartialPerm.complete🔗`  instead.\nEquations\n* One or more equations did not get rendered due to their size.\n\n", "used_premises": [69, 69, 29, 62, 29, 510, 29, 212], "def_path": "ConNF/FOA/Basic/CompleteOrbit.lean", "pos": [72, 79], "informalization": "Function `PartialPerm.completeInvFun` is a noncomputable function that completes the inverse of a partial permutation `f` defined on a subset `s` of a type `α`, where `s` and `t` are subsets of `α` such that the symmetric difference of `s` and the image of `s` under `f` has a cardinality less than or equal to the cardinality of `t`, and `t` has a cardinality greater than or equal to the smallest infinite cardinal number `ℵ₀`. The function returns an element of `α` based on the conditions provided."}
{"full_name": "PartialPerm.complete_left_inv", "url": "ConNF/FOA/Basic/CompleteOrbit.html#PartialPerm.complete_left_inv", "code_src": "con-nf", "ptype": "theorem", "header": "theorem PartialPerm.complete_left_inv {α : Type u_1} {f : α → α} {s : Set🔗<|PREMISE|>🔗 α} {t : Set🔗<|PREMISE|>🔗 α} (hs : Cardinal.mk🔗<|PREMISE|>🔗 ↑(symmDiff🔗<|PREMISE|>🔗 s (f '' s)) ≤ Cardinal.mk🔗<|PREMISE|>🔗 ↑t) (ht : Cardinal.aleph0🔗<|PREMISE|>🔗 ≤ Cardinal.mk🔗<|PREMISE|>🔗 ↑t) [Nonempty🔗<|PREMISE|>🔗 α] (hst : Disjoint🔗<|PREMISE|>🔗 (s ∪ f '' s) t) (hf : Set.InjOn🔗<|PREMISE|>🔗 f s) (x : α) (h : x ∈ PartialPerm.completeDomain🔗<|PREMISE|>🔗 hs ht) :PartialPerm.completeInvFun🔗<|PREMISE|>🔗 hs ht (PartialPerm.completeToFun🔗<|PREMISE|>🔗 hs ht x) = x", "code": "theorem complete_left_inv [Nonempty α] (hst : Disjoint (s ∪ f '' s) t) (hf : InjOn f s) (x : α)\n    (h : x ∈ completeDomain hs ht) : completeInvFun hs ht (completeToFun hs ht x) = x := by\n  rw [disjoint_iff_inter_eq_empty, eq_empty_iff_forall_not_mem] at hst\n  by_cases h₁ : x ∈ s\n  · rw [completeToFun, dif_neg, dif_neg, completeInvFun, dif_neg, dif_neg]\n    · exact hf (invFunOn_apply_mem h₁) h₁\n          (show f (invFunOn f s (f x)) = f x from invFunOn_apply_eq h₁)\n    · exact fun h' => h'.2 ⟨x, h₁, rfl⟩\n    · exact fun hx => hst (f x) ⟨Or.inr ⟨x, h₁, rfl⟩, sandboxSubset_subset hs ht hx⟩\n    · exact fun h' => h'.2 h₁\n    · exact fun hx => hst x ⟨Or.inl h₁, sandboxSubset_subset hs ht hx⟩\n  by_cases h₂ : x ∈ f '' s\n  · rw [completeToFun, dif_neg, dif_pos, completeInvFun, dif_pos]\n    simp only [Subtype.coe_prop, Subtype.coe_eta, Equiv.apply_symm_apply]\n    rfl\n    · exact ((sandboxSubsetEquiv hs ht).symm _).prop\n    · exact ⟨h₂, h₁⟩\n    · exact fun h => hst x ⟨Or.inr h₂, sandboxSubset_subset hs ht h⟩\n  obtain (h | h) | h := h\n  · cases h₁ h\n  · cases h₂ h\n  rw [completeToFun, dif_pos h, completeInvFun]\n  by_cases h₃ : ∃ a, sandboxSubsetEquiv hs ht ⟨x, h⟩ = Sum.inl ⟨0, a⟩\n  · obtain ⟨a, ha⟩ := h₃\n    rw [dif_neg, dif_pos, Subtype.coe_eq_iff]\n    refine' ⟨h, _⟩\n    simp only [ha]\n    · rw [Equiv.symm_apply_eq]\n      · simp only [ha, Sum.inl.injEq, Prod.mk.injEq, true_and]\n        rfl\n      · rw [ha]\n        exact a.prop\n    · rw [ha]\n      exact fun h => hst _ ⟨Or.inl a.prop.1, sandboxSubset_subset hs ht h⟩\n  have h₄ :\n    (∃ n a, sandboxSubsetEquiv hs ht ⟨x, h⟩ = Sum.inl ⟨n + 1, a⟩) ∨\n      ∃ n a, sandboxSubsetEquiv hs ht ⟨x, h⟩ = Sum.inr ⟨n, a⟩\n  · set val := sandboxSubsetEquiv hs ht ⟨x, h⟩\n    clear_value val\n    obtain ⟨_ | n, b⟩ | ⟨n, b⟩ := val\n    cases h₃ ⟨b, rfl⟩\n    exact Or.inl ⟨n, b, rfl⟩\n    exact Or.inr ⟨n, b, rfl⟩\n  obtain (h₄ | h₄) := h₄ <;>\n    · obtain ⟨n, a, ha⟩ := h₄\n      rw [dif_pos]\n      simp only [ha]\n      unfold shiftRight\n      simp only [Subtype.coe_eta, Equiv.apply_symm_apply]\n      exact Subtype.coe_inj.mpr ((Equiv.symm_apply_eq _).mpr ha.symm)\n      rw [ha]\n      exact ((sandboxSubsetEquiv hs ht).symm _).prop\n", "additional_info": "", "used_premises": [69, 69, 29, 62, 29, 510, 29, 212, 757, 111, 952, 955, 953], "def_path": "ConNF/FOA/Basic/CompleteOrbit.lean", "pos": [137, 189], "informalization": "Given a partial permutation `f` defined on a subset `s` of a type `α`, where `s` and `t` are subsets of `α` such that the symmetric difference of `s` and the image of `s` under `f` has a cardinality less than or equal to the cardinality of `t`, and `t` has a cardinality greater than or equal to the smallest infinite cardinal number `ℵ₀`, and the union of `s` and the image of `s` under `f` is disjoint from `t`, and `f` is injective on `s`, then the completion of `f` to a local permutation is a left inverse."}
{"full_name": "PartialPerm.complete_right_inv", "url": "ConNF/FOA/Basic/CompleteOrbit.html#PartialPerm.complete_right_inv", "code_src": "con-nf", "ptype": "theorem", "header": "theorem PartialPerm.complete_right_inv {α : Type u_1} {f : α → α} {s : Set🔗<|PREMISE|>🔗 α} {t : Set🔗<|PREMISE|>🔗 α} (hs : Cardinal.mk🔗<|PREMISE|>🔗 ↑(symmDiff🔗<|PREMISE|>🔗 s (f '' s)) ≤ Cardinal.mk🔗<|PREMISE|>🔗 ↑t) (ht : Cardinal.aleph0🔗<|PREMISE|>🔗 ≤ Cardinal.mk🔗<|PREMISE|>🔗 ↑t) [Nonempty🔗<|PREMISE|>🔗 α] (hst : Disjoint🔗<|PREMISE|>🔗 (s ∪ f '' s) t) (hf : Set.InjOn🔗<|PREMISE|>🔗 f s) (x : α) (h : x ∈ PartialPerm.completeDomain🔗<|PREMISE|>🔗 hs ht) :PartialPerm.completeToFun🔗<|PREMISE|>🔗 hs ht (PartialPerm.completeInvFun🔗<|PREMISE|>🔗 hs ht x) = x", "code": "theorem complete_right_inv [Nonempty α] (hst : Disjoint (s ∪ f '' s) t) (hf : InjOn f s) (x : α)\n    (h : x ∈ completeDomain hs ht) : completeToFun hs ht (completeInvFun hs ht x) = x := by\n  rw [disjoint_iff_inter_eq_empty, eq_empty_iff_forall_not_mem] at hst\n  by_cases h₁ : x ∈ f '' s\n  · rw [completeInvFun, dif_neg, dif_neg, completeToFun, dif_neg, dif_neg]\n    · exact invFunOn_eq h₁\n    · exact fun h' => h'.2 (invFunOn_mem h₁)\n    · exact fun hx => hst _ ⟨Or.inl (invFunOn_mem h₁), sandboxSubset_subset hs ht hx⟩\n    · exact fun h' => h'.2 h₁\n    · exact fun hx => hst x ⟨Or.inr h₁, sandboxSubset_subset hs ht hx⟩\n  by_cases h₂ : x ∈ s\n  · rw [completeInvFun, dif_neg, dif_pos, completeToFun, dif_pos]\n    simp only [Subtype.coe_prop, Subtype.coe_eta, Equiv.apply_symm_apply]\n    rfl\n    · exact ((sandboxSubsetEquiv hs ht).symm _).prop\n    · exact ⟨h₂, h₁⟩\n    · exact fun h => hst x ⟨Or.inl h₂, sandboxSubset_subset hs ht h⟩\n  obtain (h | h) | h := h\n  · cases h₂ h\n  · cases h₁ h\n  rw [completeInvFun, dif_pos h, completeToFun]\n  by_cases h₃ : ∃ a, sandboxSubsetEquiv hs ht ⟨x, h⟩ = Sum.inr ⟨0, a⟩\n  · obtain ⟨a, ha⟩ := h₃\n    rw [dif_neg, dif_pos, Subtype.coe_eq_iff]\n    refine' ⟨h, _⟩\n    simp only [ha]\n    · rw [Equiv.symm_apply_eq]\n      · simp only [ha, Sum.inr.injEq, Prod.mk.injEq, true_and]\n        rfl\n      · rw [ha]\n        exact a.prop\n    · rw [ha]\n      exact fun h => hst _ ⟨Or.inr a.prop.1, sandboxSubset_subset hs ht h⟩\n  have h₄ :\n    (∃ n a, sandboxSubsetEquiv hs ht ⟨x, h⟩ = Sum.inr ⟨n + 1, a⟩) ∨\n      ∃ n a, sandboxSubsetEquiv hs ht ⟨x, h⟩ = Sum.inl ⟨n, a⟩\n  · set val := sandboxSubsetEquiv hs ht ⟨x, h⟩\n    clear_value val\n    obtain ⟨n, b⟩ | ⟨_ | n, b⟩ := val\n    exact Or.inr ⟨n, b, rfl⟩\n    cases h₃ ⟨b, rfl⟩\n    exact Or.inl ⟨n, b, rfl⟩\n  obtain (h₄ | h₄) := h₄ <;>\n    · obtain ⟨n, a, ha⟩ := h₄\n      rw [dif_pos]\n      simp only [ha]\n      unfold shiftLeft\n      simp only [Subtype.coe_eta, Equiv.apply_symm_apply]\n      exact Subtype.coe_inj.mpr ((Equiv.symm_apply_eq _).mpr ha.symm)\n      rw [ha]\n      exact ((sandboxSubsetEquiv hs ht).symm _).prop\n", "additional_info": "", "used_premises": [69, 69, 29, 62, 29, 510, 29, 212, 757, 111, 952, 953, 955], "def_path": "ConNF/FOA/Basic/CompleteOrbit.lean", "pos": [190, 241], "informalization": "The `PartialPerm.complete_right_inv` theorem in Lean 4 states that for a partial permutation `f` defined on a subset `s` of a type `α`, with `s` and `t` being subsets of `α` such that the symmetric difference of `s` and the image of `s` under `f` has a cardinality less than or equal to the cardinality of `t`, and `t` having a cardinality greater than or equal to the smallest infinite cardinal number `ℵ₀`, if `s ∪ f '' s` and `t` are disjoint, and `f` is injective on `s`, then the completion of `f` to a local permutation, when applied to the completion of its inverse, returns the original element."}
{"full_name": "PartialPerm.completeDomain_eq", "url": "ConNF/FOA/Basic/CompleteOrbit.html#PartialPerm.completeDomain_eq", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem PartialPerm.completeDomain_eq {α : Type u_1} {f : α → α} {s : Set🔗<|PREMISE|>🔗 α} {t : Set🔗<|PREMISE|>🔗 α} (hs : Cardinal.mk🔗<|PREMISE|>🔗 ↑(symmDiff🔗<|PREMISE|>🔗 s (f '' s)) ≤ Cardinal.mk🔗<|PREMISE|>🔗 ↑t) (ht : Cardinal.aleph0🔗<|PREMISE|>🔗 ≤ Cardinal.mk🔗<|PREMISE|>🔗 ↑t) [Nonempty🔗<|PREMISE|>🔗 α] {hst : Disjoint🔗<|PREMISE|>🔗 (s ∪ f '' s) t} {hf : Set.InjOn🔗<|PREMISE|>🔗 f s} :(PartialPerm.complete🔗<|PREMISE|>🔗 f s t hs ht hst hf).domain = PartialPerm.completeDomain🔗<|PREMISE|>🔗 hs ht", "code": "theorem completeDomain_eq : (complete f s t hs ht hst hf).domain = completeDomain hs ht :=\n  rfl\n", "additional_info": "", "used_premises": [69, 69, 29, 62, 29, 510, 29, 212, 757, 111, 959, 952], "def_path": "ConNF/FOA/Basic/CompleteOrbit.lean", "pos": [259, 261], "informalization": "Function `PartialPerm.complete` completes a function `f` on a domain `s` into a local permutation that agrees with `f` on `s`, with domain contained in `s ∪ (f '' s) ∪ t`, where `t` is a set that is disjoint from `s ∪ (f '' s)` and has at least the cardinality of the natural numbers `ℵ₀`. The function `f` must be injective on `s`. Function `PartialPerm.completeDomain` defines the domain on which we will define the completion of a function to a local permutation. This domain is the union of three sets: the original set `s`, the image of `s` under the function `f`, and an additional set `sandboxSubset hs ht` which depends on the given conditions `hs` and `ht`."}
{"full_name": "PartialPerm.complete", "url": "ConNF/FOA/Basic/CompleteOrbit.html#PartialPerm.complete", "code_src": "con-nf", "ptype": "noncomputable def", "header": "noncomputable def PartialPerm.complete {α : Type u_1} [Nonempty🔗<|PREMISE|>🔗 α] (f : α → α) (s : Set🔗<|PREMISE|>🔗 α) (t : Set🔗<|PREMISE|>🔗 α) (hs : Cardinal.mk🔗<|PREMISE|>🔗 ↑(symmDiff🔗<|PREMISE|>🔗 s (f '' s)) ≤ Cardinal.mk🔗<|PREMISE|>🔗 ↑t) (ht : Cardinal.aleph0🔗<|PREMISE|>🔗 ≤ Cardinal.mk🔗<|PREMISE|>🔗 ↑t) (hst : Disjoint🔗<|PREMISE|>🔗 (s ∪ f '' s) t) (hf : Set.InjOn🔗<|PREMISE|>🔗 f s) :PartialPerm🔗<|PREMISE|>🔗 α", "code": "noncomputable def complete [Nonempty α] (f : α → α) (s : Set α) (t : Set α)\n    (hs : #(s ∆ (f '' s) : Set α) ≤ #t) (ht : ℵ₀ ≤ #t) (hst : Disjoint (s ∪ f '' s) t)\n    (hf : InjOn f s) : PartialPerm α\n    where\n  toFun := completeToFun hs ht\n  invFun := completeInvFun hs ht\n  domain := completeDomain hs ht\n  toFun_domain' := completeToFun_domain hs ht\n  invFun_domain' := completeInvFun_domain hs ht\n  left_inv' := complete_left_inv hs ht hst hf\n  right_inv' := complete_right_inv hs ht hst hf\n", "additional_info": "Completes a function `f` on a domain `s` into a local permutation that agrees with `f` on `s`,\nwith domain contained in `s ∪ (f '' s) ∪ t`.\nEquations\n* One or more equations did not get rendered due to their size.\n\n", "used_premises": [212, 69, 69, 29, 62, 29, 510, 29, 757, 111, 645], "def_path": "ConNF/FOA/Basic/CompleteOrbit.lean", "pos": [244, 255], "informalization": "Function `PartialPerm.complete` completes a function `f` on a domain `s` into a local permutation that agrees with `f` on `s`, with domain contained in `s ∪ (f '' s) ∪ t`, where `t` is a set that is disjoint from `s ∪ (f '' s)` and has at least the cardinality of the natural numbers `ℵ₀`. The function `f` must be injective on `s`."}
{"full_name": "PartialPerm.mem_completeDomain_of_mem", "url": "ConNF/FOA/Basic/CompleteOrbit.html#PartialPerm.mem_completeDomain_of_mem", "code_src": "con-nf", "ptype": "theorem", "header": "theorem PartialPerm.mem_completeDomain_of_mem {α : Type u_1} {f : α → α} {s : Set🔗<|PREMISE|>🔗 α} {t : Set🔗<|PREMISE|>🔗 α} (hs : Cardinal.mk🔗<|PREMISE|>🔗 ↑(symmDiff🔗<|PREMISE|>🔗 s (f '' s)) ≤ Cardinal.mk🔗<|PREMISE|>🔗 ↑t) (ht : Cardinal.aleph0🔗<|PREMISE|>🔗 ≤ Cardinal.mk🔗<|PREMISE|>🔗 ↑t) (x : α) (hx : x ∈ s) :x ∈ PartialPerm.completeDomain🔗<|PREMISE|>🔗 hs ht", "code": "theorem mem_completeDomain_of_mem (x : α) (hx : x ∈ s) : x ∈ completeDomain hs ht :=\n  Or.inl (Or.inl hx)\n", "additional_info": "", "used_premises": [69, 69, 29, 62, 29, 510, 29, 952], "def_path": "ConNF/FOA/Basic/CompleteOrbit.lean", "pos": [262, 264], "informalization": "Function `mem_completeDomain_of_mem` proves that if `x` is an element of `s`, then `x` is also an element of `PartialPerm.completeDomain hs ht`."}
{"full_name": "PartialPerm.mem_completeDomain_of_mem_image", "url": "ConNF/FOA/Basic/CompleteOrbit.html#PartialPerm.mem_completeDomain_of_mem_image", "code_src": "con-nf", "ptype": "theorem", "header": "theorem PartialPerm.mem_completeDomain_of_mem_image {α : Type u_1} {f : α → α} {s : Set🔗<|PREMISE|>🔗 α} {t : Set🔗<|PREMISE|>🔗 α} (hs : Cardinal.mk🔗<|PREMISE|>🔗 ↑(symmDiff🔗<|PREMISE|>🔗 s (f '' s)) ≤ Cardinal.mk🔗<|PREMISE|>🔗 ↑t) (ht : Cardinal.aleph0🔗<|PREMISE|>🔗 ≤ Cardinal.mk🔗<|PREMISE|>🔗 ↑t) (x : α) (hx : x ∈ f '' s) :x ∈ PartialPerm.completeDomain🔗<|PREMISE|>🔗 hs ht", "code": "theorem mem_completeDomain_of_mem_image (x : α) (hx : x ∈ f '' s) : x ∈ completeDomain hs ht :=\n  Or.inl (Or.inr hx)\n", "additional_info": "", "used_premises": [69, 69, 29, 62, 29, 510, 29, 952], "def_path": "ConNF/FOA/Basic/CompleteOrbit.lean", "pos": [265, 267], "informalization": "The theorem `mem_completeDomain_of_mem_image` states that if the cardinality of the symmetric difference between a set `s` and its image under a function `f` is less than or equal to the cardinality of a set `t`, and the cardinality of `t` is greater than or equal to the cardinality of the natural numbers, then for any element `x` in the image of `s` under `f`, `x` also belongs to the complete domain of the partial permutation."}
{"full_name": "PartialPerm.not_mem_sandbox_of_mem", "url": "ConNF/FOA/Basic/CompleteOrbit.html#PartialPerm.not_mem_sandbox_of_mem", "code_src": "con-nf", "ptype": "theorem", "header": "theorem PartialPerm.not_mem_sandbox_of_mem {α : Type u_1} {f : α → α} {s : Set🔗<|PREMISE|>🔗 α} {t : Set🔗<|PREMISE|>🔗 α} (hs : Cardinal.mk🔗<|PREMISE|>🔗 ↑(symmDiff🔗<|PREMISE|>🔗 s (f '' s)) ≤ Cardinal.mk🔗<|PREMISE|>🔗 ↑t) (ht : Cardinal.aleph0🔗<|PREMISE|>🔗 ≤ Cardinal.mk🔗<|PREMISE|>🔗 ↑t) (hst : Disjoint🔗<|PREMISE|>🔗 (s ∪ f '' s) t) (x : α) (hx : x ∈ s) :x ∉ PartialPerm.sandboxSubset🔗<|PREMISE|>🔗 hs ht", "code": "theorem not_mem_sandbox_of_mem (hst : Disjoint (s ∪ f '' s) t) (x : α) (hx : x ∈ s) :\n    x ∉ sandboxSubset hs ht := by\n  intro h\n  rw [disjoint_iff_inter_eq_empty, eq_empty_iff_forall_not_mem] at hst\n  exact hst x ⟨Or.inl hx, sandboxSubset_subset hs ht h⟩\n", "additional_info": "", "used_premises": [69, 69, 29, 62, 29, 510, 29, 757, 950], "def_path": "ConNF/FOA/Basic/CompleteOrbit.lean", "pos": [268, 273], "informalization": "`PartialPerm.not_mem_sandbox_of_mem` is a theorem in Lean 4 that states that if the cardinality of the symmetric difference between a set `s` and the image of `s` under a function `f` is less than or equal to the cardinality of a set `t`, and if the cardinality of `t` is infinite, and if the union of `s` and the image of `s` under `f` is disjoint from `t`, then for any element `x` in `s`, `x` is not in the sandbox subset of `t`."}
{"full_name": "PartialPerm.not_mem_sandbox_of_mem_image", "url": "ConNF/FOA/Basic/CompleteOrbit.html#PartialPerm.not_mem_sandbox_of_mem_image", "code_src": "con-nf", "ptype": "theorem", "header": "theorem PartialPerm.not_mem_sandbox_of_mem_image {α : Type u_1} {f : α → α} {s : Set🔗<|PREMISE|>🔗 α} {t : Set🔗<|PREMISE|>🔗 α} (hs : Cardinal.mk🔗<|PREMISE|>🔗 ↑(symmDiff🔗<|PREMISE|>🔗 s (f '' s)) ≤ Cardinal.mk🔗<|PREMISE|>🔗 ↑t) (ht : Cardinal.aleph0🔗<|PREMISE|>🔗 ≤ Cardinal.mk🔗<|PREMISE|>🔗 ↑t) (hst : Disjoint🔗<|PREMISE|>🔗 (s ∪ f '' s) t) (x : α) (hx : x ∈ f '' s) :x ∉ PartialPerm.sandboxSubset🔗<|PREMISE|>🔗 hs ht", "code": "theorem not_mem_sandbox_of_mem_image (hst : Disjoint (s ∪ f '' s) t) (x : α) (hx : x ∈ f '' s) :\n    x ∉ sandboxSubset hs ht := by\n  intro h\n  rw [disjoint_iff_inter_eq_empty, eq_empty_iff_forall_not_mem] at hst\n  exact hst x ⟨Or.inr hx, sandboxSubset_subset hs ht h⟩\n", "additional_info": "", "used_premises": [69, 69, 29, 62, 29, 510, 29, 757, 950], "def_path": "ConNF/FOA/Basic/CompleteOrbit.lean", "pos": [274, 279], "informalization": "The theorem `not_mem_sandbox_of_mem_image` states that if the symmetric difference between a set `s` and its image under a function `f` has a cardinality less than or equal to the cardinality of a set `t`, and `t` is disjoint from the union of `s` and its image under `f`, then any element in the image of `s` under `f` does not belong to the sandbox subset of `t`."}
{"full_name": "PartialPerm.complete_apply_eq", "url": "ConNF/FOA/Basic/CompleteOrbit.html#PartialPerm.complete_apply_eq", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem PartialPerm.complete_apply_eq {α : Type u_1} {f : α → α} {s : Set🔗<|PREMISE|>🔗 α} {t : Set🔗<|PREMISE|>🔗 α} (hs : Cardinal.mk🔗<|PREMISE|>🔗 ↑(symmDiff🔗<|PREMISE|>🔗 s (f '' s)) ≤ Cardinal.mk🔗<|PREMISE|>🔗 ↑t) (ht : Cardinal.aleph0🔗<|PREMISE|>🔗 ≤ Cardinal.mk🔗<|PREMISE|>🔗 ↑t) [Nonempty🔗<|PREMISE|>🔗 α] {hst : Disjoint🔗<|PREMISE|>🔗 (s ∪ f '' s) t} {hf : Set.InjOn🔗<|PREMISE|>🔗 f s} (x : α) (hx : x ∈ s) :(PartialPerm.complete🔗<|PREMISE|>🔗 f s t hs ht hst hf).toFun x = f x", "code": "theorem complete_apply_eq (x : α) (hx : x ∈ s) : complete f s t hs ht hst hf x = f x := by\n  rw [complete, coe_mk, completeToFun, dif_neg, dif_neg]\n  exact fun h' => h'.2 hx\n  exact not_mem_sandbox_of_mem hs ht hst x hx\n", "additional_info": "", "used_premises": [69, 69, 29, 62, 29, 510, 29, 212, 757, 111, 959], "def_path": "ConNF/FOA/Basic/CompleteOrbit.lean", "pos": [281, 285], "informalization": "The `partialPerm.complete_apply_eq` theorem in Lean 4 shows that, given a function `f` that is injective on a set `s`, and a set `t` such that the symmetric difference between `s` and `f '' s` (the image of `s` under `f`) is smaller than or equal to `t` and `t` has at least the cardinality of the natural numbers, the function `f` itself is equal to the complete function `partialPerm.complete f s t hs ht hst hf` when restricted to `s`."}
{"full_name": "ConNF.StructApprox.atom_injective_extends", "url": "ConNF/FOA/Properties/Injective.html#ConNF.StructApprox.atom_injective_extends", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.StructApprox.atom_injective_extends [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.FOAAssumptions] {β : ConNF.Λ} [ConNF.LeLevel🔗<|PREMISE|>🔗 ↑β] [ConNF.StructApprox.FreedomOfActionHypothesis🔗<|PREMISE|>🔗 β] {π : ConNF.StructApprox🔗<|PREMISE|>🔗 ↑β} {c : ConNF.Address🔗<|PREMISE|>🔗 ↑β} {d : ConNF.Address🔗<|PREMISE|>🔗 ↑β} (hcd : ConNF.StructAction.Lawful🔗<|PREMISE|>🔗 (ConNF.StructApprox.ihsAction🔗<|PREMISE|>🔗 π c d)) {a : ConNF.Atom} {b : ConNF.Atom} {A : ConNF.ExtendedIndex🔗<|PREMISE|>🔗 ↑β} (hac : { path := A, value := Sum.inl🔗<|PREMISE|>🔗 a } ∈ ConNF.StructApprox.reflTransConstrained🔗<|PREMISE|>🔗 c d) (hbc : { path := A, value := Sum.inl🔗<|PREMISE|>🔗 b } ∈ ConNF.StructApprox.reflTransConstrained🔗<|PREMISE|>🔗 c d) (h : ConNF.StructApprox.completeAtomMap🔗<|PREMISE|>🔗 π A a = ConNF.StructApprox.completeAtomMap🔗<|PREMISE|>🔗 π A b) :a = b", "code": "theorem atom_injective_extends {c d : Address β} (hcd : (ihsAction π c d).Lawful)\n    {a b : Atom} {A : ExtendedIndex β} (hac : ⟨A, inl a⟩ ∈ reflTransConstrained c d)\n    (hbc : ⟨A, inl b⟩ ∈ reflTransConstrained c d)\n    (h : π.completeAtomMap A a = π.completeAtomMap A b) : a = b :=\n  by\n  by_cases ha : a ∈ (π A).atomPerm.domain <;> by_cases hb : b ∈ (π A).atomPerm.domain\n  · rw [completeAtomMap_eq_of_mem_domain ha, completeAtomMap_eq_of_mem_domain hb] at h\n    exact (π A).atomPerm.injOn ha hb h\n  · rw [completeAtomMap_eq_of_mem_domain ha, completeAtomMap_eq_of_not_mem_domain hb] at h\n    cases\n      (π A).not_mem_domain_of_mem_largestSublitter (Subtype.coe_eq_iff.mp h.symm).choose\n        ((π A).atomPerm.map_domain ha)\n  · rw [completeAtomMap_eq_of_not_mem_domain ha, completeAtomMap_eq_of_mem_domain hb] at h\n    cases\n      (π A).not_mem_domain_of_mem_largestSublitter (Subtype.coe_eq_iff.mp h).choose\n        ((π A).atomPerm.map_domain hb)\n  · rw [completeAtomMap_eq_of_not_mem_domain ha, completeAtomMap_eq_of_not_mem_domain hb] at h\n    have h₁ := (Subtype.coe_eq_iff.mp h).choose.1\n    have h₂ :=\n      (((π A).largestSublitter b.1).equiv ((π A).largestSublitter (π.completeLitterMap A b.1))\n            ⟨b, (π A).mem_largestSublitter_of_not_mem_domain b hb⟩).prop.1\n    have := (hcd A).litterMap_injective (fst_transConstrained hac) (fst_transConstrained hbc) ?_\n    · have := eq_of_sublitter_bijection_apply_eq h this (by rw [this])\n      exact this\n    · refine' NearLitter.inter_nonempty_of_fst_eq_fst _\n      simp only [ihsAction_litterMap, completeNearLitterMap_fst_eq]\n      exact eq_of_mem_litterSet_of_mem_litterSet h₁ h₂\n", "additional_info": "", "used_premises": [1, 402, 779, 781, 60, 60, 809, 966, 61, 67, 967, 67, 967, 784, 784], "def_path": "ConNF/FOA/Properties/Injective.lean", "pos": [15, 42], "informalization": "In the context of Constructive Ordinal Notation (ConNF), the theorem `ConNF.StructApprox.atom_injective_extends` states that, given a `β`-structural approximation `π` and two addresses `c` and `d` such that the `β`-structural action `ConNF.StructApprox.ihsAction π c d` is lawful, if two atoms `a` and `b` are mapped to the same atom by the function `ConNF.StructApprox.completeAtomMap π A` for some `β`-extended index `A`, then `a` must be equal to `b`."}
{"full_name": "ConNF.StructApprox.ihsAction", "url": "ConNF/FOA/Properties/ConstrainedAction.html#ConNF.StructApprox.ihsAction", "code_src": "con-nf", "ptype": "noncomputable def", "header": "noncomputable def ConNF.StructApprox.ihsAction [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.FOAAssumptions] {β : ConNF.Λ} [ConNF.LeLevel🔗<|PREMISE|>🔗 ↑β] [ConNF.StructApprox.FreedomOfActionHypothesis🔗<|PREMISE|>🔗 β] (π : ConNF.StructApprox🔗<|PREMISE|>🔗 ↑β) (c : ConNF.Address🔗<|PREMISE|>🔗 ↑β) (d : ConNF.Address🔗<|PREMISE|>🔗 ↑β) :ConNF.StructAction🔗<|PREMISE|>🔗 ↑β", "code": "noncomputable def ihsAction (π : StructApprox β) (c d : Address β) : StructAction β :=\n  fun B =>\n  { atomMap := fun a => ⟨⟨B, inl a⟩ ∈ transConstrained c d,\n      fun _ => π.completeAtomMap B a⟩\n    litterMap := fun L => ⟨⟨B, inr L.toNearLitter⟩ ∈ transConstrained c d,\n      fun _ => π.completeNearLitterMap B L.toNearLitter⟩\n    atomMap_dom_small := by\n      exact Small.union (ihAction π.foaHypothesis B).atomMap_dom_small\n        (ihAction π.foaHypothesis B).atomMap_dom_small\n    litterMap_dom_small := by\n      exact Small.union (ihAction π.foaHypothesis B).litterMap_dom_small\n        (ihAction π.foaHypothesis B).litterMap_dom_small }\n", "additional_info": "An object like `ih_action` that can take two addresses.\nEquations\n* One or more equations did not get rendered due to their size.\n\n", "used_premises": [1, 402, 779, 781, 60, 60, 808], "def_path": "ConNF/FOA/Properties/ConstrainedAction.lean", "pos": [173, 185], "informalization": "Function `ConNF.StructApprox.ihsAction` defines a `β`-structural action as a product that assigns a near-litter action to each `β`-extended index in the context of Constructive Ordinal Notation (ConNF)."}
{"full_name": "ConNF.StructApprox.reflTransConstrained", "url": "ConNF/FOA/Properties/ConstrainedAction.html#ConNF.StructApprox.reflTransConstrained", "code_src": "con-nf", "ptype": "def", "header": "def ConNF.StructApprox.reflTransConstrained [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.FOAAssumptions] {β : ConNF.Λ} (c : ConNF.Address🔗<|PREMISE|>🔗 ↑β) (d : ConNF.Address🔗<|PREMISE|>🔗 ↑β) :Set🔗<|PREMISE|>🔗 (ConNF.Address🔗<|PREMISE|>🔗 ↑β)", "code": "def reflTransConstrained (c d : Address β) : Set (Address β) :=\n  {e | e ≤ c} ∪ {e | e ≤ d}\n", "additional_info": "Equations\n* 🗟ConNF.StructApprox.reflTransConstrained🗟🔗../../.././ConNF/FOA/Properties/ConstrainedAction.html#ConNF.StructApprox.reflTransConstrained🔗  c d 🗟=🗟🔗../../.././Init/Prelude.html#Eq🔗  {e : 🗟ConNF.Address🗟🔗../../.././ConNF/Structural/Support.html#ConNF.Address🔗  ↑β | e 🗟≤🗟🔗../../.././Init/Prelude.html#LE.le🔗  c} 🗟∪🗟🔗../../.././Init/Core.html#Union.union🔗  {e : 🗟ConNF.Address🗟🔗../../.././ConNF/Structural/Support.html#ConNF.Address🔗  ↑β | e 🗟≤🗟🔗../../.././Init/Prelude.html#LE.le🔗  d}\n\n", "used_premises": [1, 60, 60, 69, 60], "def_path": "ConNF/FOA/Properties/ConstrainedAction.lean", "pos": [18, 20], "informalization": "Function `ConNF.StructApprox.reflTransConstrained` defines a set of addresses that are either less than or equal to the address `c` or less than or equal to the address `d`, within the context of Constructive Ordinal Notation (ConNF)."}
{"full_name": "ConNF.StructApprox.inOut_def", "url": "ConNF/FOA/Properties/Injective.html#ConNF.StructApprox.inOut_def", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.StructApprox.inOut_def [ConNF.Params🔗<|PREMISE|>🔗 ] {π : ConNF.NearLitterPerm} {a : ConNF.Atom} {L : ConNF.Litter} :ConNF.StructApprox.InOut🔗<|PREMISE|>🔗 π a L ↔ Xor'🔗<|PREMISE|>🔗 (a.1 = L) ((π • a).1 = π • L)", "code": "theorem inOut_def {π : NearLitterPerm} {a : Atom} {L : Litter} :\n    InOut π a L ↔ Xor' (a.1 = L) ((π • a).1 = π • L) :=\n  Iff.rfl\n", "additional_info": "", "used_premises": [1, 969, 970], "def_path": "ConNF/FOA/Properties/Injective.lean", "pos": [46, 49], "informalization": "The theorem `ConNF.StructApprox.inOut_def` states that for a near litter permutation `π`, an atom `a`, and a litter `L`, the predicate `ConNF.StructApprox.InOut π a L` holds if and only if either `a` is equal to `L` or `π • a` is equal to `π • L`, but not both."}
{"full_name": "ConNF.StructApprox.InOut", "url": "ConNF/FOA/Properties/Injective.html#ConNF.StructApprox.InOut", "code_src": "con-nf", "ptype": "def", "header": "def ConNF.StructApprox.InOut [ConNF.Params🔗<|PREMISE|>🔗 ] (π : ConNF.NearLitterPerm) (a : ConNF.Atom) (L : ConNF.Litter) :Prop", "code": "def InOut (π : NearLitterPerm) (a : Atom) (L : Litter) : Prop :=\n  Xor' (a.1 = L) ((π • a).1 = π • L)\n", "additional_info": "Equations\n* 🗟ConNF.StructApprox.InOut🗟🔗../../.././ConNF/FOA/Properties/Injective.html#ConNF.StructApprox.InOut🔗  π a L 🗟=🗟🔗../../.././Init/Prelude.html#Eq🔗  🗟Xor'🗟🔗../../.././Mathlib/Init/Logic.html#Xor'🔗  (a.1 🗟=🗟🔗../../.././Init/Prelude.html#Eq🔗  L) ((π 🗟•🗟🔗../../.././Mathlib/Algebra/Group/Defs.html#HSMul.hSMul🔗  a).1 🗟=🗟🔗../../.././Init/Prelude.html#Eq🔗  π 🗟•🗟🔗../../.././Mathlib/Algebra/Group/Defs.html#HSMul.hSMul🔗  L)\n\n", "used_premises": [1], "def_path": "ConNF/FOA/Properties/Injective.lean", "pos": [43, 45], "informalization": "Function `ConNF.StructApprox.InOut` is a predicate used in the context of Constructive Ordinal Notation (ConNF) to determine the relationship between an atom `a`, a litter `L`, and a near litter permutation `π`. It checks if either `a` is equal to `L` or `π • a` is equal to `π • L`, but not both."}
{"full_name": "Xor'", "url": "Mathlib/Init/Logic.html#Xor'", "code_src": "mathlib4", "ptype": "def", "header": "def Xor' (a : Prop ) (b : Prop ) :Prop", "code": "def Xor' (a b : Prop) := (a ∧ ¬ b) ∨ (b ∧ ¬ a)\n", "additional_info": "Equations\n* 🗟Xor'🗟🔗../.././Mathlib/Init/Logic.html#Xor'🔗  a b 🗟=🗟🔗../.././Init/Prelude.html#Eq🔗  (a 🗟∧🗟🔗../.././Init/Prelude.html#And🔗  🗟¬🗟🔗../.././Init/Prelude.html#Not🔗 b 🗟∨🗟🔗../.././Init/Prelude.html#Or🔗  b 🗟∧🗟🔗../.././Init/Prelude.html#And🔗  🗟¬🗟🔗../.././Init/Prelude.html#Not🔗 a)\n\n", "used_premises": [], "def_path": "Mathlib/Init/Logic.lean", "pos": [95, 96], "informalization": "Function `Xor'` defines the exclusive or operation between two propositions `a` and `b`, asserting that exactly one of them is true."}
{"full_name": "ConNF.StructApprox.isException_of_inOut", "url": "ConNF/FOA/Properties/Injective.html#ConNF.StructApprox.isException_of_inOut", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.StructApprox.isException_of_inOut [ConNF.Params🔗<|PREMISE|>🔗 ] {π : ConNF.NearLitterPerm} {a : ConNF.Atom} {L : ConNF.Litter} :ConNF.StructApprox.InOut🔗<|PREMISE|>🔗 π a L → ConNF.NearLitterPerm.IsException🔗<|PREMISE|>🔗 π a ∨ ConNF.NearLitterPerm.IsException🔗<|PREMISE|>🔗 π (π • a)", "code": "theorem isException_of_inOut {π : NearLitterPerm} {a : Atom} {L : Litter} :\n    InOut π a L → π.IsException a ∨ π.IsException (π • a) := by\n  rintro (⟨rfl, ha⟩ | ha)\n  · refine' Or.inr (Or.inr _)\n    intro h\n    rw [mem_litterSet, eq_inv_smul_iff] at h\n    rw [← h, inv_smul_smul] at ha\n    exact ha rfl\n  · refine' Or.inl (Or.inl _)\n    rw [mem_litterSet, ha.1, smul_left_cancel_iff]\n    exact Ne.symm ha.2\n", "additional_info": "", "used_premises": [1, 969, 801, 801], "def_path": "ConNF/FOA/Properties/Injective.lean", "pos": [52, 63], "informalization": "In the context of Constructive Ordinal Notation (ConNF), given a near litter permutation `π`, an atom `a`, and a litter `L`, if either `a` is equal to `L` or `π • a` is equal to `π • L`, but not both, then either `π` is an exception with respect to `a` or `π` is an exception with respect to `π • a`."}
{"full_name": "ConNF.StructApprox.Biexact.constrains", "url": "ConNF/FOA/Properties/Injective.html#ConNF.StructApprox.Biexact.constrains", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.StructApprox.Biexact.constrains [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.FOAAssumptions] {β : ConNF.Λ} {π : ConNF.StructPerm🔗<|PREMISE|>🔗 ↑β} {π' : ConNF.StructPerm🔗<|PREMISE|>🔗 ↑β} {c : ConNF.Address🔗<|PREMISE|>🔗 ↑β} {d : ConNF.Address🔗<|PREMISE|>🔗 ↑β} (h : ConNF.StructApprox.Biexact🔗<|PREMISE|>🔗 π π' c) (h' : d ≤ c) :ConNF.StructApprox.Biexact🔗<|PREMISE|>🔗 π π' d", "code": "theorem Biexact.constrains {β : Λ} {π π' : StructPerm β} {c d : Address β}\n    (h : Biexact π π' c) (h' : d ≤ c) : Biexact π π' d :=\n  ⟨fun A a ha => h.smul_eq_smul_atom A a (ha.trans h'), fun A L hL =>\n    h.smul_eq_smul_litter A L (hL.trans h'), fun A L hL => h.exact A L (hL.trans h')⟩\n", "additional_info": "", "used_premises": [1, 55, 55, 60, 60, 973, 973], "def_path": "ConNF/FOA/Properties/Injective.lean", "pos": [80, 84], "informalization": "The theorem `ConNF.StructApprox.Biexact.constrains` states that if two structural permutations `π` and `π'` are biexact with respect to an address `c`, and `d` is an address that is less than or equal to `c`, then `π` and `π'` are also biexact with respect to `d`."}
{"full_name": "ConNF.StructApprox.Biexact", "url": "ConNF/FOA/Properties/Injective.html#ConNF.StructApprox.Biexact", "code_src": "con-nf", "ptype": "structure", "header": "structure ConNF.StructApprox.Biexact [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.FOAAssumptions] {β : ConNF.Λ} (π : ConNF.StructPerm🔗<|PREMISE|>🔗 ↑β) (π' : ConNF.StructPerm🔗<|PREMISE|>🔗 ↑β) (c : ConNF.Address🔗<|PREMISE|>🔗 ↑β) :Prop\n | smul_eq_smul_atom : ∀ (A : ConNF.ExtendedIndex🔗<|PREMISE|>🔗  ↑β) (a : ConNF.Atom), { path := A, value := Sum.inl🔗<|PREMISE|>🔗  a } ≤  c → π A •  a =  π' A •  a\n | smul_eq_smul_litter : ∀ (A : ConNF.ExtendedIndex🔗<|PREMISE|>🔗  ↑β) (L : ConNF.Litter),\n { path := A, value := Sum.inr🔗<|PREMISE|>🔗  (ConNF.Litter.toNearLitter🔗<|PREMISE|>🔗  L) } ≤  c → ConNF.Flexible🔗<|PREMISE|>🔗  A L → π A •  L =  π' A •  L\n | exact : ∀ (A : ConNF.ExtendedIndex🔗<|PREMISE|>🔗  ↑β) (L : ConNF.Litter),\n { path := A, value := Sum.inr🔗<|PREMISE|>🔗  (ConNF.Litter.toNearLitter🔗<|PREMISE|>🔗  L) } ≤  c →\n π A •  L =  π' A •  L → π A •  ConNF.Litter.toNearLitter🔗<|PREMISE|>🔗  L =  π' A •  ConNF.Litter.toNearLitter🔗<|PREMISE|>🔗  L", "code": "structure Biexact {β : Λ} (π π' : StructPerm β) (c : Address β) : Prop where\n  smul_eq_smul_atom :\n    ∀ A : ExtendedIndex β,\n      ∀ a : Atom, ⟨A, inl a⟩ ≤ c → π A • a = π' A • a\n  smul_eq_smul_litter :\n    ∀ A : ExtendedIndex β,\n      ∀ L : Litter,\n        ⟨A, inr L.toNearLitter⟩ ≤ c →\n          Flexible A L → π A • L = π' A • L\n  exact :\n    ∀ A : ExtendedIndex β,\n      ∀ L : Litter,\n        ⟨A, inr L.toNearLitter⟩ ≤ c →\n          π A • L = π' A • L →\n            π A • L.toNearLitter = π' A • L.toNearLitter\n", "additional_info": "", "used_premises": [1, 55, 55, 60, 61, 67, 61, 65, 483, 842, 61, 65, 483, 483, 483], "def_path": "ConNF/FOA/Properties/Injective.lean", "pos": [64, 79], "informalization": "In the context of Constructive Ordinal Notation (ConNF), the structure `ConNF.StructApprox.Biexact` defines a property of two structural permutations `π` and `π'` being *biexact* with respect to a given address `c`. This property is crucial in ensuring that the construction of the natural numbers in ConNF is well-defined and consistent. Specifically, it requires that for any extended index `A` and any atom `a`, if `⟨A, inl a⟩ ≤ c`, then `π A • a = π' A • a`. Additionally, for any extended index `A` and any litter `L`, if `⟨A, inr L.toNearLitter⟩ ≤ c` and `L` is flexible, then `π A • L = π' A • L`. Lastly, for any extended index `A` and any litter `L`, if `⟨A, inr L.toNearLitter⟩ ≤ c` and `π A • L = π' A • L`, then `π A • L.toNearLitter = π' A • L.toNearLitter`."}
{"full_name": "ConNF.StructApprox.Biexact.smul_eq_smul", "url": "ConNF/FOA/Properties/Injective.html#ConNF.StructApprox.Biexact.smul_eq_smul", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.StructApprox.Biexact.smul_eq_smul [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.FOAAssumptions] {β : ConNF.Λ} [ConNF.LeLevel🔗<|PREMISE|>🔗 ↑β] {π : ConNF.Allowable ↑β} {π' : ConNF.Allowable ↑β} {c : ConNF.Address🔗<|PREMISE|>🔗 ↑β} (h : ConNF.StructApprox.Biexact🔗<|PREMISE|>🔗 (ConNF.Allowable.toStructPerm π) (ConNF.Allowable.toStructPerm π') c) :π • c = π' • c", "code": "theorem Biexact.smul_eq_smul {β : Λ} [LeLevel β] {π π' : Allowable β} {c : Address β}\n    (h : Biexact (Allowable.toStructPerm π) (Allowable.toStructPerm π') c) :\n    π • c = π' • c := by\n  revert h\n  refine' WellFounded.induction (C := fun c => Biexact _ _ c → π • c = π' • c)\n    (constrains_wf β) c _\n  clear c\n  intro c ih h\n  simp only [Allowable.smul_address_eq_smul_iff] at ih ⊢\n  obtain ⟨A, a | N⟩ := c\n  · simp only [smul_inl, inl.injEq]\n    exact h.smul_eq_smul_atom A a Relation.ReflTransGen.refl\n  simp only [smul_inr, inr.injEq]\n  by_cases hL : N.IsLitter\n  swap\n  · have := ih _ (Constrains.nearLitter A N hL)\n      (h.constrains (le_nearLitter Relation.ReflTransGen.refl))\n    simp only [smul_inr, inr.injEq] at this\n    refine' SetLike.coe_injective _\n    refine' (NearLitterPerm.smul_nearLitter_eq_smul_symmDiff_smul _ _).trans _\n    refine' Eq.trans _ (NearLitterPerm.smul_nearLitter_eq_smul_symmDiff_smul _ _).symm\n    refine' congr_arg₂ _ (congr_arg SetLike.coe this) _\n    ext a : 1\n    constructor\n    · rintro ⟨b, hb, rfl⟩\n      have := ih _ (Constrains.symmDiff A N b hb)\n        (h.constrains (Relation.ReflTransGen.single <| Constrains.symmDiff A N b hb))\n      simp only [smul_inl, inl.injEq] at this\n      exact ⟨b, hb, this.symm⟩\n    · rintro ⟨b, hb, rfl⟩\n      have := ih _ (Constrains.symmDiff A N b hb)\n        (h.constrains (Relation.ReflTransGen.single <| Constrains.symmDiff A N b hb))\n      simp only [smul_inl, inl.injEq] at this\n      exact ⟨b, hb, this⟩\n  obtain ⟨L, rfl⟩ := hL.exists_litter_eq\n  suffices\n    Allowable.toStructPerm π A • L =\n    Allowable.toStructPerm π' A • L\n    from h.exact _ _ Relation.ReflTransGen.refl this\n  obtain hL | hL := flexible_cases A L\n  swap\n  · exact h.smul_eq_smul_litter A L Relation.ReflTransGen.refl hL\n  induction' hL with γ _ δ _ ε _ hδ hε hδε B t γ _ ε _ hε B a\n  · have := toStructPerm_smul_fuzz' hδ hε hδε\n    have h₁ := this (Allowable.comp B π) t\n    have h₂ := this (Allowable.comp B π') t\n    rw [Allowable.toStructPerm_comp, Allowable.comp_eq] at h₁ h₂\n    refine h₁.trans (h₂.trans ?_).symm\n    refine' congr_arg _ _\n    rw [← inv_smul_eq_iff, smul_smul]\n    refine' support_supports t _ _\n    intro c hc\n    rw [mul_smul, inv_smul_eq_iff]\n    simp only [Allowable.toStructPerm_smul, Allowable.toStructPerm_comp, Tree.comp_comp]\n    have := ih ⟨(B.cons hδ).comp c.path, c.value⟩ ?_ ?_\n    · simp only [Path.comp_cons, Path.comp_nil, StructPerm.smul_address_eq_smul_iff,\n        Tree.comp_apply]\n      exact this.symm\n    · exact Constrains.fuzz hδ hε hδε _ _ _ hc\n    · refine' h.constrains (Relation.ReflTransGen.single _)\n      exact Constrains.fuzz hδ hε hδε _ _ _ hc\n  · have := toStructPerm_smul_fuzz' (bot_lt_coe _) hε bot_ne_coe\n    have h₁ := this (Allowable.comp B π) a\n    have h₂ := this (Allowable.comp B π') a\n    rw [Allowable.toStructPerm_comp, Allowable.comp_eq] at h₁ h₂\n    refine h₁.trans (h₂.trans ?_).symm\n    refine' congr_arg _ _\n    refine (comp_bot_smul_atom _ _ _).trans ?_\n    refine ((comp_bot_smul_atom _ _ _).trans ?_).symm\n    simp only [Allowable.toStructPerm_comp, Tree.comp_apply]\n    have := ih ⟨B.cons <| bot_lt_coe _, inl a⟩ ?_ ?_\n    · simp only [smul_inl, inl.injEq] at this\n      exact this\n    · exact Constrains.fuzz_bot hε _ _\n    · refine' h.constrains (Relation.ReflTransGen.single _)\n      exact Constrains.fuzz_bot hε _ _\n", "additional_info": "", "used_premises": [1, 402, 60, 973], "def_path": "ConNF/FOA/Properties/Injective.lean", "pos": [85, 161], "informalization": "In the context of Constructive Ordinal Notation (ConNF), the theorem `ConNF.StructApprox.Biexact.smul_eq_smul` states that if two structural permutations `π` and `π'` are biexact with respect to a given address `c`, then `π • c = π' • c`. This property is crucial in ensuring that the construction of the natural numbers in ConNF is well-defined and consistent. Specifically, it requires that for any extended index `A` and any atom `a`, if `⟨A, inl a⟩ ≤ c`, then `π A • a = π' A • a`. Additionally, for any extended index `A` and any litter `L`, if `⟨A, inr L.toNearLitter⟩ ≤ c` and `L` is flexible, then `π A • L = π' A • L`. Lastly, for any extended index `A` and any litter `L`, if `⟨A, inr L.toNearLitter⟩ ≤ c` and `π A • L = π' A • L`, then `π A • L.toNearLitter = π' A • L.toNearLitter`."}
{"full_name": "ConNF.StructApprox.Biexact.smul_eq_smul_nearLitter", "url": "ConNF/FOA/Properties/Injective.html#ConNF.StructApprox.Biexact.smul_eq_smul_nearLitter", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.StructApprox.Biexact.smul_eq_smul_nearLitter [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.FOAAssumptions] {β : ConNF.Λ} [ConNF.LeLevel🔗<|PREMISE|>🔗 ↑β] {π : ConNF.Allowable ↑β} {π' : ConNF.Allowable ↑β} {A : ConNF.ExtendedIndex🔗<|PREMISE|>🔗 ↑β} {N : ConNF.NearLitter} (h : ConNF.StructApprox.Biexact🔗<|PREMISE|>🔗 (ConNF.Allowable.toStructPerm π) (ConNF.Allowable.toStructPerm π') { path := A, value := Sum.inr🔗<|PREMISE|>🔗 N }) :ConNF.Allowable.toStructPerm π A • N = ConNF.Allowable.toStructPerm π' A • N", "code": "theorem Biexact.smul_eq_smul_nearLitter {β : Λ} [LeLevel β]\n    {π π' : Allowable β} {A : ExtendedIndex β} {N : NearLitter}\n    (h : Biexact (Allowable.toStructPerm π) (Allowable.toStructPerm π') ⟨A, inr N⟩) :\n    Allowable.toStructPerm π A • N =\n    Allowable.toStructPerm π' A • N := by\n  have := h.smul_eq_smul\n  simp only [Allowable.toStructPerm_smul, StructPerm.smul_address_eq_smul_iff, smul_inr,\n    inr.injEq] at this\n  exact this\n", "additional_info": "", "used_premises": [1, 402, 61, 973, 65], "def_path": "ConNF/FOA/Properties/Injective.lean", "pos": [162, 171], "informalization": "The theorem `ConNF.StructApprox.Biexact.smul_eq_smul_nearLitter` states that, within the context of Constructive Ordinal Notation (ConNF), for two structural permutations `π` and `π'` that are *biexact* with respect to a given address `c`, and for any extended index `A` and any near litter `N` such that `⟨A, inr N⟩ ≤ c`, the result of applying `π A` to `N` is equal to the result of applying `π' A` to `N`. This is a key property in ensuring the consistency of the construction of the natural numbers in ConNF."}
{"full_name": "ConNF.StructApprox.mem_dom_of_exactlyApproximates", "url": "ConNF/FOA/Properties/Injective.html#ConNF.StructApprox.mem_dom_of_exactlyApproximates", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.StructApprox.mem_dom_of_exactlyApproximates [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] {β : ConNF.Λ} [ConNF.LeLevel🔗<|PREMISE|>🔗 ↑β] {π₀ : ConNF.StructApprox🔗<|PREMISE|>🔗 ↑β} {π : ConNF.StructPerm🔗<|PREMISE|>🔗 ↑β} (hπ : ConNF.StructApprox.ExactlyApproximates🔗<|PREMISE|>🔗 π₀ π) {A : ConNF.ExtendedIndex🔗<|PREMISE|>🔗 ↑β} {a : ConNF.Atom} {L : ConNF.Litter} (h : ConNF.StructApprox.InOut🔗<|PREMISE|>🔗 (π A) a L) :a ∈ (π₀ A).atomPerm.domain", "code": "theorem mem_dom_of_exactlyApproximates {β : Λ} [LeLevel β] {π₀ : StructApprox β} {π : StructPerm β}\n    (hπ : π₀.ExactlyApproximates π) {A : ExtendedIndex β} {a : Atom} {L : Litter}\n    (h : InOut (π A) a L) :\n    a ∈ (π₀ A).atomPerm.domain := by\n  obtain h | h := isException_of_inOut h\n  · exact (hπ A).exception_mem _ h\n  · have h₁ := (hπ A).exception_mem _ h\n    have := (hπ A).symm_map_atom _ h₁\n    rw [inv_smul_smul] at this\n    rw [← this]\n    exact (π₀ A).atomPerm.symm.map_domain h₁\n", "additional_info": "", "used_premises": [1, 402, 781, 55, 803, 61, 969], "def_path": "ConNF/FOA/Properties/Injective.lean", "pos": [172, 183], "informalization": "In the context of Constructive Ordinal Notation (ConNF), the theorem establishes that if a `β`-structural approximation exactly approximates a `β`-structural permutation, then for any given `β`-extended index `A` and elements `a`, `L` such that `a` is not equal to `L` and the permutation of `a` is not equal to the permutation of `L`, `a` must be in the domain of the near-litter permutation assigned to `A` by the `β`-structural approximation."}
{"full_name": "ConNF.StructApprox.constrainedAction_comp_mapFlexible", "url": "ConNF/FOA/Properties/Injective.html#ConNF.StructApprox.constrainedAction_comp_mapFlexible", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.StructApprox.constrainedAction_comp_mapFlexible [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.FOAAssumptions] {β : ConNF.Λ} [ConNF.LeLevel🔗<|PREMISE|>🔗 ↑β] [ConNF.StructApprox.FreedomOfActionHypothesis🔗<|PREMISE|>🔗 β] {π : ConNF.StructApprox🔗<|PREMISE|>🔗 ↑β} (hπf : ConNF.StructApprox.Free🔗<|PREMISE|>🔗 π) {γ : ConNF.Λ} {s : Set🔗<|PREMISE|>🔗 (ConNF.Address🔗<|PREMISE|>🔗 ↑β)} {hs : ConNF.Small🔗<|PREMISE|>🔗 s} (A : Quiver.Path🔗<|PREMISE|>🔗 ↑β ↑γ) :ConNF.StructAction.MapFlexible🔗<|PREMISE|>🔗 (ConNF.Tree.comp🔗<|PREMISE|>🔗 A (ConNF.StructApprox.constrainedAction🔗<|PREMISE|>🔗 π s hs))", "code": "theorem constrainedAction_comp_mapFlexible (hπf : π.Free) {γ : Λ} {s : Set (Address β)}\n    {hs : Small s} (A : Path (β : TypeIndex) γ) :\n    StructAction.MapFlexible ((constrainedAction π s hs).comp A) := by\n  rintro B L ⟨c, hc, hL₁⟩ hL₂\n  simp only [Tree.comp_apply, constrainedAction_litterMap,\n    foaHypothesis_nearLitterImage]\n  rw [completeNearLitterMap_fst_eq]\n  obtain hL₃ | (⟨⟨hL₃⟩⟩ | ⟨⟨hL₃⟩⟩) := flexible_cases' (A.comp B) L\n  · rw [completeLitterMap_eq_of_flexible hL₃]\n    refine' NearLitterApprox.flexibleCompletion_smul_flexible _ _ _ _ hL₂\n    intro L' hL'\n    exact flexible_of_comp_flexible (hπf (A.comp B) L' hL')\n  · rw [completeLitterMap_eq_of_inflexibleBot hL₃]\n    obtain ⟨⟨δ, ε, hε, C, hC⟩, a, rfl⟩ := hL₃\n    contrapose hL₂\n    rw [not_flexible_iff] at hL₂ ⊢\n    rw [inflexible_iff] at hL₂\n    obtain ⟨δ', _, ε', _, ζ', _, _, hζ', hεζ', C', t', rfl, h'⟩ |\n        ⟨δ', _, ε', _, hε', C', a', rfl, h'⟩ := hL₂\n    · have := congr_arg Litter.β h'\n      simp only [fuzz_β, bot_ne_coe] at this\n    · rw [Path.comp_cons, Path.comp_cons] at hC\n      cases coe_eq_coe.mp (Path.obj_eq_of_cons_eq_cons hC)\n      have hC := (Path.heq_of_cons_eq_cons hC).eq\n      cases coe_eq_coe.mp (Path.obj_eq_of_cons_eq_cons hC)\n      exact Inflexible.mk_bot hε _ _\n  · rw [completeLitterMap_eq_of_inflexible_coe' hL₃]\n    split_ifs\n    swap\n    · exact hL₂\n    obtain ⟨⟨δ, ε, ζ, hε, hζ, hεζ, C, hC⟩, t, rfl⟩ := hL₃\n    contrapose hL₂\n    rw [not_flexible_iff] at hL₂ ⊢\n    rw [inflexible_iff] at hL₂\n    obtain ⟨δ', _, ε', _, ζ', _, hε', hζ', hεζ', C', t', rfl, h'⟩ |\n        ⟨δ', _, ε', _, hε', C', a', rfl, h'⟩ := hL₂\n    · rw [Path.comp_cons, Path.comp_cons] at hC\n      cases coe_eq_coe.mp (Path.obj_eq_of_cons_eq_cons hC)\n      have hC := (Path.heq_of_cons_eq_cons hC).eq\n      cases coe_eq_coe.mp (Path.obj_eq_of_cons_eq_cons hC)\n      refine' Inflexible.mk_coe hε hζ hεζ _ _\n    · have := congr_arg Litter.β h'\n      simp only [fuzz_β, bot_ne_coe] at this\n      cases this\n", "additional_info": "We can prove that `map_flexible` holds at any `constrained_action` without any `lawful` hypothesis.", "used_premises": [1, 402, 779, 781, 782, 69, 60, 233, 76, 814, 304, 978], "def_path": "ConNF/FOA/Properties/Injective.lean", "pos": [187, 231], "informalization": "In the context of Constructive Ordinal Notation (ConNF), the theorem `ConNF.StructApprox.constrainedAction_comp_mapFlexible` states that for any `β`-structural action `π` that is free, any path `A` from type index `β` to type index `γ`, and any set `s` with small cardinality, the `β`-structural action `ConNF.Tree.comp A (ConNF.StructApprox.constrainedAction π s hs)` satisfies the `map_flexible` property. The `free` hypothesis implies that for every `β`-extended index `B`, the near-litter approximation `(π B)` is free with respect to `B`. The `small` hypothesis ensures that the cardinality of `s` is strictly less than the cardinality of `ConNF.κ`. This theorem is crucial in the proof of Freedom of Action in ConNF, which states that every free approximation exactly approximates some allowable permutation."}
{"full_name": "ConNF.StructApprox.constrainedAction", "url": "ConNF/FOA/Properties/ConstrainedAction.html#ConNF.StructApprox.constrainedAction", "code_src": "con-nf", "ptype": "noncomputable def", "header": "noncomputable def ConNF.StructApprox.constrainedAction [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.FOAAssumptions] {β : ConNF.Λ} [ConNF.LeLevel🔗<|PREMISE|>🔗 ↑β] [ConNF.StructApprox.FreedomOfActionHypothesis🔗<|PREMISE|>🔗 β] (π : ConNF.StructApprox🔗<|PREMISE|>🔗 ↑β) (s : Set🔗<|PREMISE|>🔗 (ConNF.Address🔗<|PREMISE|>🔗 ↑β)) (hs : ConNF.Small🔗<|PREMISE|>🔗 s) :ConNF.StructAction🔗<|PREMISE|>🔗 ↑β", "code": "noncomputable def constrainedAction (π : StructApprox β) (s : Set (Address β))\n    (hs : Small s) : StructAction β := fun B =>\n  { atomMap := fun a =>\n      ⟨∃ c : Address β, c ∈ s ∧ ⟨B, inl a⟩ ≤ c,\n        fun _ => π.completeAtomMap B a⟩\n    litterMap := fun L =>\n      ⟨∃ c : Address β, c ∈ s ∧ ⟨B, inr L.toNearLitter⟩ ≤ c,\n        fun _ => π.completeNearLitterMap B L.toNearLitter⟩\n    atomMap_dom_small := by\n      change Small ((fun a : Atom => ⟨B, inl a⟩) ⁻¹'\n        {c : Address β | ∃ d : Address β, d ∈ s ∧ c ≤ d})\n      refine' Small.preimage _ (reflTransClosure_small hs)\n      intro a b h\n      cases h\n      rfl\n    litterMap_dom_small := by\n      change Small ((fun L : Litter => ⟨B, inr L.toNearLitter⟩) ⁻¹'\n        {c : Address β | ∃ d : Address β, d ∈ s ∧ c ≤ d})\n      refine' Small.preimage _ (reflTransClosure_small hs)\n      intro a b h\n      cases h\n      rfl }\n", "additional_info": "Equations\n* One or more equations did not get rendered due to their size.\n\n", "used_premises": [1, 402, 779, 781, 69, 60, 233, 808], "def_path": "ConNF/FOA/Properties/ConstrainedAction.lean", "pos": [148, 170], "informalization": "Function `ConNF.StructApprox.constrainedAction` defines a `β`-structural action as a product that assigns a near-litter action to each `β`-extended index, under the condition that the cardinality of a given set `s` is strictly less than the cardinality of the type `ConNF.κ`."}
{"full_name": "ConNF.StructApprox.ihsAction_comp_mapFlexible", "url": "ConNF/FOA/Properties/Injective.html#ConNF.StructApprox.ihsAction_comp_mapFlexible", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.StructApprox.ihsAction_comp_mapFlexible [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.FOAAssumptions] {β : ConNF.Λ} [ConNF.LeLevel🔗<|PREMISE|>🔗 ↑β] [ConNF.StructApprox.FreedomOfActionHypothesis🔗<|PREMISE|>🔗 β] {π : ConNF.StructApprox🔗<|PREMISE|>🔗 ↑β} (hπf : ConNF.StructApprox.Free🔗<|PREMISE|>🔗 π) {γ : ConNF.Λ} (c : ConNF.Address🔗<|PREMISE|>🔗 ↑β) (d : ConNF.Address🔗<|PREMISE|>🔗 ↑β) (A : Quiver.Path🔗<|PREMISE|>🔗 ↑β ↑γ) :ConNF.StructAction.MapFlexible🔗<|PREMISE|>🔗 (ConNF.Tree.comp🔗<|PREMISE|>🔗 A (ConNF.StructApprox.ihsAction🔗<|PREMISE|>🔗 π c d))", "code": "theorem ihsAction_comp_mapFlexible (hπf : π.Free) {γ : Λ} (c d : Address β)\n    (A : Path (β : TypeIndex) γ) :\n    StructAction.MapFlexible ((ihsAction π c d).comp A) := by\n  rw [ihsAction_eq_constrainedAction]\n  exact constrainedAction_comp_mapFlexible hπf A\n", "additional_info": "", "used_premises": [1, 402, 779, 781, 782, 60, 60, 76, 814, 304, 966], "def_path": "ConNF/FOA/Properties/Injective.lean", "pos": [238, 243], "informalization": "The theorem `ConNF.StructApprox.ihsAction_comp_mapFlexible` is a property of a `β`-structural action `φ` in the context of Constructive Ordinal Notation (ConNF). It states that for any `β`-extended index `B`, any litter `L`, and any proof `hL` that `L` is in the domain of the litter map of `φ` applied to `B`, if `L` is a flexible litter, then `((φ B).litterMap L).get hL` is also a flexible litter."}
{"full_name": "ConNF.StructApprox.completeLitterMap_flexible", "url": "ConNF/FOA/Properties/Injective.html#ConNF.StructApprox.completeLitterMap_flexible", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.StructApprox.completeLitterMap_flexible [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.FOAAssumptions] {β : ConNF.Λ} [ConNF.LeLevel🔗<|PREMISE|>🔗 ↑β] [ConNF.StructApprox.FreedomOfActionHypothesis🔗<|PREMISE|>🔗 β] {π : ConNF.StructApprox🔗<|PREMISE|>🔗 ↑β} (hπf : ConNF.StructApprox.Free🔗<|PREMISE|>🔗 π) {A : ConNF.ExtendedIndex🔗<|PREMISE|>🔗 ↑β} {L : ConNF.Litter} (h : ConNF.Flexible🔗<|PREMISE|>🔗 A L) :ConNF.Flexible🔗<|PREMISE|>🔗 A (ConNF.StructApprox.completeLitterMap🔗<|PREMISE|>🔗 π A L)", "code": "theorem completeLitterMap_flexible (hπf : π.Free) {A : ExtendedIndex β} {L : Litter}\n    (h : Flexible A L) : Flexible A (π.completeLitterMap A L) := by\n  rw [completeLitterMap_eq_of_flexible h]\n  exact NearLitterApprox.flexibleCompletion_smul_flexible _ _ (hπf A) _ h\n", "additional_info": "", "used_premises": [1, 402, 779, 781, 782, 61, 842, 842, 787], "def_path": "ConNF/FOA/Properties/Injective.lean", "pos": [244, 248], "informalization": "In the context of Constructive Ordinal Notation (ConNF), the theorem `ConNF.StructApprox.completeLitterMap_flexible` states that for any free `β`-structural approximation `π`, any `β`-extended index `A`, and any flexible litter `L`, the litter `ConNF.StructApprox.completeLitterMap π A L` is also flexible. This property ensures that the construction of the natural numbers in ConNF is well-defined and consistent."}
{"full_name": "ConNF.StructApprox.completeLitterMap_inflexibleBot", "url": "ConNF/FOA/Properties/Injective.html#ConNF.StructApprox.completeLitterMap_inflexibleBot", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.StructApprox.completeLitterMap_inflexibleBot [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.FOAAssumptions] {β : ConNF.Λ} [ConNF.LeLevel🔗<|PREMISE|>🔗 ↑β] [ConNF.StructApprox.FreedomOfActionHypothesis🔗<|PREMISE|>🔗 β] {π : ConNF.StructApprox🔗<|PREMISE|>🔗 ↑β} {A : ConNF.ExtendedIndex🔗<|PREMISE|>🔗 ↑β} {L : ConNF.Litter} (h : ConNF.InflexibleBot🔗<|PREMISE|>🔗 A L) :ConNF.InflexibleBot🔗<|PREMISE|>🔗 A (ConNF.StructApprox.completeLitterMap🔗<|PREMISE|>🔗 π A L)", "code": "theorem completeLitterMap_inflexibleBot {A : ExtendedIndex β} {L : Litter}\n    (h : InflexibleBot A L) : InflexibleBot A (π.completeLitterMap A L) := by\n  rw [completeLitterMap_eq_of_inflexibleBot h]\n  obtain ⟨⟨γ, ε, hγε, B, rfl⟩, a, rfl⟩ := h\n  exact ⟨⟨γ, ε, hγε, B, rfl⟩, _, rfl⟩\n", "additional_info": "", "used_premises": [1, 402, 779, 781, 61, 887, 887, 787], "def_path": "ConNF/FOA/Properties/Injective.lean", "pos": [249, 254], "informalization": "The theorem `ConNF.StructApprox.completeLitterMap_inflexibleBot` states that if `L` is `A`-inflexible, then the litter `ConNF.StructApprox.completeLitterMap π A L` is also `A`-inflexible. This theorem is part of the construction of the natural numbers in the context of Constructive Ordinal Notation (ConNF)."}
{"full_name": "ConNF.StructApprox.completeLitterMap_inflexibleCoe", "url": "ConNF/FOA/Properties/Injective.html#ConNF.StructApprox.completeLitterMap_inflexibleCoe", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.StructApprox.completeLitterMap_inflexibleCoe [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.FOAAssumptions] {β : ConNF.Λ} [ConNF.LeLevel🔗<|PREMISE|>🔗 ↑β] [ConNF.StructApprox.FreedomOfActionHypothesis🔗<|PREMISE|>🔗 β] {π : ConNF.StructApprox🔗<|PREMISE|>🔗 ↑β} (hπf : ConNF.StructApprox.Free🔗<|PREMISE|>🔗 π) {c : ConNF.Address🔗<|PREMISE|>🔗 ↑β} {d : ConNF.Address🔗<|PREMISE|>🔗 ↑β} (hcd : ConNF.StructAction.Lawful🔗<|PREMISE|>🔗 (ConNF.StructApprox.ihsAction🔗<|PREMISE|>🔗 π c d)) {A : ConNF.ExtendedIndex🔗<|PREMISE|>🔗 ↑β} {L : ConNF.Litter} (h : ConNF.InflexibleCoe🔗<|PREMISE|>🔗 A L) (hL : { path := A, value := Sum.inr🔗<|PREMISE|>🔗 (ConNF.Litter.toNearLitter🔗<|PREMISE|>🔗 L) } ∈ ConNF.StructApprox.reflTransConstrained🔗<|PREMISE|>🔗 c d) :ConNF.InflexibleCoe🔗<|PREMISE|>🔗 A (ConNF.StructApprox.completeLitterMap🔗<|PREMISE|>🔗 π A L)", "code": "theorem completeLitterMap_inflexibleCoe (hπf : π.Free) {c d : Address β}\n    (hcd : (ihsAction π c d).Lawful) {A : ExtendedIndex β} {L : Litter} (h : InflexibleCoe A L)\n    (hL : ⟨A, inr L.toNearLitter⟩ ∈ reflTransConstrained c d) :\n    InflexibleCoe A (π.completeLitterMap A L) := by\n  rw [completeLitterMap_eq_of_inflexibleCoe h]\n  swap\n  · refine' (hcd.le _).comp _\n    obtain hL | hL := hL\n    · exact (ihAction_le hL).trans (ihAction_le_ihsAction _ _ _)\n    · rw [ihsAction_symm]\n      exact (ihAction_le hL).trans (ihAction_le_ihsAction _ _ _)\n  swap\n  · exact ihAction_comp_mapFlexible hπf _ _\n  obtain ⟨P, t, ht⟩ := h\n  constructor\n  rfl\n", "additional_info": "", "used_premises": [1, 402, 779, 781, 782, 60, 60, 809, 966, 61, 889, 65, 483, 967, 889, 787], "def_path": "ConNF/FOA/Properties/Injective.lean", "pos": [255, 271], "informalization": "The theorem `ConNF.StructApprox.completeLitterMap_inflexibleCoe` states that if `π` is a free `β`-structural approximation, `c` and `d` are lawful `β`-structural actions, `A` is a `β`-extended index, `L` is a litter, and `L` is `A`-inflexible, then `ConNF.StructApprox.completeLitterMap π A L` is also `A`-inflexible."}
{"full_name": "ConNF.StructApprox.completeLitterMap_flexible'", "url": "ConNF/FOA/Properties/Injective.html#ConNF.StructApprox.completeLitterMap_flexible'", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.StructApprox.completeLitterMap_flexible' [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.FOAAssumptions] {β : ConNF.Λ} [ConNF.LeLevel🔗<|PREMISE|>🔗 ↑β] [ConNF.StructApprox.FreedomOfActionHypothesis🔗<|PREMISE|>🔗 β] {π : ConNF.StructApprox🔗<|PREMISE|>🔗 ↑β} (hπf : ConNF.StructApprox.Free🔗<|PREMISE|>🔗 π) {c : ConNF.Address🔗<|PREMISE|>🔗 ↑β} {d : ConNF.Address🔗<|PREMISE|>🔗 ↑β} (hcd : ConNF.StructAction.Lawful🔗<|PREMISE|>🔗 (ConNF.StructApprox.ihsAction🔗<|PREMISE|>🔗 π c d)) {A : ConNF.ExtendedIndex🔗<|PREMISE|>🔗 ↑β} {L : ConNF.Litter} (hL : { path := A, value := Sum.inr🔗<|PREMISE|>🔗 (ConNF.Litter.toNearLitter🔗<|PREMISE|>🔗 L) } ∈ ConNF.StructApprox.reflTransConstrained🔗<|PREMISE|>🔗 c d) (h : ConNF.Flexible🔗<|PREMISE|>🔗 A (ConNF.StructApprox.completeLitterMap🔗<|PREMISE|>🔗 π A L)) :ConNF.Flexible🔗<|PREMISE|>🔗 A L", "code": "theorem completeLitterMap_flexible' (hπf : π.Free) {c d : Address β}\n    (hcd : (ihsAction π c d).Lawful) {A : ExtendedIndex β} {L : Litter}\n    (hL : ⟨A, inr L.toNearLitter⟩ ∈ reflTransConstrained c d)\n    (h : Flexible A (π.completeLitterMap A L)) : Flexible A L := by\n  obtain h' | h' | h' := flexible_cases' A L\n  · exact h'\n  · have := completeLitterMap_inflexibleBot (π := π) h'.some\n    rw [flexible_iff_not_inflexibleBot_inflexibleCoe] at h\n    cases h.1.false this\n  · have := completeLitterMap_inflexibleCoe hπf hcd h'.some hL\n    rw [flexible_iff_not_inflexibleBot_inflexibleCoe] at h\n    cases h.2.false this\n", "additional_info": "", "used_premises": [1, 402, 779, 781, 782, 60, 60, 809, 966, 61, 65, 483, 967, 842, 787, 842], "def_path": "ConNF/FOA/Properties/Injective.lean", "pos": [272, 284], "informalization": "The theorem `ConNF.StructApprox.completeLitterMap_flexible'` is a part of the proof of freedom of action in Constructive Ordinal Notation (ConNF). It states that if a `β`-structural approximation `π` is free, and the `β`-extended index `A` and the litter `L` satisfy certain conditions, then the litter `L` is also flexible. This property is crucial in ensuring that the construction of the natural numbers in ConNF is well-defined and consistent."}
{"full_name": "ConNF.StructApprox.completeLitterMap_flexible_iff", "url": "ConNF/FOA/Properties/Injective.html#ConNF.StructApprox.completeLitterMap_flexible_iff", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.StructApprox.completeLitterMap_flexible_iff [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.FOAAssumptions] {β : ConNF.Λ} [ConNF.LeLevel🔗<|PREMISE|>🔗 ↑β] [ConNF.StructApprox.FreedomOfActionHypothesis🔗<|PREMISE|>🔗 β] {π : ConNF.StructApprox🔗<|PREMISE|>🔗 ↑β} (hπf : ConNF.StructApprox.Free🔗<|PREMISE|>🔗 π) {c : ConNF.Address🔗<|PREMISE|>🔗 ↑β} {d : ConNF.Address🔗<|PREMISE|>🔗 ↑β} (hcd : ConNF.StructAction.Lawful🔗<|PREMISE|>🔗 (ConNF.StructApprox.ihsAction🔗<|PREMISE|>🔗 π c d)) {A : ConNF.ExtendedIndex🔗<|PREMISE|>🔗 ↑β} {L : ConNF.Litter} (hL : { path := A, value := Sum.inr🔗<|PREMISE|>🔗 (ConNF.Litter.toNearLitter🔗<|PREMISE|>🔗 L) } ∈ ConNF.StructApprox.reflTransConstrained🔗<|PREMISE|>🔗 c d) :ConNF.Flexible🔗<|PREMISE|>🔗 A (ConNF.StructApprox.completeLitterMap🔗<|PREMISE|>🔗 π A L) ↔ ConNF.Flexible🔗<|PREMISE|>🔗 A L", "code": "theorem completeLitterMap_flexible_iff (hπf : π.Free) {c d : Address β}\n    (hcd : (ihsAction π c d).Lawful) {A : ExtendedIndex β} {L : Litter}\n    (hL : ⟨A, inr L.toNearLitter⟩ ∈ reflTransConstrained c d) :\n    Flexible A (π.completeLitterMap A L) ↔ Flexible A L :=\n  ⟨completeLitterMap_flexible' hπf hcd hL, completeLitterMap_flexible hπf⟩\n", "additional_info": "", "used_premises": [1, 402, 779, 781, 782, 60, 60, 809, 966, 61, 65, 483, 967, 842, 787, 842], "def_path": "ConNF/FOA/Properties/Injective.lean", "pos": [285, 290], "informalization": "The theorem `ConNF.StructApprox.completeLitterMap_flexible_iff` states that for any `β`-structural approximation `π` that is free, any `β`-extended index `A`, and any litter `L`, the litter `ConNF.StructApprox.completeLitterMap π A L` is flexible if and only if `L` itself is flexible. This property is crucial in ensuring that the construction of the natural numbers in Constructive Ordinal Notation (ConNF) is well-defined and consistent."}
{"full_name": "ConNF.StructApprox.completeLitterMap_inflexibleBot'", "url": "ConNF/FOA/Properties/Injective.html#ConNF.StructApprox.completeLitterMap_inflexibleBot'", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.StructApprox.completeLitterMap_inflexibleBot' [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.FOAAssumptions] {β : ConNF.Λ} [ConNF.LeLevel🔗<|PREMISE|>🔗 ↑β] [ConNF.StructApprox.FreedomOfActionHypothesis🔗<|PREMISE|>🔗 β] {π : ConNF.StructApprox🔗<|PREMISE|>🔗 ↑β} (hπf : ConNF.StructApprox.Free🔗<|PREMISE|>🔗 π) {c : ConNF.Address🔗<|PREMISE|>🔗 ↑β} {d : ConNF.Address🔗<|PREMISE|>🔗 ↑β} (hcd : ConNF.StructAction.Lawful🔗<|PREMISE|>🔗 (ConNF.StructApprox.ihsAction🔗<|PREMISE|>🔗 π c d)) {A : ConNF.ExtendedIndex🔗<|PREMISE|>🔗 ↑β} {L : ConNF.Litter} (hL : { path := A, value := Sum.inr🔗<|PREMISE|>🔗 (ConNF.Litter.toNearLitter🔗<|PREMISE|>🔗 L) } ∈ ConNF.StructApprox.reflTransConstrained🔗<|PREMISE|>🔗 c d) (h : ConNF.InflexibleBot🔗<|PREMISE|>🔗 A (ConNF.StructApprox.completeLitterMap🔗<|PREMISE|>🔗 π A L)) :ConNF.InflexibleBot🔗<|PREMISE|>🔗 A L", "code": "theorem completeLitterMap_inflexibleBot' (hπf : π.Free) {c d : Address β}\n    (hcd : (ihsAction π c d).Lawful) {A : ExtendedIndex β} {L : Litter}\n    (hL : ⟨A, inr L.toNearLitter⟩ ∈ reflTransConstrained c d)\n    (h : InflexibleBot A (π.completeLitterMap A L)) : InflexibleBot A L := by\n  refine' Nonempty.some _\n  obtain h' | h' | h' := flexible_cases' A L\n  · have := completeLitterMap_flexible hπf h'\n    rw [flexible_iff_not_inflexibleBot_inflexibleCoe] at this\n    cases this.1.false h\n  · exact h'\n  · have := completeLitterMap_inflexibleCoe hπf hcd h'.some hL\n    cases inflexibleBot_inflexibleCoe h this\n", "additional_info": "", "used_premises": [1, 402, 779, 781, 782, 60, 60, 809, 966, 61, 65, 483, 967, 887, 787, 887], "def_path": "ConNF/FOA/Properties/Injective.lean", "pos": [291, 303], "informalization": "The theorem `ConNF.StructApprox.completeLitterMap_inflexibleBot'` is a part of the construction of the natural numbers in the context of Constructive Ordinal Notation (ConNF). It states that if a `β`-structural approximation `π` is free, a `β`-extended index `A`, and a litter `L` satisfy certain conditions, then `L` is `A`-inflexible."}
{"full_name": "ConNF.StructApprox.completeLitterMap_inflexibleBot_iff", "url": "ConNF/FOA/Properties/Injective.html#ConNF.StructApprox.completeLitterMap_inflexibleBot_iff", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.StructApprox.completeLitterMap_inflexibleBot_iff [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.FOAAssumptions] {β : ConNF.Λ} [ConNF.LeLevel🔗<|PREMISE|>🔗 ↑β] [ConNF.StructApprox.FreedomOfActionHypothesis🔗<|PREMISE|>🔗 β] {π : ConNF.StructApprox🔗<|PREMISE|>🔗 ↑β} (hπf : ConNF.StructApprox.Free🔗<|PREMISE|>🔗 π) {c : ConNF.Address🔗<|PREMISE|>🔗 ↑β} {d : ConNF.Address🔗<|PREMISE|>🔗 ↑β} (hcd : ConNF.StructAction.Lawful🔗<|PREMISE|>🔗 (ConNF.StructApprox.ihsAction🔗<|PREMISE|>🔗 π c d)) {A : ConNF.ExtendedIndex🔗<|PREMISE|>🔗 ↑β} {L : ConNF.Litter} (hL : { path := A, value := Sum.inr🔗<|PREMISE|>🔗 (ConNF.Litter.toNearLitter🔗<|PREMISE|>🔗 L) } ∈ ConNF.StructApprox.reflTransConstrained🔗<|PREMISE|>🔗 c d) :Nonempty🔗<|PREMISE|>🔗 (ConNF.InflexibleBot🔗<|PREMISE|>🔗 A (ConNF.StructApprox.completeLitterMap🔗<|PREMISE|>🔗 π A L)) ↔ Nonempty🔗<|PREMISE|>🔗 (ConNF.InflexibleBot🔗<|PREMISE|>🔗 A L)", "code": "theorem completeLitterMap_inflexibleBot_iff (hπf : π.Free) {c d : Address β}\n    (hcd : (ihsAction π c d).Lawful) {A : ExtendedIndex β} {L : Litter}\n    (hL : ⟨A, inr L.toNearLitter⟩ ∈ reflTransConstrained c d) :\n    Nonempty (InflexibleBot A (π.completeLitterMap A L)) ↔ Nonempty (InflexibleBot A L) :=\n  ⟨fun ⟨h⟩ => ⟨completeLitterMap_inflexibleBot' hπf hcd hL h⟩, fun ⟨h⟩ =>\n    ⟨completeLitterMap_inflexibleBot h⟩⟩\n", "additional_info": "", "used_premises": [1, 402, 779, 781, 782, 60, 60, 809, 966, 61, 65, 483, 967, 212, 887, 787, 212, 887], "def_path": "ConNF/FOA/Properties/Injective.lean", "pos": [304, 310], "informalization": "The theorem `ConNF.StructApprox.completeLitterMap_inflexibleBot_iff` states that for any `β`-structural approximation `π` that is free, any `β`-extended index `A`, and any litter `L`, the litter `ConNF.StructApprox.completeLitterMap π A L` is `A`-inflexible if and only if `L` is `A`-inflexible."}
{"full_name": "ConNF.StructApprox.completeLitterMap_inflexibleCoe'", "url": "ConNF/FOA/Properties/Injective.html#ConNF.StructApprox.completeLitterMap_inflexibleCoe'", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.StructApprox.completeLitterMap_inflexibleCoe' [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.FOAAssumptions] {β : ConNF.Λ} [ConNF.LeLevel🔗<|PREMISE|>🔗 ↑β] [ConNF.StructApprox.FreedomOfActionHypothesis🔗<|PREMISE|>🔗 β] {π : ConNF.StructApprox🔗<|PREMISE|>🔗 ↑β} (hπf : ConNF.StructApprox.Free🔗<|PREMISE|>🔗 π) {A : ConNF.ExtendedIndex🔗<|PREMISE|>🔗 ↑β} {L : ConNF.Litter} (h : ConNF.InflexibleCoe🔗<|PREMISE|>🔗 A (ConNF.StructApprox.completeLitterMap🔗<|PREMISE|>🔗 π A L)) :ConNF.InflexibleCoe🔗<|PREMISE|>🔗 A L", "code": "theorem completeLitterMap_inflexibleCoe' (hπf : π.Free) {A : ExtendedIndex β} {L : Litter}\n    (h : InflexibleCoe A (π.completeLitterMap A L)) : InflexibleCoe A L := by\n  refine' Nonempty.some _\n  obtain h' | h' | h' := flexible_cases' A L\n  · have := completeLitterMap_flexible hπf h'\n    rw [flexible_iff_not_inflexibleBot_inflexibleCoe] at this\n    cases this.2.false h\n  · have := completeLitterMap_inflexibleBot (π := π) h'.some\n    cases inflexibleBot_inflexibleCoe this h\n  · exact h'\n", "additional_info": "", "used_premises": [1, 402, 779, 781, 782, 61, 889, 787, 889], "def_path": "ConNF/FOA/Properties/Injective.lean", "pos": [311, 321], "informalization": "The theorem `ConNF.StructApprox.completeLitterMap_inflexibleCoe'` is a part of the construction of the natural numbers in the context of Constructive Ordinal Notation (ConNF). It states that if a `β`-structural approximation `π` is free and `L` is `A`-inflexible (excluding `ε = ⊥`), then `L` itself is `A`-inflexible."}
{"full_name": "ConNF.StructApprox.completeLitterMap_inflexibleCoe_iff", "url": "ConNF/FOA/Properties/Injective.html#ConNF.StructApprox.completeLitterMap_inflexibleCoe_iff", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.StructApprox.completeLitterMap_inflexibleCoe_iff [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.FOAAssumptions] {β : ConNF.Λ} [ConNF.LeLevel🔗<|PREMISE|>🔗 ↑β] [ConNF.StructApprox.FreedomOfActionHypothesis🔗<|PREMISE|>🔗 β] {π : ConNF.StructApprox🔗<|PREMISE|>🔗 ↑β} (hπf : ConNF.StructApprox.Free🔗<|PREMISE|>🔗 π) {c : ConNF.Address🔗<|PREMISE|>🔗 ↑β} {d : ConNF.Address🔗<|PREMISE|>🔗 ↑β} (hcd : ConNF.StructAction.Lawful🔗<|PREMISE|>🔗 (ConNF.StructApprox.ihsAction🔗<|PREMISE|>🔗 π c d)) {A : ConNF.ExtendedIndex🔗<|PREMISE|>🔗 ↑β} {L : ConNF.Litter} (hL : { path := A, value := Sum.inr🔗<|PREMISE|>🔗 (ConNF.Litter.toNearLitter🔗<|PREMISE|>🔗 L) } ∈ ConNF.StructApprox.reflTransConstrained🔗<|PREMISE|>🔗 c d) :Nonempty🔗<|PREMISE|>🔗 (ConNF.InflexibleCoe🔗<|PREMISE|>🔗 A (ConNF.StructApprox.completeLitterMap🔗<|PREMISE|>🔗 π A L)) ↔ Nonempty🔗<|PREMISE|>🔗 (ConNF.InflexibleCoe🔗<|PREMISE|>🔗 A L)", "code": "theorem completeLitterMap_inflexibleCoe_iff (hπf : π.Free) {c d : Address β}\n    (hcd : (ihsAction π c d).Lawful) {A : ExtendedIndex β} {L : Litter}\n    (hL : ⟨A, inr L.toNearLitter⟩ ∈ reflTransConstrained c d) :\n    Nonempty (InflexibleCoe A (π.completeLitterMap A L)) ↔ Nonempty (InflexibleCoe A L) :=\n  ⟨fun ⟨h⟩ => ⟨completeLitterMap_inflexibleCoe' hπf h⟩, fun ⟨h⟩ =>\n    ⟨completeLitterMap_inflexibleCoe hπf hcd h hL⟩⟩\n", "additional_info": "", "used_premises": [1, 402, 779, 781, 782, 60, 60, 809, 966, 61, 65, 483, 967, 212, 889, 787, 212, 889], "def_path": "ConNF/FOA/Properties/Injective.lean", "pos": [322, 328], "informalization": "`ConNF.StructApprox.completeLitterMap_inflexibleCoe_iff` is a theorem in the context of Constructive Ordinal Notation (ConNF) that relates the inflexibility of a litter `L` to the inflexibility of the litter `ConNF.StructApprox.completeLitterMap π A L`, where `π` is a `β`-structural approximation, `A` is a `β`-extended index, and `L` is a litter. The theorem states that the existence of a proof that `L` is `A`-inflexible (excluding `ε = ⊥`) is equivalent to the existence of a proof that `ConNF.StructApprox.completeLitterMap π A L` is `A`-inflexible (excluding `ε = ⊥`)."}
{"full_name": "ConNF.StructApprox.supports", "url": "ConNF/FOA/Properties/Injective.html#ConNF.StructApprox.supports", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.StructApprox.supports [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.FOAAssumptions] {β : ConNF.Λ} [ConNF.LeLevel🔗<|PREMISE|>🔗 ↑β] {π : ConNF.Allowable ↑β} {π' : ConNF.Allowable ↑β} {t : ConNF.Tangle ↑β} (ha : ∀ (A : ConNF.ExtendedIndex🔗<|PREMISE|>🔗 ↑β) (a : ConNF.Atom), { path := A, value := Sum.inl🔗<|PREMISE|>🔗 a } ∈ ConNF.TangleData.Tangle.support🔗<|PREMISE|>🔗 t → ConNF.Allowable.toStructPerm π A • a = ConNF.Allowable.toStructPerm π' A • a) (hN : ∀ (A : ConNF.ExtendedIndex🔗<|PREMISE|>🔗 ↑β) (N : ConNF.NearLitter), { path := A, value := Sum.inr🔗<|PREMISE|>🔗 N } ∈ ConNF.TangleData.Tangle.support🔗<|PREMISE|>🔗 t → ConNF.Allowable.toStructPerm π A • N = ConNF.Allowable.toStructPerm π' A • N) :π • t = π' • t", "code": "theorem supports {β : Λ} [LeLevel β] {π π' : Allowable β} {t : Tangle β}\n    (ha : ∀ A a, ⟨A, inl a⟩ ∈ t.support →\n      Allowable.toStructPerm π A • a =\n      Allowable.toStructPerm π' A • a)\n    (hN : ∀ A N, ⟨A, inr N⟩ ∈ t.support →\n      Allowable.toStructPerm π A • N =\n      Allowable.toStructPerm π' A • N) :\n    π • t = π' • t := by\n  rw [← inv_smul_eq_iff, smul_smul]\n  refine' support_supports t _ _\n  intro c hc\n  rw [mul_smul, inv_smul_eq_iff]\n  simp only [Allowable.smul_address_eq_smul_iff]\n  obtain ⟨A, a | N⟩ := c\n  · simp only [smul_inl, inl.injEq]\n    exact ha A a hc\n  · simp only [smul_inr, inr.injEq]\n    exact hN A N hc\n", "additional_info": "", "used_premises": [1, 402, 61, 67, 395, 61, 65, 395], "def_path": "ConNF/FOA/Properties/Injective.lean", "pos": [331, 349], "informalization": "The `ConNF.StructApprox.supports` theorem in Lean 4 is a part of the system designed to construct natural numbers using Constructive Ordinal Notation (ConNF), which includes a specific construction of the natural numbers utilizing a combination of finite and infinite paths through a transfinite hierarchy of types. The theorem asserts that for any two allowable permutations of the same type `β` within the context of ConNF, if these permutations leave each element (either an atom or a near-litter) unchanged when applied to the respective elements within the support of a given tangle at type `β`, then these permutations must in fact be identical when applied to the tangle itself. This property is crucial for ensuring that the construction of the natural numbers is well-defined and consistent."}
{"full_name": "ConNF.StructApprox.ConNF.StructApprox.extracted_1", "url": "ConNF/FOA/Properties/Injective.html#ConNF.StructApprox.ConNF.StructApprox.extracted_1", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.StructApprox.ConNF.StructApprox.extracted_1 [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.FOAAssumptions] {β : ConNF.Λ} [ConNF.LeLevel🔗<|PREMISE|>🔗 ↑β] [ConNF.StructApprox.FreedomOfActionHypothesis🔗<|PREMISE|>🔗 β] {π : ConNF.StructApprox🔗<|PREMISE|>🔗 ↑β} {γ : ConNF.Λ} [ConNF.LeLevel🔗<|PREMISE|>🔗 ↑γ] (A : Quiver.Path🔗<|PREMISE|>🔗 ↑β ↑γ) (s : Set🔗<|PREMISE|>🔗 (ConNF.Address🔗<|PREMISE|>🔗 ↑β)) (hs : ConNF.Small🔗<|PREMISE|>🔗 s) (hπ : ConNF.StructAction.Lawful🔗<|PREMISE|>🔗 (ConNF.Tree.comp🔗<|PREMISE|>🔗 A (ConNF.StructApprox.constrainedAction🔗<|PREMISE|>🔗 π s hs))) (ρ : ConNF.Allowable ↑γ) (h : ConNF.StructApprox.ExactlyApproximates🔗<|PREMISE|>🔗 (ConNF.StructAction.rc🔗<|PREMISE|>🔗 (ConNF.Tree.comp🔗<|PREMISE|>🔗 A (ConNF.StructApprox.constrainedAction🔗<|PREMISE|>🔗 π s hs)) hπ) (ConNF.Allowable.toStructPerm ρ)) (B : ConNF.ExtendedIndex🔗<|PREMISE|>🔗 ↑γ) (N : ConNF.NearLitter) (c : ConNF.Address🔗<|PREMISE|>🔗 ↑β) (hc₁ : c ∈ s) (hc₂ : { path := Quiver.Path.comp🔗<|PREMISE|>🔗 A B, value := Sum.inr🔗<|PREMISE|>🔗 N } ≤ c) (L : ConNF.Litter) (hc₂' : { path := Quiver.Path.comp🔗<|PREMISE|>🔗 A B, value := Sum.inr🔗<|PREMISE|>🔗 (ConNF.Litter.toNearLitter🔗<|PREMISE|>🔗 L) } ≤ c) (hNL : N.fst = L) (hL : ConNF.InflexibleBot🔗<|PREMISE|>🔗 B L) :ConNF.StructApprox.completeLitterMap🔗<|PREMISE|>🔗 π (Quiver.Path.comp🔗<|PREMISE|>🔗 A B) L = ConNF.Allowable.toStructPerm ρ B • L", "code": "theorem ConNF.StructApprox.extracted_1\n    {γ : Λ} [LeLevel γ] (A : Path (β : TypeIndex) γ)\n    (s : Set (Address β)) (hs : Small s)\n    (hπ : StructAction.Lawful (Tree.comp A (constrainedAction π s hs)))\n    (ρ : Allowable γ)\n    (h : ExactlyApproximates\n      (StructAction.rc (Tree.comp A (constrainedAction π s hs)) hπ)\n      (Allowable.toStructPerm ρ))\n    (B : ExtendedIndex γ) (N : NearLitter)\n    (c : Address β) (hc₁ : c ∈ s)\n    (hc₂ : ⟨A.comp B, inr N⟩ ≤ c)\n    (L : Litter)\n    (hc₂' : ⟨A.comp B, inr (Litter.toNearLitter L)⟩ ≤ c)\n    (hNL : N.1 = L)\n    (hL : InflexibleBot B L) :\n    completeLitterMap π (Path.comp A B) L = Allowable.toStructPerm ρ B • L := by\n  rw [completeLitterMap_eq_of_inflexibleBot (hL.comp A)]\n  obtain ⟨⟨δ, ε, hε, C, rfl⟩, a, rfl⟩ := hL\n  rw [toStructPerm_smul_fuzz (bot_lt_coe δ)]\n  refine' congr_arg _ _\n  have := comp_bot_smul_atom ρ (C.cons (bot_lt_coe _)) a\n  refine Eq.trans ?_ this.symm\n  rw [← (h <| C.cons (bot_lt_coe _)).map_atom a\n        (Or.inl (Or.inl (Or.inl (Or.inl\n          ⟨c, hc₁, Relation.ReflTransGen.head (Constrains.fuzz_bot hε _ _) hc₂'⟩))))]\n  rw [StructAction.rc_smul_atom_eq]\n  · rfl\n  · simp only [Tree.comp_apply, constrainedAction_atomMap]\n    exact ⟨c, hc₁, Relation.ReflTransGen.head (Constrains.fuzz_bot hε _ _) hc₂'⟩\n", "additional_info": "", "used_premises": [1, 402, 779, 781, 402, 76, 69, 60, 233, 809, 304, 978, 803, 810, 304, 978, 61, 60, 135, 65, 135, 65, 483, 887, 787, 135], "def_path": "ConNF/FOA/Properties/Injective.lean", "pos": [350, 379], "informalization": "The object `ConNF.StructApprox.ConNF.StructApprox.extracted_1` is a theorem in the Lean 4 library that is used in the context of Constructive Ordinal Notation (ConNF). The theorem is a key step in the proof of Freedom of Action, which is a statement about the action of a structured permutation on a litter. The theorem states that if a structured action exactly approximates a structured permutation, then a certain construction involving the structured action and the permutation results in the same litter. The theorem is a crucial part of the proof of Freedom of Action in the context of Constructive Ordinal Notation."}
{"full_name": "ConNF.StructApprox.constrainedAction_coherent'", "url": "ConNF/FOA/Properties/Injective.html#ConNF.StructApprox.constrainedAction_coherent'", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.StructApprox.constrainedAction_coherent' [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.FOAAssumptions] {β : ConNF.Λ} [ConNF.LeLevel🔗<|PREMISE|>🔗 ↑β] [ConNF.StructApprox.FreedomOfActionHypothesis🔗<|PREMISE|>🔗 β] {π : ConNF.StructApprox🔗<|PREMISE|>🔗 ↑β} (hπf : ConNF.StructApprox.Free🔗<|PREMISE|>🔗 π) {γ : ConNF.Λ} [ConNF.LeLevel🔗<|PREMISE|>🔗 ↑γ] (A : Quiver.Path🔗<|PREMISE|>🔗 ↑β ↑γ) (N : ConNF.ExtendedIndex🔗<|PREMISE|>🔗 ↑γ × ConNF.NearLitter) (s : Set🔗<|PREMISE|>🔗 (ConNF.Address🔗<|PREMISE|>🔗 ↑β)) (hs : ConNF.Small🔗<|PREMISE|>🔗 s) (hc : ∃ c ∈ s, { path := Quiver.Path.comp🔗<|PREMISE|>🔗 A N.1, value := Sum.inr🔗<|PREMISE|>🔗 N.2 } ≤ c) (hπ : ConNF.StructAction.Lawful🔗<|PREMISE|>🔗 (ConNF.Tree.comp🔗<|PREMISE|>🔗 A (ConNF.StructApprox.constrainedAction🔗<|PREMISE|>🔗 π s hs))) (ρ : ConNF.Allowable ↑γ) (h : ConNF.StructApprox.ExactlyApproximates🔗<|PREMISE|>🔗 (ConNF.StructAction.rc🔗<|PREMISE|>🔗 (ConNF.Tree.comp🔗<|PREMISE|>🔗 A (ConNF.StructApprox.constrainedAction🔗<|PREMISE|>🔗 π s hs)) hπ) (ConNF.Allowable.toStructPerm ρ)) :ConNF.StructApprox.completeNearLitterMap🔗<|PREMISE|>🔗 π (Quiver.Path.comp🔗<|PREMISE|>🔗 A N.1) N.2 = ConNF.Allowable.toStructPerm ρ N.1 • N.2", "code": "theorem constrainedAction_coherent' (hπf : π.Free) {γ : Λ} [LeLevel γ] (A : Path (β : TypeIndex) γ)\n    (N : ExtendedIndex γ × NearLitter) (s : Set (Address β)) (hs : Small s)\n    (hc : ∃ c : Address β, c ∈ s ∧ ⟨A.comp N.1, inr N.2⟩ ≤ c)\n    (hπ : StructAction.Lawful ((constrainedAction π s hs).comp A)) (ρ : Allowable γ)\n    (h : StructApprox.ExactlyApproximates\n      (StructAction.rc ((constrainedAction π s hs).comp A) hπ)\n      (Allowable.toStructPerm ρ)) :\n    completeNearLitterMap π (A.comp N.1) N.2 =\n    Allowable.toStructPerm ρ N.1 • N.2 := by\n  revert hc\n  refine' WellFounded.induction\n    (C := fun N : ExtendedIndex γ × NearLitter => (∃ c : Address β, c ∈ s ∧\n      ⟨A.comp N.fst, inr N.snd⟩ ≤ c) →\n      completeNearLitterMap π (Path.comp A N.fst) N.snd =\n      Allowable.toStructPerm ρ N.fst • N.snd)\n    (InvImage.wf (fun N => ⟨N.1, inr N.2⟩) (WellFounded.transGen (constrains_wf γ))) N _\n  clear N\n  rintro ⟨B, N⟩ ih ⟨c, hc₁, hc₂⟩\n  dsimp only at *\n  have hdom : ((((constrainedAction π s hs).comp A B).refine (hπ B)).litterMap N.fst).Dom :=\n    ⟨c, hc₁, le_nearLitter hc₂⟩\n  suffices completeLitterMap π (A.comp B) N.fst = Allowable.toStructPerm ρ B • N.fst by\n    refine' SetLike.coe_injective _\n    refine'\n      Eq.trans _\n        (NearLitterAction.smul_nearLitter_eq_of_preciseAt _ (h B) hdom\n            (NearLitterAction.refine_precise _) this.symm).symm\n    rw [completeNearLitterMap_eq' (A.comp B) N]\n    simp only [StructAction.refine_apply, StructAction.refine_litterMap,\n      foaHypothesis_nearLitterImage, Tree.ofBot_smul]\n    simp only [Tree.comp_apply, constrainedAction_litterMap, symmDiff_right_inj]\n    ext a : 1\n    constructor\n    · rintro ⟨a, ha, rfl⟩\n      refine' ⟨a, ha, _⟩\n      refine' ((h B).map_atom a _).symm.trans _\n      · refine' Or.inl (Or.inl (Or.inl (Or.inl _)))\n        exact ⟨c, hc₁, Relation.ReflTransGen.head (Constrains.symmDiff _ N a ha) hc₂⟩\n      · rw [StructAction.rc_smul_atom_eq]\n        rfl\n        exact ⟨c, hc₁, Relation.ReflTransGen.head (Constrains.symmDiff _ N a ha) hc₂⟩\n    · rintro ⟨a, ha, rfl⟩\n      refine' ⟨a, ha, _⟩\n      refine' Eq.trans _ ((h B).map_atom a _)\n      · rw [StructAction.rc_smul_atom_eq]\n        rfl\n        exact ⟨c, hc₁, Relation.ReflTransGen.head (Constrains.symmDiff _ N a ha) hc₂⟩\n      · refine' Or.inl (Or.inl (Or.inl (Or.inl _)))\n        exact ⟨c, hc₁, Relation.ReflTransGen.head (Constrains.symmDiff _ N a ha) hc₂⟩\n  have hc₂' := le_nearLitter hc₂\n  generalize hNL : N.fst = L\n  rw [hNL] at hdom hc₂'\n  obtain hL | ⟨⟨hL⟩⟩ | ⟨⟨hL⟩⟩ := flexible_cases' B L\n  · refine' Eq.trans _ ((h B).map_litter L _)\n    · rw [StructAction.rc_smul_litter_eq]\n      rw [NearLitterAction.flexibleLitterPartialPerm_apply_eq]\n      swap; exact hdom\n      swap; exact hL\n      exact (NearLitterAction.roughLitterMapOrElse_of_dom _ hdom).symm\n    · refine' Or.inl (Or.inl _)\n      refine' ⟨hdom, hL⟩\n  · exact ConNF.StructApprox.extracted_1 A s hs hπ ρ h B N c hc₁ hc₂ L hc₂' hNL hL\n  · refine ConNF.StructApprox.extracted_2 hπf A s hs hπ ρ h B N ?_ c hc₁ hc₂ L hc₂' hNL hL\n    intro C M h\n    exact ih (C, M) h ⟨c, hc₁, trans (lt_comp h A).to_reflTransGen hc₂⟩\n", "additional_info": "", "used_premises": [1, 402, 779, 781, 782, 402, 76, 61, 69, 60, 233, 135, 65, 809, 304, 978, 803, 810, 304, 978, 792, 135], "def_path": "ConNF/FOA/Properties/Injective.lean", "pos": [550, 615], "informalization": "The theorem `ConNF.StructApprox.constrainedAction_coherent'` is a key step in the proof of freedom of action in Constructive Ordinal Notation (ConNF). It states that for any `β`-structural approximation `π` that is free, any `β`-extended index `A`, and any near-litter `N`, the function `ConNF.StructApprox.completeNearLitterMap π A N` is equal to the action of the allowable permutation `ρ` on `N`."}
{"full_name": "ConNF.StructApprox.constrainedAction_coherent", "url": "ConNF/FOA/Properties/Injective.html#ConNF.StructApprox.constrainedAction_coherent", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.StructApprox.constrainedAction_coherent [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.FOAAssumptions] {β : ConNF.Λ} [ConNF.LeLevel🔗<|PREMISE|>🔗 ↑β] [ConNF.StructApprox.FreedomOfActionHypothesis🔗<|PREMISE|>🔗 β] {π : ConNF.StructApprox🔗<|PREMISE|>🔗 ↑β} (hπf : ConNF.StructApprox.Free🔗<|PREMISE|>🔗 π) {γ : ConNF.Λ} [ConNF.LeLevel🔗<|PREMISE|>🔗 ↑γ] (A : Quiver.Path🔗<|PREMISE|>🔗 ↑β ↑γ) (B : ConNF.ExtendedIndex🔗<|PREMISE|>🔗 ↑γ) (N : ConNF.NearLitter) (s : Set🔗<|PREMISE|>🔗 (ConNF.Address🔗<|PREMISE|>🔗 ↑β)) (hs : ConNF.Small🔗<|PREMISE|>🔗 s) (hc : ∃ c ∈ s, { path := Quiver.Path.comp🔗<|PREMISE|>🔗 A B, value := Sum.inr🔗<|PREMISE|>🔗 N } ≤ c) (hπ : ConNF.StructAction.Lawful🔗<|PREMISE|>🔗 (ConNF.Tree.comp🔗<|PREMISE|>🔗 A (ConNF.StructApprox.constrainedAction🔗<|PREMISE|>🔗 π s hs))) (ρ : ConNF.Allowable ↑γ) (h : ConNF.StructApprox.ExactlyApproximates🔗<|PREMISE|>🔗 (ConNF.StructAction.rc🔗<|PREMISE|>🔗 (ConNF.Tree.comp🔗<|PREMISE|>🔗 A (ConNF.StructApprox.constrainedAction🔗<|PREMISE|>🔗 π s hs)) hπ) (ConNF.Allowable.toStructPerm ρ)) :ConNF.StructApprox.completeNearLitterMap🔗<|PREMISE|>🔗 π (Quiver.Path.comp🔗<|PREMISE|>🔗 A B) N = ConNF.Tree.comp🔗<|PREMISE|>🔗 B (ConNF.Allowable.toStructPerm ρ) • N", "code": "theorem constrainedAction_coherent (hπf : π.Free) {γ : Λ} [LeLevel γ] (A : Path (β : TypeIndex) γ)\n    (B : ExtendedIndex γ) (N : NearLitter) (s : Set (Address β)) (hs : Small s)\n    (hc : ∃ c : Address β, c ∈ s ∧ ⟨A.comp B, inr N⟩ ≤ c)\n    (hπ : StructAction.Lawful ((constrainedAction π s hs).comp A)) (ρ : Allowable γ)\n    (h : StructApprox.ExactlyApproximates\n      (StructAction.rc ((constrainedAction π s hs).comp A) hπ)\n      (Allowable.toStructPerm ρ)) :\n    completeNearLitterMap π (A.comp B) N = Tree.comp B (Allowable.toStructPerm ρ) • N :=\n  constrainedAction_coherent' hπf A (B, N) s hs hc hπ ρ h\n", "additional_info": "**Coherence lemma**: The action of the complete litter map, below a given address `c`,\nis equal to the action of any allowable permutation that exactly approximates it.\nThis condition can only be applied for `γ < α` as we're dealing with lower allowable permutations.", "used_premises": [1, 402, 779, 781, 782, 402, 76, 61, 69, 60, 233, 135, 65, 809, 304, 978, 803, 810, 304, 978, 792, 135, 304], "def_path": "ConNF/FOA/Properties/Injective.lean", "pos": [620, 629], "informalization": "The theorem `ConNF.StructApprox.constrainedAction_coherent` is a coherence lemma in the context of Constructive Ordinal Notation (ConNF). It states that the action of the complete litter map, below a given address `c`, is equal to the action of any allowable permutation that exactly approximates it. This condition can only be applied for `γ < α` as we're dealing with lower allowable permutations."}
{"full_name": "ConNF.StructApprox.constrainedAction_coherent_atom", "url": "ConNF/FOA/Properties/Injective.html#ConNF.StructApprox.constrainedAction_coherent_atom", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.StructApprox.constrainedAction_coherent_atom [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.FOAAssumptions] {β : ConNF.Λ} [ConNF.LeLevel🔗<|PREMISE|>🔗 ↑β] [ConNF.StructApprox.FreedomOfActionHypothesis🔗<|PREMISE|>🔗 β] {π : ConNF.StructApprox🔗<|PREMISE|>🔗 ↑β} {γ : ConNF.Λ} [ConNF.LeLevel🔗<|PREMISE|>🔗 ↑γ] (A : Quiver.Path🔗<|PREMISE|>🔗 ↑β ↑γ) (B : ConNF.ExtendedIndex🔗<|PREMISE|>🔗 ↑γ) (a : ConNF.Atom) (s : Set🔗<|PREMISE|>🔗 (ConNF.Address🔗<|PREMISE|>🔗 ↑β)) (hs : ConNF.Small🔗<|PREMISE|>🔗 s) (hc : ∃ c ∈ s, { path := Quiver.Path.comp🔗<|PREMISE|>🔗 A B, value := Sum.inl🔗<|PREMISE|>🔗 a } ≤ c) (hπ : ConNF.StructAction.Lawful🔗<|PREMISE|>🔗 (ConNF.Tree.comp🔗<|PREMISE|>🔗 A (ConNF.StructApprox.constrainedAction🔗<|PREMISE|>🔗 π s hs))) (ρ : ConNF.Allowable ↑γ) (h : ConNF.StructApprox.ExactlyApproximates🔗<|PREMISE|>🔗 (ConNF.StructAction.rc🔗<|PREMISE|>🔗 (ConNF.Tree.comp🔗<|PREMISE|>🔗 A (ConNF.StructApprox.constrainedAction🔗<|PREMISE|>🔗 π s hs)) hπ) (ConNF.Allowable.toStructPerm ρ)) :ConNF.StructApprox.completeAtomMap🔗<|PREMISE|>🔗 π (Quiver.Path.comp🔗<|PREMISE|>🔗 A B) a = ConNF.Tree.comp🔗<|PREMISE|>🔗 B (ConNF.Allowable.toStructPerm ρ) • a", "code": "theorem constrainedAction_coherent_atom {γ : Λ} [LeLevel γ]\n    (A : Path (β : TypeIndex) γ) (B : ExtendedIndex γ) (a : Atom) (s : Set (Address β))\n    (hs : Small s) (hc : ∃ c : Address β, c ∈ s ∧ ⟨A.comp B, inl a⟩ ≤ c)\n    (hπ : StructAction.Lawful ((constrainedAction π s hs).comp A)) (ρ : Allowable γ)\n    (h : StructApprox.ExactlyApproximates\n      (StructAction.rc ((constrainedAction π s hs).comp A) hπ)\n      (Allowable.toStructPerm ρ)) :\n    completeAtomMap π (A.comp B) a = Tree.comp B (Allowable.toStructPerm ρ) • a := by\n  refine' Eq.trans _ ((h B).map_atom a (Or.inl (Or.inl (Or.inl (Or.inl hc)))))\n  rw [StructAction.rc_smul_atom_eq]\n  rfl\n  exact hc\n", "additional_info": "The coherence lemma for atoms, which is much easier to prove.\nThe statement is here for symmetry.", "used_premises": [1, 402, 779, 781, 402, 76, 61, 69, 60, 233, 135, 67, 809, 304, 978, 803, 810, 304, 978, 784, 135, 304], "def_path": "ConNF/FOA/Properties/Injective.lean", "pos": [633, 645], "informalization": "The coherence lemma for atoms, which is much easier to prove. The statement is here for symmetry."}
{"full_name": "ConNF.StructApprox.ihsAction_coherent", "url": "ConNF/FOA/Properties/Injective.html#ConNF.StructApprox.ihsAction_coherent", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.StructApprox.ihsAction_coherent [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.FOAAssumptions] {β : ConNF.Λ} [ConNF.LeLevel🔗<|PREMISE|>🔗 ↑β] [ConNF.StructApprox.FreedomOfActionHypothesis🔗<|PREMISE|>🔗 β] {π : ConNF.StructApprox🔗<|PREMISE|>🔗 ↑β} (hπf : ConNF.StructApprox.Free🔗<|PREMISE|>🔗 π) {γ : ConNF.Λ} [ConNF.LeLevel🔗<|PREMISE|>🔗 ↑γ] (A : Quiver.Path🔗<|PREMISE|>🔗 ↑β ↑γ) (B : ConNF.ExtendedIndex🔗<|PREMISE|>🔗 ↑γ) (N : ConNF.NearLitter) (c : ConNF.Address🔗<|PREMISE|>🔗 ↑β) (d : ConNF.Address🔗<|PREMISE|>🔗 ↑β) (hc : { path := Quiver.Path.comp🔗<|PREMISE|>🔗 A B, value := Sum.inr🔗<|PREMISE|>🔗 N } ∈ ConNF.StructApprox.transConstrained🔗<|PREMISE|>🔗 c d) (hπ : ConNF.StructAction.Lawful🔗<|PREMISE|>🔗 (ConNF.Tree.comp🔗<|PREMISE|>🔗 A (ConNF.StructApprox.ihsAction🔗<|PREMISE|>🔗 π c d))) (ρ : ConNF.Allowable ↑γ) (h : ConNF.StructApprox.ExactlyApproximates🔗<|PREMISE|>🔗 (ConNF.StructAction.rc🔗<|PREMISE|>🔗 (ConNF.Tree.comp🔗<|PREMISE|>🔗 A (ConNF.StructApprox.ihsAction🔗<|PREMISE|>🔗 π c d)) hπ) (ConNF.Allowable.toStructPerm ρ)) :ConNF.StructApprox.completeNearLitterMap🔗<|PREMISE|>🔗 π (Quiver.Path.comp🔗<|PREMISE|>🔗 A B) N = ConNF.Tree.comp🔗<|PREMISE|>🔗 B (ConNF.Allowable.toStructPerm ρ) • N", "code": "theorem ihsAction_coherent (hπf : π.Free) {γ : Λ} [LeLevel γ] (A : Path (β : TypeIndex) γ)\n    (B : ExtendedIndex γ) (N : NearLitter) (c d : Address β)\n    (hc : ⟨A.comp B, inr N⟩ ∈ transConstrained c d)\n    (hπ : StructAction.Lawful ((ihsAction π c d).comp A))\n    (ρ : Allowable γ)\n    (h : StructApprox.ExactlyApproximates\n      (StructAction.rc ((ihsAction π c d).comp A) hπ)\n      (Allowable.toStructPerm ρ)) :\n    completeNearLitterMap π (A.comp B) N =\n    Tree.comp B (Allowable.toStructPerm ρ) • N := by\n  simp_rw [ihsAction_eq_constrainedAction] at hπ\n  refine constrainedAction_coherent hπf A B N _ _ ?_ hπ ρ ?_\n  obtain hc | hc := hc\n  · simp only [Address.lt_iff, Relation.TransGen.tail'_iff] at hc\n    obtain ⟨d, hd₁, hd₂⟩ := hc\n    exact ⟨d, Or.inl hd₂, hd₁⟩\n  · simp only [Address.lt_iff, Relation.TransGen.tail'_iff] at hc\n    obtain ⟨d, hd₁, hd₂⟩ := hc\n    exact ⟨d, Or.inr hd₂, hd₁⟩\n  · convert h\n    rw [ihsAction_eq_constrainedAction]\n", "additional_info": "", "used_premises": [1, 402, 779, 781, 782, 402, 76, 61, 60, 60, 135, 65, 995, 809, 304, 966, 803, 810, 304, 966, 792, 135, 304], "def_path": "ConNF/FOA/Properties/Injective.lean", "pos": [646, 667], "informalization": "The theorem `ConNF.StructApprox.ihsAction_coherent` states that in the context of Constructive Ordinal Notation (ConNF), given a `β`-structural approximation `π` that is free, a path `A` from `β` to `γ`, a `γ`-extended index `B`, a near-litter `N`, addresses `c` and `d` such that the composition of `A` and `B` is in the transitive closure of `c` and `d`, and a lawful `β`-structural action that exactly approximates a `γ`-allowable permutation `ρ`, the `β`-structural approximation `π` applied to the composition of `A` and `B` and `N` is equal to the `γ`-allowable permutation `ρ` applied to `N`."}
{"full_name": "ConNF.StructApprox.transConstrained", "url": "ConNF/FOA/Properties/ConstrainedAction.html#ConNF.StructApprox.transConstrained", "code_src": "con-nf", "ptype": "def", "header": "def ConNF.StructApprox.transConstrained [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.FOAAssumptions] {β : ConNF.Λ} (c : ConNF.Address🔗<|PREMISE|>🔗 ↑β) (d : ConNF.Address🔗<|PREMISE|>🔗 ↑β) :Set🔗<|PREMISE|>🔗 (ConNF.Address🔗<|PREMISE|>🔗 ↑β)", "code": "def transConstrained (c d : Address β) : Set (Address β) :=\n  {e | e < c} ∪ {e | e < d}\n", "additional_info": "Equations\n* 🗟ConNF.StructApprox.transConstrained🗟🔗../../.././ConNF/FOA/Properties/ConstrainedAction.html#ConNF.StructApprox.transConstrained🔗  c d 🗟=🗟🔗../../.././Init/Prelude.html#Eq🔗  {e : 🗟ConNF.Address🗟🔗../../.././ConNF/Structural/Support.html#ConNF.Address🔗  ↑β | e 🗟<🗟🔗../../.././Init/Prelude.html#LT.lt🔗  c} 🗟∪🗟🔗../../.././Init/Core.html#Union.union🔗  {e : 🗟ConNF.Address🗟🔗../../.././ConNF/Structural/Support.html#ConNF.Address🔗  ↑β | e 🗟<🗟🔗../../.././Init/Prelude.html#LT.lt🔗  d}\n\n", "used_premises": [1, 60, 60, 69, 60], "def_path": "ConNF/FOA/Properties/ConstrainedAction.lean", "pos": [15, 17], "informalization": "Function `ConNF.StructApprox.transConstrained` takes two addresses `c` and `d` in the context of Constructive Ordinal Notation (ConNF) and returns a set of addresses that are either strictly less than `c` or strictly less than `d`. This set represents the transitive closure of the relation defined by `c` and `d`."}
{"full_name": "ConNF.StructApprox.ihsAction_coherent_atom", "url": "ConNF/FOA/Properties/Injective.html#ConNF.StructApprox.ihsAction_coherent_atom", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.StructApprox.ihsAction_coherent_atom [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.FOAAssumptions] {β : ConNF.Λ} [ConNF.LeLevel🔗<|PREMISE|>🔗 ↑β] [ConNF.StructApprox.FreedomOfActionHypothesis🔗<|PREMISE|>🔗 β] {π : ConNF.StructApprox🔗<|PREMISE|>🔗 ↑β} {γ : ConNF.Λ} [ConNF.LeLevel🔗<|PREMISE|>🔗 ↑γ] (A : Quiver.Path🔗<|PREMISE|>🔗 ↑β ↑γ) (B : ConNF.ExtendedIndex🔗<|PREMISE|>🔗 ↑γ) (a : ConNF.Atom) (c : ConNF.Address🔗<|PREMISE|>🔗 ↑β) (d : ConNF.Address🔗<|PREMISE|>🔗 ↑β) (hc : { path := Quiver.Path.comp🔗<|PREMISE|>🔗 A B, value := Sum.inl🔗<|PREMISE|>🔗 a } < c) (hπ : ConNF.StructAction.Lawful🔗<|PREMISE|>🔗 (ConNF.Tree.comp🔗<|PREMISE|>🔗 A (ConNF.StructApprox.ihsAction🔗<|PREMISE|>🔗 π c d))) (ρ : ConNF.Allowable ↑γ) (h : ConNF.StructApprox.ExactlyApproximates🔗<|PREMISE|>🔗 (ConNF.StructAction.rc🔗<|PREMISE|>🔗 (ConNF.Tree.comp🔗<|PREMISE|>🔗 A (ConNF.StructApprox.ihsAction🔗<|PREMISE|>🔗 π c d)) hπ) (ConNF.Allowable.toStructPerm ρ)) :ConNF.StructApprox.completeAtomMap🔗<|PREMISE|>🔗 π (Quiver.Path.comp🔗<|PREMISE|>🔗 A B) a = ConNF.Tree.comp🔗<|PREMISE|>🔗 B (ConNF.Allowable.toStructPerm ρ) • a", "code": "theorem ihsAction_coherent_atom {γ : Λ} [LeLevel γ] (A : Path (β : TypeIndex) γ)\n    (B : ExtendedIndex γ) (a : Atom) (c d : Address β) (hc : ⟨A.comp B, inl a⟩ < c)\n    (hπ : StructAction.Lawful ((ihsAction π c d).comp A)) (ρ : Allowable γ)\n    (h : StructApprox.ExactlyApproximates\n      (StructAction.rc ((ihsAction π c d).comp A) hπ)\n      (Allowable.toStructPerm ρ)) :\n    completeAtomMap π (A.comp B) a = Tree.comp B (Allowable.toStructPerm ρ) • a := by\n  refine' Eq.trans _ ((h B).map_atom a (Or.inl (Or.inl (Or.inl (Or.inl (Or.inl hc))))))\n  rw [StructAction.rc_smul_atom_eq]\n  rfl\n  exact Or.inl hc\n", "additional_info": "", "used_premises": [1, 402, 779, 781, 402, 76, 61, 60, 60, 135, 67, 809, 304, 966, 803, 810, 304, 966, 784, 135, 304], "def_path": "ConNF/FOA/Properties/Injective.lean", "pos": [668, 679], "informalization": "The theorem `ConNF.StructApprox.ihsAction_coherent_atom` states that in the context of Constructive Ordinal Notation (ConNF), given a `β`-structural approximation `π`, a `β`-extended index `A`, a `γ`-extended index `B`, an atom `a`, a `β`-address `c`, and a `β`-address `d`, if `A` composed with `B` is less than `c`, the `β`-structural action `ConNF.StructApprox.ihsAction π c d` is lawful, and the `β`-structural approximation `ConNF.StructAction.rc (ConNF.Tree.comp A (ConNF.StructApprox.ihsAction π c d)) hπ` exactly approximates the `β`-structural permutation `ConNF.Allowable.toStructPerm ρ`, then the function `ConNF.StructApprox.completeAtomMap π (Quiver.Path.comp A B) a` is equal to `ConNF.Tree.comp B (ConNF.Allowable.toStructPerm ρ) • a`."}
{"full_name": "ConNF.StructApprox.litter_injective_extends", "url": "ConNF/FOA/Properties/Injective.html#ConNF.StructApprox.litter_injective_extends", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.StructApprox.litter_injective_extends [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.FOAAssumptions] {β : ConNF.Λ} [ConNF.LeLevel🔗<|PREMISE|>🔗 ↑β] [ConNF.StructApprox.FreedomOfActionHypothesis🔗<|PREMISE|>🔗 β] {π : ConNF.StructApprox🔗<|PREMISE|>🔗 ↑β} (hπf : ConNF.StructApprox.Free🔗<|PREMISE|>🔗 π) {c : ConNF.Address🔗<|PREMISE|>🔗 ↑β} {d : ConNF.Address🔗<|PREMISE|>🔗 ↑β} (hcd : ConNF.StructAction.Lawful🔗<|PREMISE|>🔗 (ConNF.StructApprox.ihsAction🔗<|PREMISE|>🔗 π c d)) {A : ConNF.ExtendedIndex🔗<|PREMISE|>🔗 ↑β} {L₁ : ConNF.Litter} {L₂ : ConNF.Litter} (h₁ : { path := A, value := Sum.inr🔗<|PREMISE|>🔗 (ConNF.Litter.toNearLitter🔗<|PREMISE|>🔗 L₁) } ∈ ConNF.StructApprox.reflTransConstrained🔗<|PREMISE|>🔗 c d) (h₂ : { path := A, value := Sum.inr🔗<|PREMISE|>🔗 (ConNF.Litter.toNearLitter🔗<|PREMISE|>🔗 L₂) } ∈ ConNF.StructApprox.reflTransConstrained🔗<|PREMISE|>🔗 c d) (h : ConNF.StructApprox.completeLitterMap🔗<|PREMISE|>🔗 π A L₁ = ConNF.StructApprox.completeLitterMap🔗<|PREMISE|>🔗 π A L₂) :L₁ = L₂", "code": "theorem litter_injective_extends (hπf : π.Free) {c d : Address β}\n    (hcd : (ihsAction π c d).Lawful) {A : ExtendedIndex β} {L₁ L₂ : Litter}\n    (h₁ : ⟨A, inr L₁.toNearLitter⟩ ∈ reflTransConstrained c d)\n    (h₂ : ⟨A, inr L₂.toNearLitter⟩ ∈ reflTransConstrained c d)\n    (h : completeLitterMap π A L₁ = completeLitterMap π A L₂) : L₁ = L₂ := by\n  obtain h₁' | h₁' | h₁' := flexible_cases' A L₁\n  · have h₂' : Flexible A L₂\n    · have := completeLitterMap_flexible hπf h₁'\n      rw [h] at this\n      exact completeLitterMap_flexible' hπf hcd h₂ this\n    rw [completeLitterMap_eq_of_flexible h₁', completeLitterMap_eq_of_flexible h₂'] at h\n    refine' PartialPerm.injOn _ _ _ h\n    all_goals\n      rw [NearLitterApprox.flexibleCompletion_litterPerm_domain_free _ _ (hπf A)]\n      assumption\n  · obtain ⟨h₁'⟩ := h₁'\n    have h₂' : InflexibleBot A L₂\n    · have := completeLitterMap_inflexibleBot (π := π) h₁'\n      rw [h] at this\n      exact completeLitterMap_inflexibleBot' hπf hcd h₂ this\n    rw [completeLitterMap_eq_of_inflexibleBot h₁',\n      completeLitterMap_eq_of_inflexibleBot h₂'] at h\n    obtain ⟨⟨γ₁, ε₁, hγε₁, B₁, rfl⟩, a₁, rfl⟩ := h₁'\n    obtain ⟨⟨γ₂, ε₂, hγε₂, B₂, hB⟩, a₂, rfl⟩ := h₂'\n    cases coe_injective (Path.obj_eq_of_cons_eq_cons hB)\n    cases coe_injective (Path.obj_eq_of_cons_eq_cons (Path.heq_of_cons_eq_cons hB).eq)\n    cases (Path.heq_of_cons_eq_cons (Path.heq_of_cons_eq_cons hB).eq).eq\n    refine' congr_arg _ ((hcd _).atomMap_injective _ _ (fuzz_injective bot_ne_coe h))\n    · have := Constrains.fuzz_bot hγε₁ B₁ a₁\n      exact transConstrained_of_reflTransConstrained_of_trans_constrains h₁\n        (Relation.TransGen.single this)\n    · have := Constrains.fuzz_bot hγε₁ B₁ a₂\n      exact transConstrained_of_reflTransConstrained_of_trans_constrains h₂\n        (Relation.TransGen.single this)\n  · obtain ⟨h₁'⟩ := h₁'\n    have h₂' : InflexibleCoe A L₂\n    · have := completeLitterMap_inflexibleCoe hπf hcd h₁' h₁\n      rw [h] at this\n      exact completeLitterMap_inflexibleCoe' hπf this\n    rw [completeLitterMap_eq_of_inflexibleCoe h₁'] at h\n    swap\n    · refine' (hcd.le _).comp _\n      obtain h₁ | h₁ := h₁\n      · exact (ihAction_le h₁).trans (ihAction_le_ihsAction _ _ _)\n      · rw [ihsAction_symm]\n        exact (ihAction_le h₁).trans (ihAction_le_ihsAction _ _ _)\n    swap\n    · exact ihAction_comp_mapFlexible hπf _ _\n    rw [completeLitterMap_eq_of_inflexibleCoe h₂'] at h\n    swap\n    · refine' (hcd.le _).comp _\n      obtain h₂ | h₂ := h₂\n      · exact (ihAction_le h₂).trans (ihAction_le_ihsAction _ _ _)\n      · rw [ihsAction_symm]\n        exact (ihAction_le h₂).trans (ihAction_le_ihsAction _ _ _)\n    swap\n    · exact ihAction_comp_mapFlexible hπf _ _\n    obtain ⟨⟨γ₁, δ₁, ε₁, hδ₁, hε₁, hδε₁, B₁, rfl⟩, t₁, rfl⟩ := h₁'\n    obtain ⟨⟨γ₂, δ₂, ε₂, hδ₂, hε₂, hδε₂, B₂, hB⟩, t₂, rfl⟩ := h₂'\n    cases coe_injective (Path.obj_eq_of_cons_eq_cons hB)\n    cases coe_injective (Path.obj_eq_of_cons_eq_cons (Path.heq_of_cons_eq_cons hB).eq)\n    cases (Path.heq_of_cons_eq_cons (Path.heq_of_cons_eq_cons hB).eq).eq\n    have := congr_arg Litter.β h\n    cases coe_injective this\n    clear this\n    refine' congr_arg _ _\n    have h' := fuzz_injective _ h\n    rw [ihAction_smul_tangle hπf c d _ _ h₁ _ _ (hcd.comp _)] at h'\n    rw [ihAction_smul_tangle hπf c d _ _ h₂ _ _ (hcd.comp _)] at h'\n    rw [smul_left_cancel_iff] at h'\n    exact h'\n", "additional_info": "", "used_premises": [1, 402, 779, 781, 782, 60, 60, 809, 966, 61, 65, 483, 967, 65, 483, 967, 787, 787], "def_path": "ConNF/FOA/Properties/Injective.lean", "pos": [766, 837], "informalization": "In the context of Constructive Ordinal Notation (ConNF), the theorem `ConNF.StructApprox.litter_injective_extends` states that for a free `β`-structural approximation `π`, a `β`-extended index `A`, and two litters `L₁` and `L₂`, if both `L₁` and `L₂` are within the set of addresses that are either less than or equal to the address `c` or less than or equal to the address `d`, and if the complete litter map of `π` applied to `A` and `L₁` equals the complete litter map of `π` applied to `A` and `L₂`, then `L₁` must equal `L₂`."}
{"full_name": "ConNF.StructApprox.splitLt_wellFounded", "url": "ConNF/FOA/Properties/Injective.html#ConNF.StructApprox.splitLt_wellFounded", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.StructApprox.splitLt_wellFounded {α : Type u_1} {r : α → α → Prop } (hr : WellFounded🔗<|PREMISE|>🔗 r) :WellFounded🔗<|PREMISE|>🔗 (ConNF.StructApprox.SplitLt🔗<|PREMISE|>🔗 r)", "code": "theorem splitLt_wellFounded {α : Type _} {r : α → α → Prop} (hr : WellFounded r) :\n    WellFounded (SplitLt r) := by\n  refine' Subrelation.wf @(lex_lt_of_splitLt hr) _\n  refine' InvImage.wf _ (InvImage.wf _ _)\n  refine' WellFounded.prod_lex _ _ <;>\n    exact (WellFounded.wellOrderExtension.isWellFounded_lt hr).wf\n", "additional_info": "", "used_premises": [19, 19, 999], "def_path": "ConNF/FOA/Properties/Injective.lean", "pos": [920, 926], "informalization": "Given a well-founded relation `r` on a type `α`, the split relation `ConNF.StructApprox.SplitLt r` on `α × α` is also well-founded."}
{"full_name": "ConNF.StructApprox.SplitLt", "url": "ConNF/FOA/Properties/Injective.html#ConNF.StructApprox.SplitLt", "code_src": "con-nf", "ptype": "inductive", "header": "inductive ConNF.StructApprox.SplitLt {α : Type u_1} (r : α → α → Prop ) :α × α → α × α → Prop", "code": "inductive SplitLt {α : Type _} (r : α → α → Prop) : α × α → α × α → Prop\n  | left_lt ⦃a b c : α⦄ : r a b → SplitLt r (a, c) (b, c)\n  | right_lt ⦃a b c : α⦄ : r b c → SplitLt r (a, b) (a, c)\n  | left_split ⦃a b c d : α⦄ : r a c → r b c → SplitLt r (a, b) (c, d)\n  | right_split ⦃a b c d : α⦄ : r a d → r b d → SplitLt r (a, b) (c, d)\n", "additional_info": "**Split relation**\nLet `<` denote a relation on `α`.\nThe split relation `<ₛ` defined on `α × α` is defined by:\n* `a < b → (a, c) <ₛ (b, c)` (left `<`)\n* `b < c → (a, b) <ₛ (a, c)` (right `<`)\n* `a < c → b < c → (a, b) <ₛ (c, d)` (left split)\n* `a < d → b < d → (a, b) <ₛ (c, d)` (right split)\n\nThis is more granular than the standard product of relations,\nwhich would be given by just the first two constructors.\nThe splitting constructors allow one to \"split\" either `c` or `d` into two lower values `a` and `b`.\nSplitting has applications with well-founded relations; in particular, `<ₛ` is well-founded whenever\n`<` is, so this relation can simplify certain inductive steps.\n", "used_premises": [], "def_path": "ConNF/FOA/Properties/Injective.lean", "pos": [854, 859], "informalization": "Type `ConNF.StructApprox.SplitLt` represents the split relation on `α × α`, which is more granular than the standard product of relations, allowing one to \"split\" either `c` or `d` into two lower values `a` and `b`."}
{"full_name": "ConNF.StructApprox.completeAtomMap_mem_completeNearLitterMap_toNearLitter'", "url": "ConNF/FOA/Properties/Injective.html#ConNF.StructApprox.completeAtomMap_mem_completeNearLitterMap_toNearLitter'", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.StructApprox.completeAtomMap_mem_completeNearLitterMap_toNearLitter' [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.FOAAssumptions] {β : ConNF.Λ} [ConNF.LeLevel🔗<|PREMISE|>🔗 ↑β] [ConNF.StructApprox.FreedomOfActionHypothesis🔗<|PREMISE|>🔗 β] {π : ConNF.StructApprox🔗<|PREMISE|>🔗 ↑β} (hπf : ConNF.StructApprox.Free🔗<|PREMISE|>🔗 π) {c : ConNF.Address🔗<|PREMISE|>🔗 ↑β} {d : ConNF.Address🔗<|PREMISE|>🔗 ↑β} (hcd : ConNF.StructAction.Lawful🔗<|PREMISE|>🔗 (ConNF.StructApprox.ihsAction🔗<|PREMISE|>🔗 π c d)) {A : ConNF.ExtendedIndex🔗<|PREMISE|>🔗 ↑β} {a : ConNF.Atom} {L : ConNF.Litter} (ha : a.1 = L) (hL : { path := A, value := Sum.inr🔗<|PREMISE|>🔗 (ConNF.Litter.toNearLitter🔗<|PREMISE|>🔗 L) } ∈ ConNF.StructApprox.reflTransConstrained🔗<|PREMISE|>🔗 c d) :ConNF.StructApprox.completeAtomMap🔗<|PREMISE|>🔗 π A a ∈ ConNF.StructApprox.completeNearLitterMap🔗<|PREMISE|>🔗 π A (ConNF.Litter.toNearLitter🔗<|PREMISE|>🔗 L)", "code": "theorem completeAtomMap_mem_completeNearLitterMap_toNearLitter' (hπf : π.Free)\n    {c d : Address β} (hcd : (ihsAction π c d).Lawful) {A : ExtendedIndex β} {a : Atom}\n    {L : Litter} (ha : a.1 = L) (hL : ⟨A, inr L.toNearLitter⟩ ∈ reflTransConstrained c d) :\n    π.completeAtomMap A a ∈ π.completeNearLitterMap A L.toNearLitter := by\n  subst ha\n  rw [completeNearLitterMap_eq]\n  by_cases ha : a ∈ (π A).atomPerm.domain\n  · rw [completeAtomMap_eq_of_mem_domain ha]\n    refine' Or.inl ⟨Or.inr ⟨a, ⟨rfl, ha⟩, rfl⟩, _⟩\n    rintro ⟨_, ⟨b, rfl⟩, _, ⟨hb, rfl⟩, hab⟩\n    simp only [foaHypothesis_atomImage, mem_singleton_iff] at hab\n    rw [completeAtomMap_eq_of_not_mem_domain hb.2] at hab\n    have := Sublitter.equiv_apply_mem (S := (π A).largestSublitter b.fst)\n      (T := (π A).largestSublitter (completeLitterMap π A b.fst)) ⟨b, rfl, hb.2⟩\n    rw [← hab] at this\n    exact this.2 ((π A).atomPerm.map_domain ha)\n  rw [completeAtomMap_eq_of_not_mem_domain ha]\n  refine' Or.inl ⟨Or.inl _, _⟩\n  · rw [SetLike.mem_coe]\n    convert Sublitter.equiv_apply_mem _ using 1\n    rw [nearLitterHypothesis_eq, completeLitterMap_eq]\n    rfl\n  · rintro ⟨_, ⟨b, rfl⟩, _, ⟨hb, rfl⟩, hab⟩\n    simp only [foaHypothesis_atomImage, mem_singleton_iff] at hab\n    rw [completeAtomMap_eq_of_not_mem_domain hb.2] at hab\n    have := litter_injective_extends hπf hcd hL\n      (fst_mem_reflTransConstrained_of_mem_symmDiff hb.1 hL) ?_\n    · rw [Sublitter.equiv_congr_left (congr_arg _ this) _,\n        Sublitter.equiv_congr_right (congr_arg _ (congr_arg₂ _ rfl this)) _,\n        Subtype.coe_inj] at hab\n      cases (EquivLike.apply_eq_iff_eq _).mp hab\n      exact hb.1.elim (fun h' => h'.2 rfl) fun h' => h'.2 rfl\n    exact equiv_apply_eq hab\n", "additional_info": "", "used_premises": [1, 402, 779, 781, 782, 60, 60, 809, 966, 61, 65, 483, 967, 784, 792, 483], "def_path": "ConNF/FOA/Properties/Injective.lean", "pos": [928, 961], "informalization": "The Lean 4 object `ConNF.StructApprox.completeAtomMap_mem_completeNearLitterMap_toNearLitter'` is a theorem in the context of Constructive Ordinal Notation (ConNF). It states that for any `β`-structural approximation `π` that is free, and any `β`-extended indices `c` and `d` such that the `β`-structural action `ConNF.StructApprox.ihsAction π c d` is lawful, and any `β`-extended index `A` and atom `a` such that `a.1 = L` and the address `{ path := A, value := Sum.inr (ConNF.Litter.toNearLitter L) }` is in the set `ConNF.StructApprox.reflTransConstrained c d`, then `ConNF.StructApprox.completeAtomMap π A a` is in `ConNF.StructApprox.completeNearLitterMap π A (ConNF.Litter.toNearLitter L)`."}
{"full_name": "ConNF.StructApprox.ihsAction_lawful_extends", "url": "ConNF/FOA/Properties/Injective.html#ConNF.StructApprox.ihsAction_lawful_extends", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.StructApprox.ihsAction_lawful_extends [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.FOAAssumptions] {β : ConNF.Λ} [ConNF.LeLevel🔗<|PREMISE|>🔗 ↑β] [ConNF.StructApprox.FreedomOfActionHypothesis🔗<|PREMISE|>🔗 β] {π : ConNF.StructApprox🔗<|PREMISE|>🔗 ↑β} (hπf : ConNF.StructApprox.Free🔗<|PREMISE|>🔗 π) (c : ConNF.Address🔗<|PREMISE|>🔗 ↑β) (d : ConNF.Address🔗<|PREMISE|>🔗 ↑β) (hπ : ∀ (e f : ConNF.Address🔗<|PREMISE|>🔗 ↑β), ConNF.StructApprox.SplitLt🔗<|PREMISE|>🔗 (fun (c d : ConNF.Address🔗<|PREMISE|>🔗 ↑β) => c < d) (e, f) (c, d) → ConNF.StructAction.Lawful🔗<|PREMISE|>🔗 (ConNF.StructApprox.ihsAction🔗<|PREMISE|>🔗 π e f)) :ConNF.StructAction.Lawful🔗<|PREMISE|>🔗 (ConNF.StructApprox.ihsAction🔗<|PREMISE|>🔗 π c d)", "code": "theorem ihsAction_lawful_extends (hπf : π.Free) (c d : Address β)\n    (hπ : ∀ e f, SplitLt (fun c d => c < d) (e, f) (c, d) → (ihsAction π e f).Lawful) :\n    (ihsAction π c d).Lawful := by\n  intro A\n  have litter_map_injective :\n    ∀ ⦃L₁ L₂ : Litter⦄,\n      ⟨A, inr L₁.toNearLitter⟩ ∈ transConstrained c d →\n      ⟨A, inr L₂.toNearLitter⟩ ∈ transConstrained c d →\n      ((π.completeNearLitterMap A L₁.toNearLitter : Set Atom) ∩\n        (π.completeNearLitterMap A L₂.toNearLitter : Set Atom)).Nonempty →\n      L₁ = L₂ := by\n    intro L₁ L₂ h₁ h₂ h₁₂\n    have := eq_of_completeLitterMap_inter_nonempty h₁₂\n    obtain h₁ | h₁ := h₁ <;> obtain h₂ | h₂ := h₂\n    · specialize hπ ⟨A, inr L₁.toNearLitter⟩ ⟨A, inr L₂.toNearLitter⟩ (SplitLt.left_split h₁ h₂)\n      exact litter_injective_extends hπf hπ (Or.inl Relation.ReflTransGen.refl)\n        (Or.inr Relation.ReflTransGen.refl) this\n    · specialize hπ ⟨A, inr L₁.toNearLitter⟩ d (SplitLt.left_lt h₁)\n      exact litter_injective_extends hπf hπ\n        (Or.inl Relation.ReflTransGen.refl) (Or.inr h₂.to_reflTransGen) this\n    · specialize hπ c ⟨A, inr L₁.toNearLitter⟩ (SplitLt.right_lt h₁)\n      exact litter_injective_extends hπf hπ\n        (Or.inr Relation.ReflTransGen.refl) (Or.inl h₂.to_reflTransGen) this\n    · specialize hπ ⟨A, inr L₁.toNearLitter⟩ ⟨A, inr L₂.toNearLitter⟩ (SplitLt.right_split h₁ h₂)\n      exact litter_injective_extends hπf hπ (Or.inl Relation.ReflTransGen.refl)\n        (Or.inr Relation.ReflTransGen.refl) this\n  constructor\n  · intro a b ha hb hab\n    simp only [ihsAction_atomMap] at ha hb hab\n    obtain ha | ha := ha <;> obtain hb | hb := hb\n    · specialize hπ ⟨A, inl a⟩ ⟨A, inl b⟩ (SplitLt.left_split ha hb)\n      exact atom_injective_extends hπ (Or.inl Relation.ReflTransGen.refl)\n        (Or.inr Relation.ReflTransGen.refl) hab\n    · specialize hπ ⟨A, inl a⟩ d (SplitLt.left_lt ha)\n      exact atom_injective_extends hπ\n        (Or.inl Relation.ReflTransGen.refl) (Or.inr hb.to_reflTransGen) hab\n    · specialize hπ c ⟨A, inl a⟩ (SplitLt.right_lt ha)\n      exact atom_injective_extends hπ\n        (Or.inr Relation.ReflTransGen.refl) (Or.inl hb.to_reflTransGen) hab\n    · specialize hπ ⟨A, inl a⟩ ⟨A, inl b⟩ (SplitLt.right_split ha hb)\n      exact atom_injective_extends hπ (Or.inl Relation.ReflTransGen.refl)\n        (Or.inr Relation.ReflTransGen.refl) hab\n  · exact litter_map_injective\n  · intro a ha L hL\n    simp only [ihsAction_atomMap, ihsAction_litterMap]\n    have : π.completeAtomMap A a ∈ π.completeNearLitterMap A a.fst.toNearLitter := by\n      obtain ha | ha := ha <;> obtain hL | hL := hL\n      · specialize hπ ⟨A, inl a⟩ ⟨A, inr L.toNearLitter⟩ (SplitLt.left_split ha hL)\n        exact completeAtomMap_mem_completeNearLitterMap_toNearLitter' hπf hπ rfl\n          (fst_mem_refl_trans_constrained' (Or.inl Relation.ReflTransGen.refl))\n      · specialize hπ ⟨A, inl a⟩ d (SplitLt.left_lt ha)\n        exact completeAtomMap_mem_completeNearLitterMap_toNearLitter' hπf hπ rfl\n          (fst_mem_refl_trans_constrained' (Or.inl Relation.ReflTransGen.refl))\n      · specialize hπ c ⟨A, inl a⟩ (SplitLt.right_lt ha)\n        exact completeAtomMap_mem_completeNearLitterMap_toNearLitter' hπf hπ rfl\n          (fst_mem_refl_trans_constrained' (Or.inr Relation.ReflTransGen.refl))\n      · specialize hπ ⟨A, inl a⟩ ⟨A, inr L.toNearLitter⟩ (SplitLt.right_split ha hL)\n        exact\n          completeAtomMap_mem_completeNearLitterMap_toNearLitter' hπf hπ rfl\n            (fst_mem_refl_trans_constrained' (Or.inl Relation.ReflTransGen.refl))\n    constructor\n    · rintro rfl\n      exact this\n    · intro h\n      exact litter_map_injective (fst_mem_trans_constrained' ha) hL ⟨_, this, h⟩\n", "additional_info": "", "used_premises": [1, 402, 779, 781, 782, 60, 60, 60, 999, 60, 809, 966, 809, 966], "def_path": "ConNF/FOA/Properties/Injective.lean", "pos": [962, 1027], "informalization": "In the context of Constructive Ordinal Notation (ConNF), the theorem `ConNF.StructApprox.ihsAction_lawful_extends` states that if a `β`-structural approximation `π` is free and satisfies the lawfulness condition for all pairs of addresses `e` and `f` that split `c` and `d` under the split relation, then the `β`-structural action defined by `π` is lawful for the pair `c` and `d`."}
{"full_name": "ConNF.StructApprox.ihsAction_lawful", "url": "ConNF/FOA/Properties/Injective.html#ConNF.StructApprox.ihsAction_lawful", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.StructApprox.ihsAction_lawful [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.FOAAssumptions] {β : ConNF.Λ} [ConNF.LeLevel🔗<|PREMISE|>🔗 ↑β] [ConNF.StructApprox.FreedomOfActionHypothesis🔗<|PREMISE|>🔗 β] {π : ConNF.StructApprox🔗<|PREMISE|>🔗 ↑β} (hπf : ConNF.StructApprox.Free🔗<|PREMISE|>🔗 π) (c : ConNF.Address🔗<|PREMISE|>🔗 ↑β) (d : ConNF.Address🔗<|PREMISE|>🔗 ↑β) :ConNF.StructAction.Lawful🔗<|PREMISE|>🔗 (ConNF.StructApprox.ihsAction🔗<|PREMISE|>🔗 π c d)", "code": "theorem ihsAction_lawful (hπf : π.Free) (c d : Address β) : (ihsAction π c d).Lawful := by\n  refine WellFounded.induction (C := fun c => (ihsAction π c.1 c.2).Lawful)\n    (splitLt_wellFounded WellFoundedRelation.wf) (c, d) ?_\n  rintro ⟨c, d⟩ ih\n  exact ihsAction_lawful_extends hπf c d fun e f hef => ih (e, f) hef\n", "additional_info": "Every `ihs_action` is lawful. This is a consequence of all of the previous lemmas.", "used_premises": [1, 402, 779, 781, 782, 60, 60, 809, 966], "def_path": "ConNF/FOA/Properties/Injective.lean", "pos": [1029, 1034], "informalization": "The theorem `ConNF.StructApprox.ihsAction_lawful` states that every `ihs_action` defined in the context of Constructive Ordinal Notation (ConNF) satisfies the lawfulness condition for each `β`-extended index."}
{"full_name": "ConNF.StructApprox.completeAtomMap_injective", "url": "ConNF/FOA/Properties/Injective.html#ConNF.StructApprox.completeAtomMap_injective", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.StructApprox.completeAtomMap_injective [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.FOAAssumptions] {β : ConNF.Λ} [ConNF.LeLevel🔗<|PREMISE|>🔗 ↑β] [ConNF.StructApprox.FreedomOfActionHypothesis🔗<|PREMISE|>🔗 β] {π : ConNF.StructApprox🔗<|PREMISE|>🔗 ↑β} (hπf : ConNF.StructApprox.Free🔗<|PREMISE|>🔗 π) (A : ConNF.ExtendedIndex🔗<|PREMISE|>🔗 ↑β) :Function.Injective🔗<|PREMISE|>🔗 (ConNF.StructApprox.completeAtomMap🔗<|PREMISE|>🔗 π A)", "code": "theorem completeAtomMap_injective (hπf : π.Free) (A : ExtendedIndex β) :\n    Injective (π.completeAtomMap A) := fun a b =>\n  atom_injective_extends (ihsAction_lawful hπf ⟨A, inl a⟩ ⟨A, inl b⟩)\n    (Or.inl Relation.ReflTransGen.refl) (Or.inr Relation.ReflTransGen.refl)\n", "additional_info": "The complete atom map is injective.", "used_premises": [1, 402, 779, 781, 782, 61, 89, 784], "def_path": "ConNF/FOA/Properties/Injective.lean", "pos": [1045, 1049], "informalization": "In Constructive Ordinal Notation (ConNF), given a free β-structural approximation π, the function that maps each β-extended index to an atom, known as the complete atom map, is injective. This means that for any two β-extended indices A and B, if the complete atom maps of A and B are equal, then A and B are equal as well."}
{"full_name": "ConNF.StructApprox.completeLitterMap_injective", "url": "ConNF/FOA/Properties/Injective.html#ConNF.StructApprox.completeLitterMap_injective", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.StructApprox.completeLitterMap_injective [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.FOAAssumptions] {β : ConNF.Λ} [ConNF.LeLevel🔗<|PREMISE|>🔗 ↑β] [ConNF.StructApprox.FreedomOfActionHypothesis🔗<|PREMISE|>🔗 β] {π : ConNF.StructApprox🔗<|PREMISE|>🔗 ↑β} (hπf : ConNF.StructApprox.Free🔗<|PREMISE|>🔗 π) (A : ConNF.ExtendedIndex🔗<|PREMISE|>🔗 ↑β) :Function.Injective🔗<|PREMISE|>🔗 (ConNF.StructApprox.completeLitterMap🔗<|PREMISE|>🔗 π A)", "code": "theorem completeLitterMap_injective (hπf : π.Free) (A : ExtendedIndex β) :\n    Injective (π.completeLitterMap A) := fun L₁ L₂ =>\n  litter_injective_extends hπf\n    (ihsAction_lawful hπf ⟨A, inr L₁.toNearLitter⟩ ⟨A, inr L₂.toNearLitter⟩)\n    (Or.inl Relation.ReflTransGen.refl) (Or.inr Relation.ReflTransGen.refl)\n", "additional_info": "The complete litter map is injective.", "used_premises": [1, 402, 779, 781, 782, 61, 89, 787], "def_path": "ConNF/FOA/Properties/Injective.lean", "pos": [1051, 1056], "informalization": "The theorem `ConNF.StructApprox.completeLitterMap_injective` states that the function `ConNF.StructApprox.completeLitterMap`, which takes a `β`-structural approximation `π`, a `β`-extended index `A`, and a litter `L`, and returns a litter, is injective. This means that for any two litters `L₁` and `L₂`, if `ConNF.StructApprox.completeLitterMap π A L₁ = ConNF.StructApprox.completeLitterMap π A L₂`, then `L₁ = L₂`."}
{"full_name": "ConNF.StructApprox.completeAtomMap_mem_completeNearLitterMap_toNearLitter", "url": "ConNF/FOA/Properties/Injective.html#ConNF.StructApprox.completeAtomMap_mem_completeNearLitterMap_toNearLitter", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.StructApprox.completeAtomMap_mem_completeNearLitterMap_toNearLitter [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.FOAAssumptions] {β : ConNF.Λ} [ConNF.LeLevel🔗<|PREMISE|>🔗 ↑β] [ConNF.StructApprox.FreedomOfActionHypothesis🔗<|PREMISE|>🔗 β] {π : ConNF.StructApprox🔗<|PREMISE|>🔗 ↑β} (hπf : ConNF.StructApprox.Free🔗<|PREMISE|>🔗 π) {A : ConNF.ExtendedIndex🔗<|PREMISE|>🔗 ↑β} {a : ConNF.Atom} {L : ConNF.Litter} :ConNF.StructApprox.completeAtomMap🔗<|PREMISE|>🔗 π A a ∈ ConNF.StructApprox.completeNearLitterMap🔗<|PREMISE|>🔗 π A (ConNF.Litter.toNearLitter🔗<|PREMISE|>🔗 L) ↔ a.1 = L", "code": "theorem completeAtomMap_mem_completeNearLitterMap_toNearLitter (hπf : π.Free) {A : ExtendedIndex β}\n    {a : Atom} {L : Litter} :\n    π.completeAtomMap A a ∈ π.completeNearLitterMap A L.toNearLitter ↔ a.1 = L := by\n  have := completeAtomMap_mem_completeNearLitterMap_toNearLitter' hπf\n    (ihsAction_lawful hπf ⟨A, inl a⟩ ⟨A, inl a⟩) rfl\n    (fst_mem_refl_trans_constrained' (Or.inl Relation.ReflTransGen.refl))\n  constructor\n  · intro h\n    exact completeLitterMap_injective hπf _ (eq_of_completeLitterMap_inter_nonempty ⟨_, this, h⟩)\n  · rintro rfl\n    exact this\n", "additional_info": "Atoms inside litters are mapped inside the corresponding image near-litter.", "used_premises": [1, 402, 779, 781, 782, 61, 784, 792, 483], "def_path": "ConNF/FOA/Properties/Injective.lean", "pos": [1058, 1069], "informalization": "The theorem `ConNF.StructApprox.completeAtomMap_mem_completeNearLitterMap_toNearLitter` states that in the context of Constructive Ordinal Notation (ConNF), if a `β`-structural approximation `π` is free (meaning that for every `β`-extended index `A`, the near-litter approximation `(π A)` is free with respect to `A`), and `A` is a `β`-extended index, `a` is an atom, and `L` is a litter, then the condition `ConNF.StructApprox.completeAtomMap π A a ∈ ConNF.StructApprox.completeNearLitterMap π A (ConNF.Litter.toNearLitter L)` holds if and only if `a.1 = L`. This means that atoms inside litters are mapped inside the corresponding image near-litter."}
{"full_name": "ConNF.StructApprox.mem_image_iff", "url": "ConNF/FOA/Properties/Injective.html#ConNF.StructApprox.mem_image_iff", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.StructApprox.mem_image_iff {α : Type u_1} {β : Type u_2} {f : α → β} (hf : Function.Injective🔗<|PREMISE|>🔗 f) (x : α) (s : Set🔗<|PREMISE|>🔗 α) :f x ∈ f '' s ↔ x ∈ s", "code": "theorem mem_image_iff {α β : Type _} {f : α → β} (hf : Injective f) (x : α) (s : Set α) :\n    f x ∈ f '' s ↔ x ∈ s :=\n  Set.InjOn.mem_image_iff (hf.injOn Set.univ) (subset_univ _) (mem_univ _)\n", "additional_info": "", "used_premises": [89, 69], "def_path": "ConNF/FOA/Properties/Injective.lean", "pos": [1070, 1073], "informalization": "The theorem `ConNF.StructApprox.mem_image_iff` states that for an injective function `f` and a set `s`, an element `f x` is in the image of `s` under `f` if and only if `x` is in `s`."}
{"full_name": "ConNF.StructApprox.completeAtomMap_mem_completeNearLitterMap", "url": "ConNF/FOA/Properties/Injective.html#ConNF.StructApprox.completeAtomMap_mem_completeNearLitterMap", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.StructApprox.completeAtomMap_mem_completeNearLitterMap [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.FOAAssumptions] {β : ConNF.Λ} [ConNF.LeLevel🔗<|PREMISE|>🔗 ↑β] [ConNF.StructApprox.FreedomOfActionHypothesis🔗<|PREMISE|>🔗 β] {π : ConNF.StructApprox🔗<|PREMISE|>🔗 ↑β} (hπf : ConNF.StructApprox.Free🔗<|PREMISE|>🔗 π) {A : ConNF.ExtendedIndex🔗<|PREMISE|>🔗 ↑β} {a : ConNF.Atom} {N : ConNF.NearLitter} :ConNF.StructApprox.completeAtomMap🔗<|PREMISE|>🔗 π A a ∈ ConNF.StructApprox.completeNearLitterMap🔗<|PREMISE|>🔗 π A N ↔ a ∈ N", "code": "theorem completeAtomMap_mem_completeNearLitterMap (hπf : π.Free) {A : ExtendedIndex β} {a : Atom}\n    {N : NearLitter} : π.completeAtomMap A a ∈ π.completeNearLitterMap A N ↔ a ∈ N := by\n  rw [← SetLike.mem_coe, completeNearLitterMap_eq', Set.symmDiff_def]\n  simp only [mem_union, mem_diff, SetLike.mem_coe, not_exists, not_and,\n    symmDiff_symmDiff_cancel_left]\n  rw [completeAtomMap_mem_completeNearLitterMap_toNearLitter hπf]\n  rw [mem_image_iff (completeAtomMap_injective hπf A)]\n  simp only [← mem_litterSet, ← mem_diff, ← mem_union]\n  rw [← Set.symmDiff_def, symmDiff_symmDiff_cancel_left]\n  rw [SetLike.mem_coe]\n", "additional_info": "Atoms inside near litters are mapped inside the corresponding image near-litter.", "used_premises": [1, 402, 779, 781, 782, 61, 784, 792], "def_path": "ConNF/FOA/Properties/Injective.lean", "pos": [1075, 1085], "informalization": "In the context of Constructive Ordinal Notation (ConNF), the theorem `ConNF.StructApprox.completeAtomMap_mem_completeNearLitterMap` states that if a `β`-structural approximation `π` is free, meaning that for every `β`-extended index `A`, the near-litter approximation `(π A)` is free with respect to `A`, then an atom `a` is inside a near-litter `N` if and only if the image of `a` under the function `ConNF.StructApprox.completeAtomMap π A` is inside the image near-litter `ConNF.StructApprox.completeNearLitterMap π A N`."}
{"full_name": "ConNF.StructApprox.completeNearLitterMap_injective", "url": "ConNF/FOA/Properties/Injective.html#ConNF.StructApprox.completeNearLitterMap_injective", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.StructApprox.completeNearLitterMap_injective [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.FOAAssumptions] {β : ConNF.Λ} [ConNF.LeLevel🔗<|PREMISE|>🔗 ↑β] [ConNF.StructApprox.FreedomOfActionHypothesis🔗<|PREMISE|>🔗 β] {π : ConNF.StructApprox🔗<|PREMISE|>🔗 ↑β} (hπf : ConNF.StructApprox.Free🔗<|PREMISE|>🔗 π) (A : ConNF.ExtendedIndex🔗<|PREMISE|>🔗 ↑β) :Function.Injective🔗<|PREMISE|>🔗 (ConNF.StructApprox.completeNearLitterMap🔗<|PREMISE|>🔗 π A)", "code": "theorem completeNearLitterMap_injective (hπf : π.Free) (A : ExtendedIndex β) :\n    Injective (π.completeNearLitterMap A) := by\n  intro N₁ N₂ h\n  rw [← SetLike.coe_set_eq, Set.ext_iff] at h ⊢\n  intro a\n  specialize h (π.completeAtomMap A a)\n  simp only [SetLike.mem_coe, completeAtomMap_mem_completeNearLitterMap hπf] at h ⊢\n  exact h\n", "additional_info": "The complete near-litter map is injective.", "used_premises": [1, 402, 779, 781, 782, 61, 89, 792], "def_path": "ConNF/FOA/Properties/Injective.lean", "pos": [1087, 1095], "informalization": "The theorem `ConNF.StructApprox.completeNearLitterMap_injective` states that the function `ConNF.StructApprox.completeNearLitterMap` is injective. This function is used in the proof of freedom of action in Constructive Ordinal Notation (ConNF)."}
{"full_name": "ConNF.StructApprox.completeAtomMap_bijective", "url": "ConNF/FOA/Properties/Bijective.html#ConNF.StructApprox.completeAtomMap_bijective", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.StructApprox.completeAtomMap_bijective [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.FOAAssumptions] {β : ConNF.Λ} [ConNF.LeLevel🔗<|PREMISE|>🔗 ↑β] [ConNF.StructApprox.FreedomOfActionHypothesis🔗<|PREMISE|>🔗 β] {π : ConNF.StructApprox🔗<|PREMISE|>🔗 ↑β} (hπf : ConNF.StructApprox.Free🔗<|PREMISE|>🔗 π) (A : ConNF.ExtendedIndex🔗<|PREMISE|>🔗 ↑β) :Function.Bijective🔗<|PREMISE|>🔗 (ConNF.StructApprox.completeAtomMap🔗<|PREMISE|>🔗 π A)", "code": "theorem completeAtomMap_bijective (hπf : π.Free) (A : ExtendedIndex β) :\n    Bijective (π.completeAtomMap A) :=\n  ⟨completeAtomMap_injective hπf A, completeAtomMap_surjective hπf A⟩\n", "additional_info": "", "used_premises": [1, 402, 779, 781, 782, 61, 1010, 784], "def_path": "ConNF/FOA/Properties/Bijective.lean", "pos": [16, 19], "informalization": "The theorem `ConNF.StructApprox.completeAtomMap_bijective` states that the function `ConNF.StructApprox.completeAtomMap`, which maps each `β`-extended index to an atom, is bijective. This means that the function is both injective (one-to-one) and surjective (onto)."}
{"full_name": "Function.Bijective", "url": "Mathlib/Init/Function.html#Function.Bijective", "code_src": "mathlib4", "ptype": "def", "header": "def Function.Bijective {α : Sort u₁} {β : Sort u₂} (f : α → β) :Prop", "code": "def Bijective (f : α → β) :=\n  Injective f ∧ Surjective f\n", "additional_info": "A function is called bijective if it is both injective and surjective.\nEquations\n* 🗟Function.Bijective🗟🔗../.././Mathlib/Init/Function.html#Function.Bijective🔗  f 🗟=🗟🔗../.././Init/Prelude.html#Eq🔗  (🗟Function.Injective🗟🔗../.././Mathlib/Init/Function.html#Function.Injective🔗  f 🗟∧🗟🔗../.././Init/Prelude.html#And🔗  🗟Function.Surjective🗟🔗../.././Mathlib/Init/Function.html#Function.Surjective🔗  f)\n\n", "used_premises": [], "def_path": "Mathlib/Init/Function.lean", "pos": [137, 139], "informalization": "Function `Function.Bijective` checks if a function `f` is bijective, meaning it is both injective (one-to-one) and surjective (onto)."}
{"full_name": "ConNF.StructApprox.completeLitterMap_bijective", "url": "ConNF/FOA/Properties/Bijective.html#ConNF.StructApprox.completeLitterMap_bijective", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.StructApprox.completeLitterMap_bijective [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.FOAAssumptions] {β : ConNF.Λ} [ConNF.LeLevel🔗<|PREMISE|>🔗 ↑β] [ConNF.StructApprox.FreedomOfActionHypothesis🔗<|PREMISE|>🔗 β] {π : ConNF.StructApprox🔗<|PREMISE|>🔗 ↑β} (hπf : ConNF.StructApprox.Free🔗<|PREMISE|>🔗 π) (A : ConNF.ExtendedIndex🔗<|PREMISE|>🔗 ↑β) :Function.Bijective🔗<|PREMISE|>🔗 (ConNF.StructApprox.completeLitterMap🔗<|PREMISE|>🔗 π A)", "code": "theorem completeLitterMap_bijective (hπf : π.Free) (A : ExtendedIndex β) :\n    Bijective (π.completeLitterMap A) :=\n  ⟨completeLitterMap_injective hπf A, completeLitterMap_surjective hπf A⟩\n", "additional_info": "", "used_premises": [1, 402, 779, 781, 782, 61, 1010, 787], "def_path": "ConNF/FOA/Properties/Bijective.lean", "pos": [20, 23], "informalization": "The theorem `ConNF.StructApprox.completeLitterMap_bijective` states that the function `ConNF.StructApprox.completeLitterMap` is bijective, meaning it is both injective (one-to-one) and surjective (onto). This function is part of the construction of the natural numbers in the context of Constructive Ordinal Notation (ConNF)."}
{"full_name": "ConNF.StructApprox.completeNearLitterMap_bijective", "url": "ConNF/FOA/Properties/Bijective.html#ConNF.StructApprox.completeNearLitterMap_bijective", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.StructApprox.completeNearLitterMap_bijective [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.FOAAssumptions] {β : ConNF.Λ} [ConNF.LeLevel🔗<|PREMISE|>🔗 ↑β] [ConNF.StructApprox.FreedomOfActionHypothesis🔗<|PREMISE|>🔗 β] {π : ConNF.StructApprox🔗<|PREMISE|>🔗 ↑β} (hπf : ConNF.StructApprox.Free🔗<|PREMISE|>🔗 π) (A : ConNF.ExtendedIndex🔗<|PREMISE|>🔗 ↑β) :Function.Bijective🔗<|PREMISE|>🔗 (ConNF.StructApprox.completeNearLitterMap🔗<|PREMISE|>🔗 π A)", "code": "theorem completeNearLitterMap_bijective (hπf : π.Free) (A : ExtendedIndex β) :\n    Bijective (π.completeNearLitterMap A) :=\n  ⟨completeNearLitterMap_injective hπf A, completeNearLitterMap_surjective hπf A⟩\n", "additional_info": "", "used_premises": [1, 402, 779, 781, 782, 61, 1010, 792], "def_path": "ConNF/FOA/Properties/Bijective.lean", "pos": [24, 27], "informalization": "The theorem `ConNF.StructApprox.completeNearLitterMap_bijective` states that the function `ConNF.StructApprox.completeNearLitterMap π A` is bijective, meaning it is both injective (one-to-one) and surjective (onto), for any free `β`-structural approximation `π` and any `β`-extended index `A`."}
{"full_name": "ConNF.StructApprox.completeNearLitterMap_subset_range", "url": "ConNF/FOA/Properties/Surjective.html#ConNF.StructApprox.completeNearLitterMap_subset_range", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.StructApprox.completeNearLitterMap_subset_range [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.FOAAssumptions] {β : ConNF.Λ} [ConNF.LeLevel🔗<|PREMISE|>🔗 ↑β] [ConNF.StructApprox.FreedomOfActionHypothesis🔗<|PREMISE|>🔗 β] {π : ConNF.StructApprox🔗<|PREMISE|>🔗 ↑β} (A : ConNF.ExtendedIndex🔗<|PREMISE|>🔗 ↑β) (L : ConNF.Litter) :↑(ConNF.StructApprox.completeNearLitterMap🔗<|PREMISE|>🔗 π A (ConNF.Litter.toNearLitter🔗<|PREMISE|>🔗 L)) ⊆ Set.range🔗<|PREMISE|>🔗 (ConNF.StructApprox.completeAtomMap🔗<|PREMISE|>🔗 π A)", "code": "theorem completeNearLitterMap_subset_range (A : ExtendedIndex β) (L : Litter) :\n    (π.completeNearLitterMap A L.toNearLitter : Set Atom) ⊆ range (π.completeAtomMap A) := by\n  rw [completeNearLitterMap_toNearLitter_eq]\n  rintro a (⟨ha₁, ha₂⟩ | ⟨a, ⟨_, ha₂⟩, rfl⟩)\n  · refine' ⟨(((π A).largestSublitter L).equiv ((π A).largestSublitter a.1)).symm\n      ⟨a, (π A).mem_largestSublitter_of_not_mem_domain a ha₂⟩, _⟩\n    rw [completeAtomMap_eq_of_not_mem_domain]\n    swap\n    · exact NearLitterApprox.not_mem_domain_of_mem_largestSublitter _\n        (Sublitter.equiv_symm_apply_mem ⟨a, _⟩)\n    · rw [mem_litterSet] at ha₁\n      have : ((((π A).largestSublitter L).equiv\n        ((π A).largestSublitter a.fst)).symm ⟨a, rfl, ha₂⟩ : Atom).fst =\n          L :=\n        Sublitter.equiv_symm_apply_fst_eq ⟨a, _⟩\n      rw [Sublitter.equiv_congr_left (congr_arg _ this),\n        Sublitter.equiv_congr_right (congr_arg _ (congr_arg _ this)),\n        Sublitter.equiv_congr_right (congr_arg _ ha₁.symm)]\n      simp only [SetLike.eta, Equiv.apply_symm_apply]\n  · refine' ⟨a, _⟩\n    rw [completeAtomMap_eq_of_mem_domain ha₂]\n", "additional_info": "", "used_premises": [1, 402, 779, 781, 61, 792, 483, 1014, 784], "def_path": "ConNF/FOA/Properties/Surjective.lean", "pos": [15, 36], "informalization": "In the context of Constructive Ordinal Notation (ConNF), the theorem `ConNF.StructApprox.completeNearLitterMap_subset_range` states that for any `β`-extended index `A` and litter `L`, the near-litter `ConNF.StructApprox.completeNearLitterMap π A (ConNF.Litter.toNearLitter L)` is a subset of the range of the function `ConNF.StructApprox.completeAtomMap π A`, which maps each `β`-extended index to an atom."}
{"full_name": "Set.range", "url": "Mathlib/Data/Set/Defs.html#Set.range", "code_src": "mathlib4", "ptype": "def", "header": "def Set.range {α : Type u} {ι : Sort u_1} (f : ι → α) :Set🔗<|PREMISE|>🔗 α", "code": "def range (f : ι → α) : Set α := {x | ∃ y, f y = x}\n", "additional_info": "Range of a function.\nThis function is more flexible than `f '' univ`, as the image requires that the domain is in Type\nand not an arbitrary Sort.\nEquations\n* 🗟Set.range🗟🔗../../.././Mathlib/Data/Set/Defs.html#Set.range🔗  f 🗟=🗟🔗../../.././Init/Prelude.html#Eq🔗  {x : α | ∃ (y : ι), f y 🗟=🗟🔗../../.././Init/Prelude.html#Eq🔗  x}\n\n", "used_premises": [69], "def_path": "Mathlib/Data/Set/Defs.lean", "pos": [156, 157], "informalization": "Function `Set.range` computes the set of all output values of a function `f`, representing the image of the function's domain."}
{"full_name": "ConNF.StructApprox.completeAtomMap_surjective_extends", "url": "ConNF/FOA/Properties/Surjective.html#ConNF.StructApprox.completeAtomMap_surjective_extends", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.StructApprox.completeAtomMap_surjective_extends [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.FOAAssumptions] {β : ConNF.Λ} [ConNF.LeLevel🔗<|PREMISE|>🔗 ↑β] [ConNF.StructApprox.FreedomOfActionHypothesis🔗<|PREMISE|>🔗 β] {π : ConNF.StructApprox🔗<|PREMISE|>🔗 ↑β} (A : ConNF.ExtendedIndex🔗<|PREMISE|>🔗 ↑β) (a : ConNF.Atom) (h : a.1 ∈ Set.range🔗<|PREMISE|>🔗 (ConNF.StructApprox.completeLitterMap🔗<|PREMISE|>🔗 π A)) :a ∈ Set.range🔗<|PREMISE|>🔗 (ConNF.StructApprox.completeAtomMap🔗<|PREMISE|>🔗 π A)", "code": "theorem completeAtomMap_surjective_extends (A : ExtendedIndex β) (a : Atom)\n    (h : a.1 ∈ range (π.completeLitterMap A)) : a ∈ range (π.completeAtomMap A) := by\n  obtain ⟨L, hL⟩ := h\n  by_cases ha : a ∈ (π A).atomPerm.domain\n  · refine' ⟨(π A).atomPerm.symm a, _⟩\n    rw [completeAtomMap_eq_of_mem_domain ((π A).atomPerm.symm.map_domain ha)]\n    exact (π A).atomPerm.right_inv ha\n  · have := completeNearLitterMap_toNearLitter_eq (π := π) A L\n    rw [hL] at this\n    have := Eq.subset this.symm (Or.inl ⟨rfl, ha⟩)\n    exact completeNearLitterMap_subset_range A L this\n", "additional_info": "", "used_premises": [1, 402, 779, 781, 61, 1014, 787, 1014, 784], "def_path": "ConNF/FOA/Properties/Surjective.lean", "pos": [37, 48], "informalization": "`ConNF.StructApprox.completeAtomMap_surjective_extends` is a theorem in the Lean proof assistant that is used in the context of Constructive Ordinal Notation (ConNF). It states that if a given atom is a member of the range of the litter map generated by a β-structural approximation, then it must also be a member of the range of the atom map generated by the same β-structural approximation. This theorem is crucial in establishing the \"Freedom of Action\" principle in ConNF, ensuring that every free approximation exactly approximates some allowable permutation."}
{"full_name": "ConNF.StructApprox.completeAddressMap_atom_eq", "url": "ConNF/FOA/Properties/Surjective.html#ConNF.StructApprox.completeAddressMap_atom_eq", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.StructApprox.completeAddressMap_atom_eq [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.FOAAssumptions] {β : ConNF.Λ} [ConNF.LeLevel🔗<|PREMISE|>🔗 ↑β] [ConNF.StructApprox.FreedomOfActionHypothesis🔗<|PREMISE|>🔗 β] {π : ConNF.StructApprox🔗<|PREMISE|>🔗 ↑β} {a : ConNF.Atom} {B : ConNF.ExtendedIndex🔗<|PREMISE|>🔗 ↑β} :ConNF.StructApprox.completeAddressMap🔗<|PREMISE|>🔗 π { path := B, value := Sum.inl🔗<|PREMISE|>🔗 a } = { path := B, value := Sum.inl🔗<|PREMISE|>🔗 (ConNF.StructApprox.completeAtomMap🔗<|PREMISE|>🔗 π B a) }", "code": "theorem completeAddressMap_atom_eq {π : StructApprox β} {a : Atom} {B : ExtendedIndex β} :\n    π.completeAddressMap ⟨B, inl a⟩ = ⟨B, inl (π.completeAtomMap B a)⟩ :=\n  rfl\n", "additional_info": "", "used_premises": [1, 402, 779, 781, 61, 1017, 67, 67, 784], "def_path": "ConNF/FOA/Properties/Surjective.lean", "pos": [55, 58], "informalization": "In the context of Constructive Ordinal Notation (ConNF), the function `ConNF.StructApprox.completeAddressMap` takes a `β`-structural approximation `π` and returns a function that maps each `β`-address to another `β`-address. This function is crucial in the proof of Freedom of Action in ConNF, which states that every free approximation exactly approximates some allowable permutation. The theorem `ConNF.StructApprox.completeAddressMap_atom_eq` states that for a `β`-extended index `B` and an atom `a`, the function `ConNF.StructApprox.completeAddressMap π` maps the `β`-address `{ path := B, value := Sum.inl a }` to the `β`-address `{ path := B, value := Sum.inl (ConNF.StructApprox.completeAtomMap π B a) }`."}
{"full_name": "ConNF.StructApprox.completeAddressMap", "url": "ConNF/FOA/Properties/Surjective.html#ConNF.StructApprox.completeAddressMap", "code_src": "con-nf", "ptype": "noncomputable def", "header": "noncomputable def ConNF.StructApprox.completeAddressMap [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.FOAAssumptions] {β : ConNF.Λ} [ConNF.LeLevel🔗<|PREMISE|>🔗 ↑β] [ConNF.StructApprox.FreedomOfActionHypothesis🔗<|PREMISE|>🔗 β] (π : ConNF.StructApprox🔗<|PREMISE|>🔗 ↑β) :ConNF.Address🔗<|PREMISE|>🔗 ↑β → ConNF.Address🔗<|PREMISE|>🔗 ↑β", "code": "noncomputable def completeAddressMap (π : StructApprox β) :\n    Address β → Address β\n  | ⟨B, inl a⟩ => ⟨B, inl (π.completeAtomMap B a)⟩\n  | ⟨B, inr N⟩ => ⟨B, inr (π.completeNearLitterMap B N)⟩\n", "additional_info": "Equations\n* One or more equations did not get rendered due to their size.\n\n", "used_premises": [1, 402, 779, 781, 60, 60], "def_path": "ConNF/FOA/Properties/Surjective.lean", "pos": [49, 53], "informalization": "Function `ConNF.StructApprox.completeAddressMap` is a noncomputable function defined in the context of Constructive Ordinal Notation (ConNF). It takes as input a `β`-structural approximation `π` and returns a function that maps each `β`-address to another `β`-address. This function is crucial in the proof of Freedom of Action in ConNF, which states that every free approximation exactly approximates some allowable permutation."}
{"full_name": "ConNF.StructApprox.completeAddressMap_nearLitter_eq", "url": "ConNF/FOA/Properties/Surjective.html#ConNF.StructApprox.completeAddressMap_nearLitter_eq", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.StructApprox.completeAddressMap_nearLitter_eq [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.FOAAssumptions] {β : ConNF.Λ} [ConNF.LeLevel🔗<|PREMISE|>🔗 ↑β] [ConNF.StructApprox.FreedomOfActionHypothesis🔗<|PREMISE|>🔗 β] {π : ConNF.StructApprox🔗<|PREMISE|>🔗 ↑β} {N : ConNF.NearLitter} {B : ConNF.ExtendedIndex🔗<|PREMISE|>🔗 ↑β} :ConNF.StructApprox.completeAddressMap🔗<|PREMISE|>🔗 π { path := B, value := Sum.inr🔗<|PREMISE|>🔗 N } = { path := B, value := Sum.inr🔗<|PREMISE|>🔗 (ConNF.StructApprox.completeNearLitterMap🔗<|PREMISE|>🔗 π B N) }", "code": "theorem completeAddressMap_nearLitter_eq {π : StructApprox β} {N : NearLitter}\n    {B : ExtendedIndex β} :\n    π.completeAddressMap ⟨B, inr N⟩ = ⟨B, inr (π.completeNearLitterMap B N)⟩ :=\n  rfl\n", "additional_info": "", "used_premises": [1, 402, 779, 781, 61, 1017, 65, 65, 792], "def_path": "ConNF/FOA/Properties/Surjective.lean", "pos": [60, 64], "informalization": "The theorem `ConNF.StructApprox.completeAddressMap_nearLitter_eq` is a part of the proof of Freedom of Action in Constructive Ordinal Notation (ConNF). It states that for a `β`-structural approximation `π`, the function `ConNF.StructApprox.completeAddressMap π` applied to a `β`-address of the form `{ path := B, value := Sum.inr N }` (where `B` is a `β`-extended index and `N` is a `β`-near-litter) returns a `β`-address of the form `{ path := B, value := Sum.inr (ConNF.StructApprox.completeNearLitterMap π B N) }`."}
{"full_name": "ConNF.StructApprox.completeAddressMap_injective", "url": "ConNF/FOA/Properties/Surjective.html#ConNF.StructApprox.completeAddressMap_injective", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.StructApprox.completeAddressMap_injective [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.FOAAssumptions] {β : ConNF.Λ} [ConNF.LeLevel🔗<|PREMISE|>🔗 ↑β] [ConNF.StructApprox.FreedomOfActionHypothesis🔗<|PREMISE|>🔗 β] {π : ConNF.StructApprox🔗<|PREMISE|>🔗 ↑β} (hπf : ConNF.StructApprox.Free🔗<|PREMISE|>🔗 π) :Function.Injective🔗<|PREMISE|>🔗 (ConNF.StructApprox.completeAddressMap🔗<|PREMISE|>🔗 π)", "code": "theorem completeAddressMap_injective (hπf : π.Free) :\n    Injective π.completeAddressMap := by\n  rintro ⟨B₁, a₁ | N₁⟩ ⟨B₂, a₂ | N₂⟩ h <;>\n    rw [Address.ext_iff] at h <;>\n    simp only [completeAddressMap_atom_eq,\n      completeAddressMap_nearLitter_eq,\n      inl.injEq, inr.injEq, and_false] at h\n  · cases h.1\n    cases completeAtomMap_injective hπf B₁ h.2\n    rfl\n  · cases h.1\n    cases completeNearLitterMap_injective hπf B₁ h.2\n    rfl\n", "additional_info": "", "used_premises": [1, 402, 779, 781, 782, 89, 1017], "def_path": "ConNF/FOA/Properties/Surjective.lean", "pos": [65, 78], "informalization": "Function `ConNF.StructApprox.completeAddressMap` is a noncomputable function defined in the context of Constructive Ordinal Notation (ConNF). It takes as input a `β`-structural approximation `π` and returns a function that maps each `β`-address to another `β`-address. This function is crucial in the proof of Freedom of Action in ConNF, which states that every free approximation exactly approximates some allowable permutation."}
{"full_name": "ConNF.StructApprox.preimageConstrained_small", "url": "ConNF/FOA/Properties/Surjective.html#ConNF.StructApprox.preimageConstrained_small", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.StructApprox.preimageConstrained_small [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.FOAAssumptions] {β : ConNF.Λ} [ConNF.LeLevel🔗<|PREMISE|>🔗 ↑β] [ConNF.StructApprox.FreedomOfActionHypothesis🔗<|PREMISE|>🔗 β] {π : ConNF.StructApprox🔗<|PREMISE|>🔗 ↑β} (hπf : ConNF.StructApprox.Free🔗<|PREMISE|>🔗 π) (c : ConNF.Address🔗<|PREMISE|>🔗 ↑β) :ConNF.Small🔗<|PREMISE|>🔗 (ConNF.StructApprox.preimageConstrained🔗<|PREMISE|>🔗 π c)", "code": "theorem preimageConstrained_small (hπf : π.Free) (c : Address β) :\n    Small (preimageConstrained π c) :=\n  Small.preimage (completeAddressMap_injective hπf) (small_constrains c)\n", "additional_info": "", "used_premises": [1, 402, 779, 781, 782, 60, 233, 1021], "def_path": "ConNF/FOA/Properties/Surjective.lean", "pos": [82, 85], "informalization": "The theorem `ConNF.StructApprox.preimageConstrained_small` states that the preimage of the set of `β`-addresses `d` such that `d ≺ c` under the map `ConNF.StructApprox.completeAddressMap π` is a small set, meaning its cardinality is strictly less than the cardinality of the type `ConNF.κ` in the context of Constructive Ordinal Notation (ConNF)."}
{"full_name": "ConNF.StructApprox.preimageConstrained", "url": "ConNF/FOA/Properties/Surjective.html#ConNF.StructApprox.preimageConstrained", "code_src": "con-nf", "ptype": "def", "header": "def ConNF.StructApprox.preimageConstrained [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.FOAAssumptions] {β : ConNF.Λ} [ConNF.LeLevel🔗<|PREMISE|>🔗 ↑β] [ConNF.StructApprox.FreedomOfActionHypothesis🔗<|PREMISE|>🔗 β] (π : ConNF.StructApprox🔗<|PREMISE|>🔗 ↑β) (c : ConNF.Address🔗<|PREMISE|>🔗 ↑β) :Set🔗<|PREMISE|>🔗 (ConNF.Address🔗<|PREMISE|>🔗 ↑β)", "code": "def preimageConstrained (π : StructApprox β) (c : Address β) : Set (Address β) :=\n  π.completeAddressMap ⁻¹' {d | d ≺ c}\n", "additional_info": "Equations\n* 🗟ConNF.StructApprox.preimageConstrained🗟🔗../../.././ConNF/FOA/Properties/Surjective.html#ConNF.StructApprox.preimageConstrained🔗  π c 🗟=🗟🔗../../.././Init/Prelude.html#Eq🔗  🗟ConNF.StructApprox.completeAddressMap🗟🔗../../.././ConNF/FOA/Properties/Surjective.html#ConNF.StructApprox.completeAddressMap🔗  π 🗟⁻¹'🗟🔗../../.././Mathlib/Data/Set/Defs.html#Set.preimage🔗  {d : 🗟ConNF.Address🗟🔗../../.././ConNF/Structural/Support.html#ConNF.Address🔗  ↑β | d 🗟≺🗟🔗../../.././ConNF/FOA/Basic/Constrains.html#ConNF.Constrains🔗  c}\n\n", "used_premises": [1, 402, 779, 781, 60, 69, 60], "def_path": "ConNF/FOA/Properties/Surjective.lean", "pos": [79, 81], "informalization": "Function `ConNF.StructApprox.preimageConstrained` takes a `β`-structural approximation `π` and a `β`-address `c`, and returns the preimage of the set of `β`-addresses `d` such that `d ≺ c` under the map `ConNF.StructApprox.completeAddressMap π`."}
{"full_name": "ConNF.StructApprox.preimageAction_lawful", "url": "ConNF/FOA/Properties/Surjective.html#ConNF.StructApprox.preimageAction_lawful", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.StructApprox.preimageAction_lawful [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.FOAAssumptions] {β : ConNF.Λ} [ConNF.LeLevel🔗<|PREMISE|>🔗 ↑β] [ConNF.StructApprox.FreedomOfActionHypothesis🔗<|PREMISE|>🔗 β] {π : ConNF.StructApprox🔗<|PREMISE|>🔗 ↑β} (hπf : ConNF.StructApprox.Free🔗<|PREMISE|>🔗 π) {c : ConNF.Address🔗<|PREMISE|>🔗 ↑β} :ConNF.StructAction.Lawful🔗<|PREMISE|>🔗 (ConNF.StructApprox.preimageAction🔗<|PREMISE|>🔗 hπf c)", "code": "theorem preimageAction_lawful (hπf : π.Free) {c : Address β} :\n    (preimageAction hπf c).Lawful := by\n  intro A\n  constructor\n  · intro a b ha hb hab\n    exact completeAtomMap_injective hπf A hab\n  · intro L₁ L₂ hL₁ hL₂ hL\n    exact completeLitterMap_injective hπf A (eq_of_completeLitterMap_inter_nonempty hL)\n  · intro a _ L _\n    exact (completeAtomMap_mem_completeNearLitterMap_toNearLitter hπf).symm\n", "additional_info": "", "used_premises": [1, 402, 779, 781, 782, 60, 809, 1023], "def_path": "ConNF/FOA/Properties/Surjective.lean", "pos": [95, 105], "informalization": "Function `ConNF.StructApprox.preimageAction` defines a `β`-structural action as a product that assigns a near-litter action to each `β`-extended index, under the condition that the `β`-structural approximation `π` is free, meaning that for every `β`-extended index `A`, the near-litter approximation `(π A)` is free with respect to `A`. The theorem `ConNF.StructApprox.preimageAction_lawful` proves that this `β`-structural action satisfies the lawfulness condition for each `β`-extended index."}
{"full_name": "ConNF.StructApprox.preimageAction", "url": "ConNF/FOA/Properties/Surjective.html#ConNF.StructApprox.preimageAction", "code_src": "con-nf", "ptype": "noncomputable def", "header": "noncomputable def ConNF.StructApprox.preimageAction [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.FOAAssumptions] {β : ConNF.Λ} [ConNF.LeLevel🔗<|PREMISE|>🔗 ↑β] [ConNF.StructApprox.FreedomOfActionHypothesis🔗<|PREMISE|>🔗 β] {π : ConNF.StructApprox🔗<|PREMISE|>🔗 ↑β} (hπf : ConNF.StructApprox.Free🔗<|PREMISE|>🔗 π) (c : ConNF.Address🔗<|PREMISE|>🔗 ↑β) :ConNF.StructAction🔗<|PREMISE|>🔗 ↑β", "code": "noncomputable def preimageAction (hπf : π.Free) (c : Address β) : StructAction β :=\n  constrainedAction π (preimageConstrained π c) (preimageConstrained_small hπf c)\n", "additional_info": "Equations\n* 🗟ConNF.StructApprox.preimageAction🗟🔗../../.././ConNF/FOA/Properties/Surjective.html#ConNF.StructApprox.preimageAction🔗  hπf c 🗟=🗟🔗../../.././Init/Prelude.html#Eq🔗  🗟ConNF.StructApprox.constrainedAction🗟🔗../../.././ConNF/FOA/Properties/ConstrainedAction.html#ConNF.StructApprox.constrainedAction🔗  π (🗟ConNF.StructApprox.preimageConstrained🗟🔗../../.././ConNF/FOA/Properties/Surjective.html#ConNF.StructApprox.preimageConstrained🔗  π c) ⋯\n\n", "used_premises": [1, 402, 779, 781, 782, 60, 808], "def_path": "ConNF/FOA/Properties/Surjective.lean", "pos": [86, 88], "informalization": "Function `ConNF.StructApprox.preimageAction` defines a `β`-structural action as a product that assigns a near-litter action to each `β`-extended index, under the condition that the `β`-structural approximation `π` is free, meaning that for every `β`-extended index `A`, the near-litter approximation `(π A)` is free with respect to `A`."}
{"full_name": "ConNF.StructApprox.preimageAction_comp_mapFlexible", "url": "ConNF/FOA/Properties/Surjective.html#ConNF.StructApprox.preimageAction_comp_mapFlexible", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.StructApprox.preimageAction_comp_mapFlexible [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.FOAAssumptions] {β : ConNF.Λ} [ConNF.LeLevel🔗<|PREMISE|>🔗 ↑β] [ConNF.StructApprox.FreedomOfActionHypothesis🔗<|PREMISE|>🔗 β] {π : ConNF.StructApprox🔗<|PREMISE|>🔗 ↑β} {hπf : ConNF.StructApprox.Free🔗<|PREMISE|>🔗 π} {γ : ConNF.Λ} {c : ConNF.Address🔗<|PREMISE|>🔗 ↑β} (A : Quiver.Path🔗<|PREMISE|>🔗 ↑β ↑γ) :ConNF.StructAction.MapFlexible🔗<|PREMISE|>🔗 (ConNF.Tree.comp🔗<|PREMISE|>🔗 A (ConNF.StructApprox.preimageAction🔗<|PREMISE|>🔗 hπf c))", "code": "theorem preimageAction_comp_mapFlexible {hπf : π.Free} {γ : Λ} {c : Address β}\n    (A : Path (β : TypeIndex) γ) :\n    StructAction.MapFlexible ((preimageAction hπf c).comp A) :=\n  constrainedAction_comp_mapFlexible hπf A\n", "additional_info": "", "used_premises": [1, 402, 779, 781, 782, 60, 76, 814, 304, 1023], "def_path": "ConNF/FOA/Properties/Surjective.lean", "pos": [106, 110], "informalization": "The theorem `ConNF.StructApprox.preimageAction_comp_mapFlexible` in Constructive Ordinal Notation (ConNF) establishes a property of a `β`-structural action `φ`, specifically that for any path `A` from type index `β` to type index `γ`, if `φ` is a free `β`-structural action (which ensures that for every `β`-extended index `A`, the near-litter approximation `(π A)` is free with respect to `A`), then the `γ`-structural action obtained by composing `A` with `φ` is such that for any `γ`-extended index `B`, if `L` is a flexible litter in the domain of the litter map of `φ` applied to `B`, then `((φ B).litterMap L).get hL` is also a flexible litter. This property is crucial in the proof of Freedom of Action in ConNF, which states that every free approximation exactly approximates some allowable permutation."}
{"full_name": "ConNF.StructApprox.Relation.reflTransGen_of_eq", "url": "ConNF/FOA/Properties/Surjective.html#ConNF.StructApprox.Relation.reflTransGen_of_eq", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.StructApprox.Relation.reflTransGen_of_eq {α : Type u_1} {r : α → α → Prop } {x : α} {y : α} (h : x = y) :Relation.ReflTransGen🔗<|PREMISE|>🔗 r x y", "code": "theorem Relation.reflTransGen_of_eq {α : Type _} {r : α → α → Prop} {x y : α} (h : x = y) :\n    Relation.ReflTransGen r x y := by\n  cases h\n  rfl\n", "additional_info": "", "used_premises": [924], "def_path": "ConNF/FOA/Properties/Surjective.lean", "pos": [111, 115], "informalization": "The theorem `ConNF.StructApprox.Relation.reflTransGen_of_eq` states that for any relation `r` on a type `α`, if `x` and `y` are equal, then `x` is related to `y` by the reflexive transitive closure of `r`."}
{"full_name": "ConNF.StructApprox.completeLitterMap_surjective_extends", "url": "ConNF/FOA/Properties/Surjective.html#ConNF.StructApprox.completeLitterMap_surjective_extends", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.StructApprox.completeLitterMap_surjective_extends [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.FOAAssumptions] {β : ConNF.Λ} [ConNF.LeLevel🔗<|PREMISE|>🔗 ↑β] [ConNF.StructApprox.FreedomOfActionHypothesis🔗<|PREMISE|>🔗 β] {π : ConNF.StructApprox🔗<|PREMISE|>🔗 ↑β} (hπf : ConNF.StructApprox.Free🔗<|PREMISE|>🔗 π) (A : ConNF.ExtendedIndex🔗<|PREMISE|>🔗 ↑β) (L : ConNF.Litter) (ha : ∀ (B : ConNF.ExtendedIndex🔗<|PREMISE|>🔗 ↑β) (a : ConNF.Atom), { path := B, value := Sum.inl🔗<|PREMISE|>🔗 a } ≺ { path := A, value := Sum.inr🔗<|PREMISE|>🔗 (ConNF.Litter.toNearLitter🔗<|PREMISE|>🔗 L) } → a ∈ Set.range🔗<|PREMISE|>🔗 (ConNF.StructApprox.completeAtomMap🔗<|PREMISE|>🔗 π B)) (hN : ∀ (B : ConNF.ExtendedIndex🔗<|PREMISE|>🔗 ↑β) (N : ConNF.NearLitter), { path := B, value := Sum.inr🔗<|PREMISE|>🔗 N } ≺ { path := A, value := Sum.inr🔗<|PREMISE|>🔗 (ConNF.Litter.toNearLitter🔗<|PREMISE|>🔗 L) } → N ∈ Set.range🔗<|PREMISE|>🔗 (ConNF.StructApprox.completeNearLitterMap🔗<|PREMISE|>🔗 π B)) :L ∈ Set.range🔗<|PREMISE|>🔗 (ConNF.StructApprox.completeLitterMap🔗<|PREMISE|>🔗 π A)", "code": "theorem completeLitterMap_surjective_extends (hπf : π.Free) (A : ExtendedIndex β) (L : Litter)\n    (ha : ∀ (B : ExtendedIndex β) (a : Atom),\n      ⟨B, inl a⟩ ≺ ⟨A, inr L.toNearLitter⟩ → a ∈ range (π.completeAtomMap B))\n    (hN : ∀ (B : ExtendedIndex β) (N : NearLitter),\n      ⟨B, inr N⟩ ≺ ⟨A, inr L.toNearLitter⟩ → N ∈ range (π.completeNearLitterMap B)) :\n    L ∈ range (π.completeLitterMap A) := by\n  obtain h | ⟨⟨h⟩⟩ | ⟨⟨h⟩⟩ := flexible_cases' A L\n  · refine' ⟨(NearLitterApprox.flexibleCompletion (π A) A).symm • L, _⟩\n    rw [completeLitterMap_eq_of_flexible, NearLitterApprox.right_inv_litter]\n    · rw [NearLitterApprox.flexibleCompletion_litterPerm_domain_free (π A) A (hπf A)]\n      exact h\n    · exact NearLitterApprox.flexibleCompletion_symm_smul_flexible (π A) A (hπf A) L h\n  · obtain ⟨⟨γ, ε, hε, C, rfl⟩, a, rfl⟩ := h\n    obtain ⟨b, rfl⟩ := ha _ a (Constrains.fuzz_bot hε _ a)\n    refine' ⟨fuzz (show ⊥ ≠ (ε : TypeIndex) from bot_ne_coe) b, _⟩\n    rw [completeLitterMap_eq_of_inflexibleBot ⟨⟨γ, ε, hε, C, rfl⟩, b, rfl⟩]\n  · obtain ⟨⟨γ, δ, ε, hδ, hε, hδε, B, rfl⟩, t, rfl⟩ := h\n    refine' ⟨fuzz hδε\n      (((preimageAction hπf\n            ⟨(B.cons hε).cons (bot_lt_coe _),\n              inr (fuzz hδε t).toNearLitter⟩).hypothesisedAllowable\n          ⟨γ, δ, ε, hδ, hε, hδε, B, rfl⟩\n          ((preimageAction_lawful hπf).comp _) (preimageAction_comp_mapFlexible _))⁻¹ • t), _⟩\n    rw [completeLitterMap_eq_of_inflexibleCoe ⟨⟨γ, δ, ε, hδ, hε, hδε, B, rfl⟩, _, rfl⟩\n        ((ihAction_lawful hπf _).comp _) (ihAction_comp_mapFlexible hπf _ _)]\n    refine' congr_arg _ _\n    dsimp only\n    rw [smul_eq_iff_eq_inv_smul]\n    refine supports (t := t) ?_ ?_\n    · intros A a hc\n      have hac := Constrains.fuzz hδ hε hδε B t _ hc\n      specialize ha _ a hac\n      obtain ⟨b, ha⟩ := ha\n      have : (Tree.comp A\n        (Allowable.toStructPerm ((preimageAction hπf\n            ⟨(B.cons hε).cons (bot_lt_coe _),\n              inr (fuzz hδε t).toNearLitter⟩).hypothesisedAllowable\n              ⟨γ, δ, ε, hδ, hε, hδε, B, rfl⟩ ((preimageAction_lawful hπf).comp _)\n              (preimageAction_comp_mapFlexible _))))⁻¹ • a = b\n      · rw [inv_smul_eq_iff, ← ha]\n        rw [StructAction.hypothesisedAllowable]\n        refine' preimageAction_coherent_atom hπf (B.cons hδ) A b _ _ _\n          (StructAction.allowable_exactlyApproximates _ _ _ _)\n        rw [ha]\n        exact hac\n      trans b\n      · rw [map_inv]\n        exact this\n      · rw [map_inv, Tree.inv_apply, ← smul_eq_iff_eq_inv_smul, ← ha]\n        rw [StructAction.hypothesisedAllowable]\n        refine' (ihAction_coherent_atom (B.cons hδ) A b _ _\n          ((ihAction_lawful hπf _).comp _) _\n          (StructAction.allowable_exactlyApproximates _ _ _ _)).symm\n        refine' Relation.TransGen.tail' _\n          (Constrains.fuzz hδ hε hδε B _ _ (smul_mem_support hc _))\n        refine' Relation.reflTransGen_of_eq _\n        refine' Address.ext _ _ rfl _\n        change inl _ = inl _\n        simp only [← this, ne_eq, Tree.comp_bot, Tree.toBot_inv_smul, map_inv,\n          Tree.inv_apply]\n    · intros A N hc\n      have hNc := Constrains.fuzz hδ hε hδε B t _ hc\n      specialize hN _ N hNc\n      obtain ⟨N', hN⟩ := hN\n      have : (Tree.comp A\n        (Allowable.toStructPerm ((preimageAction hπf\n          ⟨(B.cons hε).cons (bot_lt_coe _),\n            inr (fuzz hδε t).toNearLitter⟩).hypothesisedAllowable\n              ⟨γ, δ, ε, hδ, hε, hδε, B, rfl⟩ ((preimageAction_lawful hπf).comp _)\n              (preimageAction_comp_mapFlexible _))))⁻¹ • N = N'\n      · rw [inv_smul_eq_iff, ← hN]\n        rw [StructAction.hypothesisedAllowable]\n        refine' preimageAction_coherent hπf (B.cons hδ) A N' _ _ _\n          (StructAction.allowable_exactlyApproximates _ _ _ _)\n        rw [hN]\n        exact hNc\n      trans N'\n      · rw [map_inv]\n        exact this\n      · rw [map_inv, Tree.inv_apply, ← smul_eq_iff_eq_inv_smul, ← hN]\n        rw [StructAction.hypothesisedAllowable]\n        refine' (ihAction_coherent hπf (B.cons hδ) A N' _ _\n          ((ihAction_lawful hπf _).comp _) _\n          (StructAction.allowable_exactlyApproximates _ _ _ _)).symm\n        refine' Relation.TransGen.tail' _\n          (Constrains.fuzz hδ hε hδε B _ _ (smul_mem_support hc _))\n        refine' Relation.reflTransGen_of_eq _\n        refine' Address.ext _ _ rfl _\n        change inr _ = inr _\n        simp only [← this, ne_eq, Tree.comp_bot, Tree.toBot_inv_smul, map_inv,\n          Tree.inv_apply]\n", "additional_info": "", "used_premises": [1, 402, 779, 781, 782, 61, 61, 67, 65, 483, 1014, 784, 61, 65, 65, 483, 1014, 792, 1014, 787], "def_path": "ConNF/FOA/Properties/Surjective.lean", "pos": [140, 231], "informalization": "The theorem `ConNF.StructApprox.completeLitterMap_surjective_extends` is a part of the proof of freedom of action in Constructive Ordinal Notation (ConNF). It states that for any `β`-structural approximation `π` that is free, any `β`-extended index `A`, and any litter `L`, if for every `β`-extended index `B` and every atom `a`, `a` is in the range of `ConNF.StructApprox.completeAtomMap π B`, and for every `β`-extended index `B` and every near-litter `N`, `N` is in the range of `ConNF.StructApprox.completeNearLitterMap π B`, then `L` is in the range of `ConNF.StructApprox.completeLitterMap π A`."}
{"full_name": "ConNF.StructApprox.atom_mem_range_of_mem_completeNearLitterMap", "url": "ConNF/FOA/Properties/Surjective.html#ConNF.StructApprox.atom_mem_range_of_mem_completeNearLitterMap", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.StructApprox.atom_mem_range_of_mem_completeNearLitterMap [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.FOAAssumptions] {β : ConNF.Λ} [ConNF.LeLevel🔗<|PREMISE|>🔗 ↑β] [ConNF.StructApprox.FreedomOfActionHypothesis🔗<|PREMISE|>🔗 β] {π : ConNF.StructApprox🔗<|PREMISE|>🔗 ↑β} (A : ConNF.ExtendedIndex🔗<|PREMISE|>🔗 ↑β) (a : ConNF.Atom) {N : ConNF.NearLitter} (h : a ∈ ConNF.StructApprox.completeNearLitterMap🔗<|PREMISE|>🔗 π A N) :a ∈ Set.range🔗<|PREMISE|>🔗 (ConNF.StructApprox.completeAtomMap🔗<|PREMISE|>🔗 π A)", "code": "theorem atom_mem_range_of_mem_completeNearLitterMap (A : ExtendedIndex β) (a : Atom)\n    {N : NearLitter} (h : a ∈ π.completeNearLitterMap A N) : a ∈ range (π.completeAtomMap A) := by\n  rw [← SetLike.mem_coe] at h\n  rw [completeNearLitterMap_eq'] at h\n  obtain ⟨h₁, h₂⟩ | ⟨h₁, h₂⟩ := h\n  · rw [completeNearLitterMap_toNearLitter_eq] at h₁\n    obtain h₁ | h₁ := h₁\n    · exact completeAtomMap_surjective_extends A a ⟨_, h₁.1.symm⟩\n    · obtain ⟨b, h₁, rfl⟩ := h₁\n      refine' ⟨b, _⟩\n      exact completeAtomMap_eq_of_mem_domain h₁.2\n  · obtain ⟨b, _, rfl⟩ := h₁\n    exact ⟨b, rfl⟩\n", "additional_info": "", "used_premises": [1, 402, 779, 781, 61, 792, 1014, 784], "def_path": "ConNF/FOA/Properties/Surjective.lean", "pos": [232, 245], "informalization": "In the context of Constructive Ordinal Notation (ConNF), the theorem `ConNF.StructApprox.atom_mem_range_of_mem_completeNearLitterMap` states that if an atom `a` belongs to the range of the function `ConNF.StructApprox.completeNearLitterMap`, then `a` also belongs to the range of the function `ConNF.StructApprox.completeAtomMap`."}
{"full_name": "ConNF.StructApprox.completeNearLitterMap_coe", "url": "ConNF/FOA/Properties/Surjective.html#ConNF.StructApprox.completeNearLitterMap_coe", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.StructApprox.completeNearLitterMap_coe [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.FOAAssumptions] {β : ConNF.Λ} [ConNF.LeLevel🔗<|PREMISE|>🔗 ↑β] [ConNF.StructApprox.FreedomOfActionHypothesis🔗<|PREMISE|>🔗 β] {π : ConNF.StructApprox🔗<|PREMISE|>🔗 ↑β} (hπf : ConNF.StructApprox.Free🔗<|PREMISE|>🔗 π) (A : ConNF.ExtendedIndex🔗<|PREMISE|>🔗 ↑β) (N : ConNF.NearLitter) :↑(ConNF.StructApprox.completeNearLitterMap🔗<|PREMISE|>🔗 π A N) = ConNF.StructApprox.completeAtomMap🔗<|PREMISE|>🔗 π A '' ↑N", "code": "theorem completeNearLitterMap_coe (hπf : π.Free) (A : ExtendedIndex β) (N : NearLitter) :\n    (π.completeNearLitterMap A N : Set Atom) = π.completeAtomMap A '' N := by\n  ext a : 1\n  constructor\n  · intro h\n    obtain ⟨b, rfl⟩ := atom_mem_range_of_mem_completeNearLitterMap A a h\n    rw [SetLike.mem_coe, completeAtomMap_mem_completeNearLitterMap hπf] at h\n    exact ⟨b, h, rfl⟩\n  · rintro ⟨b, h, rfl⟩\n    rw [SetLike.mem_coe, completeAtomMap_mem_completeNearLitterMap hπf]\n    exact h\n", "additional_info": "", "used_premises": [1, 402, 779, 781, 782, 61, 792, 784], "def_path": "ConNF/FOA/Properties/Surjective.lean", "pos": [246, 257], "informalization": "`ConNF.StructApprox.completeNearLitterMap_coe` is a theorem in the context of Constructive Ordinal Notation (ConNF). It states that for any `β`-structural approximation `π` that is free, any `β`-extended index `A`, and any near-litter `N`, the image of `N` under the function `ConNF.StructApprox.completeNearLitterMap π A` is equal to the image of `N` under the function `ConNF.StructApprox.completeAtomMap π A`."}
{"full_name": "ConNF.StructApprox.preimage_symmDiff", "url": "ConNF/FOA/Properties/Surjective.html#ConNF.StructApprox.preimage_symmDiff", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.StructApprox.preimage_symmDiff {α : Type u_1} {β : Type u_2} {s : Set🔗<|PREMISE|>🔗 β} {t : Set🔗<|PREMISE|>🔗 β} {f : α → β} :f ⁻¹' symmDiff🔗<|PREMISE|>🔗 s t = symmDiff🔗<|PREMISE|>🔗 (f ⁻¹' s) (f ⁻¹' t)", "code": "theorem preimage_symmDiff {α β : Type _} {s t : Set β} {f : α → β} :\n    f ⁻¹' s ∆ t = (f ⁻¹' s) ∆ (f ⁻¹' t) :=\n  rfl\n", "additional_info": "", "used_premises": [69, 69, 62, 62], "def_path": "ConNF/FOA/Properties/Surjective.lean", "pos": [259, 262], "informalization": "The preimage of the symmetric difference of two sets under a function is equal to the symmetric difference of the preimages of the two sets."}
{"full_name": "ConNF.StructApprox.completeNearLitterMap_surjective_extends", "url": "ConNF/FOA/Properties/Surjective.html#ConNF.StructApprox.completeNearLitterMap_surjective_extends", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.StructApprox.completeNearLitterMap_surjective_extends [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.FOAAssumptions] {β : ConNF.Λ} [ConNF.LeLevel🔗<|PREMISE|>🔗 ↑β] [ConNF.StructApprox.FreedomOfActionHypothesis🔗<|PREMISE|>🔗 β] {π : ConNF.StructApprox🔗<|PREMISE|>🔗 ↑β} (hπf : ConNF.StructApprox.Free🔗<|PREMISE|>🔗 π) (A : ConNF.ExtendedIndex🔗<|PREMISE|>🔗 ↑β) (N : ConNF.NearLitter) (hN : N.fst ∈ Set.range🔗<|PREMISE|>🔗 (ConNF.StructApprox.completeLitterMap🔗<|PREMISE|>🔗 π A)) (ha : symmDiff🔗<|PREMISE|>🔗 (ConNF.litterSet🔗<|PREMISE|>🔗 N.fst) ↑N ⊆ Set.range🔗<|PREMISE|>🔗 (ConNF.StructApprox.completeAtomMap🔗<|PREMISE|>🔗 π A)) :N ∈ Set.range🔗<|PREMISE|>🔗 (ConNF.StructApprox.completeNearLitterMap🔗<|PREMISE|>🔗 π A)", "code": "theorem completeNearLitterMap_surjective_extends (hπf : π.Free) (A : ExtendedIndex β)\n    (N : NearLitter) (hN : N.1 ∈ range (π.completeLitterMap A))\n    (ha : litterSet N.1 ∆ N ⊆ range (π.completeAtomMap A)) :\n    N ∈ range (π.completeNearLitterMap A) := by\n  obtain ⟨L, hN⟩ := hN\n  refine' ⟨⟨L, π.completeAtomMap A ⁻¹' N, _⟩, _⟩\n  · suffices Small ((π.completeAtomMap A '' L.toNearLitter) ∆ N) by\n      have := Small.preimage (completeAtomMap_injective hπf A) this\n      rw [preimage_symmDiff, preimage_image_eq _ (completeAtomMap_injective hπf A)] at this\n      exact this\n    rw [← completeNearLitterMap_coe hπf]\n    refine' IsNearLitter.near _ N.2.2\n    simp only [NearLitter.isNearLitter, completeNearLitterMap_fst_eq]\n    exact hN\n  · refine' SetLike.coe_injective _\n    rw [completeNearLitterMap_coe hπf]\n    simp only [NearLitter.coe_mk, Subtype.coe_mk, Litter.coe_toNearLitter]\n    rw [image_preimage_eq_of_subset _]\n    intro a ha'\n    by_cases h : a.1 = N.1\n    · rw [← hN] at h\n      exact completeAtomMap_surjective_extends A a ⟨_, h.symm⟩\n    · exact ha (Or.inr ⟨ha', h⟩)\n", "additional_info": "", "used_premises": [1, 402, 779, 781, 782, 61, 1014, 787, 62, 467, 1014, 784, 1014, 792], "def_path": "ConNF/FOA/Properties/Surjective.lean", "pos": [263, 286], "informalization": "The theorem `ConNF.StructApprox.completeNearLitterMap_surjective_extends` is a part of the proof of freedom of action in Constructive Ordinal Notation (ConNF). It states that for any free `β`-structural approximation `π`, any `β`-extended index `A`, and any near-litter `N` such that the first projection of `N` is in the range of `ConNF.StructApprox.completeLitterMap π A` and the symmetric difference of the litter set of `N` and `N` itself is a subset of the range of `ConNF.StructApprox.completeAtomMap π A`, then `N` is in the range of `ConNF.StructApprox.completeNearLitterMap π A`."}
{"full_name": "ConNF.StructApprox.completeMap_surjective_extends", "url": "ConNF/FOA/Properties/Surjective.html#ConNF.StructApprox.completeMap_surjective_extends", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.StructApprox.completeMap_surjective_extends [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.FOAAssumptions] {β : ConNF.Λ} [ConNF.LeLevel🔗<|PREMISE|>🔗 ↑β] [ConNF.StructApprox.FreedomOfActionHypothesis🔗<|PREMISE|>🔗 β] {π : ConNF.StructApprox🔗<|PREMISE|>🔗 ↑β} (hπf : ConNF.StructApprox.Free🔗<|PREMISE|>🔗 π) (c : ConNF.Address🔗<|PREMISE|>🔗 ↑β) (hc : ∀ d < c, ConNF.StructApprox.CompleteMapSurjectiveAt🔗<|PREMISE|>🔗 π d) :ConNF.StructApprox.CompleteMapSurjectiveAt🔗<|PREMISE|>🔗 π c", "code": "theorem completeMap_surjective_extends (hπf : π.Free) (c : Address β)\n    (hc : ∀ d : Address β, d < c → π.CompleteMapSurjectiveAt d) :\n    π.CompleteMapSurjectiveAt c := by\n  obtain ⟨A, a | N⟩ := c\n  · refine' completeAtomMap_surjective_extends A a _\n    obtain ⟨N, hN⟩ := hc ⟨A, inr a.1.toNearLitter⟩ (Relation.TransGen.single <| Constrains.atom A a)\n    refine' ⟨N.1, _⟩\n    apply_fun Sigma.fst at hN\n    simp only [Litter.toNearLitter_fst, completeNearLitterMap_fst_eq'] at hN\n    exact hN\n  · refine' completeNearLitterMap_surjective_extends hπf A N _ _\n    · refine' completeLitterMap_surjective_extends hπf A N.1 _ _\n      · intro B a h\n        exact hc ⟨B, inl a⟩ (lt_nearLitter <| Relation.TransGen.single h)\n      · intro B N h\n        exact hc ⟨B, inr N⟩ (lt_nearLitter <| Relation.TransGen.single h)\n    · intro a h\n      exact hc ⟨A, inl a⟩ (Relation.TransGen.single <| Constrains.symmDiff A N a h)\n", "additional_info": "", "used_premises": [1, 402, 779, 781, 782, 60, 1032, 1032], "def_path": "ConNF/FOA/Properties/Surjective.lean", "pos": [295, 313], "informalization": "The theorem `ConNF.StructApprox.completeMap_surjective_extends` is a part of the proof of the Freedom of Action in Constructive Ordinal Notation (ConNF). It asserts that for any `β`-structural approximation `π` which is free, if `π` is such that for all addresses `d` less than a given address `c`, the condition `ConNF.StructApprox.CompleteMapSurjectiveAt π d` holds, then `ConNF.StructApprox.CompleteMapSurjectiveAt π c` also holds. This theorem is used to prove that any free approximation `π` exactly approximates some allowable permutation."}
{"full_name": "ConNF.StructApprox.CompleteMapSurjectiveAt", "url": "ConNF/FOA/Properties/Surjective.html#ConNF.StructApprox.CompleteMapSurjectiveAt", "code_src": "con-nf", "ptype": "def", "header": "def ConNF.StructApprox.CompleteMapSurjectiveAt [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.FOAAssumptions] {β : ConNF.Λ} [ConNF.LeLevel🔗<|PREMISE|>🔗 ↑β] [ConNF.StructApprox.FreedomOfActionHypothesis🔗<|PREMISE|>🔗 β] (π : ConNF.StructApprox🔗<|PREMISE|>🔗 ↑β) :ConNF.Address🔗<|PREMISE|>🔗 ↑β → Prop", "code": "def CompleteMapSurjectiveAt : Address β → Prop\n  | ⟨A, inl a⟩ => a ∈ range (π.completeAtomMap A)\n  | ⟨A, inr N⟩ => N ∈ range (π.completeNearLitterMap A)\n", "additional_info": "Equations\n* One or more equations did not get rendered due to their size.\n\n", "used_premises": [1, 402, 779, 781, 60], "def_path": "ConNF/FOA/Properties/Surjective.lean", "pos": [289, 292], "informalization": "Function `ConNF.StructApprox.CompleteMapSurjectiveAt` defines a property of `β`-structural approximations in the context of Constructive Ordinal Notation (ConNF). Given a `β`-structural approximation `π` and an address `⟨A, inl a⟩` or `⟨A, inr N⟩`, the property `CompleteMapSurjectiveAt π ⟨A, inl a⟩` holds if `a` is in the range of `π.completeAtomMap A`, and `CompleteMapSurjectiveAt π ⟨A, inr N⟩` holds if `N` is in the range of `π.completeNearLitterMap A`."}
{"full_name": "ConNF.StructApprox.completeMapSurjectiveAtAll", "url": "ConNF/FOA/Properties/Surjective.html#ConNF.StructApprox.completeMapSurjectiveAtAll", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.StructApprox.completeMapSurjectiveAtAll [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.FOAAssumptions] {β : ConNF.Λ} [ConNF.LeLevel🔗<|PREMISE|>🔗 ↑β] [ConNF.StructApprox.FreedomOfActionHypothesis🔗<|PREMISE|>🔗 β] {π : ConNF.StructApprox🔗<|PREMISE|>🔗 ↑β} (hπf : ConNF.StructApprox.Free🔗<|PREMISE|>🔗 π) (c : ConNF.Address🔗<|PREMISE|>🔗 ↑β) :ConNF.StructApprox.CompleteMapSurjectiveAt🔗<|PREMISE|>🔗 π c", "code": "theorem completeMapSurjectiveAtAll (hπf : π.Free) (c : Address β) :\n    π.CompleteMapSurjectiveAt c :=\n  WellFoundedRelation.wf.induction c (completeMap_surjective_extends hπf)\n", "additional_info": "", "used_premises": [1, 402, 779, 781, 782, 60, 1032], "def_path": "ConNF/FOA/Properties/Surjective.lean", "pos": [314, 317], "informalization": "In the context of Constructive Ordinal Notation (ConNF), the theorem `ConNF.StructApprox.completeMapSurjectiveAtAll` states that for any `β`-structural approximation `π` that is free (i.e., every near-litter approximation in `π` is free with respect to the corresponding `β`-extended index), and any address `c` in the base type (the atom or near-litter) together with the path detailing how we descend from type `β` to type `⊥` by looking at elements of elements and so on in the model, the property `CompleteMapSurjectiveAt π c` holds, meaning that the address `c` is in the range of `π`'s complete map."}
{"full_name": "ConNF.StructApprox.completeAtomMap_surjective", "url": "ConNF/FOA/Properties/Surjective.html#ConNF.StructApprox.completeAtomMap_surjective", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.StructApprox.completeAtomMap_surjective [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.FOAAssumptions] {β : ConNF.Λ} [ConNF.LeLevel🔗<|PREMISE|>🔗 ↑β] [ConNF.StructApprox.FreedomOfActionHypothesis🔗<|PREMISE|>🔗 β] {π : ConNF.StructApprox🔗<|PREMISE|>🔗 ↑β} (hπf : ConNF.StructApprox.Free🔗<|PREMISE|>🔗 π) (A : ConNF.ExtendedIndex🔗<|PREMISE|>🔗 ↑β) :Function.Surjective🔗<|PREMISE|>🔗 (ConNF.StructApprox.completeAtomMap🔗<|PREMISE|>🔗 π A)", "code": "theorem completeAtomMap_surjective (hπf : π.Free) (A : ExtendedIndex β) :\n    Surjective (π.completeAtomMap A) := fun a => completeMapSurjectiveAtAll hπf ⟨A, inl a⟩\n", "additional_info": "", "used_premises": [1, 402, 779, 781, 782, 61, 1035, 784], "def_path": "ConNF/FOA/Properties/Surjective.lean", "pos": [318, 320], "informalization": "In the context of Constructive Ordinal Notation (ConNF), the theorem `ConNF.StructApprox.completeAtomMap_surjective` asserts that for any free `β`-structural approximation `π` and any `β`-extended index `A`, the function `ConNF.StructApprox.completeAtomMap π A`, which maps each `β`-extended index to an atom, is surjective. This means that every atom has at least one corresponding `β`-extended index through this function."}
{"full_name": "Function.Surjective", "url": "Mathlib/Init/Function.html#Function.Surjective", "code_src": "mathlib4", "ptype": "def", "header": "def Function.Surjective {α : Sort u₁} {β : Sort u₂} (f : α → β) :Prop", "code": "def Surjective (f : α → β) : Prop :=\n  ∀ b, ∃ a, f a = b\n", "additional_info": "A function `f : α → β` is called surjective if every `b : β` is equal to `f a`\nfor some `a : α`.\nEquations\n* 🗟Function.Surjective🗟🔗../.././Mathlib/Init/Function.html#Function.Surjective🔗  f 🗟=🗟🔗../.././Init/Prelude.html#Eq🔗  ∀ (b : β), ∃ (a : α), f a 🗟=🗟🔗../.././Init/Prelude.html#Eq🔗  b\n\n", "used_premises": [], "def_path": "Mathlib/Init/Function.lean", "pos": [125, 127], "informalization": "Function `Function.Surjective` is a predicate that checks if a given function `f` from `α` to `β` is surjective, meaning every element in `β` has at least one corresponding element in `α` through `f`."}
{"full_name": "ConNF.StructApprox.completeNearLitterMap_surjective", "url": "ConNF/FOA/Properties/Surjective.html#ConNF.StructApprox.completeNearLitterMap_surjective", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.StructApprox.completeNearLitterMap_surjective [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.FOAAssumptions] {β : ConNF.Λ} [ConNF.LeLevel🔗<|PREMISE|>🔗 ↑β] [ConNF.StructApprox.FreedomOfActionHypothesis🔗<|PREMISE|>🔗 β] {π : ConNF.StructApprox🔗<|PREMISE|>🔗 ↑β} (hπf : ConNF.StructApprox.Free🔗<|PREMISE|>🔗 π) (A : ConNF.ExtendedIndex🔗<|PREMISE|>🔗 ↑β) :Function.Surjective🔗<|PREMISE|>🔗 (ConNF.StructApprox.completeNearLitterMap🔗<|PREMISE|>🔗 π A)", "code": "theorem completeNearLitterMap_surjective (hπf : π.Free) (A : ExtendedIndex β) :\n    Surjective (π.completeNearLitterMap A) := fun N => completeMapSurjectiveAtAll hπf ⟨A, inr N⟩\n", "additional_info": "", "used_premises": [1, 402, 779, 781, 782, 61, 1035, 792], "def_path": "ConNF/FOA/Properties/Surjective.lean", "pos": [321, 323], "informalization": "The theorem `ConNF.StructApprox.completeNearLitterMap_surjective` is a part of the ConNF project and represents a key step in the proof of freedom of action within the Constructive Ordinal Notation (ConNF) system. It establishes that the function `ConNF.StructApprox.completeNearLitterMap` is surjective for a given `β`-structural approximation `π` that is free, meaning it satisfies the freedom of action hypothesis. The `β`-structural approximation `π` maps `β`-extended indices to near-litter approximations, and this surjectivity ensures that for every near-litter approximation, there exists a `β`-extended index that maps to it under the `π` function. This theorem is crucial for demonstrating the power of the ConNF system to constructively build up the natural numbers and other mathematical objects using a finite set of type indices and operations defined within the system."}
{"full_name": "ConNF.StructApprox.completeLitterMap_surjective", "url": "ConNF/FOA/Properties/Surjective.html#ConNF.StructApprox.completeLitterMap_surjective", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.StructApprox.completeLitterMap_surjective [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.FOAAssumptions] {β : ConNF.Λ} [ConNF.LeLevel🔗<|PREMISE|>🔗 ↑β] [ConNF.StructApprox.FreedomOfActionHypothesis🔗<|PREMISE|>🔗 β] {π : ConNF.StructApprox🔗<|PREMISE|>🔗 ↑β} (hπf : ConNF.StructApprox.Free🔗<|PREMISE|>🔗 π) (A : ConNF.ExtendedIndex🔗<|PREMISE|>🔗 ↑β) :Function.Surjective🔗<|PREMISE|>🔗 (ConNF.StructApprox.completeLitterMap🔗<|PREMISE|>🔗 π A)", "code": "theorem completeLitterMap_surjective (hπf : π.Free) (A : ExtendedIndex β) :\n    Surjective (π.completeLitterMap A) := by\n  intro L\n  obtain ⟨N, hN⟩ := completeNearLitterMap_surjective hπf A L.toNearLitter\n  refine' ⟨N.1, _⟩\n  apply_fun Sigma.fst at hN\n  simp only [completeNearLitterMap_fst_eq', Litter.toNearLitter_fst] at hN\n  exact hN\n", "additional_info": "", "used_premises": [1, 402, 779, 781, 782, 61, 1035, 787], "def_path": "ConNF/FOA/Properties/Surjective.lean", "pos": [324, 332], "informalization": "The theorem `ConNF.StructApprox.completeLitterMap_surjective` proves that the function `ConNF.StructApprox.completeLitterMap` is surjective. This function is part of the construction of the natural numbers in the context of Constructive Ordinal Notation (ConNF), and it takes a `β`-structural approximation `π`, a `β`-extended index `A`, and a litter `L`, and returns a litter. The theorem states that for any `β`-structural approximation `π` that is free, and any `β`-extended index `A`, the function `ConNF.StructApprox.completeLitterMap π A` is surjective."}
{"full_name": "ConNF.StructApprox.transConstrained_symm", "url": "ConNF/FOA/Properties/ConstrainedAction.html#ConNF.StructApprox.transConstrained_symm", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.StructApprox.transConstrained_symm [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.FOAAssumptions] {β : ConNF.Λ} (c : ConNF.Address🔗<|PREMISE|>🔗 ↑β) (d : ConNF.Address🔗<|PREMISE|>🔗 ↑β) :ConNF.StructApprox.transConstrained🔗<|PREMISE|>🔗 c d = ConNF.StructApprox.transConstrained🔗<|PREMISE|>🔗 d c", "code": "theorem transConstrained_symm (c d : Address β) :\n    transConstrained c d = transConstrained d c :=\n  union_comm _ _\n", "additional_info": "", "used_premises": [1, 60, 60, 995, 995], "def_path": "ConNF/FOA/Properties/ConstrainedAction.lean", "pos": [21, 24], "informalization": "The theorem `ConNF.StructApprox.transConstrained_symm` states that the function `ConNF.StructApprox.transConstrained` is symmetric, meaning that for any two addresses `c` and `d` in the context of Constructive Ordinal Notation (ConNF), the set of addresses that are either strictly less than `c` or strictly less than `d` is the same as the set of addresses that are either strictly less than `d` or strictly less than `c`."}
{"full_name": "ConNF.StructApprox.reflTransConstrained_symm", "url": "ConNF/FOA/Properties/ConstrainedAction.html#ConNF.StructApprox.reflTransConstrained_symm", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.StructApprox.reflTransConstrained_symm [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.FOAAssumptions] {β : ConNF.Λ} (c : ConNF.Address🔗<|PREMISE|>🔗 ↑β) (d : ConNF.Address🔗<|PREMISE|>🔗 ↑β) :ConNF.StructApprox.reflTransConstrained🔗<|PREMISE|>🔗 c d = ConNF.StructApprox.reflTransConstrained🔗<|PREMISE|>🔗 d c", "code": "theorem reflTransConstrained_symm (c d : Address β) :\n    reflTransConstrained c d = reflTransConstrained d c :=\n  union_comm _ _\n", "additional_info": "", "used_premises": [1, 60, 60, 967, 967], "def_path": "ConNF/FOA/Properties/ConstrainedAction.lean", "pos": [25, 28], "informalization": "The theorem `ConNF.StructApprox.reflTransConstrained_symm` states that the set of addresses that are either less than or equal to the address `c` or less than or equal to the address `d`, within the context of Constructive Ordinal Notation (ConNF), is symmetric with respect to `c` and `d`."}
{"full_name": "ConNF.StructApprox.transConstrained_self", "url": "ConNF/FOA/Properties/ConstrainedAction.html#ConNF.StructApprox.transConstrained_self", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.StructApprox.transConstrained_self [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.FOAAssumptions] {β : ConNF.Λ} (c : ConNF.Address🔗<|PREMISE|>🔗 ↑β) :ConNF.StructApprox.transConstrained🔗<|PREMISE|>🔗 c c = {e : ConNF.Address🔗<|PREMISE|>🔗 ↑β | e < c}", "code": "theorem transConstrained_self (c : Address β) : transConstrained c c = {e | e < c} :=\n  union_self _\n", "additional_info": "", "used_premises": [1, 60, 995, 60], "def_path": "ConNF/FOA/Properties/ConstrainedAction.lean", "pos": [30, 32], "informalization": "The theorem `ConNF.StructApprox.transConstrained_self` states that for any address `c` in the context of Constructive Ordinal Notation (ConNF), the set of addresses that are either strictly less than `c` or strictly less than `c` itself is exactly the set of addresses that are strictly less than `c`."}
{"full_name": "ConNF.StructApprox.reflTransConstrained_self", "url": "ConNF/FOA/Properties/ConstrainedAction.html#ConNF.StructApprox.reflTransConstrained_self", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.StructApprox.reflTransConstrained_self [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.FOAAssumptions] {β : ConNF.Λ} (c : ConNF.Address🔗<|PREMISE|>🔗 ↑β) :ConNF.StructApprox.reflTransConstrained🔗<|PREMISE|>🔗 c c = {e : ConNF.Address🔗<|PREMISE|>🔗 ↑β | e ≤ c}", "code": "theorem reflTransConstrained_self (c : Address β) :\n    reflTransConstrained c c = {e | e ≤ c} :=\n  union_self _\n", "additional_info": "", "used_premises": [1, 60, 967, 60], "def_path": "ConNF/FOA/Properties/ConstrainedAction.lean", "pos": [34, 37], "informalization": "Function `ConNF.StructApprox.reflTransConstrained` defines a set of addresses that are either less than or equal to the address `c` or less than or equal to the address `d`, within the context of Constructive Ordinal Notation (ConNF). The theorem `ConNF.StructApprox.reflTransConstrained_self` states that for any address `c`, the set of addresses `ConNF.StructApprox.reflTransConstrained c c` is equal to the set of addresses that are less than or equal to `c`."}
{"full_name": "ConNF.StructApprox.mem_reflTransConstrained_of_mem_transConstrained", "url": "ConNF/FOA/Properties/ConstrainedAction.html#ConNF.StructApprox.mem_reflTransConstrained_of_mem_transConstrained", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.StructApprox.mem_reflTransConstrained_of_mem_transConstrained [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.FOAAssumptions] {β : ConNF.Λ} {c : ConNF.Address🔗<|PREMISE|>🔗 ↑β} {d : ConNF.Address🔗<|PREMISE|>🔗 ↑β} {e : ConNF.Address🔗<|PREMISE|>🔗 ↑β} (he : e ∈ ConNF.StructApprox.transConstrained🔗<|PREMISE|>🔗 c d) :e ∈ ConNF.StructApprox.reflTransConstrained🔗<|PREMISE|>🔗 c d", "code": "theorem mem_reflTransConstrained_of_mem_transConstrained {c d e : Address β}\n    (he : e ∈ transConstrained c d) : e ∈ reflTransConstrained c d := by\n  obtain he | he := he\n  exact Or.inl he.to_reflTransGen\n  exact Or.inr he.to_reflTransGen\n", "additional_info": "", "used_premises": [1, 60, 60, 60, 995, 967], "def_path": "ConNF/FOA/Properties/ConstrainedAction.lean", "pos": [38, 43], "informalization": "In the context of Constructive Ordinal Notation (ConNF), given three addresses `c`, `d`, and `e`, if `e` is in the transitive closure of `c` and `d`, then `e` is also in the reflexive-transitive closure of `c` and `d`."}
{"full_name": "ConNF.StructApprox.transConstrained_trans", "url": "ConNF/FOA/Properties/ConstrainedAction.html#ConNF.StructApprox.transConstrained_trans", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.StructApprox.transConstrained_trans [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.FOAAssumptions] {β : ConNF.Λ} {c : ConNF.Address🔗<|PREMISE|>🔗 ↑β} {d : ConNF.Address🔗<|PREMISE|>🔗 ↑β} {e : ConNF.Address🔗<|PREMISE|>🔗 ↑β} {f : ConNF.Address🔗<|PREMISE|>🔗 ↑β} (he : e ∈ ConNF.StructApprox.transConstrained🔗<|PREMISE|>🔗 c d) (hf : f ≤ e) :f ∈ ConNF.StructApprox.transConstrained🔗<|PREMISE|>🔗 c d", "code": "theorem transConstrained_trans {c d e f : Address β} (he : e ∈ transConstrained c d)\n    (hf : f ≤ e) : f ∈ transConstrained c d := by\n  obtain he | he := he\n  exact Or.inl (Relation.TransGen.trans_right hf he)\n  exact Or.inr (Relation.TransGen.trans_right hf he)\n", "additional_info": "", "used_premises": [1, 60, 60, 60, 60, 995, 995], "def_path": "ConNF/FOA/Properties/ConstrainedAction.lean", "pos": [44, 49], "informalization": "Function `ConNF.StructApprox.transConstrained` takes two addresses `c` and `d` in the context of Constructive Ordinal Notation (ConNF) and returns a set of addresses that are either strictly less than `c` or strictly less than `d`. This set represents the transitive closure of the relation defined by `c` and `d`. The theorem `ConNF.StructApprox.transConstrained_trans` states that if `e` is in the transitive closure of `c` and `d`, and `f` is less than or equal to `e`, then `f` is also in the transitive closure of `c` and `d`."}
{"full_name": "ConNF.StructApprox.reflTransConstrained_trans", "url": "ConNF/FOA/Properties/ConstrainedAction.html#ConNF.StructApprox.reflTransConstrained_trans", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.StructApprox.reflTransConstrained_trans [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.FOAAssumptions] {β : ConNF.Λ} {c : ConNF.Address🔗<|PREMISE|>🔗 ↑β} {d : ConNF.Address🔗<|PREMISE|>🔗 ↑β} {e : ConNF.Address🔗<|PREMISE|>🔗 ↑β} {f : ConNF.Address🔗<|PREMISE|>🔗 ↑β} (he : e ∈ ConNF.StructApprox.reflTransConstrained🔗<|PREMISE|>🔗 c d) (hf : f ≤ e) :f ∈ ConNF.StructApprox.reflTransConstrained🔗<|PREMISE|>🔗 c d", "code": "theorem reflTransConstrained_trans {c d e f : Address β}\n    (he : e ∈ reflTransConstrained c d) (hf : f ≤ e) : f ∈ reflTransConstrained c d := by\n  obtain he | he := he\n  exact Or.inl (hf.trans he)\n  exact Or.inr (hf.trans he)\n", "additional_info": "", "used_premises": [1, 60, 60, 60, 60, 967, 967], "def_path": "ConNF/FOA/Properties/ConstrainedAction.lean", "pos": [50, 55], "informalization": "Given a chain of addresses `e` and `f` where `e` is in the refl-trans closure of `c` and `d`, and `f` is less than or equal to `e`, then `f` is also in the refl-trans closure of `c` and `d`. This is a property of transitive closures in the context of constructing ordinals using Constructive Ordinal Notation (ConNF)."}
{"full_name": "ConNF.StructApprox.transConstrained_of_reflTransConstrained_of_trans_constrains", "url": "ConNF/FOA/Properties/ConstrainedAction.html#ConNF.StructApprox.transConstrained_of_reflTransConstrained_of_trans_constrains", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.StructApprox.transConstrained_of_reflTransConstrained_of_trans_constrains [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.FOAAssumptions] {β : ConNF.Λ} {c : ConNF.Address🔗<|PREMISE|>🔗 ↑β} {d : ConNF.Address🔗<|PREMISE|>🔗 ↑β} {e : ConNF.Address🔗<|PREMISE|>🔗 ↑β} {f : ConNF.Address🔗<|PREMISE|>🔗 ↑β} (he : e ∈ ConNF.StructApprox.reflTransConstrained🔗<|PREMISE|>🔗 c d) (hf : f < e) :f ∈ ConNF.StructApprox.transConstrained🔗<|PREMISE|>🔗 c d", "code": "theorem transConstrained_of_reflTransConstrained_of_trans_constrains {c d e f : Address β}\n    (he : e ∈ reflTransConstrained c d) (hf : f < e) : f ∈ transConstrained c d := by\n  obtain he | he := he\n  exact Or.inl (hf.trans_left he)\n  exact Or.inr (hf.trans_left he)\n", "additional_info": "", "used_premises": [1, 60, 60, 60, 60, 967, 995], "def_path": "ConNF/FOA/Properties/ConstrainedAction.lean", "pos": [56, 61], "informalization": "The theorem `ConNF.StructApprox.transConstrained_of_reflTransConstrained_of_trans_constrains` is a mathematical statement about Constructive Ordinal Notation (ConNF), which is a system used for representing ordinals in a computer proof assistant. The theorem states that if an address `f` is strictly less than another address `e`, and `e` is in the reflexive-transitive closure of the addresses `c` and `d`, then `f` is in the transitive closure of `c` and `d`. This theorem is used to prove properties about the structure of ConNFAddresses and helps to establish the correctness and soundness of the ConNF system in representing ordinals."}
{"full_name": "ConNF.StructApprox.transConstrained_of_constrains", "url": "ConNF/FOA/Properties/ConstrainedAction.html#ConNF.StructApprox.transConstrained_of_constrains", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.StructApprox.transConstrained_of_constrains [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.FOAAssumptions] {β : ConNF.Λ} {c : ConNF.Address🔗<|PREMISE|>🔗 ↑β} {d : ConNF.Address🔗<|PREMISE|>🔗 ↑β} {e : ConNF.Address🔗<|PREMISE|>🔗 ↑β} {f : ConNF.Address🔗<|PREMISE|>🔗 ↑β} (he : e ∈ ConNF.StructApprox.transConstrained🔗<|PREMISE|>🔗 c d) (hf : f ≺ e) :f ∈ ConNF.StructApprox.transConstrained🔗<|PREMISE|>🔗 c d", "code": "theorem transConstrained_of_constrains {c d e f : Address β}\n    (he : e ∈ transConstrained c d) (hf : f ≺ e) : f ∈ transConstrained c d :=\n  transConstrained_trans he (Relation.ReflTransGen.single hf)\n", "additional_info": "", "used_premises": [1, 60, 60, 60, 60, 995, 995], "def_path": "ConNF/FOA/Properties/ConstrainedAction.lean", "pos": [62, 65], "informalization": "The theorem `ConNF.StructApprox.transConstrained_of_constrains` states that if `e` is in the transitive closure of `c` and `d`, and `f` is strictly less than `e`, then `f` is also in the transitive closure of `c` and `d`."}
{"full_name": "ConNF.StructApprox.reflTransConstrained_of_constrains", "url": "ConNF/FOA/Properties/ConstrainedAction.html#ConNF.StructApprox.reflTransConstrained_of_constrains", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.StructApprox.reflTransConstrained_of_constrains [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.FOAAssumptions] {β : ConNF.Λ} {c : ConNF.Address🔗<|PREMISE|>🔗 ↑β} {d : ConNF.Address🔗<|PREMISE|>🔗 ↑β} {e : ConNF.Address🔗<|PREMISE|>🔗 ↑β} {f : ConNF.Address🔗<|PREMISE|>🔗 ↑β} (he : e ∈ ConNF.StructApprox.reflTransConstrained🔗<|PREMISE|>🔗 c d) (hf : f ≺ e) :f ∈ ConNF.StructApprox.reflTransConstrained🔗<|PREMISE|>🔗 c d", "code": "theorem reflTransConstrained_of_constrains {c d e f : Address β}\n    (he : e ∈ reflTransConstrained c d) (hf : f ≺ e) : f ∈ reflTransConstrained c d :=\n  reflTransConstrained_trans he (Relation.ReflTransGen.single hf)\n", "additional_info": "", "used_premises": [1, 60, 60, 60, 60, 967, 967], "def_path": "ConNF/FOA/Properties/ConstrainedAction.lean", "pos": [66, 69], "informalization": "The theorem `ConNF.StructApprox.reflTransConstrained_of_constrains` states that if `e` is in the set of addresses that are either less than or equal to `c` or less than or equal to `d`, and `f` is strictly less than `e`, then `f` is also in the set of addresses that are either less than or equal to `c` or less than or equal to `d`."}
{"full_name": "ConNF.StructApprox.transConstrained_of_reflTransConstrained_of_constrains", "url": "ConNF/FOA/Properties/ConstrainedAction.html#ConNF.StructApprox.transConstrained_of_reflTransConstrained_of_constrains", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.StructApprox.transConstrained_of_reflTransConstrained_of_constrains [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.FOAAssumptions] {β : ConNF.Λ} {c : ConNF.Address🔗<|PREMISE|>🔗 ↑β} {d : ConNF.Address🔗<|PREMISE|>🔗 ↑β} {e : ConNF.Address🔗<|PREMISE|>🔗 ↑β} {f : ConNF.Address🔗<|PREMISE|>🔗 ↑β} (he : e ∈ ConNF.StructApprox.reflTransConstrained🔗<|PREMISE|>🔗 c d) (hf : f ≺ e) :f ∈ ConNF.StructApprox.transConstrained🔗<|PREMISE|>🔗 c d", "code": "theorem transConstrained_of_reflTransConstrained_of_constrains {c d e f : Address β}\n    (he : e ∈ reflTransConstrained c d) (hf : f ≺ e) : f ∈ transConstrained c d :=\n  transConstrained_of_reflTransConstrained_of_trans_constrains he (Relation.TransGen.single hf)\n", "additional_info": "", "used_premises": [1, 60, 60, 60, 60, 967, 995], "def_path": "ConNF/FOA/Properties/ConstrainedAction.lean", "pos": [70, 73], "informalization": "The theorem `ConNF.StructApprox.transConstrained_of_reflTransConstrained_of_constrains` states that if `e` is in the reflexive-transitive closure of `c` and `d`, and `f` is strictly less than `e`, then `f` is in the transitive closure of `c` and `d`."}
{"full_name": "ConNF.StructApprox.fst_transConstrained", "url": "ConNF/FOA/Properties/ConstrainedAction.html#ConNF.StructApprox.fst_transConstrained", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.StructApprox.fst_transConstrained [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.FOAAssumptions] {β : ConNF.Λ} {c : ConNF.Address🔗<|PREMISE|>🔗 ↑β} {d : ConNF.Address🔗<|PREMISE|>🔗 ↑β} {A : ConNF.ExtendedIndex🔗<|PREMISE|>🔗 ↑β} {a : ConNF.Atom} (hac : { path := A, value := Sum.inl🔗<|PREMISE|>🔗 a } ∈ ConNF.StructApprox.reflTransConstrained🔗<|PREMISE|>🔗 c d) :{ path := A, value := Sum.inr🔗<|PREMISE|>🔗 (ConNF.Litter.toNearLitter🔗<|PREMISE|>🔗 a.1) } ∈ ConNF.StructApprox.transConstrained🔗<|PREMISE|>🔗 c d", "code": "theorem fst_transConstrained {c d : Address β} {A : ExtendedIndex β} {a : Atom}\n    (hac : ⟨A, inl a⟩ ∈ reflTransConstrained c d) :\n    ⟨A, inr a.fst.toNearLitter⟩ ∈ transConstrained c d :=\n  transConstrained_of_reflTransConstrained_of_constrains hac (Constrains.atom A a)\n", "additional_info": "", "used_premises": [1, 60, 60, 61, 67, 967, 65, 483, 995], "def_path": "ConNF/FOA/Properties/ConstrainedAction.lean", "pos": [74, 78], "informalization": "The theorem `ConNF.StructApprox.fst_transConstrained` is a part of the Constructive Ordinal Notation (ConNF) project in Lean 4. It states that if an address `A` with a left injection of an atom `a` is in the reflexive-transitive closure of two addresses `c` and `d`, then the same address `A` with a right injection of the near-litter corresponding to `a` is in the transitive closure of `c` and `d`."}
{"full_name": "ConNF.StructApprox.fst_mem_trans_constrained'", "url": "ConNF/FOA/Properties/ConstrainedAction.html#ConNF.StructApprox.fst_mem_trans_constrained'", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.StructApprox.fst_mem_trans_constrained' [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.FOAAssumptions] {β : ConNF.Λ} {c : ConNF.Address🔗<|PREMISE|>🔗 ↑β} {d : ConNF.Address🔗<|PREMISE|>🔗 ↑β} {A : ConNF.ExtendedIndex🔗<|PREMISE|>🔗 ↑β} {a : ConNF.Atom} (h : { path := A, value := Sum.inl🔗<|PREMISE|>🔗 a } ∈ ConNF.StructApprox.transConstrained🔗<|PREMISE|>🔗 c d) :{ path := A, value := Sum.inr🔗<|PREMISE|>🔗 (ConNF.Litter.toNearLitter🔗<|PREMISE|>🔗 a.1) } ∈ ConNF.StructApprox.transConstrained🔗<|PREMISE|>🔗 c d", "code": "theorem fst_mem_trans_constrained' {c d : Address β} {A : ExtendedIndex β} {a : Atom}\n    (h : ⟨A, inl a⟩ ∈ transConstrained c d) :\n    ⟨A, inr a.fst.toNearLitter⟩ ∈ transConstrained c d :=\n  transConstrained_of_constrains h (Constrains.atom A a)\n", "additional_info": "", "used_premises": [1, 60, 60, 61, 67, 995, 65, 483, 995], "def_path": "ConNF/FOA/Properties/ConstrainedAction.lean", "pos": [79, 83], "informalization": "In the context of Constructive Ordinal Notation (ConNF), the theorem `ConNF.StructApprox.fst_mem_trans_constrained'` asserts that if an address in the transitive closure of two addresses `c` and `d` is of the form `{ path := A, value := Sum.inl a }`, where `A` is an extended index and `a` is an atom, then the corresponding near-litter address `{ path := A, value := Sum.inr (ConNF.Litter.toNearLitter a.1) }` is also in the transitive closure of `c` and `d`."}
{"full_name": "ConNF.StructApprox.fst_mem_transConstrained", "url": "ConNF/FOA/Properties/ConstrainedAction.html#ConNF.StructApprox.fst_mem_transConstrained", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.StructApprox.fst_mem_transConstrained [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.FOAAssumptions] {β : ConNF.Λ} {c : ConNF.Address🔗<|PREMISE|>🔗 ↑β} {d : ConNF.Address🔗<|PREMISE|>🔗 ↑β} {A : ConNF.ExtendedIndex🔗<|PREMISE|>🔗 ↑β} {N : ConNF.NearLitter} (hN : { path := A, value := Sum.inr🔗<|PREMISE|>🔗 N } ∈ ConNF.StructApprox.transConstrained🔗<|PREMISE|>🔗 c d) :{ path := A, value := Sum.inr🔗<|PREMISE|>🔗 (ConNF.Litter.toNearLitter🔗<|PREMISE|>🔗 N.fst) } ∈ ConNF.StructApprox.transConstrained🔗<|PREMISE|>🔗 c d", "code": "theorem fst_mem_transConstrained {c d : Address β} {A : ExtendedIndex β} {N : NearLitter}\n    (hN : ⟨A, inr N⟩ ∈ transConstrained c d) :\n    ⟨A, inr N.fst.toNearLitter⟩ ∈ transConstrained c d := by\n  obtain hN | hN := hN\n  exact Or.inl (lt_nearLitter' hN)\n  exact Or.inr (lt_nearLitter' hN)\n", "additional_info": "", "used_premises": [1, 60, 60, 61, 65, 995, 65, 483, 995], "def_path": "ConNF/FOA/Properties/ConstrainedAction.lean", "pos": [84, 90], "informalization": "The theorem `ConNF.StructApprox.fst_mem_transConstrained` is a part of the Constructive Ordinal Notation (ConNF) project in Lean 4. It states that if a near-litter `N` is an element of the transitive closure of the relation defined by two addresses `c` and `d`, then the near-litter obtained by converting the litter of `N` to a near-litter is also an element of the transitive closure of the relation defined by `c` and `d`."}
{"full_name": "ConNF.StructApprox.fst_mem_refl_trans_constrained'", "url": "ConNF/FOA/Properties/ConstrainedAction.html#ConNF.StructApprox.fst_mem_refl_trans_constrained'", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.StructApprox.fst_mem_refl_trans_constrained' [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.FOAAssumptions] {β : ConNF.Λ} {c : ConNF.Address🔗<|PREMISE|>🔗 ↑β} {d : ConNF.Address🔗<|PREMISE|>🔗 ↑β} {A : ConNF.ExtendedIndex🔗<|PREMISE|>🔗 ↑β} {a : ConNF.Atom} (h : { path := A, value := Sum.inl🔗<|PREMISE|>🔗 a } ∈ ConNF.StructApprox.reflTransConstrained🔗<|PREMISE|>🔗 c d) :{ path := A, value := Sum.inr🔗<|PREMISE|>🔗 (ConNF.Litter.toNearLitter🔗<|PREMISE|>🔗 a.1) } ∈ ConNF.StructApprox.reflTransConstrained🔗<|PREMISE|>🔗 c d", "code": "theorem fst_mem_refl_trans_constrained' {c d : Address β} {A : ExtendedIndex β} {a : Atom}\n    (h : ⟨A, inl a⟩ ∈ reflTransConstrained c d) :\n    ⟨A, inr a.fst.toNearLitter⟩ ∈ reflTransConstrained c d :=\n  reflTransConstrained_of_constrains h (Constrains.atom A a)\n", "additional_info": "", "used_premises": [1, 60, 60, 61, 67, 967, 65, 483, 967], "def_path": "ConNF/FOA/Properties/ConstrainedAction.lean", "pos": [91, 95], "informalization": "The theorem `ConNF.StructApprox.fst_mem_refl_trans_constrained'` is a part of the Constructive Ordinal Notation (ConNF) project in Lean 4. It states that if a certain address is in the set of addresses that are either less than or equal to the address `c` or less than or equal to the address `d`, within the context of Constructive Ordinal Notation (ConNF), then another related address is also in the same set. This theorem is crucial for proving the correctness of the ConNF construction."}
{"full_name": "ConNF.StructApprox.fst_mem_reflTransConstrained", "url": "ConNF/FOA/Properties/ConstrainedAction.html#ConNF.StructApprox.fst_mem_reflTransConstrained", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.StructApprox.fst_mem_reflTransConstrained [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.FOAAssumptions] {β : ConNF.Λ} {c : ConNF.Address🔗<|PREMISE|>🔗 ↑β} {d : ConNF.Address🔗<|PREMISE|>🔗 ↑β} {A : ConNF.ExtendedIndex🔗<|PREMISE|>🔗 ↑β} {N : ConNF.NearLitter} (hN : { path := A, value := Sum.inr🔗<|PREMISE|>🔗 N } ∈ ConNF.StructApprox.reflTransConstrained🔗<|PREMISE|>🔗 c d) :{ path := A, value := Sum.inr🔗<|PREMISE|>🔗 (ConNF.Litter.toNearLitter🔗<|PREMISE|>🔗 N.fst) } ∈ ConNF.StructApprox.reflTransConstrained🔗<|PREMISE|>🔗 c d", "code": "theorem fst_mem_reflTransConstrained {c d : Address β} {A : ExtendedIndex β}\n    {N : NearLitter} (hN : ⟨A, inr N⟩ ∈ reflTransConstrained c d) :\n    ⟨A, inr N.fst.toNearLitter⟩ ∈ reflTransConstrained c d := by\n  obtain hN | hN := hN\n  exact Or.inl (le_nearLitter hN)\n  exact Or.inr (le_nearLitter hN)\n", "additional_info": "", "used_premises": [1, 60, 60, 61, 65, 967, 65, 483, 967], "def_path": "ConNF/FOA/Properties/ConstrainedAction.lean", "pos": [96, 102], "informalization": "In the context of Constructive Ordinal Notation (ConNF), the theorem `ConNF.StructApprox.fst_mem_reflTransConstrained` states that if a near-litter `N` is an element of the set `ConNF.StructApprox.reflTransConstrained c d`, then the near-litter formed by wrapping the litter of `N` with its litter set is also an element of `ConNF.StructApprox.reflTransConstrained c d`."}
{"full_name": "ConNF.StructApprox.fst_mem_transConstrained_of_mem_symmDiff", "url": "ConNF/FOA/Properties/ConstrainedAction.html#ConNF.StructApprox.fst_mem_transConstrained_of_mem_symmDiff", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.StructApprox.fst_mem_transConstrained_of_mem_symmDiff [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.FOAAssumptions] {β : ConNF.Λ} {c : ConNF.Address🔗<|PREMISE|>🔗 ↑β} {d : ConNF.Address🔗<|PREMISE|>🔗 ↑β} {A : ConNF.ExtendedIndex🔗<|PREMISE|>🔗 ↑β} {N : ConNF.NearLitter} {a : ConNF.Atom} (h : a ∈ symmDiff🔗<|PREMISE|>🔗 (ConNF.litterSet🔗<|PREMISE|>🔗 N.fst) ↑N) (hN : { path := A, value := Sum.inr🔗<|PREMISE|>🔗 N } ∈ ConNF.StructApprox.transConstrained🔗<|PREMISE|>🔗 c d) :{ path := A, value := Sum.inr🔗<|PREMISE|>🔗 (ConNF.Litter.toNearLitter🔗<|PREMISE|>🔗 a.1) } ∈ ConNF.StructApprox.transConstrained🔗<|PREMISE|>🔗 c d", "code": "theorem fst_mem_transConstrained_of_mem_symmDiff {c d : Address β} {A : ExtendedIndex β}\n    {N : NearLitter} {a : Atom} (h : a ∈ litterSet N.1 ∆ N)\n    (hN : ⟨A, inr N⟩ ∈ transConstrained c d) :\n    ⟨A, inr a.fst.toNearLitter⟩ ∈ transConstrained c d := by\n  obtain ⟨h₁, h₂⟩ | ⟨h₁, h₂⟩ := h\n  · rw [mem_litterSet] at h₁\n    rw [h₁]\n    exact fst_mem_transConstrained hN\n  · obtain hN | hN := hN\n    · refine' fst_mem_trans_constrained' (Or.inl _)\n      exact Relation.TransGen.head (Constrains.symmDiff A N a (Or.inr ⟨h₁, h₂⟩)) hN\n    · refine' fst_mem_trans_constrained' (Or.inr _)\n      exact Relation.TransGen.head (Constrains.symmDiff A N a (Or.inr ⟨h₁, h₂⟩)) hN\n", "additional_info": "", "used_premises": [1, 60, 60, 61, 62, 467, 65, 995, 65, 483, 995], "def_path": "ConNF/FOA/Properties/ConstrainedAction.lean", "pos": [103, 116], "informalization": "The theorem `ConNF.StructApprox.fst_mem_transConstrained_of_mem_symmDiff` states that if an atom `a` is in the symmetric difference of the litter set of a near-litter `N` and the near-litter `N` itself, and if `N` is in the transitive closure of two addresses `c` and `d`, then the near-litter formed by the litter of `a` is also in the transitive closure of `c` and `d`."}
{"full_name": "ConNF.StructApprox.fst_mem_reflTransConstrained_of_mem_symmDiff", "url": "ConNF/FOA/Properties/ConstrainedAction.html#ConNF.StructApprox.fst_mem_reflTransConstrained_of_mem_symmDiff", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.StructApprox.fst_mem_reflTransConstrained_of_mem_symmDiff [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.FOAAssumptions] {β : ConNF.Λ} {c : ConNF.Address🔗<|PREMISE|>🔗 ↑β} {d : ConNF.Address🔗<|PREMISE|>🔗 ↑β} {A : ConNF.ExtendedIndex🔗<|PREMISE|>🔗 ↑β} {N : ConNF.NearLitter} {a : ConNF.Atom} (h : a ∈ symmDiff🔗<|PREMISE|>🔗 (ConNF.litterSet🔗<|PREMISE|>🔗 N.fst) ↑N) (hN : { path := A, value := Sum.inr🔗<|PREMISE|>🔗 N } ∈ ConNF.StructApprox.reflTransConstrained🔗<|PREMISE|>🔗 c d) :{ path := A, value := Sum.inr🔗<|PREMISE|>🔗 (ConNF.Litter.toNearLitter🔗<|PREMISE|>🔗 a.1) } ∈ ConNF.StructApprox.reflTransConstrained🔗<|PREMISE|>🔗 c d", "code": "theorem fst_mem_reflTransConstrained_of_mem_symmDiff {c d : Address β}\n    {A : ExtendedIndex β} {N : NearLitter} {a : Atom} (h : a ∈ litterSet N.1 ∆ N)\n    (hN : ⟨A, inr N⟩ ∈ reflTransConstrained c d) :\n    ⟨A, inr a.fst.toNearLitter⟩ ∈ reflTransConstrained c d := by\n  obtain ⟨h₁, h₂⟩ | ⟨h₁, h₂⟩ := h\n  · rw [mem_litterSet] at h₁\n    rw [h₁]\n    exact fst_mem_reflTransConstrained hN\n  · obtain hN | hN := hN\n    · refine' fst_mem_refl_trans_constrained' (Or.inl _)\n      exact Relation.ReflTransGen.head (Constrains.symmDiff A N a (Or.inr ⟨h₁, h₂⟩)) hN\n    · refine' fst_mem_refl_trans_constrained' (Or.inr _)\n      exact Relation.ReflTransGen.head (Constrains.symmDiff A N a (Or.inr ⟨h₁, h₂⟩)) hN\n", "additional_info": "", "used_premises": [1, 60, 60, 61, 62, 467, 65, 967, 65, 483, 967], "def_path": "ConNF/FOA/Properties/ConstrainedAction.lean", "pos": [117, 130], "informalization": "In the context of Constructive Ordinal Notation (ConNF), the theorem `ConNF.StructApprox.fst_mem_reflTransConstrained_of_mem_symmDiff` states that if an atom `a` belongs to the symmetric difference of the litter set of a near-litter `N` and the near-litter `N` itself, and if the near-litter `N` is in the reflexive-transitive closure of two addresses `c` and `d`, then the near-litter formed by the litter of `a` and its litter set is also in the reflexive-transitive closure of `c` and `d`."}
{"full_name": "ConNF.StructApprox.fst_mem_transConstrained_of_mem", "url": "ConNF/FOA/Properties/ConstrainedAction.html#ConNF.StructApprox.fst_mem_transConstrained_of_mem", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.StructApprox.fst_mem_transConstrained_of_mem [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.FOAAssumptions] {β : ConNF.Λ} {c : ConNF.Address🔗<|PREMISE|>🔗 ↑β} {d : ConNF.Address🔗<|PREMISE|>🔗 ↑β} {A : ConNF.ExtendedIndex🔗<|PREMISE|>🔗 ↑β} {N : ConNF.NearLitter} {a : ConNF.Atom} (h : a ∈ N) (hN : { path := A, value := Sum.inr🔗<|PREMISE|>🔗 N } ∈ ConNF.StructApprox.transConstrained🔗<|PREMISE|>🔗 c d) :{ path := A, value := Sum.inr🔗<|PREMISE|>🔗 (ConNF.Litter.toNearLitter🔗<|PREMISE|>🔗 a.1) } ∈ ConNF.StructApprox.transConstrained🔗<|PREMISE|>🔗 c d", "code": "theorem fst_mem_transConstrained_of_mem {c d : Address β} {A : ExtendedIndex β}\n    {N : NearLitter} {a : Atom} (h : a ∈ N) (hN : ⟨A, inr N⟩ ∈ transConstrained c d) :\n    ⟨A, inr a.fst.toNearLitter⟩ ∈ transConstrained c d := by\n  by_cases ha : a.1 = N.1\n  · rw [ha]\n    exact fst_mem_transConstrained hN\n  · exact fst_mem_transConstrained_of_mem_symmDiff (Or.inr ⟨h, ha⟩) hN\n", "additional_info": "", "used_premises": [1, 60, 60, 61, 65, 995, 65, 483, 995], "def_path": "ConNF/FOA/Properties/ConstrainedAction.lean", "pos": [131, 138], "informalization": "In the context of Constructive Ordinal Notation (ConNF), the theorem `ConNF.StructApprox.fst_mem_transConstrained_of_mem` asserts that if an atom `a` belongs to a near-litter `N`, and the near-litter `N` is an element of the transitive closure of the relation defined by two addresses `c` and `d`, then the near-litter formed by wrapping the litter of `a` is also an element of the transitive closure of the relation defined by `c` and `d`."}
{"full_name": "ConNF.StructApprox.constrainedAction_atomMap", "url": "ConNF/FOA/Properties/ConstrainedAction.html#ConNF.StructApprox.constrainedAction_atomMap", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.StructApprox.constrainedAction_atomMap [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.FOAAssumptions] {β : ConNF.Λ} [ConNF.LeLevel🔗<|PREMISE|>🔗 ↑β] [ConNF.StructApprox.FreedomOfActionHypothesis🔗<|PREMISE|>🔗 β] {π : ConNF.StructApprox🔗<|PREMISE|>🔗 ↑β} {s : Set🔗<|PREMISE|>🔗 (ConNF.Address🔗<|PREMISE|>🔗 ↑β)} {hs : ConNF.Small🔗<|PREMISE|>🔗 s} {B : ConNF.ExtendedIndex🔗<|PREMISE|>🔗 ↑β} {a : ConNF.Atom} :(ConNF.StructApprox.constrainedAction🔗<|PREMISE|>🔗 π s hs B).atomMap a = { Dom := ∃ c ∈ s, { path := B, value := Sum.inl🔗<|PREMISE|>🔗 a } ≤ c, get := fun (x : ∃ c ∈ s, { path := B, value := Sum.inl🔗<|PREMISE|>🔗 a } ≤ c) => ConNF.StructApprox.completeAtomMap🔗<|PREMISE|>🔗 π B a }", "code": "theorem constrainedAction_atomMap {π : StructApprox β} {s : Set (Address β)} {hs : Small s}\n    {B : ExtendedIndex β} {a : Atom} :\n    (constrainedAction π s hs B).atomMap a =\n      ⟨∃ c : Address β, c ∈ s ∧ ⟨B, inl a⟩ ≤ c,\n        fun _ => completeAtomMap π B a⟩ :=\n  rfl\n", "additional_info": "", "used_premises": [1, 402, 779, 781, 69, 60, 233, 61, 978, 67, 67, 784], "def_path": "ConNF/FOA/Properties/ConstrainedAction.lean", "pos": [187, 193], "informalization": "In the context of Constructive Ordinal Notation (ConNF), the function `ConNF.StructApprox.constrainedAction_atomMap` defines a `β`-structural action as a product that assigns a near-litter action to each `β`-extended index, under the condition that the cardinality of a given set `s` is strictly less than the cardinality of the type `ConNF.κ`."}
{"full_name": "ConNF.StructApprox.constrainedAction_litterMap", "url": "ConNF/FOA/Properties/ConstrainedAction.html#ConNF.StructApprox.constrainedAction_litterMap", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.StructApprox.constrainedAction_litterMap [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.FOAAssumptions] {β : ConNF.Λ} [ConNF.LeLevel🔗<|PREMISE|>🔗 ↑β] [ConNF.StructApprox.FreedomOfActionHypothesis🔗<|PREMISE|>🔗 β] {π : ConNF.StructApprox🔗<|PREMISE|>🔗 ↑β} {s : Set🔗<|PREMISE|>🔗 (ConNF.Address🔗<|PREMISE|>🔗 ↑β)} {hs : ConNF.Small🔗<|PREMISE|>🔗 s} {B : ConNF.ExtendedIndex🔗<|PREMISE|>🔗 ↑β} {L : ConNF.Litter} :(ConNF.StructApprox.constrainedAction🔗<|PREMISE|>🔗 π s hs B).litterMap L = { Dom := ∃ c ∈ s, { path := B, value := Sum.inr🔗<|PREMISE|>🔗 (ConNF.Litter.toNearLitter🔗<|PREMISE|>🔗 L) } ≤ c, get := fun (x : ∃ c ∈ s, { path := B, value := Sum.inr🔗<|PREMISE|>🔗 (ConNF.Litter.toNearLitter🔗<|PREMISE|>🔗 L) } ≤ c) => ConNF.StructApprox.completeNearLitterMap🔗<|PREMISE|>🔗 π B (ConNF.Litter.toNearLitter🔗<|PREMISE|>🔗 L) }", "code": "theorem constrainedAction_litterMap {π : StructApprox β} {s : Set (Address β)}\n    {hs : Small s} {B : ExtendedIndex β} {L : Litter} :\n    (constrainedAction π s hs B).litterMap L =\n      ⟨∃ c : Address β, c ∈ s ∧ ⟨B, inr L.toNearLitter⟩ ≤ c,\n        fun _ => π.completeNearLitterMap B L.toNearLitter⟩ :=\n  rfl\n", "additional_info": "", "used_premises": [1, 402, 779, 781, 69, 60, 233, 61, 978, 65, 483, 65, 483, 792, 483], "def_path": "ConNF/FOA/Properties/ConstrainedAction.lean", "pos": [195, 201], "informalization": "The function `ConNF.StructApprox.constrainedAction_litterMap` is a part of the proof of freedom of action in Constructive Ordinal Notation (ConNF). It defines a `β`-structural action as a product that assigns a near-litter action to each `β`-extended index, under the condition that the cardinality of a given set `s` is strictly less than the cardinality of the type `ConNF.κ`."}
{"full_name": "ConNF.StructApprox.ihsAction_atomMap", "url": "ConNF/FOA/Properties/ConstrainedAction.html#ConNF.StructApprox.ihsAction_atomMap", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.StructApprox.ihsAction_atomMap [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.FOAAssumptions] {β : ConNF.Λ} [ConNF.LeLevel🔗<|PREMISE|>🔗 ↑β] [ConNF.StructApprox.FreedomOfActionHypothesis🔗<|PREMISE|>🔗 β] {π : ConNF.StructApprox🔗<|PREMISE|>🔗 ↑β} {c : ConNF.Address🔗<|PREMISE|>🔗 ↑β} {d : ConNF.Address🔗<|PREMISE|>🔗 ↑β} {B : ConNF.ExtendedIndex🔗<|PREMISE|>🔗 ↑β} {a : ConNF.Atom} :(ConNF.StructApprox.ihsAction🔗<|PREMISE|>🔗 π c d B).atomMap a = { Dom := { path := B, value := Sum.inl🔗<|PREMISE|>🔗 a } ∈ ConNF.StructApprox.transConstrained🔗<|PREMISE|>🔗 c d, get := fun (x : { path := B, value := Sum.inl🔗<|PREMISE|>🔗 a } ∈ ConNF.StructApprox.transConstrained🔗<|PREMISE|>🔗 c d) => ConNF.StructApprox.completeAtomMap🔗<|PREMISE|>🔗 π B a }", "code": "theorem ihsAction_atomMap {π : StructApprox β} {c d : Address β} {B : ExtendedIndex β}\n    {a : Atom} :\n    (ihsAction π c d B).atomMap a =\n      ⟨⟨B, inl a⟩ ∈ transConstrained c d,\n        fun _ => completeAtomMap π B a⟩ :=\n  rfl\n", "additional_info": "", "used_premises": [1, 402, 779, 781, 60, 60, 61, 966, 67, 995, 67, 995, 784], "def_path": "ConNF/FOA/Properties/ConstrainedAction.lean", "pos": [203, 209], "informalization": "In the context of Constructive Ordinal Notation (ConNF), the function `ConNF.StructApprox.ihsAction_atomMap` defines a `β`-structural action as a product that assigns a near-litter action to each `β`-extended index. It takes a `β`-structural approximation `π` and returns a function that maps each `β`-extended index to an atom. This function is defined using the `ConNF.HypAction.fixAtom` function, which is part of the `ConNF.HypAction` class. The `ConNF.HypAction.fixAtom` function uses the `ConNF.StructApprox.atomCompletion` and `ConNF.StructApprox.nearLitterCompletion` components of the `β`-structural approximation `π`."}
{"full_name": "ConNF.StructApprox.ihsAction_litterMap", "url": "ConNF/FOA/Properties/ConstrainedAction.html#ConNF.StructApprox.ihsAction_litterMap", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.StructApprox.ihsAction_litterMap [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.FOAAssumptions] {β : ConNF.Λ} [ConNF.LeLevel🔗<|PREMISE|>🔗 ↑β] [ConNF.StructApprox.FreedomOfActionHypothesis🔗<|PREMISE|>🔗 β] {π : ConNF.StructApprox🔗<|PREMISE|>🔗 ↑β} {c : ConNF.Address🔗<|PREMISE|>🔗 ↑β} {d : ConNF.Address🔗<|PREMISE|>🔗 ↑β} {B : ConNF.ExtendedIndex🔗<|PREMISE|>🔗 ↑β} {L : ConNF.Litter} :(ConNF.StructApprox.ihsAction🔗<|PREMISE|>🔗 π c d B).litterMap L = { Dom := { path := B, value := Sum.inr🔗<|PREMISE|>🔗 (ConNF.Litter.toNearLitter🔗<|PREMISE|>🔗 L) } ∈ ConNF.StructApprox.transConstrained🔗<|PREMISE|>🔗 c d, get := fun (x : { path := B, value := Sum.inr🔗<|PREMISE|>🔗 (ConNF.Litter.toNearLitter🔗<|PREMISE|>🔗 L) } ∈ ConNF.StructApprox.transConstrained🔗<|PREMISE|>🔗 c d) => ConNF.StructApprox.completeNearLitterMap🔗<|PREMISE|>🔗 π B (ConNF.Litter.toNearLitter🔗<|PREMISE|>🔗 L) }", "code": "theorem ihsAction_litterMap {π : StructApprox β} {c d : Address β} {B : ExtendedIndex β}\n    {L : Litter} :\n    (ihsAction π c d B).litterMap L =\n      ⟨⟨B, inr L.toNearLitter⟩ ∈ transConstrained c d,\n        fun _ => π.completeNearLitterMap B L.toNearLitter⟩ :=\n  rfl\n", "additional_info": "", "used_premises": [1, 402, 779, 781, 60, 60, 61, 966, 65, 483, 995, 65, 483, 995, 792, 483], "def_path": "ConNF/FOA/Properties/ConstrainedAction.lean", "pos": [211, 217], "informalization": "The function `ConNF.StructApprox.ihsAction_litterMap` defines a `β`-structural action as a product that assigns a near-litter action to each `β`-extended index in the context of Constructive Ordinal Notation (ConNF). This function is used in the proof of freedom of action in Constructive Ordinal Notation (ConNF)."}
{"full_name": "ConNF.StructApprox.ihsAction_symm", "url": "ConNF/FOA/Properties/ConstrainedAction.html#ConNF.StructApprox.ihsAction_symm", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.StructApprox.ihsAction_symm [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.FOAAssumptions] {β : ConNF.Λ} [ConNF.LeLevel🔗<|PREMISE|>🔗 ↑β] [ConNF.StructApprox.FreedomOfActionHypothesis🔗<|PREMISE|>🔗 β] (π : ConNF.StructApprox🔗<|PREMISE|>🔗 ↑β) (c : ConNF.Address🔗<|PREMISE|>🔗 ↑β) (d : ConNF.Address🔗<|PREMISE|>🔗 ↑β) :ConNF.StructApprox.ihsAction🔗<|PREMISE|>🔗 π c d = ConNF.StructApprox.ihsAction🔗<|PREMISE|>🔗 π d c", "code": "theorem ihsAction_symm (π : StructApprox β) (c d : Address β) :\n    ihsAction π c d = ihsAction π d c := by\n  funext\n  ext\n  · funext\n    rw [ihsAction_atomMap, ihsAction_atomMap, transConstrained_symm]\n  · funext\n    rw [ihsAction_litterMap, ihsAction_litterMap, transConstrained_symm]\n", "additional_info": "", "used_premises": [1, 402, 779, 781, 60, 60, 966, 966], "def_path": "ConNF/FOA/Properties/ConstrainedAction.lean", "pos": [218, 226], "informalization": "The theorem `ConNF.StructApprox.ihsAction_symm` states that the `β`-structural action (defined by `ConNF.StructApprox.ihsAction`) is symmetric in the sense that swapping the arguments does not change the outcome. This property is crucial for establishing the well-definedness of the `β`-structural action when constructing proofs about the freedom of action in Constructive Ordinal Notation (ConNF)."}
{"full_name": "ConNF.StructApprox.constrainedAction_mono", "url": "ConNF/FOA/Properties/ConstrainedAction.html#ConNF.StructApprox.constrainedAction_mono", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.StructApprox.constrainedAction_mono [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.FOAAssumptions] {β : ConNF.Λ} [ConNF.LeLevel🔗<|PREMISE|>🔗 ↑β] [ConNF.StructApprox.FreedomOfActionHypothesis🔗<|PREMISE|>🔗 β] {π : ConNF.StructApprox🔗<|PREMISE|>🔗 ↑β} {s : Set🔗<|PREMISE|>🔗 (ConNF.Address🔗<|PREMISE|>🔗 ↑β)} {t : Set🔗<|PREMISE|>🔗 (ConNF.Address🔗<|PREMISE|>🔗 ↑β)} {hs : ConNF.Small🔗<|PREMISE|>🔗 s} {ht : ConNF.Small🔗<|PREMISE|>🔗 t} (h : s ⊆ t) :ConNF.StructApprox.constrainedAction🔗<|PREMISE|>🔗 π s hs ≤ ConNF.StructApprox.constrainedAction🔗<|PREMISE|>🔗 π t ht", "code": "theorem constrainedAction_mono {π : StructApprox β} {s t : Set (Address β)} {hs : Small s}\n    {ht : Small t} (h : s ⊆ t) : constrainedAction π s hs ≤ constrainedAction π t ht :=\n  fun _ =>\n  ⟨⟨fun _ ha => ⟨ha.choose, h ha.choose_spec.1, ha.choose_spec.2⟩, fun _ _ => rfl⟩,\n    ⟨fun _ hL => ⟨hL.choose, h hL.choose_spec.1, hL.choose_spec.2⟩, fun _ _ => rfl⟩⟩\n", "additional_info": "", "used_premises": [1, 402, 779, 781, 69, 60, 69, 60, 233, 233, 978, 978], "def_path": "ConNF/FOA/Properties/ConstrainedAction.lean", "pos": [239, 244], "informalization": "Let $s \\subseteq t$ be subsets of the set of $\\beta$-extended indices with the property that their cardinalities are strictly less than the cardinality of type $\\kappa$. Then, the constrained action of $\\pi$ on $s$ is less than or equal to the constrained action of $\\pi$ on $t$."}
{"full_name": "ConNF.NearLitterAction.mk_dom_symmDiff_le", "url": "ConNF/FOA/Action/FillAtomOrbits.html#ConNF.NearLitterAction.mk_dom_symmDiff_le", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterAction.mk_dom_symmDiff_le [ConNF.Params🔗<|PREMISE|>🔗 ] (φ : ConNF.NearLitterAction) :Cardinal.mk🔗<|PREMISE|>🔗 ↑(symmDiff🔗<|PREMISE|>🔗 (PFun.Dom🔗<|PREMISE|>🔗 φ.litterMap) (ConNF.NearLitterAction.roughLitterMapOrElse🔗<|PREMISE|>🔗 φ '' PFun.Dom🔗<|PREMISE|>🔗 φ.litterMap)) ≤ Cardinal.mk🔗<|PREMISE|>🔗 ↑{L : ConNF.Litter | ¬ ConNF.NearLitterAction.BannedLitter🔗<|PREMISE|>🔗 φ L}", "code": "theorem mk_dom_symmDiff_le :\n    #(φ.litterMap.Dom ∆ (φ.roughLitterMapOrElse '' φ.litterMap.Dom) : Set Litter) ≤\n      #{L : Litter | ¬φ.BannedLitter L} := by\n  rw [mk_not_bannedLitter]\n  refine' le_trans (le_of_lt _) Params.κ_lt_μ.le\n  exact Small.symmDiff φ.litterMap_dom_small φ.litterMap_dom_small.image\n", "additional_info": "", "used_premises": [1, 29, 62, 404, 1064, 404, 29, 1065], "def_path": "ConNF/FOA/Action/FillAtomOrbits.lean", "pos": [20, 26], "informalization": "The theorem `ConNF.NearLitterAction.mk_dom_symmDiff_le` states that the cardinality of the symmetric difference of the domain of `φ.litterMap` and the image of the domain of `φ.litterMap` under `ConNF.NearLitterAction.roughLitterMapOrElse` is less than or equal to the cardinality of the set of litters that are not banned by `φ`."}
{"full_name": "ConNF.NearLitterAction.roughLitterMapOrElse", "url": "ConNF/FOA/Action/NearLitterAction.html#ConNF.NearLitterAction.roughLitterMapOrElse", "code_src": "con-nf", "ptype": "noncomputable def", "header": "noncomputable def ConNF.NearLitterAction.roughLitterMapOrElse [ConNF.Params🔗<|PREMISE|>🔗 ] (φ : ConNF.NearLitterAction) (L : ConNF.Litter) :ConNF.Litter", "code": "noncomputable def roughLitterMapOrElse (L : Litter) : Litter :=\n  (φ.litterMapOrElse L).1\n", "additional_info": "Equations\n* 🗟ConNF.NearLitterAction.roughLitterMapOrElse🗟🔗../../.././ConNF/FOA/Action/NearLitterAction.html#ConNF.NearLitterAction.roughLitterMapOrElse🔗  φ L 🗟=🗟🔗../../.././Init/Prelude.html#Eq🔗  (🗟ConNF.NearLitterAction.litterMapOrElse🗟🔗../../.././ConNF/FOA/Action/NearLitterAction.html#ConNF.NearLitterAction.litterMapOrElse🔗  φ L).fst\n\n", "used_premises": [1], "def_path": "ConNF/FOA/Action/NearLitterAction.lean", "pos": [161, 163], "informalization": "Function `ConNF.NearLitterAction.roughLitterMapOrElse` takes a `ConNF.NearLitterAction` object `φ` and a `ConNF.Litter` object `L`, and returns the first component of the result of applying `ConNF.NearLitterAction.litterMapOrElse` to `φ` and `L`."}
{"full_name": "ConNF.NearLitterAction.BannedLitter", "url": "ConNF/FOA/Action/NearLitterAction.html#ConNF.NearLitterAction.BannedLitter", "code_src": "con-nf", "ptype": "inductive", "header": "inductive ConNF.NearLitterAction.BannedLitter [ConNF.Params🔗<|PREMISE|>🔗 ] (φ : ConNF.NearLitterAction) :ConNF.Litter → Prop", "code": "inductive BannedLitter : Litter → Prop\n  | atomDom (a : Atom) : (φ.atomMap a).Dom → BannedLitter a.1\n  | litterDom (L : Litter) : (φ.litterMap L).Dom → BannedLitter L\n  | atomMap (a : Atom) (h) : BannedLitter ((φ.atomMap a).get h).1\n  | litterMap (L : Litter) (h) : BannedLitter ((φ.litterMap L).get h).1\n  | diff (L : Litter) (h) (a : Atom) :\n    a ∈ ((φ.litterMap L).get h : Set Atom) \\ litterSet ((φ.litterMap L).get h).1 → BannedLitter a.1\n", "additional_info": "A litter that is not allowed to be used as a sandbox because it appears somewhere that\nwe need to preserve.\n", "used_premises": [1], "def_path": "ConNF/FOA/Action/NearLitterAction.lean", "pos": [59, 66], "informalization": "The type `ConNF.NearLitterAction.BannedLitter` represents a litter that is not allowed to be used as a sandbox because it appears somewhere that we need to preserve."}
{"full_name": "ConNF.NearLitterAction.aleph0_le_not_bannedLitter", "url": "ConNF/FOA/Action/FillAtomOrbits.html#ConNF.NearLitterAction.aleph0_le_not_bannedLitter", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterAction.aleph0_le_not_bannedLitter [ConNF.Params🔗<|PREMISE|>🔗 ] (φ : ConNF.NearLitterAction) :Cardinal.aleph0🔗<|PREMISE|>🔗 ≤ Cardinal.mk🔗<|PREMISE|>🔗 ↑{L : ConNF.Litter | ¬ ConNF.NearLitterAction.BannedLitter🔗<|PREMISE|>🔗 φ L}", "code": "theorem aleph0_le_not_bannedLitter : ℵ₀ ≤ #{L | ¬φ.BannedLitter L} := by\n  rw [mk_not_bannedLitter]\n  exact Params.μ_isStrongLimit.isLimit.aleph0_le\n", "additional_info": "", "used_premises": [1, 510, 29, 1065], "def_path": "ConNF/FOA/Action/FillAtomOrbits.lean", "pos": [27, 30], "informalization": "The theorem `ConNF.NearLitterAction.aleph0_le_not_bannedLitter` states that the cardinality of the set of litters that are not banned is at least `ℵ₀`, the smallest infinite cardinal number."}
{"full_name": "ConNF.NearLitterAction.litterPerm'_apply_eq", "url": "ConNF/FOA/Action/FillAtomOrbits.html#ConNF.NearLitterAction.litterPerm'_apply_eq", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterAction.litterPerm'_apply_eq [ConNF.Params🔗<|PREMISE|>🔗 ] {φ : ConNF.NearLitterAction} {hφ : ConNF.NearLitterAction.Lawful🔗<|PREMISE|>🔗 φ} (L : ConNF.Litter) (hL : L ∈ PFun.Dom🔗<|PREMISE|>🔗 φ.litterMap) :(ConNF.NearLitterAction.litterPerm'🔗<|PREMISE|>🔗 φ hφ).toFun L = ConNF.NearLitterAction.roughLitterMapOrElse🔗<|PREMISE|>🔗 φ L", "code": "theorem litterPerm'_apply_eq {φ : NearLitterAction} {hφ : φ.Lawful} (L : Litter)\n    (hL : L ∈ φ.litterMap.Dom) : φ.litterPerm' hφ L = φ.roughLitterMapOrElse L :=\n  PartialPerm.complete_apply_eq _ _ _ hL\n", "additional_info": "", "used_premises": [1, 825, 404, 1068, 1064], "def_path": "ConNF/FOA/Action/FillAtomOrbits.lean", "pos": [52, 55], "informalization": "The function ConNF.NearLitterAction.litterPerm'_apply_eq is a theorem that states that for any litter L in the domain of the map of a near litter action φ, the application of the permutation litterPerm' to L is equal to the first component of the result of applying roughLitterMapOrElse to φ and L. This theorem ensures that the permutation on litters behaves as expected according to the laws of the near litter action."}
{"full_name": "ConNF.NearLitterAction.litterPerm'", "url": "ConNF/FOA/Action/FillAtomOrbits.html#ConNF.NearLitterAction.litterPerm'", "code_src": "con-nf", "ptype": "noncomputable def", "header": "noncomputable def ConNF.NearLitterAction.litterPerm' [ConNF.Params🔗<|PREMISE|>🔗 ] (φ : ConNF.NearLitterAction) (hφ : ConNF.NearLitterAction.Lawful🔗<|PREMISE|>🔗 φ) :PartialPerm🔗<|PREMISE|>🔗 ConNF.Litter", "code": "noncomputable def litterPerm' (hφ : φ.Lawful) : PartialPerm Litter :=\n  PartialPerm.complete φ.roughLitterMapOrElse φ.litterMap.Dom {L | ¬φ.BannedLitter L}\n    φ.mk_dom_symmDiff_le φ.aleph0_le_not_bannedLitter φ.disjoint_dom_not_bannedLitter\n    (φ.roughLitterMapOrElse_injOn hφ)\n", "additional_info": "A local permutation on the set of litters that occur in the domain or range of `w`.\nThis permutes both flexible and inflexible litters.\nEquations\n* One or more equations did not get rendered due to their size.\n\n", "used_premises": [1, 825, 645], "def_path": "ConNF/FOA/Action/FillAtomOrbits.lean", "pos": [33, 37], "informalization": "Function `ConNF.NearLitterAction.litterPerm'` is a partial permutation on the set of litters in the context of Constructive Ordinal Notation (ConNF). It represents a local permutation that permutes both flexible and inflexible litters."}
{"full_name": "ConNF.NearLitterAction.litterPerm_apply_eq", "url": "ConNF/FOA/Action/FillAtomOrbits.html#ConNF.NearLitterAction.litterPerm_apply_eq", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterAction.litterPerm_apply_eq [ConNF.Params🔗<|PREMISE|>🔗 ] {φ : ConNF.NearLitterAction} {hφ : ConNF.NearLitterAction.Lawful🔗<|PREMISE|>🔗 φ} (L : ConNF.Litter) (hL : L ∈ PFun.Dom🔗<|PREMISE|>🔗 φ.litterMap) :(ConNF.NearLitterAction.litterPerm🔗<|PREMISE|>🔗 φ hφ).toFun L = ConNF.NearLitterAction.roughLitterMapOrElse🔗<|PREMISE|>🔗 φ L", "code": "theorem litterPerm_apply_eq {φ : NearLitterAction} {hφ : φ.Lawful} (L : Litter)\n    (hL : L ∈ φ.litterMap.Dom) : φ.litterPerm hφ L = φ.roughLitterMapOrElse L := by\n  rw [← litterPerm'_apply_eq L hL]\n  exact PartialPerm.piecewise_apply_eq_left (Or.inl (Or.inl hL))\n", "additional_info": "", "used_premises": [1, 825, 404, 1070, 1064], "def_path": "ConNF/FOA/Action/FillAtomOrbits.lean", "pos": [56, 60], "informalization": "The theorem states that for any lawful near litter action `φ` and any litter `L` in the domain of the litter map, the partial permutation `ConNF.NearLitterAction.litterPerm φ hφ` applied to `L` is equal to `ConNF.NearLitterAction.roughLitterMapOrElse φ L`."}
{"full_name": "ConNF.NearLitterAction.litterPerm", "url": "ConNF/FOA/Action/FillAtomOrbits.html#ConNF.NearLitterAction.litterPerm", "code_src": "con-nf", "ptype": "noncomputable def", "header": "noncomputable def ConNF.NearLitterAction.litterPerm [ConNF.Params🔗<|PREMISE|>🔗 ] (φ : ConNF.NearLitterAction) (hφ : ConNF.NearLitterAction.Lawful🔗<|PREMISE|>🔗 φ) :PartialPerm🔗<|PREMISE|>🔗 ConNF.Litter", "code": "noncomputable def litterPerm (hφ : φ.Lawful) : PartialPerm Litter :=\n  PartialPerm.piecewise (φ.litterPerm' hφ) (φ.idOnBanned (φ.litterPerm' hφ).domain)\n    (by rw [← Set.subset_compl_iff_disjoint_left]; exact fun L h => h.2)\n", "additional_info": "Equations\n* 🗟ConNF.NearLitterAction.litterPerm🗟🔗../../.././ConNF/FOA/Action/FillAtomOrbits.html#ConNF.NearLitterAction.litterPerm🔗  φ hφ 🗟=🗟🔗../../.././Init/Prelude.html#Eq🔗  🗟PartialPerm.piecewise🗟🔗../../.././ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm.piecewise🔗  (🗟ConNF.NearLitterAction.litterPerm'🗟🔗../../.././ConNF/FOA/Action/FillAtomOrbits.html#ConNF.NearLitterAction.litterPerm'🔗  φ hφ)\n(🗟ConNF.NearLitterAction.idOnBanned🗟🔗../../.././ConNF/FOA/Action/FillAtomOrbits.html#ConNF.NearLitterAction.idOnBanned🔗  φ (🗟ConNF.NearLitterAction.litterPerm'🗟🔗../../.././ConNF/FOA/Action/FillAtomOrbits.html#ConNF.NearLitterAction.litterPerm'🔗  φ hφ).domain) ⋯\n\n", "used_premises": [1, 825, 645], "def_path": "ConNF/FOA/Action/FillAtomOrbits.lean", "pos": [48, 51], "informalization": "The function `ConNF.NearLitterAction.litterPerm` is a partial permutation on the set of litters in the context of Constructive Ordinal Notation (ConNF). It is defined as a piecewise function that combines two components: `ConNF.NearLitterAction.litterPerm' φ hφ` and `ConNF.NearLitterAction.idOnBanned φ (ConNF.NearLitterAction.litterPerm' φ hφ).domain`. The first component, `ConNF.NearLitterAction.litterPerm' φ hφ`, is a partial permutation on the set of litters, and the second component, `ConNF.NearLitterAction.idOnBanned φ (ConNF.NearLitterAction.litterPerm' φ hφ).domain`, is the identity permutation on the complement of the domain of `ConNF.NearLitterAction.litterPerm' φ hφ`."}
{"full_name": "ConNF.NearLitterAction.litterPerm'_domain_small", "url": "ConNF/FOA/Action/FillAtomOrbits.html#ConNF.NearLitterAction.litterPerm'_domain_small", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterAction.litterPerm'_domain_small [ConNF.Params🔗<|PREMISE|>🔗 ] (φ : ConNF.NearLitterAction) (hφ : ConNF.NearLitterAction.Lawful🔗<|PREMISE|>🔗 φ) :ConNF.Small🔗<|PREMISE|>🔗 (ConNF.NearLitterAction.litterPerm'🔗<|PREMISE|>🔗 φ hφ).domain", "code": "theorem litterPerm'_domain_small (hφ : φ.Lawful) : Small (φ.litterPerm' hφ).domain := by\n  refine' Small.union (Small.union φ.litterMap_dom_small φ.litterMap_dom_small.image) _\n  rw [Small]\n  rw [Cardinal.mk_congr (PartialPerm.sandboxSubsetEquiv _ _)]\n  simp only [mk_sum, mk_prod, mk_denumerable, lift_aleph0, lift_uzero, lift_id]\n  refine' add_lt_of_lt Params.κ_isRegular.aleph0_le _ _ <;>\n    refine' mul_lt_of_lt Params.κ_isRegular.aleph0_le\n      (lt_of_le_of_lt aleph0_le_mk_Λ Params.Λ_lt_κ) _ <;>\n    refine' lt_of_le_of_lt (mk_subtype_mono (diff_subset _ _)) _\n  exact φ.litterMap_dom_small\n  exact φ.litterMap_dom_small.image\n", "additional_info": "", "used_premises": [1, 825, 233, 1068], "def_path": "ConNF/FOA/Action/FillAtomOrbits.lean", "pos": [61, 72], "informalization": "The theorem `ConNF.NearLitterAction.litterPerm'_domain_small` states that the domain of the partial permutation `ConNF.NearLitterAction.litterPerm'` on the set of litters in the context of Constructive Ordinal Notation (ConNF) is small, meaning its cardinality is strictly less than the cardinality of the type `ConNF.κ`."}
{"full_name": "ConNF.NearLitterAction.litterPerm_domain_small", "url": "ConNF/FOA/Action/FillAtomOrbits.html#ConNF.NearLitterAction.litterPerm_domain_small", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterAction.litterPerm_domain_small [ConNF.Params🔗<|PREMISE|>🔗 ] (φ : ConNF.NearLitterAction) (hφ : ConNF.NearLitterAction.Lawful🔗<|PREMISE|>🔗 φ) :ConNF.Small🔗<|PREMISE|>🔗 (ConNF.NearLitterAction.litterPerm🔗<|PREMISE|>🔗 φ hφ).domain", "code": "theorem litterPerm_domain_small (hφ : φ.Lawful) : Small (φ.litterPerm hφ).domain :=\n  Small.union (φ.litterPerm'_domain_small hφ) (Small.mono (diff_subset _ _) φ.bannedLitter_small)\n", "additional_info": "", "used_premises": [1, 825, 233, 1070], "def_path": "ConNF/FOA/Action/FillAtomOrbits.lean", "pos": [73, 75], "informalization": "The theorem `ConNF.NearLitterAction.litterPerm_domain_small` states that the domain of the partial permutation `ConNF.NearLitterAction.litterPerm φ hφ` is small, meaning its cardinality is strictly less than the cardinality of the type `ConNF.κ` in the context of Constructive Ordinal Notation (ConNF)."}
{"full_name": "ConNF.NearLitterAction.atomMap_ran_small", "url": "ConNF/FOA/Action/FillAtomOrbits.html#ConNF.NearLitterAction.atomMap_ran_small", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterAction.atomMap_ran_small [ConNF.Params🔗<|PREMISE|>🔗 ] (φ : ConNF.NearLitterAction) :ConNF.Small🔗<|PREMISE|>🔗 (PFun.ran🔗<|PREMISE|>🔗 φ.atomMap)", "code": "theorem atomMap_ran_small : Small φ.atomMap.ran := by\n  have : Small (φ.atomMapOrElse '' φ.atomMap.Dom) := Small.image φ.atomMap_dom_small\n  refine' Small.mono _ this\n  rintro _ ⟨a, ha, rfl⟩\n  refine' ⟨a, ha, _⟩\n  rw [atomMapOrElse_of_dom]\n", "additional_info": "", "used_premises": [1, 233, 824], "def_path": "ConNF/FOA/Action/FillAtomOrbits.lean", "pos": [82, 88], "informalization": "In the context of Constructive Ordinal Notation (ConNF), the theorem `ConNF.NearLitterAction.atomMap_ran_small` asserts that the range of the partial function `φ.atomMap`, which maps elements of a \"near-litter\" to \"atoms\" in ConNF, is a small set. This means that the cardinality of the set of all possible values that `φ.atomMap` can produce is strictly less than the cardinality of the type `ConNF.κ`. This property is crucial for the construction of the natural numbers in ConNF to avoid inconsistencies in the definition of subtraction."}
{"full_name": "ConNF.NearLitterAction.needForwardImages_small", "url": "ConNF/FOA/Action/FillAtomOrbits.html#ConNF.NearLitterAction.needForwardImages_small", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterAction.needForwardImages_small [ConNF.Params🔗<|PREMISE|>🔗 ] (φ : ConNF.NearLitterAction) :ConNF.Small🔗<|PREMISE|>🔗 (ConNF.NearLitterAction.needForwardImages🔗<|PREMISE|>🔗 φ)", "code": "theorem needForwardImages_small : Small φ.needForwardImages :=\n  Small.mono (diff_subset _ _) φ.atomMap_ran_small\n", "additional_info": "", "used_premises": [1, 233, 1075], "def_path": "ConNF/FOA/Action/FillAtomOrbits.lean", "pos": [89, 91], "informalization": "The theorem `ConNF.NearLitterAction.needForwardImages_small` states that the set of elements in the range of the partial function `φ.atomMap` that are not in its domain has a cardinality strictly less than the cardinality of the type `ConNF.κ`."}
{"full_name": "ConNF.NearLitterAction.needForwardImages", "url": "ConNF/FOA/Action/FillAtomOrbits.html#ConNF.NearLitterAction.needForwardImages", "code_src": "con-nf", "ptype": "def", "header": "def ConNF.NearLitterAction.needForwardImages [ConNF.Params🔗<|PREMISE|>🔗 ] (φ : ConNF.NearLitterAction) :Set🔗<|PREMISE|>🔗 ConNF.Atom", "code": "def needForwardImages : Set Atom :=\n  φ.atomMap.ran \\ φ.atomMap.Dom\n", "additional_info": "Equations\n* 🗟ConNF.NearLitterAction.needForwardImages🗟🔗../../.././ConNF/FOA/Action/FillAtomOrbits.html#ConNF.NearLitterAction.needForwardImages🔗  φ 🗟=🗟🔗../../.././Init/Prelude.html#Eq🔗  🗟PFun.ran🗟🔗../../.././Mathlib/Data/PFun.html#PFun.ran🔗  φ.atomMap 🗟\\🗟🔗../../.././Init/Core.html#SDiff.sdiff🔗  🗟PFun.Dom🗟🔗../../.././Mathlib/Data/PFun.html#PFun.Dom🔗  φ.atomMap\n\n", "used_premises": [1, 69], "def_path": "ConNF/FOA/Action/FillAtomOrbits.lean", "pos": [76, 78], "informalization": "Function `ConNF.NearLitterAction.needForwardImages` computes the set of elements in the range of the partial function `φ.atomMap` that are not in its domain."}
{"full_name": "ConNF.NearLitterAction.needBackwardImages_small", "url": "ConNF/FOA/Action/FillAtomOrbits.html#ConNF.NearLitterAction.needBackwardImages_small", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterAction.needBackwardImages_small [ConNF.Params🔗<|PREMISE|>🔗 ] (φ : ConNF.NearLitterAction) :ConNF.Small🔗<|PREMISE|>🔗 (ConNF.NearLitterAction.needBackwardImages🔗<|PREMISE|>🔗 φ)", "code": "theorem needBackwardImages_small : Small φ.needBackwardImages :=\n  Small.mono (diff_subset _ _) φ.atomMap_dom_small\n", "additional_info": "", "used_premises": [1, 233, 1077], "def_path": "ConNF/FOA/Action/FillAtomOrbits.lean", "pos": [92, 94], "informalization": "The theorem `ConNF.NearLitterAction.needBackwardImages_small` states that the set of `ConNF.Atom`s that need backward images under the partial function `ConNF.NearLitterAction.atomMap` has a cardinality strictly less than the cardinality of the type `ConNF.κ`."}
{"full_name": "ConNF.NearLitterAction.needBackwardImages", "url": "ConNF/FOA/Action/FillAtomOrbits.html#ConNF.NearLitterAction.needBackwardImages", "code_src": "con-nf", "ptype": "def", "header": "def ConNF.NearLitterAction.needBackwardImages [ConNF.Params🔗<|PREMISE|>🔗 ] (φ : ConNF.NearLitterAction) :Set🔗<|PREMISE|>🔗 ConNF.Atom", "code": "def needBackwardImages : Set Atom :=\n  φ.atomMap.Dom \\ φ.atomMap.ran\n", "additional_info": "Equations\n* 🗟ConNF.NearLitterAction.needBackwardImages🗟🔗../../.././ConNF/FOA/Action/FillAtomOrbits.html#ConNF.NearLitterAction.needBackwardImages🔗  φ 🗟=🗟🔗../../.././Init/Prelude.html#Eq🔗  🗟PFun.Dom🗟🔗../../.././Mathlib/Data/PFun.html#PFun.Dom🔗  φ.atomMap 🗟\\🗟🔗../../.././Init/Core.html#SDiff.sdiff🔗  🗟PFun.ran🗟🔗../../.././Mathlib/Data/PFun.html#PFun.ran🔗  φ.atomMap\n\n", "used_premises": [1, 69], "def_path": "ConNF/FOA/Action/FillAtomOrbits.lean", "pos": [79, 81], "informalization": "Function `ConNF.NearLitterAction.needBackwardImages` computes the set of `ConNF.Atom`s that need backward images under the partial function `ConNF.NearLitterAction.atomMap`. This set is defined as the difference between the domain of the partial function and its range."}
{"full_name": "ConNF.NearLitterAction.mk_diff_dom_ran", "url": "ConNF/FOA/Action/FillAtomOrbits.html#ConNF.NearLitterAction.mk_diff_dom_ran", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterAction.mk_diff_dom_ran [ConNF.Params🔗<|PREMISE|>🔗 ] (φ : ConNF.NearLitterAction) (L : ConNF.Litter) :Cardinal.mk🔗<|PREMISE|>🔗 ↑(ConNF.litterSet🔗<|PREMISE|>🔗 L \\ (PFun.Dom🔗<|PREMISE|>🔗 φ.atomMap ∪ PFun.ran🔗<|PREMISE|>🔗 φ.atomMap)) = Cardinal.mk🔗<|PREMISE|>🔗 ConNF.κ", "code": "theorem mk_diff_dom_ran (L : Litter) :\n    #(litterSet L \\ (φ.atomMap.Dom ∪ φ.atomMap.ran) : Set Atom) = #κ := by\n  refine' le_antisymm _ _\n  · refine' ⟨⟨fun a => a.1.2, _⟩⟩\n    intro a b h\n    exact Subtype.coe_injective (Prod.ext (a.prop.1.trans b.prop.1.symm) h)\n  · by_contra h\n    have := add_lt_of_lt Params.κ_isRegular.aleph0_le (lt_of_not_le h)\n      (Small.union φ.atomMap_dom_small φ.atomMap_ran_small)\n    have := (le_mk_diff_add_mk (litterSet L) _).trans_lt this\n    simp only [mk_litterSet, lt_self_iff_false] at this\n", "additional_info": "", "used_premises": [1, 29, 467, 404, 824, 29], "def_path": "ConNF/FOA/Action/FillAtomOrbits.lean", "pos": [95, 106], "informalization": "The theorem `ConNF.NearLitterAction.mk_diff_dom_ran` asserts that the difference between the number of atoms in a litter `L` (excluding those in the domain and range of the `NearLitterAction` function `φ`) and the cardinality of the set of atoms in `ConNF.κ` is equal to the cardinality of `ConNF.κ`."}
{"full_name": "ConNF.NearLitterAction.need_images_small", "url": "ConNF/FOA/Action/FillAtomOrbits.html#ConNF.NearLitterAction.need_images_small", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterAction.need_images_small [ConNF.Params🔗<|PREMISE|>🔗 ] (φ : ConNF.NearLitterAction) :Cardinal.mk🔗<|PREMISE|>🔗 (ℕ × ↑(ConNF.NearLitterAction.needBackwardImages🔗<|PREMISE|>🔗 φ) ⊕ ℕ × ↑(ConNF.NearLitterAction.needForwardImages🔗<|PREMISE|>🔗 φ)) < Cardinal.mk🔗<|PREMISE|>🔗 ConNF.κ", "code": "theorem need_images_small :\n    #(Sum (ℕ × φ.needBackwardImages) (ℕ × φ.needForwardImages)) < #κ := by\n  simp only [mk_prod, mk_denumerable, lift_aleph0, lift_uzero, mk_diff_dom_ran, mk_sum, lift_id]\n  rw [← mul_add]\n  refine' lt_of_le_of_lt (mul_le_max _ _) (max_lt (max_lt _ _) _)\n  exact aleph0_le_mk_Λ.trans_lt Params.Λ_lt_κ\n  exact add_lt_of_lt Params.κ_isRegular.aleph0_le\n    φ.needBackwardImages_small φ.needForwardImages_small\n  exact aleph0_le_mk_Λ.trans_lt Params.Λ_lt_κ\n", "additional_info": "", "used_premises": [1, 29, 1077, 1075, 29], "def_path": "ConNF/FOA/Action/FillAtomOrbits.lean", "pos": [107, 116], "informalization": "The theorem states that the cardinality of the union of two sets, each being the product of `ℕ` (the natural numbers) with a subset of `ConNF.Atom`s (the atoms used in the notation system of Constructive Ordinal Notation, ConNF), is less than the cardinality of `ConNF.κ`. The first set consists of pairs `(n, a)` where `n` is a natural number and `a` is an atom that needs backward images under the partial function `ConNF.NearLitterAction.atomMap`, and the second set consists of pairs `(n, b)` where `n` is a natural number and `b` is an element in the range of the partial function that is not in its domain. The inequality signifies that the union of these two sets is a small subset of `ConNF.κ`, which is a key condition for the construction of the natural numbers in ConNF."}
{"full_name": "ConNF.NearLitterAction.le_mk_diff_dom_ran", "url": "ConNF/FOA/Action/FillAtomOrbits.html#ConNF.NearLitterAction.le_mk_diff_dom_ran", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterAction.le_mk_diff_dom_ran [ConNF.Params🔗<|PREMISE|>🔗 ] (φ : ConNF.NearLitterAction) (L : ConNF.Litter) :Cardinal.mk🔗<|PREMISE|>🔗 (ℕ × ↑(ConNF.NearLitterAction.needBackwardImages🔗<|PREMISE|>🔗 φ) ⊕ ℕ × ↑(ConNF.NearLitterAction.needForwardImages🔗<|PREMISE|>🔗 φ)) ≤ Cardinal.mk🔗<|PREMISE|>🔗 ↑(ConNF.litterSet🔗<|PREMISE|>🔗 L \\ (PFun.Dom🔗<|PREMISE|>🔗 φ.atomMap ∪ PFun.ran🔗<|PREMISE|>🔗 φ.atomMap))", "code": "theorem le_mk_diff_dom_ran (L : Litter) :\n    #(Sum (ℕ × φ.needBackwardImages) (ℕ × φ.needForwardImages)) ≤\n      #(litterSet L \\ (φ.atomMap.Dom ∪ φ.atomMap.ran) : Set Atom) := by\n  rw [mk_diff_dom_ran]\n  exact φ.need_images_small.le\n", "additional_info": "", "used_premises": [1, 29, 1077, 1075, 29, 467, 404, 824], "def_path": "ConNF/FOA/Action/FillAtomOrbits.lean", "pos": [117, 122], "informalization": "In the context of Constructive Ordinal Notation (ConNF), the theorem `ConNF.NearLitterAction.le_mk_diff_dom_ran` states that the cardinality of the union of two sets, each representing the need for backward and forward images under a partial function `φ.atomMap`, is less than or equal to the cardinality of the difference between the litter set corresponding to a given litter `L` and the union of the domain and range of `φ.atomMap`."}
{"full_name": "ConNF.NearLitterAction.orbitSet_subset", "url": "ConNF/FOA/Action/FillAtomOrbits.html#ConNF.NearLitterAction.orbitSet_subset", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterAction.orbitSet_subset [ConNF.Params🔗<|PREMISE|>🔗 ] (φ : ConNF.NearLitterAction) (L : ConNF.Litter) :ConNF.NearLitterAction.orbitSet🔗<|PREMISE|>🔗 φ L ⊆ ConNF.litterSet🔗<|PREMISE|>🔗 L \\ (PFun.Dom🔗<|PREMISE|>🔗 φ.atomMap ∪ PFun.ran🔗<|PREMISE|>🔗 φ.atomMap)", "code": "theorem orbitSet_subset (L : Litter) :\n    φ.orbitSet L ⊆ litterSet L \\ (φ.atomMap.Dom ∪ φ.atomMap.ran) :=\n  (le_mk_iff_exists_subset.mp (φ.le_mk_diff_dom_ran L)).choose_spec.1\n", "additional_info": "", "used_premises": [1, 1082, 467, 404, 824], "def_path": "ConNF/FOA/Action/FillAtomOrbits.lean", "pos": [126, 129], "informalization": "Given a `ConNF.NearLitterAction` object `φ` and a `ConNF.Litter` object `L`, the set `ConNF.NearLitterAction.orbitSet φ L` represents the orbit of `L` under the action of `φ`. This set contains all the `ConNF.Atom` objects that can be reached from `L` by repeatedly applying the action defined by `φ`. The theorem `ConNF.NearLitterAction.orbitSet_subset` states that this orbit set is a subset of the set `ConNF.litterSet L` minus the union of the domain and range of the partial function `φ.atomMap`."}
{"full_name": "ConNF.NearLitterAction.orbitSet", "url": "ConNF/FOA/Action/FillAtomOrbits.html#ConNF.NearLitterAction.orbitSet", "code_src": "con-nf", "ptype": "def", "header": "def ConNF.NearLitterAction.orbitSet [ConNF.Params🔗<|PREMISE|>🔗 ] (φ : ConNF.NearLitterAction) (L : ConNF.Litter) :Set🔗<|PREMISE|>🔗 ConNF.Atom", "code": "def orbitSet (L : Litter) : Set Atom :=\n  (le_mk_iff_exists_subset.mp (φ.le_mk_diff_dom_ran L)).choose\n", "additional_info": "Equations\n* 🗟ConNF.NearLitterAction.orbitSet🗟🔗../../.././ConNF/FOA/Action/FillAtomOrbits.html#ConNF.NearLitterAction.orbitSet🔗  φ L 🗟=🗟🔗../../.././Init/Prelude.html#Eq🔗  🗟Exists.choose🗟🔗../../.././Init/Classical.html#Exists.choose🔗  ⋯\n\n", "used_premises": [1, 69], "def_path": "ConNF/FOA/Action/FillAtomOrbits.lean", "pos": [123, 125], "informalization": "Function `ConNF.NearLitterAction.orbitSet` is a method that, given a `ConNF.NearLitterAction` object `φ` and a `ConNF.Litter` object `L`, returns a set of `ConNF.Atom` objects. This set represents the orbit of `L` under the action of `φ`, which means it contains all the `ConNF.Atom` objects that can be reached from `L` by repeatedly applying the action defined by `φ`."}
{"full_name": "ConNF.NearLitterAction.not_mem_needForwardImages_of_mem_orbitSet", "url": "ConNF/FOA/Action/FillAtomOrbits.html#ConNF.NearLitterAction.not_mem_needForwardImages_of_mem_orbitSet", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterAction.not_mem_needForwardImages_of_mem_orbitSet [ConNF.Params🔗<|PREMISE|>🔗 ] (φ : ConNF.NearLitterAction) {a : ConNF.Atom} {L : ConNF.Litter} (h : a ∈ ConNF.NearLitterAction.orbitSet🔗<|PREMISE|>🔗 φ L) :a ∉ ConNF.NearLitterAction.needForwardImages🔗<|PREMISE|>🔗 φ", "code": "theorem not_mem_needForwardImages_of_mem_orbitSet {a : Atom} {L : Litter} (h : a ∈ φ.orbitSet L) :\n    a ∉ φ.needForwardImages := fun ha => (φ.orbitSet_subset L h).2 (Or.inr ha.1)\n", "additional_info": "", "used_premises": [1, 1082, 1075], "def_path": "ConNF/FOA/Action/FillAtomOrbits.lean", "pos": [130, 132], "informalization": "Given a `ConNF.NearLitterAction` object `φ` and a `ConNF.Litter` object `L`, if an `ConNF.Atom` object `a` is in the orbit of `L` under the action of `φ`, then `a` is not in the set of elements in the range of the partial function `φ.atomMap` that are not in its domain."}
{"full_name": "ConNF.NearLitterAction.not_mem_needBackwardImages_of_mem_orbitSet", "url": "ConNF/FOA/Action/FillAtomOrbits.html#ConNF.NearLitterAction.not_mem_needBackwardImages_of_mem_orbitSet", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterAction.not_mem_needBackwardImages_of_mem_orbitSet [ConNF.Params🔗<|PREMISE|>🔗 ] (φ : ConNF.NearLitterAction) {a : ConNF.Atom} {L : ConNF.Litter} (h : a ∈ ConNF.NearLitterAction.orbitSet🔗<|PREMISE|>🔗 φ L) :a ∉ ConNF.NearLitterAction.needBackwardImages🔗<|PREMISE|>🔗 φ", "code": "theorem not_mem_needBackwardImages_of_mem_orbitSet {a : Atom} {L : Litter} (h : a ∈ φ.orbitSet L) :\n    a ∉ φ.needBackwardImages := fun ha => (φ.orbitSet_subset L h).2 (Or.inl ha.1)\n", "additional_info": "", "used_premises": [1, 1082, 1077], "def_path": "ConNF/FOA/Action/FillAtomOrbits.lean", "pos": [133, 135], "informalization": "Given a `ConNF.NearLitterAction` object `φ` and a `ConNF.Litter` object `L`, if an `ConNF.Atom` object `a` is in the orbit of `L` under the action of `φ`, then `a` is not in the set of `ConNF.Atom`s that need backward images under the partial function `ConNF.NearLitterAction.atomMap`."}
{"full_name": "ConNF.NearLitterAction.mk_orbitSet", "url": "ConNF/FOA/Action/FillAtomOrbits.html#ConNF.NearLitterAction.mk_orbitSet", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterAction.mk_orbitSet [ConNF.Params🔗<|PREMISE|>🔗 ] (φ : ConNF.NearLitterAction) (L : ConNF.Litter) :Cardinal.mk🔗<|PREMISE|>🔗 ↑(ConNF.NearLitterAction.orbitSet🔗<|PREMISE|>🔗 φ L) = Cardinal.mk🔗<|PREMISE|>🔗 (ℕ × ↑(ConNF.NearLitterAction.needBackwardImages🔗<|PREMISE|>🔗 φ) ⊕ ℕ × ↑(ConNF.NearLitterAction.needForwardImages🔗<|PREMISE|>🔗 φ))", "code": "theorem mk_orbitSet (L : Litter) :\n    #(φ.orbitSet L) = #(Sum (ℕ × φ.needBackwardImages) (ℕ × φ.needForwardImages)) :=\n  (le_mk_iff_exists_subset.mp (φ.le_mk_diff_dom_ran L)).choose_spec.2\n", "additional_info": "", "used_premises": [1, 29, 1082, 29, 1077, 1075], "def_path": "ConNF/FOA/Action/FillAtomOrbits.lean", "pos": [136, 139], "informalization": "The theorem `ConNF.NearLitterAction.mk_orbitSet` states that the cardinality of the orbit of a `ConNF.Litter` object `L` under the action of a `ConNF.NearLitterAction` object `φ` is equal to the cardinality of the set `ℕ × ↑(ConNF.NearLitterAction.needBackwardImages φ) ⊕ ℕ × ↑(ConNF.NearLitterAction.needForwardImages φ)`."}
{"full_name": "ConNF.NearLitterAction.orbitSet_small", "url": "ConNF/FOA/Action/FillAtomOrbits.html#ConNF.NearLitterAction.orbitSet_small", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterAction.orbitSet_small [ConNF.Params🔗<|PREMISE|>🔗 ] (φ : ConNF.NearLitterAction) (L : ConNF.Litter) :ConNF.Small🔗<|PREMISE|>🔗 (ConNF.NearLitterAction.orbitSet🔗<|PREMISE|>🔗 φ L)", "code": "theorem orbitSet_small (L : Litter) : Small (φ.orbitSet L) := by\n  rw [Small, mk_orbitSet]\n  exact φ.need_images_small\n", "additional_info": "", "used_premises": [1, 233, 1082], "def_path": "ConNF/FOA/Action/FillAtomOrbits.lean", "pos": [161, 164], "informalization": "Given a `ConNF.NearLitterAction` object `φ` and a `ConNF.Litter` object `L`, the set of `ConNF.Atom` objects that can be reached from `L` by repeatedly applying the action defined by `φ` has a cardinality that is strictly less than the cardinality of the type `ConNF.κ`."}
{"full_name": "ConNF.NearLitterAction.nextForwardImage_eq", "url": "ConNF/FOA/Action/FillAtomOrbits.html#ConNF.NearLitterAction.nextForwardImage_eq", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterAction.nextForwardImage_eq [ConNF.Params🔗<|PREMISE|>🔗 ] (φ : ConNF.NearLitterAction) (hφ : ConNF.NearLitterAction.Lawful🔗<|PREMISE|>🔗 φ) {L₁ : ConNF.Litter} {L₂ : ConNF.Litter} {a : ℕ × ↑(ConNF.NearLitterAction.needForwardImages🔗<|PREMISE|>🔗 φ)} {b : ℕ × ↑(ConNF.NearLitterAction.needForwardImages🔗<|PREMISE|>🔗 φ)} (hL₁ : L₁ ∈ (ConNF.NearLitterAction.litterPerm🔗<|PREMISE|>🔗 φ hφ).domain) (hL₂ : L₂ ∈ (ConNF.NearLitterAction.litterPerm🔗<|PREMISE|>🔗 φ hφ).domain) (h : ConNF.NearLitterAction.nextForwardImage🔗<|PREMISE|>🔗 φ hφ L₁ a = ConNF.NearLitterAction.nextForwardImage🔗<|PREMISE|>🔗 φ hφ L₂ b) :L₁ = L₂", "code": "theorem nextForwardImage_eq {L₁ L₂ : Litter} {a b : ℕ × φ.needForwardImages}\n    (hL₁ : L₁ ∈ (φ.litterPerm hφ).domain) (hL₂ : L₂ ∈ (φ.litterPerm hφ).domain)\n    (h : φ.nextForwardImage hφ L₁ a = φ.nextForwardImage hφ L₂ b) : L₁ = L₂ := by\n  rw [nextForwardImage, nextForwardImage] at h\n  have ha :=\n    φ.orbitSet_subset _ ((φ.orbitSetEquiv (φ.litterPerm hφ L₁)).symm (inr (a.1 + 1, a.2))).prop\n  have hb :=\n    φ.orbitSet_subset _ ((φ.orbitSetEquiv (φ.litterPerm hφ L₂)).symm (inr (b.1 + 1, b.2))).prop\n  rw [h] at ha\n  refine' (φ.litterPerm hφ).injOn hL₁ hL₂ _\n  exact eq_of_mem_litterSet_of_mem_litterSet ha.1 hb.1\n", "additional_info": "", "used_premises": [1, 825, 1075, 1075, 1070, 1070, 1088, 1088], "def_path": "ConNF/FOA/Action/FillAtomOrbits.lean", "pos": [190, 201], "informalization": "The `ConNF.NearLitterAction.nextForwardImage_eq` theorem in Lean 4 states that for a lawful near litter action φ, if two elements `a` and `b` are mapped by `ConNF.NearLitterAction.nextForwardImage φ hφ` to the same litter element, then the two litters containing `a` and `b` respectively must be equal."}
{"full_name": "ConNF.NearLitterAction.nextForwardImage", "url": "ConNF/FOA/Action/FillAtomOrbits.html#ConNF.NearLitterAction.nextForwardImage", "code_src": "con-nf", "ptype": "noncomputable def", "header": "noncomputable def ConNF.NearLitterAction.nextForwardImage [ConNF.Params🔗<|PREMISE|>🔗 ] (φ : ConNF.NearLitterAction) (hφ : ConNF.NearLitterAction.Lawful🔗<|PREMISE|>🔗 φ) (L : ConNF.Litter) (a : ℕ × ↑(ConNF.NearLitterAction.needForwardImages🔗<|PREMISE|>🔗 φ)) :ConNF.Atom", "code": "noncomputable def nextForwardImage (L : Litter) (a : ℕ × φ.needForwardImages) : Atom :=\n  (φ.orbitSetEquiv (φ.litterPerm hφ L)).symm (inr (a.1 + 1, a.2))\n", "additional_info": "Equations\n* 🗟ConNF.NearLitterAction.nextForwardImage🗟🔗../../.././ConNF/FOA/Action/FillAtomOrbits.html#ConNF.NearLitterAction.nextForwardImage🔗  φ hφ L a 🗟=🗟🔗../../.././Init/Prelude.html#Eq🔗  ↑((🗟ConNF.NearLitterAction.orbitSetEquiv🗟🔗../../.././ConNF/FOA/Action/FillAtomOrbits.html#ConNF.NearLitterAction.orbitSetEquiv🔗  φ ((🗟ConNF.NearLitterAction.litterPerm🗟🔗../../.././ConNF/FOA/Action/FillAtomOrbits.html#ConNF.NearLitterAction.litterPerm🔗  φ hφ).toFun L)).symm\n(🗟Sum.inr🗟🔗../../.././Init/Core.html#Sum.inr🔗  (a.1 🗟+🗟🔗../../.././Init/Prelude.html#HAdd.hAdd🔗  1, a.2)))\n\n", "used_premises": [1, 825, 1075], "def_path": "ConNF/FOA/Action/FillAtomOrbits.lean", "pos": [165, 167], "informalization": "Function `ConNF.NearLitterAction.nextForwardImage` computes the next element in the range of the partial function `φ.atomMap` that is not in its domain, given a lawful near litter action `φ`, a litter `L`, and an element `a` in the set of elements in the range of `φ.atomMap` that are not in its domain."}
{"full_name": "ConNF.NearLitterAction.nextBackwardImage_eq", "url": "ConNF/FOA/Action/FillAtomOrbits.html#ConNF.NearLitterAction.nextBackwardImage_eq", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterAction.nextBackwardImage_eq [ConNF.Params🔗<|PREMISE|>🔗 ] (φ : ConNF.NearLitterAction) (hφ : ConNF.NearLitterAction.Lawful🔗<|PREMISE|>🔗 φ) {L₁ : ConNF.Litter} {L₂ : ConNF.Litter} {a : ℕ × ↑(ConNF.NearLitterAction.needBackwardImages🔗<|PREMISE|>🔗 φ)} {b : ℕ × ↑(ConNF.NearLitterAction.needBackwardImages🔗<|PREMISE|>🔗 φ)} (ha : a ∈ ConNF.NearLitterAction.nextBackwardImageDomain🔗<|PREMISE|>🔗 φ hφ L₁) (hb : b ∈ ConNF.NearLitterAction.nextBackwardImageDomain🔗<|PREMISE|>🔗 φ hφ L₂) (hL₁ : L₁ ∈ (ConNF.NearLitterAction.litterPerm🔗<|PREMISE|>🔗 φ hφ).domain) (hL₂ : L₂ ∈ (ConNF.NearLitterAction.litterPerm🔗<|PREMISE|>🔗 φ hφ).domain) (h : ConNF.NearLitterAction.nextBackwardImage🔗<|PREMISE|>🔗 φ hφ L₁ a = ConNF.NearLitterAction.nextBackwardImage🔗<|PREMISE|>🔗 φ hφ L₂ b) :L₁ = L₂", "code": "theorem nextBackwardImage_eq {L₁ L₂ : Litter} {a b : ℕ × φ.needBackwardImages}\n    (ha : a ∈ φ.nextBackwardImageDomain hφ L₁) (hb : b ∈ φ.nextBackwardImageDomain hφ L₂)\n    (hL₁ : L₁ ∈ (φ.litterPerm hφ).domain) (hL₂ : L₂ ∈ (φ.litterPerm hφ).domain)\n    (h : φ.nextBackwardImage hφ L₁ a = φ.nextBackwardImage hφ L₂ b) : L₁ = L₂ := by\n  obtain ⟨m, a⟩ := a\n  obtain ⟨n, b⟩ := b\n  obtain (_ | m) := m <;>\n    obtain (_ | n) := n <;>\n    simp only [nextBackwardImage, nextBackwardImage] at h\n  · simp only [nextBackwardImageDomain, Function.iterate_succ, Function.comp_apply,\n      mem_setOf_eq, Function.iterate_zero, id.def] at ha hb\n    rw [← h, ha.2] at hb\n    exact hb.2\n  · rw [Subtype.coe_eq_iff] at h\n    cases φ.not_mem_needBackwardImages_of_mem_orbitSet ((φ.orbitSetEquiv _).symm _).prop h.1\n  · symm at h\n    rw [Subtype.coe_eq_iff] at h\n    cases φ.not_mem_needBackwardImages_of_mem_orbitSet ((φ.orbitSetEquiv _).symm _).prop h.1\n  · have ha :=\n      φ.orbitSet_subset _ ((φ.orbitSetEquiv (φ.litterPerm hφ L₁)).symm (inl (m, a))).prop\n    have hb :=\n      φ.orbitSet_subset _ ((φ.orbitSetEquiv (φ.litterPerm hφ L₂)).symm (inl (n, b))).prop\n    rw [h] at ha\n    refine' (φ.litterPerm hφ).injOn hL₁ hL₂ _\n    exact eq_of_mem_litterSet_of_mem_litterSet ha.1 hb.1\n", "additional_info": "", "used_premises": [1, 825, 1077, 1077, 1090, 1090, 1070, 1070, 1091, 1091], "def_path": "ConNF/FOA/Action/FillAtomOrbits.lean", "pos": [202, 227], "informalization": "Function `ConNF.NearLitterAction.nextBackwardImage` is used in the context of Constructive Ordinal Notation (ConNF) to compute the next backward image of an element in the set of `ConNF.Atom`s that need backward images under the partial function `ConNF.NearLitterAction.atomMap`. The theorem `ConNF.NearLitterAction.nextBackwardImage_eq` states that for two elements `a` and `b` in the domain of `ConNF.NearLitterAction.nextBackwardImage`, if their next backward images are equal, then the corresponding litters `L₁` and `L₂` must also be equal."}
{"full_name": "ConNF.NearLitterAction.nextBackwardImageDomain", "url": "ConNF/FOA/Action/FillAtomOrbits.html#ConNF.NearLitterAction.nextBackwardImageDomain", "code_src": "con-nf", "ptype": "def", "header": "def ConNF.NearLitterAction.nextBackwardImageDomain [ConNF.Params🔗<|PREMISE|>🔗 ] (φ : ConNF.NearLitterAction) (hφ : ConNF.NearLitterAction.Lawful🔗<|PREMISE|>🔗 φ) (L : ConNF.Litter) :Set🔗<|PREMISE|>🔗 (ℕ × ↑(ConNF.NearLitterAction.needBackwardImages🔗<|PREMISE|>🔗 φ))", "code": "def nextBackwardImageDomain (L : Litter) : Set (ℕ × φ.needBackwardImages) :=\n  {a |\n    (a.2 : Atom).1 ∈ (φ.litterPerm hφ).domain ∧\n      ((φ.litterPerm hφ).symm^[a.1 + 1]) (a.2 : Atom).1 = L}\n", "additional_info": "Equations\n* One or more equations did not get rendered due to their size.\n\n", "used_premises": [1, 825, 69, 1077], "def_path": "ConNF/FOA/Action/FillAtomOrbits.lean", "pos": [175, 179], "informalization": "Function `ConNF.NearLitterAction.nextBackwardImageDomain` computes the set of `ConNF.Atom`s that need backward images under the partial function `ConNF.NearLitterAction.atomMap`. This set is defined as the difference between the domain of the partial function and its range."}
{"full_name": "ConNF.NearLitterAction.nextBackwardImage", "url": "ConNF/FOA/Action/FillAtomOrbits.html#ConNF.NearLitterAction.nextBackwardImage", "code_src": "con-nf", "ptype": "noncomputable def", "header": "noncomputable def ConNF.NearLitterAction.nextBackwardImage [ConNF.Params🔗<|PREMISE|>🔗 ] (φ : ConNF.NearLitterAction) (hφ : ConNF.NearLitterAction.Lawful🔗<|PREMISE|>🔗 φ) (L : ConNF.Litter) :ℕ × ↑(ConNF.NearLitterAction.needBackwardImages🔗<|PREMISE|>🔗 φ) → ConNF.Atom", "code": "noncomputable def nextBackwardImage (L : Litter) : ℕ × φ.needBackwardImages → Atom\n  | (0, a) => a\n  | (n + 1, a) => (φ.orbitSetEquiv (φ.litterPerm hφ L)).symm (inl (n, a))\n", "additional_info": "Equations\n* One or more equations did not get rendered due to their size.\n\n", "used_premises": [1, 825, 1077], "def_path": "ConNF/FOA/Action/FillAtomOrbits.lean", "pos": [168, 171], "informalization": "Function `ConNF.NearLitterAction.nextBackwardImage` is used in the context of Constructive Ordinal Notation (ConNF) to compute the next backward image of an element in the set of `ConNF.Atom`s that need backward images under the partial function `ConNF.NearLitterAction.atomMap`."}
{"full_name": "ConNF.NearLitterAction.nextForwardImage_injective", "url": "ConNF/FOA/Action/FillAtomOrbits.html#ConNF.NearLitterAction.nextForwardImage_injective", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterAction.nextForwardImage_injective [ConNF.Params🔗<|PREMISE|>🔗 ] (φ : ConNF.NearLitterAction) (hφ : ConNF.NearLitterAction.Lawful🔗<|PREMISE|>🔗 φ) {L : ConNF.Litter} {a : ℕ × ↑(ConNF.NearLitterAction.needForwardImages🔗<|PREMISE|>🔗 φ)} {b : ℕ × ↑(ConNF.NearLitterAction.needForwardImages🔗<|PREMISE|>🔗 φ)} (h : ConNF.NearLitterAction.nextForwardImage🔗<|PREMISE|>🔗 φ hφ L a = ConNF.NearLitterAction.nextForwardImage🔗<|PREMISE|>🔗 φ hφ L b) :a = b", "code": "theorem nextForwardImage_injective {L : Litter} {a b : ℕ × φ.needForwardImages}\n    (h : φ.nextForwardImage hφ L a = φ.nextForwardImage hφ L b) : a = b := by\n  simp only [nextForwardImage, Subtype.coe_inj, EmbeddingLike.apply_eq_iff_eq, inr.injEq,\n    Prod.mk.injEq, add_left_inj] at h\n  exact Prod.ext h.1 h.2\n", "additional_info": "", "used_premises": [1, 825, 1075, 1075, 1088, 1088], "def_path": "ConNF/FOA/Action/FillAtomOrbits.lean", "pos": [228, 233], "informalization": "The theorem `ConNF.NearLitterAction.nextForwardImage_injective` states that the function `ConNF.NearLitterAction.nextForwardImage`, which computes the next element in the range of the partial function `φ.atomMap` that is not in its domain, given a lawful near litter action `φ`, a litter `L`, and an element `a` in the set of elements in the range of `φ.atomMap` that are not in its domain, is injective."}
{"full_name": "ConNF.NearLitterAction.nextBackwardImage_injective", "url": "ConNF/FOA/Action/FillAtomOrbits.html#ConNF.NearLitterAction.nextBackwardImage_injective", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterAction.nextBackwardImage_injective [ConNF.Params🔗<|PREMISE|>🔗 ] (φ : ConNF.NearLitterAction) (hφ : ConNF.NearLitterAction.Lawful🔗<|PREMISE|>🔗 φ) {L : ConNF.Litter} {a : ℕ × ↑(ConNF.NearLitterAction.needBackwardImages🔗<|PREMISE|>🔗 φ)} {b : ℕ × ↑(ConNF.NearLitterAction.needBackwardImages🔗<|PREMISE|>🔗 φ)} (ha : a ∈ ConNF.NearLitterAction.nextBackwardImageDomain🔗<|PREMISE|>🔗 φ hφ L) (hb : b ∈ ConNF.NearLitterAction.nextBackwardImageDomain🔗<|PREMISE|>🔗 φ hφ L) (h : ConNF.NearLitterAction.nextBackwardImage🔗<|PREMISE|>🔗 φ hφ L a = ConNF.NearLitterAction.nextBackwardImage🔗<|PREMISE|>🔗 φ hφ L b) :a = b", "code": "theorem nextBackwardImage_injective {L : Litter} {a b : ℕ × φ.needBackwardImages}\n    (ha : a ∈ φ.nextBackwardImageDomain hφ L) (hb : b ∈ φ.nextBackwardImageDomain hφ L)\n    (h : φ.nextBackwardImage hφ L a = φ.nextBackwardImage hφ L b) : a = b := by\n  obtain ⟨m, a⟩ := a\n  obtain ⟨n, b⟩ := b\n  cases m <;> cases n <;>\n    simp only [Prod.mk.inj_iff, EmbeddingLike.apply_eq_iff_eq, nextBackwardImage,\n      true_and_iff, Subtype.coe_inj, inl.injEq, Prod.mk.injEq, Nat.succ.injEq] at h ⊢\n  · exact h\n  · rw [Subtype.coe_eq_iff] at h\n    cases φ.not_mem_needBackwardImages_of_mem_orbitSet ((φ.orbitSetEquiv _).symm _).prop h.1\n  · symm at h\n    rw [Subtype.coe_eq_iff] at h\n    cases φ.not_mem_needBackwardImages_of_mem_orbitSet ((φ.orbitSetEquiv _).symm _).prop h.1\n  · exact h\n", "additional_info": "", "used_premises": [1, 825, 1077, 1077, 1090, 1090, 1091, 1091], "def_path": "ConNF/FOA/Action/FillAtomOrbits.lean", "pos": [234, 249], "informalization": "The theorem `ConNF.NearLitterAction.nextBackwardImage_injective` states that the function `ConNF.NearLitterAction.nextBackwardImage`, which computes the next backward image of an element in the set of `ConNF.Atom`s that need backward images under the partial function `ConNF.NearLitterAction.atomMap`, is injective."}
{"full_name": "ConNF.NearLitterAction.nextForwardImage_injective'", "url": "ConNF/FOA/Action/FillAtomOrbits.html#ConNF.NearLitterAction.nextForwardImage_injective'", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterAction.nextForwardImage_injective' [ConNF.Params🔗<|PREMISE|>🔗 ] (φ : ConNF.NearLitterAction) (hφ : ConNF.NearLitterAction.Lawful🔗<|PREMISE|>🔗 φ) {L₁ : ConNF.Litter} {L₂ : ConNF.Litter} {a : ℕ × ↑(ConNF.NearLitterAction.needForwardImages🔗<|PREMISE|>🔗 φ)} {b : ℕ × ↑(ConNF.NearLitterAction.needForwardImages🔗<|PREMISE|>🔗 φ)} (hL₁ : L₁ ∈ (ConNF.NearLitterAction.litterPerm🔗<|PREMISE|>🔗 φ hφ).domain) (hL₂ : L₂ ∈ (ConNF.NearLitterAction.litterPerm🔗<|PREMISE|>🔗 φ hφ).domain) (h : ConNF.NearLitterAction.nextForwardImage🔗<|PREMISE|>🔗 φ hφ L₁ a = ConNF.NearLitterAction.nextForwardImage🔗<|PREMISE|>🔗 φ hφ L₂ b) :a = b", "code": "theorem nextForwardImage_injective' {L₁ L₂ : Litter} {a b : ℕ × φ.needForwardImages}\n    (hL₁ : L₁ ∈ (φ.litterPerm hφ).domain) (hL₂ : L₂ ∈ (φ.litterPerm hφ).domain)\n    (h : φ.nextForwardImage hφ L₁ a = φ.nextForwardImage hφ L₂ b) : a = b := by\n  cases φ.nextForwardImage_eq hφ hL₁ hL₂ h\n  exact φ.nextForwardImage_injective hφ h\n", "additional_info": "", "used_premises": [1, 825, 1075, 1075, 1070, 1070, 1088, 1088], "def_path": "ConNF/FOA/Action/FillAtomOrbits.lean", "pos": [250, 255], "informalization": "The theorem `ConNF.NearLitterAction.nextForwardImage_injective'` states that the function `ConNF.NearLitterAction.nextForwardImage`, which computes the next element in the range of the partial function `φ.atomMap` that is not in its domain, given a lawful near litter action `φ`, a litter `L`, and an element `a` in the set of elements in the range of `φ.atomMap` that are not in its domain, is injective."}
{"full_name": "ConNF.NearLitterAction.nextBackwardImage_injective'", "url": "ConNF/FOA/Action/FillAtomOrbits.html#ConNF.NearLitterAction.nextBackwardImage_injective'", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterAction.nextBackwardImage_injective' [ConNF.Params🔗<|PREMISE|>🔗 ] (φ : ConNF.NearLitterAction) (hφ : ConNF.NearLitterAction.Lawful🔗<|PREMISE|>🔗 φ) {L₁ : ConNF.Litter} {L₂ : ConNF.Litter} {a : ℕ × ↑(ConNF.NearLitterAction.needBackwardImages🔗<|PREMISE|>🔗 φ)} {b : ℕ × ↑(ConNF.NearLitterAction.needBackwardImages🔗<|PREMISE|>🔗 φ)} (ha : a ∈ ConNF.NearLitterAction.nextBackwardImageDomain🔗<|PREMISE|>🔗 φ hφ L₁) (hb : b ∈ ConNF.NearLitterAction.nextBackwardImageDomain🔗<|PREMISE|>🔗 φ hφ L₂) (hL₁ : L₁ ∈ (ConNF.NearLitterAction.litterPerm🔗<|PREMISE|>🔗 φ hφ).domain) (hL₂ : L₂ ∈ (ConNF.NearLitterAction.litterPerm🔗<|PREMISE|>🔗 φ hφ).domain) (h : ConNF.NearLitterAction.nextBackwardImage🔗<|PREMISE|>🔗 φ hφ L₁ a = ConNF.NearLitterAction.nextBackwardImage🔗<|PREMISE|>🔗 φ hφ L₂ b) :a = b", "code": "theorem nextBackwardImage_injective' {L₁ L₂ : Litter} {a b : ℕ × φ.needBackwardImages}\n    (ha : a ∈ φ.nextBackwardImageDomain hφ L₁) (hb : b ∈ φ.nextBackwardImageDomain hφ L₂)\n    (hL₁ : L₁ ∈ (φ.litterPerm hφ).domain) (hL₂ : L₂ ∈ (φ.litterPerm hφ).domain)\n    (h : φ.nextBackwardImage hφ L₁ a = φ.nextBackwardImage hφ L₂ b) : a = b := by\n  cases φ.nextBackwardImage_eq hφ ha hb hL₁ hL₂ h\n  exact φ.nextBackwardImage_injective hφ ha hb h\n", "additional_info": "", "used_premises": [1, 825, 1077, 1077, 1090, 1090, 1070, 1070, 1091, 1091], "def_path": "ConNF/FOA/Action/FillAtomOrbits.lean", "pos": [256, 262], "informalization": "The function `ConNF.NearLitterAction.nextBackwardImage` is used to compute the next backward image of an element in the set of `ConNF.Atom`s that need backward images under the partial function `ConNF.NearLitterAction.atomMap`. The theorem `ConNF.NearLitterAction.nextBackwardImage_injective'` states that this function is injective under certain conditions."}
{"full_name": "ConNF.NearLitterAction.nextForwardImage_ne_nextBackwardImage", "url": "ConNF/FOA/Action/FillAtomOrbits.html#ConNF.NearLitterAction.nextForwardImage_ne_nextBackwardImage", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterAction.nextForwardImage_ne_nextBackwardImage [ConNF.Params🔗<|PREMISE|>🔗 ] (φ : ConNF.NearLitterAction) (hφ : ConNF.NearLitterAction.Lawful🔗<|PREMISE|>🔗 φ) {L₁ : ConNF.Litter} {L₂ : ConNF.Litter} {a : ℕ × ↑(ConNF.NearLitterAction.needForwardImages🔗<|PREMISE|>🔗 φ)} {b : ℕ × ↑(ConNF.NearLitterAction.needBackwardImages🔗<|PREMISE|>🔗 φ)} :ConNF.NearLitterAction.nextForwardImage🔗<|PREMISE|>🔗 φ hφ L₁ a ≠ ConNF.NearLitterAction.nextBackwardImage🔗<|PREMISE|>🔗 φ hφ L₂ b", "code": "theorem nextForwardImage_ne_nextBackwardImage {L₁ L₂ : Litter} {a : ℕ × φ.needForwardImages}\n    {b : ℕ × φ.needBackwardImages} : φ.nextForwardImage hφ L₁ a ≠ φ.nextBackwardImage hφ L₂ b := by\n  obtain ⟨n, b⟩ := b\n  cases n\n  · rw [nextForwardImage, nextBackwardImage]\n    refine'\n      (ne_of_mem_of_not_mem _ (φ.orbitSet_subset _ ((φ.orbitSetEquiv _).symm _).prop).2).symm\n    exact Or.inl b.prop.1\n  · rw [nextForwardImage, nextBackwardImage]\n    intro h\n    cases (φ.orbitSetEquiv_injective h).2\n", "additional_info": "", "used_premises": [1, 825, 1075, 1077, 1088, 1091], "def_path": "ConNF/FOA/Action/FillAtomOrbits.lean", "pos": [263, 274], "informalization": "The theorem `ConNF.NearLitterAction.nextForwardImage_ne_nextBackwardImage` states that the next element in the range of the partial function `φ.atomMap` that is not in its domain, given a lawful near litter action `φ`, a litter `L`, and an element `a` in the set of elements in the range of `φ.atomMap` that are not in its domain, is not equal to the next backward image of an element in the set of `ConNF.Atom`s that need backward images under the partial function `ConNF.NearLitterAction.atomMap`."}
{"full_name": "ConNF.NearLitterAction.nextImageCoreDomain_small", "url": "ConNF/FOA/Action/FillAtomOrbits.html#ConNF.NearLitterAction.nextImageCoreDomain_small", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterAction.nextImageCoreDomain_small [ConNF.Params🔗<|PREMISE|>🔗 ] (φ : ConNF.NearLitterAction) (hφ : ConNF.NearLitterAction.Lawful🔗<|PREMISE|>🔗 φ) :ConNF.Small🔗<|PREMISE|>🔗 (ConNF.NearLitterAction.nextImageCoreDomain🔗<|PREMISE|>🔗 φ hφ)", "code": "theorem nextImageCoreDomain_small : Small (φ.nextImageCoreDomain hφ) :=\n  Small.bUnion (φ.litterPerm_domain_small hφ)\n    (fun L _ => Small.image (lt_of_le_of_lt (Cardinal.mk_subtype_le _) (φ.orbitSet_small L)))\n", "additional_info": "", "used_premises": [1, 825, 233, 1098], "def_path": "ConNF/FOA/Action/FillAtomOrbits.lean", "pos": [285, 288], "informalization": "The theorem `ConNF.NearLitterAction.nextImageCoreDomain_small` states that the domain of the next image function for a lawful near litter action in the context of Constructive Ordinal Notation (ConNF) is small, meaning its cardinality is strictly less than the cardinality of the type `ConNF.κ`."}
{"full_name": "ConNF.NearLitterAction.nextImageCoreDomain", "url": "ConNF/FOA/Action/FillAtomOrbits.html#ConNF.NearLitterAction.nextImageCoreDomain", "code_src": "con-nf", "ptype": "def", "header": "def ConNF.NearLitterAction.nextImageCoreDomain [ConNF.Params🔗<|PREMISE|>🔗 ] (φ : ConNF.NearLitterAction) (hφ : ConNF.NearLitterAction.Lawful🔗<|PREMISE|>🔗 φ) :Set🔗<|PREMISE|>🔗 ConNF.Atom", "code": "def nextImageCoreDomain : Set Atom :=\n  ⋃ L ∈ (φ.litterPerm hφ).domain, Subtype.val ''\n    {a : φ.orbitSet L |\n      (φ.orbitSetEquiv L a).elim\n        (fun b => b ∈ φ.nextBackwardImageDomain hφ L)\n        (fun b => b ∈ φ.nextForwardImageDomain hφ L)}\n", "additional_info": "Equations\n* One or more equations did not get rendered due to their size.\n\n", "used_premises": [1, 825, 69], "def_path": "ConNF/FOA/Action/FillAtomOrbits.lean", "pos": [278, 284], "informalization": "Function `ConNF.NearLitterAction.nextImageCoreDomain` is used in the context of Constructive Ordinal Notation (ConNF) to define the domain of the next image function for a lawful near litter action. It is defined as the union of the images of the next backward and forward image domains for each litter in the domain of the litter permutation."}
{"full_name": "ConNF.NearLitterAction.litter_map_dom_of_mem_nextImageCoreDomain", "url": "ConNF/FOA/Action/FillAtomOrbits.html#ConNF.NearLitterAction.litter_map_dom_of_mem_nextImageCoreDomain", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterAction.litter_map_dom_of_mem_nextImageCoreDomain [ConNF.Params🔗<|PREMISE|>🔗 ] (φ : ConNF.NearLitterAction) (hφ : ConNF.NearLitterAction.Lawful🔗<|PREMISE|>🔗 φ) {a : ConNF.Atom} (h : a ∈ ConNF.NearLitterAction.nextImageCoreDomain🔗<|PREMISE|>🔗 φ hφ) :a.1 ∈ (ConNF.NearLitterAction.litterPerm🔗<|PREMISE|>🔗 φ hφ).domain", "code": "theorem litter_map_dom_of_mem_nextImageCoreDomain {a : Atom} (h : a ∈ φ.nextImageCoreDomain hφ) :\n    a.1 ∈ (φ.litterPerm hφ).domain := by\n  rw [nextImageCoreDomain] at h\n  simp only [PFun.mem_dom, iUnion_exists, mem_iUnion, mem_image, mem_setOf_eq, SetCoe.exists,\n    Subtype.coe_mk, exists_and_right, exists_eq_right, exists_prop] at h\n  obtain ⟨L, hL, ha, _⟩ := h\n  have := (φ.orbitSet_subset L ha).1\n  rw [mem_litterSet] at this\n  rw [this]\n  exact hL\n", "additional_info": "", "used_premises": [1, 825, 1098, 1070], "def_path": "ConNF/FOA/Action/FillAtomOrbits.lean", "pos": [289, 299], "informalization": "The theorem `ConNF.NearLitterAction.litter_map_dom_of_mem_nextImageCoreDomain` states that if an atom `a` is in the domain of the next image function for a lawful near litter action, then the litter of `a` is in the domain of the litter permutation."}
{"full_name": "ConNF.NearLitterAction.mem_orbitSet_of_mem_nextImageCoreDomain", "url": "ConNF/FOA/Action/FillAtomOrbits.html#ConNF.NearLitterAction.mem_orbitSet_of_mem_nextImageCoreDomain", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterAction.mem_orbitSet_of_mem_nextImageCoreDomain [ConNF.Params🔗<|PREMISE|>🔗 ] (φ : ConNF.NearLitterAction) (hφ : ConNF.NearLitterAction.Lawful🔗<|PREMISE|>🔗 φ) {a : ConNF.Atom} (h : a ∈ ConNF.NearLitterAction.nextImageCoreDomain🔗<|PREMISE|>🔗 φ hφ) :a ∈ ConNF.NearLitterAction.orbitSet🔗<|PREMISE|>🔗 φ a.1", "code": "theorem mem_orbitSet_of_mem_nextImageCoreDomain {a : Atom} (h : a ∈ φ.nextImageCoreDomain hφ) :\n    a ∈ φ.orbitSet a.1 := by\n  rw [nextImageCoreDomain] at h\n  simp only [PFun.mem_dom, iUnion_exists, mem_iUnion, mem_image, mem_setOf_eq, SetCoe.exists,\n    Subtype.coe_mk, exists_and_right, exists_eq_right, exists_prop] at h\n  obtain ⟨L, _, ha, _⟩ := h\n  have := (φ.orbitSet_subset L ha).1\n  rw [mem_litterSet] at this\n  rw [this]\n  exact ha\n", "additional_info": "", "used_premises": [1, 825, 1098, 1082], "def_path": "ConNF/FOA/Action/FillAtomOrbits.lean", "pos": [300, 310], "informalization": "The theorem `ConNF.NearLitterAction.mem_orbitSet_of_mem_nextImageCoreDomain` states that if an atom `a` belongs to the domain of the next image function for a lawful near litter action `φ`, then `a` also belongs to the orbit set of `a` under the action of `φ`."}
{"full_name": "ConNF.NearLitterAction.nextImageDomain_small", "url": "ConNF/FOA/Action/FillAtomOrbits.html#ConNF.NearLitterAction.nextImageDomain_small", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterAction.nextImageDomain_small [ConNF.Params🔗<|PREMISE|>🔗 ] (φ : ConNF.NearLitterAction) (hφ : ConNF.NearLitterAction.Lawful🔗<|PREMISE|>🔗 φ) :ConNF.Small🔗<|PREMISE|>🔗 (ConNF.NearLitterAction.nextImageDomain🔗<|PREMISE|>🔗 φ hφ)", "code": "theorem nextImageDomain_small : Small (φ.nextImageDomain hφ) :=\n  Small.union (Small.mono (inter_subset_left _ _) φ.needForwardImages_small)\n    (φ.nextImageCoreDomain_small hφ)\n", "additional_info": "", "used_premises": [1, 825, 233, 1102], "def_path": "ConNF/FOA/Action/FillAtomOrbits.lean", "pos": [372, 375], "informalization": "The theorem `ConNF.NearLitterAction.nextImageDomain_small` states that the domain of the next image function for a lawful near litter action in the context of Constructive Ordinal Notation (ConNF) is small, meaning its cardinality is strictly less than the cardinality of the type `ConNF.κ`."}
{"full_name": "ConNF.NearLitterAction.nextImageDomain", "url": "ConNF/FOA/Action/FillAtomOrbits.html#ConNF.NearLitterAction.nextImageDomain", "code_src": "con-nf", "ptype": "def", "header": "def ConNF.NearLitterAction.nextImageDomain [ConNF.Params🔗<|PREMISE|>🔗 ] (φ : ConNF.NearLitterAction) (hφ : ConNF.NearLitterAction.Lawful🔗<|PREMISE|>🔗 φ) :Set🔗<|PREMISE|>🔗 ConNF.Atom", "code": "def nextImageDomain : Set Atom :=\n  φ.needForwardImages ∩ {a | a.1 ∈ (φ.litterPerm hφ).domain} ∪ φ.nextImageCoreDomain hφ\n", "additional_info": "Equations\n* One or more equations did not get rendered due to their size.\n\n", "used_premises": [1, 825, 69], "def_path": "ConNF/FOA/Action/FillAtomOrbits.lean", "pos": [364, 366], "informalization": "Function `ConNF.NearLitterAction.nextImageDomain` is used in the context of Constructive Ordinal Notation (ConNF) to define the domain of the next image function for a lawful near litter action. It is defined as the intersection of the set of atoms that need forward images and the set of atoms whose first component is in the domain of the litter permutation, unioned with the next image core domain."}
{"full_name": "ConNF.NearLitterAction.disjoint_needForwardImages_nextImageCoreDomain", "url": "ConNF/FOA/Action/FillAtomOrbits.html#ConNF.NearLitterAction.disjoint_needForwardImages_nextImageCoreDomain", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterAction.disjoint_needForwardImages_nextImageCoreDomain [ConNF.Params🔗<|PREMISE|>🔗 ] (φ : ConNF.NearLitterAction) (hφ : ConNF.NearLitterAction.Lawful🔗<|PREMISE|>🔗 φ) :Disjoint🔗<|PREMISE|>🔗 (ConNF.NearLitterAction.needForwardImages🔗<|PREMISE|>🔗 φ) (ConNF.NearLitterAction.nextImageCoreDomain🔗<|PREMISE|>🔗 φ hφ)", "code": "theorem disjoint_needForwardImages_nextImageCoreDomain :\n    Disjoint φ.needForwardImages (φ.nextImageCoreDomain hφ) := by\n  rw [Set.disjoint_iff]\n  rintro a ⟨ha₁, ha₂⟩\n  exact (φ.orbitSet_subset _ (φ.mem_orbitSet_of_mem_nextImageCoreDomain hφ ha₂)).2 (Or.inr ha₁.1)\n", "additional_info": "", "used_premises": [1, 825, 757, 1075, 1098], "def_path": "ConNF/FOA/Action/FillAtomOrbits.lean", "pos": [376, 381], "informalization": "The theorem states that the set of elements in the range of the partial function `φ.atomMap` that are not in its domain is disjoint from the domain of the next image function for a lawful near litter action."}
{"full_name": "ConNF.NearLitterAction.nextImage_injective", "url": "ConNF/FOA/Action/FillAtomOrbits.html#ConNF.NearLitterAction.nextImage_injective", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterAction.nextImage_injective [ConNF.Params🔗<|PREMISE|>🔗 ] (φ : ConNF.NearLitterAction) (hφ : ConNF.NearLitterAction.Lawful🔗<|PREMISE|>🔗 φ) (a : ConNF.Atom) (b : ConNF.Atom) (ha : a ∈ ConNF.NearLitterAction.nextImageDomain🔗<|PREMISE|>🔗 φ hφ) (hb : b ∈ ConNF.NearLitterAction.nextImageDomain🔗<|PREMISE|>🔗 φ hφ) (h : ConNF.NearLitterAction.nextImage🔗<|PREMISE|>🔗 φ hφ a ha = ConNF.NearLitterAction.nextImage🔗<|PREMISE|>🔗 φ hφ b hb) :a = b", "code": "theorem nextImage_injective (a b : Atom) (ha : a ∈ φ.nextImageDomain hφ)\n    (hb : b ∈ φ.nextImageDomain hφ) (h : φ.nextImage hφ a ha = φ.nextImage hφ b hb) : a = b := by\n  obtain (ha | ha) := ha <;> obtain (hb | hb) := hb\n  · rw [φ.nextImage_eq_of_needForwardImages hφ a ha,\n      φ.nextImage_eq_of_needForwardImages hφ b hb] at h\n    have := φ.orbitSetEquiv_injective h\n    simp only [inr.injEq, Prod.mk.injEq, Subtype.mk.injEq, true_and] at this\n    exact this.2\n  · rw [φ.nextImage_eq_of_needForwardImages hφ a ha,\n      φ.nextImage_eq_of_mem_nextImageCoreDomain hφ b hb] at h\n    cases φ.orbitSetEquiv_ne_nextImageCore hφ _ _ ha hb h\n  · rw [φ.nextImage_eq_of_mem_nextImageCoreDomain hφ a ha,\n      φ.nextImage_eq_of_needForwardImages hφ b hb] at h\n    cases φ.orbitSetEquiv_ne_nextImageCore hφ _ _ hb ha h.symm\n  · rw [φ.nextImage_eq_of_mem_nextImageCoreDomain hφ a ha,\n      φ.nextImage_eq_of_mem_nextImageCoreDomain hφ b hb] at h\n    exact φ.nextImageCore_injective hφ a b ha hb h\n", "additional_info": "", "used_premises": [1, 825, 1102, 1102, 1105, 1105], "def_path": "ConNF/FOA/Action/FillAtomOrbits.lean", "pos": [414, 431], "informalization": "The theorem `ConNF.NearLitterAction.nextImage_injective` states that the next image function for a lawful near litter action in the context of Constructive Ordinal Notation (ConNF) is injective. This means that if two atoms `a` and `b` are in the domain of the next image function and their next images are equal, then `a` must be equal to `b`."}
{"full_name": "ConNF.NearLitterAction.nextImage", "url": "ConNF/FOA/Action/FillAtomOrbits.html#ConNF.NearLitterAction.nextImage", "code_src": "con-nf", "ptype": "noncomputable def", "header": "noncomputable def ConNF.NearLitterAction.nextImage [ConNF.Params🔗<|PREMISE|>🔗 ] (φ : ConNF.NearLitterAction) (hφ : ConNF.NearLitterAction.Lawful🔗<|PREMISE|>🔗 φ) (a : ConNF.Atom) (ha : a ∈ ConNF.NearLitterAction.nextImageDomain🔗<|PREMISE|>🔗 φ hφ) :ConNF.Atom", "code": "noncomputable def nextImage (a : Atom) (ha : a ∈ φ.nextImageDomain hφ) : Atom :=\n  ha.elim'\n    (fun ha' => (φ.orbitSetEquiv (φ.litterPerm hφ a.1)).symm (inr (0, ⟨a, ha'.1⟩)))\n    (φ.nextImageCore hφ a a.1 ∘ φ.mem_orbitSet_of_mem_nextImageCoreDomain hφ)\n", "additional_info": "Equations\n* One or more equations did not get rendered due to their size.\n\n", "used_premises": [1, 825, 1102], "def_path": "ConNF/FOA/Action/FillAtomOrbits.lean", "pos": [367, 371], "informalization": "Function `ConNF.NearLitterAction.nextImage` is used in the context of Constructive Ordinal Notation (ConNF) to define the next image function for a lawful near litter action. It takes an atom `a` and a proof that `a` is in the domain of the next image function, and returns the next image of `a`."}
{"full_name": "ConNF.NearLitterAction.orbitAtomMap_dom_iff", "url": "ConNF/FOA/Action/FillAtomOrbits.html#ConNF.NearLitterAction.orbitAtomMap_dom_iff", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.NearLitterAction.orbitAtomMap_dom_iff [ConNF.Params🔗<|PREMISE|>🔗 ] (φ : ConNF.NearLitterAction) (hφ : ConNF.NearLitterAction.Lawful🔗<|PREMISE|>🔗 φ) (a : ConNF.Atom) :(ConNF.NearLitterAction.orbitAtomMap🔗<|PREMISE|>🔗 φ hφ a).Dom ↔ (φ.atomMap a).Dom ∨ a ∈ ConNF.NearLitterAction.nextImageDomain🔗<|PREMISE|>🔗 φ hφ", "code": "theorem orbitAtomMap_dom_iff (a : Atom) :\n    (φ.orbitAtomMap hφ a).Dom ↔ (φ.atomMap a).Dom ∨ a ∈ φ.nextImageDomain hφ :=\n  Iff.rfl\n", "additional_info": "", "used_premises": [1, 825, 1107, 1102], "def_path": "ConNF/FOA/Action/FillAtomOrbits.lean", "pos": [437, 440], "informalization": "The theorem `ConNF.NearLitterAction.orbitAtomMap_dom_iff` states that the domain of the partial function `ConNF.NearLitterAction.orbitAtomMap` is determined by whether the atom `a` is in the domain of the atom map or in the next image domain of the near-litter action."}
{"full_name": "ConNF.NearLitterAction.orbitAtomMap", "url": "ConNF/FOA/Action/FillAtomOrbits.html#ConNF.NearLitterAction.orbitAtomMap", "code_src": "con-nf", "ptype": "noncomputable def", "header": "noncomputable def ConNF.NearLitterAction.orbitAtomMap [ConNF.Params🔗<|PREMISE|>🔗 ] (φ : ConNF.NearLitterAction) (hφ : ConNF.NearLitterAction.Lawful🔗<|PREMISE|>🔗 φ) :ConNF.Atom →. ConNF.Atom", "code": "noncomputable def orbitAtomMap : Atom →. Atom := fun a =>\n  { Dom := (φ.atomMap a).Dom ∨ a ∈ φ.nextImageDomain hφ\n    get := fun h => Or.elim' h (φ.atomMap a).get (φ.nextImage hφ a) }\n", "additional_info": "Equations\n* One or more equations did not get rendered due to their size.\n\n", "used_premises": [1, 825], "def_path": "ConNF/FOA/Action/FillAtomOrbits.lean", "pos": [432, 435], "informalization": "Function `ConNF.NearLitterAction.orbitAtomMap` is used in the context of Constructive Ordinal Notation (ConNF) to define the orbit of an atom under a near-litter action. It returns a partial function from atoms to atoms, where the domain of the function is determined by whether the atom is in the domain of the atom map or in the next image domain of the near-litter action."}
{"full_name": "ConNF.NearLitterAction.orbitAtomMap_dom", "url": "ConNF/FOA/Action/FillAtomOrbits.html#ConNF.NearLitterAction.orbitAtomMap_dom", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.NearLitterAction.orbitAtomMap_dom [ConNF.Params🔗<|PREMISE|>🔗 ] (φ : ConNF.NearLitterAction) (hφ : ConNF.NearLitterAction.Lawful🔗<|PREMISE|>🔗 φ) :PFun.Dom🔗<|PREMISE|>🔗 (ConNF.NearLitterAction.orbitAtomMap🔗<|PREMISE|>🔗 φ hφ) = PFun.Dom🔗<|PREMISE|>🔗 φ.atomMap ∪ ConNF.NearLitterAction.nextImageDomain🔗<|PREMISE|>🔗 φ hφ", "code": "theorem orbitAtomMap_dom : (φ.orbitAtomMap hφ).Dom = φ.atomMap.Dom ∪ φ.nextImageDomain hφ :=\n  rfl\n", "additional_info": "", "used_premises": [1, 825, 404, 1107, 404, 1102], "def_path": "ConNF/FOA/Action/FillAtomOrbits.lean", "pos": [442, 444], "informalization": "The domain of the partial function `ConNF.NearLitterAction.orbitAtomMap` is the union of the domain of the atom map `φ.atomMap` and the next image domain `ConNF.NearLitterAction.nextImageDomain φ hφ`."}
{"full_name": "ConNF.NearLitterAction.disjoint_atomMap_dom_nextImageDomain", "url": "ConNF/FOA/Action/FillAtomOrbits.html#ConNF.NearLitterAction.disjoint_atomMap_dom_nextImageDomain", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterAction.disjoint_atomMap_dom_nextImageDomain [ConNF.Params🔗<|PREMISE|>🔗 ] (φ : ConNF.NearLitterAction) (hφ : ConNF.NearLitterAction.Lawful🔗<|PREMISE|>🔗 φ) :Disjoint🔗<|PREMISE|>🔗 (PFun.Dom🔗<|PREMISE|>🔗 φ.atomMap) (ConNF.NearLitterAction.nextImageDomain🔗<|PREMISE|>🔗 φ hφ)", "code": "theorem disjoint_atomMap_dom_nextImageDomain : Disjoint φ.atomMap.Dom (φ.nextImageDomain hφ) := by\n  rw [Set.disjoint_iff]\n  rintro a ⟨h₁, h₂ | h₂⟩\n  · exact h₂.1.2 h₁\n  · exact (φ.orbitSet_subset _ (φ.mem_orbitSet_of_mem_nextImageCoreDomain hφ h₂)).2 (Or.inl h₁)\n", "additional_info": "", "used_premises": [1, 825, 757, 404, 1102], "def_path": "ConNF/FOA/Action/FillAtomOrbits.lean", "pos": [445, 450], "informalization": "The theorem `ConNF.NearLitterAction.disjoint_atomMap_dom_nextImageDomain` states that the domain of the atom map of a lawful near litter action in the context of Constructive Ordinal Notation (ConNF) is disjoint from the domain of the next image function."}
{"full_name": "ConNF.NearLitterAction.orbitAtomMap_dom_small", "url": "ConNF/FOA/Action/FillAtomOrbits.html#ConNF.NearLitterAction.orbitAtomMap_dom_small", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterAction.orbitAtomMap_dom_small [ConNF.Params🔗<|PREMISE|>🔗 ] (φ : ConNF.NearLitterAction) (hφ : ConNF.NearLitterAction.Lawful🔗<|PREMISE|>🔗 φ) :ConNF.Small🔗<|PREMISE|>🔗 (PFun.Dom🔗<|PREMISE|>🔗 (ConNF.NearLitterAction.orbitAtomMap🔗<|PREMISE|>🔗 φ hφ))", "code": "theorem orbitAtomMap_dom_small : Small (φ.orbitAtomMap hφ).Dom :=\n  Small.union φ.atomMap_dom_small (φ.nextImageDomain_small hφ)\n", "additional_info": "", "used_premises": [1, 825, 233, 404, 1107], "def_path": "ConNF/FOA/Action/FillAtomOrbits.lean", "pos": [479, 481], "informalization": "The theorem `ConNF.NearLitterAction.orbitAtomMap_dom_small` states that the domain of the partial function `ConNF.NearLitterAction.orbitAtomMap`, which represents the orbit of an atom under a near-litter action in the context of Constructive Ordinal Notation (ConNF), is a small set, meaning its cardinality is strictly less than the cardinality of the type `ConNF.κ`."}
{"full_name": "ConNF.NearLitterAction.orbitAtomMap_injective", "url": "ConNF/FOA/Action/FillAtomOrbits.html#ConNF.NearLitterAction.orbitAtomMap_injective", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterAction.orbitAtomMap_injective [ConNF.Params🔗<|PREMISE|>🔗 ] (φ : ConNF.NearLitterAction) (hφ : ConNF.NearLitterAction.Lawful🔗<|PREMISE|>🔗 φ) ⦃a : ConNF.Atom⦄ ⦃b : ConNF.Atom⦄ (ha : (ConNF.NearLitterAction.orbitAtomMap🔗<|PREMISE|>🔗 φ hφ a).Dom) (hb : (ConNF.NearLitterAction.orbitAtomMap🔗<|PREMISE|>🔗 φ hφ b).Dom) (h : (ConNF.NearLitterAction.orbitAtomMap🔗<|PREMISE|>🔗 φ hφ a).get ha = (ConNF.NearLitterAction.orbitAtomMap🔗<|PREMISE|>🔗 φ hφ b).get hb) :a = b", "code": "theorem orbitAtomMap_injective ⦃a b : Atom⦄ (ha : (φ.orbitAtomMap hφ a).Dom)\n    (hb : (φ.orbitAtomMap hφ b).Dom)\n    (h : (φ.orbitAtomMap hφ a).get ha = (φ.orbitAtomMap hφ b).get hb) : a = b := by\n  obtain (ha | ha) := ha <;> obtain (hb | hb) := hb\n  · rw [orbitAtomMap_eq_of_mem_dom, orbitAtomMap_eq_of_mem_dom] at h\n    exact hφ.atomMap_injective ha hb h\n  · cases φ.orbitAtomMap_apply_ne hφ ha hb h\n  · cases φ.orbitAtomMap_apply_ne hφ hb ha h.symm\n  · rw [orbitAtomMap_eq_of_mem_nextImageDomain, orbitAtomMap_eq_of_mem_nextImageDomain] at h\n    exact φ.nextImage_injective hφ a b ha hb h\n", "additional_info": "", "used_premises": [1, 825, 1107, 1107, 1107, 1107], "def_path": "ConNF/FOA/Action/FillAtomOrbits.lean", "pos": [523, 533], "informalization": "The theorem `ConNF.NearLitterAction.orbitAtomMap_injective` states that the orbit of an atom under a lawful near-litter action in the context of Constructive Ordinal Notation (ConNF) is injective. This means that if two atoms have the same image under the orbit map, then they must be equal."}
{"full_name": "ConNF.NearLitterAction.orbit_atom_mem", "url": "ConNF/FOA/Action/FillAtomOrbits.html#ConNF.NearLitterAction.orbit_atom_mem", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterAction.orbit_atom_mem [ConNF.Params🔗<|PREMISE|>🔗 ] (φ : ConNF.NearLitterAction) (hφ : ConNF.NearLitterAction.Lawful🔗<|PREMISE|>🔗 φ) (hdiff : ∀ (L : ConNF.Litter) (hL : (φ.litterMap L).Dom), symmDiff🔗<|PREMISE|>🔗 (↑((φ.litterMap L).get hL)) (ConNF.litterSet🔗<|PREMISE|>🔗 ((φ.litterMap L).get hL).fst) ⊆ PFun.ran🔗<|PREMISE|>🔗 φ.atomMap) (a : ConNF.Atom) (ha : (ConNF.NearLitterAction.orbitAtomMap🔗<|PREMISE|>🔗 φ hφ a).Dom) (L : ConNF.Litter) (hL : (φ.litterMap L).Dom) :a.1 = L ↔ (ConNF.NearLitterAction.orbitAtomMap🔗<|PREMISE|>🔗 φ hφ a).get ha ∈ (φ.litterMap L).get hL", "code": "theorem orbit_atom_mem\n    (hdiff : ∀ L hL,\n      ((φ.litterMap L).get hL : Set Atom) ∆ litterSet ((φ.litterMap L).get hL).1 ⊆ φ.atomMap.ran)\n    (a : Atom) (ha : (φ.orbitAtomMap hφ a).Dom) (L : Litter) (hL : (φ.litterMap L).Dom) :\n    a.fst = L ↔ (φ.orbitAtomMap hφ a).get ha ∈ (φ.litterMap L).get hL := by\n  obtain ha | ha | ha := ha\n  · rw [orbitAtomMap_eq_of_mem_dom]\n    exact hφ.atom_mem a ha L hL\n  · rw [φ.orbitAtomMap_eq_of_needForwardImages hφ a ha]\n    exact φ.orbitSetEquiv_atom_mem hφ hdiff a ha L hL\n  · rw [φ.orbitAtomMap_eq_of_mem_nextImageCoreDomain hφ a ha]\n    rw [φ.nextImageCore_atom_mem hφ hdiff a ha L hL]\n", "additional_info": "", "used_premises": [1, 825, 62, 467, 824, 1107, 1107], "def_path": "ConNF/FOA/Action/FillAtomOrbits.lean", "pos": [636, 648], "informalization": "The theorem states that if an atom `a` is in a specific litter `L`, then its orbit under a lawful near-litter action `φ` is also in the same litter `L`. The implication is proven by showing that the symmetric difference of the orbit and the litter set of `L` is a subset of the range of the atom map, which implies that the orbit is either in the domain of the atom map or in the next image domain of the near-litter action. Given that the near-litter action is lawful, the orbit must be in the domain of the atom map, and thus in the litter set of `L`."}
{"full_name": "ConNF.NearLitterAction.fillAtomOrbitsLawful", "url": "ConNF/FOA/Action/FillAtomOrbits.html#ConNF.NearLitterAction.fillAtomOrbitsLawful", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterAction.fillAtomOrbitsLawful [ConNF.Params🔗<|PREMISE|>🔗 ] (φ : ConNF.NearLitterAction) (hφ : ConNF.NearLitterAction.Lawful🔗<|PREMISE|>🔗 φ) (hdiff : ∀ (L : ConNF.Litter) (hL : (φ.litterMap L).Dom), symmDiff🔗<|PREMISE|>🔗 (↑((φ.litterMap L).get hL)) (ConNF.litterSet🔗<|PREMISE|>🔗 ((φ.litterMap L).get hL).fst) ⊆ PFun.ran🔗<|PREMISE|>🔗 φ.atomMap) :ConNF.NearLitterAction.Lawful🔗<|PREMISE|>🔗 (ConNF.NearLitterAction.fillAtomOrbits🔗<|PREMISE|>🔗 φ hφ)", "code": "theorem fillAtomOrbitsLawful\n    (hdiff : ∀ L hL,\n      ((φ.litterMap L).get hL : Set Atom) ∆ litterSet ((φ.litterMap L).get hL).1 ⊆ φ.atomMap.ran) :\n    (φ.fillAtomOrbits hφ).Lawful :=\n  { atomMap_injective := φ.orbitAtomMap_injective hφ\n    litterMap_injective := hφ.litterMap_injective\n    atom_mem := φ.orbit_atom_mem hφ hdiff }\n", "additional_info": "", "used_premises": [1, 825, 62, 467, 824, 825, 1114], "def_path": "ConNF/FOA/Action/FillAtomOrbits.lean", "pos": [656, 663], "informalization": "`ConNF.NearLitterAction.fillAtomOrbitsLawful` is a theorem in the context of Constructive Ordinal Notation (ConNF) in Lean 4. It states that if we have a lawful near litter action `φ` and a condition `hdiff` on the symmetric difference of the image of the litter map and the litter set, then the filled near litter action `ConNF.NearLitterAction.fillAtomOrbits φ hφ` is also lawful."}
{"full_name": "ConNF.NearLitterAction.fillAtomOrbits", "url": "ConNF/FOA/Action/FillAtomOrbits.html#ConNF.NearLitterAction.fillAtomOrbits", "code_src": "con-nf", "ptype": "noncomputable def", "header": "noncomputable def ConNF.NearLitterAction.fillAtomOrbits [ConNF.Params🔗<|PREMISE|>🔗 ] (φ : ConNF.NearLitterAction) (hφ : ConNF.NearLitterAction.Lawful🔗<|PREMISE|>🔗 φ) :ConNF.NearLitterAction", "code": "noncomputable def fillAtomOrbits : NearLitterAction\n    where\n  atomMap := φ.orbitAtomMap hφ\n  litterMap := φ.litterMap\n  atomMap_dom_small := φ.orbitAtomMap_dom_small hφ\n  litterMap_dom_small := φ.litterMap_dom_small\n", "additional_info": "Equations\n* 🗟ConNF.NearLitterAction.fillAtomOrbits🗟🔗../../.././ConNF/FOA/Action/FillAtomOrbits.html#ConNF.NearLitterAction.fillAtomOrbits🔗  φ hφ 🗟=🗟🔗../../.././Init/Prelude.html#Eq🔗  { atomMap := 🗟ConNF.NearLitterAction.orbitAtomMap🗟🔗../../.././ConNF/FOA/Action/FillAtomOrbits.html#ConNF.NearLitterAction.orbitAtomMap🔗  φ hφ, litterMap := φ.litterMap, atomMap_dom_small := ⋯,\n litterMap_dom_small := ⋯ }\n\n", "used_premises": [1, 825], "def_path": "ConNF/FOA/Action/FillAtomOrbits.lean", "pos": [649, 655], "informalization": "Function `ConNF.NearLitterAction.fillAtomOrbits` is a noncomputable definition in the context of Constructive Ordinal Notation (ConNF) in Lean 4. It takes as input a lawful near litter action `φ` and returns a new near litter action where the domain of the atom map is extended to include all possible orbits of atoms under the action of the near litter action."}
{"full_name": "ConNF.NearLitterAction.fillAtomOrbits_atomMap", "url": "ConNF/FOA/Action/FillAtomOrbits.html#ConNF.NearLitterAction.fillAtomOrbits_atomMap", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.NearLitterAction.fillAtomOrbits_atomMap [ConNF.Params🔗<|PREMISE|>🔗 ] {φ : ConNF.NearLitterAction} (hφ : ConNF.NearLitterAction.Lawful🔗<|PREMISE|>🔗 φ) :(ConNF.NearLitterAction.fillAtomOrbits🔗<|PREMISE|>🔗 φ hφ).atomMap = ConNF.NearLitterAction.orbitAtomMap🔗<|PREMISE|>🔗 φ hφ", "code": "theorem fillAtomOrbits_atomMap : (φ.fillAtomOrbits hφ).atomMap = φ.orbitAtomMap hφ :=\n  rfl\n", "additional_info": "", "used_premises": [1, 825, 1114, 1107], "def_path": "ConNF/FOA/Action/FillAtomOrbits.lean", "pos": [667, 669], "informalization": "The theorem `ConNF.NearLitterAction.fillAtomOrbits_atomMap` states that the atom map of the filled near-litter action `ConNF.NearLitterAction.fillAtomOrbits φ hφ` is equal to the orbit atom map `ConNF.NearLitterAction.orbitAtomMap φ hφ`."}
{"full_name": "ConNF.NearLitterAction.fillAtomOrbits_litterMap", "url": "ConNF/FOA/Action/FillAtomOrbits.html#ConNF.NearLitterAction.fillAtomOrbits_litterMap", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.NearLitterAction.fillAtomOrbits_litterMap [ConNF.Params🔗<|PREMISE|>🔗 ] {φ : ConNF.NearLitterAction} (hφ : ConNF.NearLitterAction.Lawful🔗<|PREMISE|>🔗 φ) :(ConNF.NearLitterAction.fillAtomOrbits🔗<|PREMISE|>🔗 φ hφ).litterMap = φ.litterMap", "code": "theorem fillAtomOrbits_litterMap : (φ.fillAtomOrbits hφ).litterMap = φ.litterMap :=\n  rfl\n", "additional_info": "", "used_premises": [1, 825, 1114], "def_path": "ConNF/FOA/Action/FillAtomOrbits.lean", "pos": [671, 673], "informalization": "The theorem `ConNF.NearLitterAction.fillAtomOrbits_litterMap` states that the litter map of a lawful near litter action remains unchanged after extending the domain of the atom map to include all possible orbits of atoms under the action of the near litter action."}
{"full_name": "ConNF.NearLitterAction.subset_orbitAtomMap_dom", "url": "ConNF/FOA/Action/FillAtomOrbits.html#ConNF.NearLitterAction.subset_orbitAtomMap_dom", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterAction.subset_orbitAtomMap_dom [ConNF.Params🔗<|PREMISE|>🔗 ] {φ : ConNF.NearLitterAction} (hφ : ConNF.NearLitterAction.Lawful🔗<|PREMISE|>🔗 φ) :PFun.Dom🔗<|PREMISE|>🔗 φ.atomMap ⊆ PFun.Dom🔗<|PREMISE|>🔗 (ConNF.NearLitterAction.orbitAtomMap🔗<|PREMISE|>🔗 φ hφ)", "code": "theorem subset_orbitAtomMap_dom : φ.atomMap.Dom ⊆ (φ.orbitAtomMap hφ).Dom :=\n  subset_union_left _ _\n", "additional_info": "", "used_premises": [1, 825, 404, 404, 1107], "def_path": "ConNF/FOA/Action/FillAtomOrbits.lean", "pos": [674, 676], "informalization": "The theorem `ConNF.NearLitterAction.subset_orbitAtomMap_dom` states that the domain of the atom map of a lawful near-litter action is a subset of the domain of the orbit atom map. This means that if an atom is in the domain of the atom map, it is also in the domain of the orbit atom map."}
{"full_name": "ConNF.NearLitterAction.subset_orbitAtomMap_ran", "url": "ConNF/FOA/Action/FillAtomOrbits.html#ConNF.NearLitterAction.subset_orbitAtomMap_ran", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterAction.subset_orbitAtomMap_ran [ConNF.Params🔗<|PREMISE|>🔗 ] {φ : ConNF.NearLitterAction} (hφ : ConNF.NearLitterAction.Lawful🔗<|PREMISE|>🔗 φ) :PFun.ran🔗<|PREMISE|>🔗 φ.atomMap ⊆ PFun.ran🔗<|PREMISE|>🔗 (ConNF.NearLitterAction.orbitAtomMap🔗<|PREMISE|>🔗 φ hφ)", "code": "theorem subset_orbitAtomMap_ran : φ.atomMap.ran ⊆ (φ.orbitAtomMap hφ).ran := by\n  rintro _ ⟨a, ha, rfl⟩\n  exact ⟨a, subset_orbitAtomMap_dom hφ ha, φ.orbitAtomMap_eq_of_mem_dom hφ _ _⟩\n", "additional_info": "", "used_premises": [1, 825, 824, 824, 1107], "def_path": "ConNF/FOA/Action/FillAtomOrbits.lean", "pos": [677, 680], "informalization": "In the context of Constructive Ordinal Notation (ConNF), this theorem states that the range of the atom map, which represents the set of atoms that are mapped to by the near-litter action, is a subset of the range of the orbit atom map. This orbit atom map is defined as the orbit of an atom under the near-litter action, considering the domain of the atom map and the next image domain of the near-litter action."}
{"full_name": "ConNF.NearLitterAction.fst_mem_litterPerm_domain_of_mem_map", "url": "ConNF/FOA/Action/FillAtomOrbits.html#ConNF.NearLitterAction.fst_mem_litterPerm_domain_of_mem_map", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterAction.fst_mem_litterPerm_domain_of_mem_map [ConNF.Params🔗<|PREMISE|>🔗 ] {φ : ConNF.NearLitterAction} (hφ : ConNF.NearLitterAction.Lawful🔗<|PREMISE|>🔗 φ) ⦃L : ConNF.Litter⦄ (hL : (φ.litterMap L).Dom) ⦃a : ConNF.Atom⦄ (ha : a ∈ (φ.litterMap L).get hL) :a.1 ∈ (ConNF.NearLitterAction.litterPerm🔗<|PREMISE|>🔗 φ hφ).domain", "code": "theorem fst_mem_litterPerm_domain_of_mem_map ⦃L : Litter⦄ (hL : (φ.litterMap L).Dom) ⦃a : Atom⦄\n    (ha : a ∈ (φ.litterMap L).get hL) : a.1 ∈ (φ.litterPerm hφ).domain := by\n  by_cases h : a.1 = ((φ.litterMap L).get hL).1\n  · rw [h]\n    refine' Or.inl (Or.inl (Or.inr ⟨L, hL, _⟩))\n    rw [roughLitterMapOrElse_of_dom]\n  · by_cases h' : a.fst ∈ (φ.litterPerm' hφ).domain\n    exact Or.inl h'\n    exact Or.inr ⟨BannedLitter.diff L hL a ⟨ha, h⟩, h'⟩\n", "additional_info": "", "used_premises": [1, 825, 1070], "def_path": "ConNF/FOA/Action/FillAtomOrbits.lean", "pos": [681, 690], "informalization": "This theorem states that if `L` is a litter and `a` is an atom that belongs to the image of `L` under the litter map `φ`, then the first component of `a` (which is a natural number) belongs to the domain of the litter permutation `ConNF.NearLitterAction.litterPerm φ hφ`. This is a useful result because it allows us to apply the litter permutation to the first component of `a`, which is crucial for recursive definitions in the ConNF library."}
{"full_name": "ConNF.NearLitterAction.fst_mem_litterPerm_domain_of_dom", "url": "ConNF/FOA/Action/FillAtomOrbits.html#ConNF.NearLitterAction.fst_mem_litterPerm_domain_of_dom", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterAction.fst_mem_litterPerm_domain_of_dom [ConNF.Params🔗<|PREMISE|>🔗 ] {φ : ConNF.NearLitterAction} (hφ : ConNF.NearLitterAction.Lawful🔗<|PREMISE|>🔗 φ) ⦃a : ConNF.Atom⦄ (ha : a ∈ PFun.Dom🔗<|PREMISE|>🔗 φ.atomMap) :a.1 ∈ (ConNF.NearLitterAction.litterPerm🔗<|PREMISE|>🔗 φ hφ).domain", "code": "theorem fst_mem_litterPerm_domain_of_dom ⦃a : Atom⦄ (ha : a ∈ φ.atomMap.Dom) :\n    a.fst ∈ (φ.litterPerm hφ).domain := by\n  by_cases h' : a.fst ∈ (φ.litterPerm' hφ).domain\n  exact Or.inl h'\n  exact Or.inr ⟨BannedLitter.atomDom a ha, h'⟩\n", "additional_info": "", "used_premises": [1, 825, 404, 1070], "def_path": "ConNF/FOA/Action/FillAtomOrbits.lean", "pos": [691, 696], "informalization": "The theorem `ConNF.NearLitterAction.fst_mem_litterPerm_domain_of_dom` states that if `a` is an element of the domain of the partial function `φ.atomMap`, then the first component of `a`, denoted as `a.1`, is an element of the domain of the partial permutation `ConNF.NearLitterAction.litterPerm φ hφ`."}
{"full_name": "ConNF.NearLitterAction.fst_mem_litterPerm_domain_of_ran", "url": "ConNF/FOA/Action/FillAtomOrbits.html#ConNF.NearLitterAction.fst_mem_litterPerm_domain_of_ran", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterAction.fst_mem_litterPerm_domain_of_ran [ConNF.Params🔗<|PREMISE|>🔗 ] {φ : ConNF.NearLitterAction} (hφ : ConNF.NearLitterAction.Lawful🔗<|PREMISE|>🔗 φ) ⦃a : ConNF.Atom⦄ (ha : a ∈ PFun.ran🔗<|PREMISE|>🔗 φ.atomMap) :a.1 ∈ (ConNF.NearLitterAction.litterPerm🔗<|PREMISE|>🔗 φ hφ).domain", "code": "theorem fst_mem_litterPerm_domain_of_ran ⦃a : Atom⦄ (ha : a ∈ φ.atomMap.ran) :\n    a.fst ∈ (φ.litterPerm hφ).domain := by\n  by_cases h' : a.fst ∈ (φ.litterPerm' hφ).domain\n  exact Or.inl h'\n  obtain ⟨b, hb, rfl⟩ := ha\n  exact Or.inr ⟨BannedLitter.atomMap b hb, h'⟩\n", "additional_info": "", "used_premises": [1, 825, 824, 1070], "def_path": "ConNF/FOA/Action/FillAtomOrbits.lean", "pos": [697, 703], "informalization": "The theorem `ConNF.NearLitterAction.fst_mem_litterPerm_domain_of_ran` proves that given a lawful near litter action `φ` in the context of Constructive Ordinal Notation (ConNF), for any atom `a` in the range of the atom map `φ.atomMap`, the first component of `a` is in the domain of the permutation of litters `ConNF.NearLitterAction.litterPerm φ hφ`. This theorem is crucial for ensuring that the near litter action is well-defined."}
{"full_name": "ConNF.NearLitterAction.fillAtomOrbits_precise", "url": "ConNF/FOA/Action/FillAtomOrbits.html#ConNF.NearLitterAction.fillAtomOrbits_precise", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterAction.fillAtomOrbits_precise [ConNF.Params🔗<|PREMISE|>🔗 ] {φ : ConNF.NearLitterAction} (hφ : ConNF.NearLitterAction.Lawful🔗<|PREMISE|>🔗 φ) (hdiff : ∀ (L : ConNF.Litter) (hL : (φ.litterMap L).Dom), symmDiff🔗<|PREMISE|>🔗 (↑((φ.litterMap L).get hL)) (ConNF.litterSet🔗<|PREMISE|>🔗 ((φ.litterMap L).get hL).fst) ⊆ PFun.ran🔗<|PREMISE|>🔗 φ.atomMap) :ConNF.NearLitterAction.Precise🔗<|PREMISE|>🔗 (ConNF.NearLitterAction.fillAtomOrbits🔗<|PREMISE|>🔗 φ hφ)", "code": "theorem fillAtomOrbits_precise\n    (hdiff : ∀ L hL,\n      ((φ.litterMap L).get hL : Set Atom) ∆ litterSet ((φ.litterMap L).get hL).1 ⊆ φ.atomMap.ran) :\n    Precise (φ.fillAtomOrbits hφ) := by\n  intro L hL\n  constructor\n  · exact subset_trans (hdiff L hL) (subset_orbitAtomMap_ran hφ)\n  · intro a ha ha'\n    simp only [fillAtomOrbits_atomMap, fillAtomOrbits_litterMap, mem_litterSet,\n      orbitAtomMap_dom_iff] at *\n    obtain ha | ha | ha := ha\n    · have := φ.orbitAtomMap_eq_of_mem_dom hφ a ha\n      rw [this, or_iff_not_imp_left]\n      intro hmap\n      have hfwd : (φ.atomMap a).get ha ∈ φ.needForwardImages := ⟨⟨a, _, rfl⟩, hmap⟩\n      refine' Or.inl ⟨hfwd, Or.inl (Or.inl _)⟩\n      refine' mem_of_eq_of_mem _ (Or.inl hL)\n      rw [← ha', this]\n    · refine' Or.inr (Or.inr ⟨_, ⟨L, rfl⟩, _⟩)\n      simp only [PFun.mem_dom, iUnion_exists, mem_iUnion, mem_image, mem_setOf_eq, SetCoe.exists,\n        Subtype.coe_mk, exists_and_right, exists_eq_right, exists_prop]\n      have haL : L = φ.litterPerm hφ a.fst\n      · have := (congr_arg Prod.fst\n          (φ.orbitAtomMap_eq_of_needForwardImages hφ a ha)).symm.trans ha'\n        rw [← this]\n        exact (φ.orbitSet_subset _ ((φ.orbitSetEquiv _).symm _).prop).1\n      refine' ⟨Or.inl (Or.inl (Or.inl hL)), _, _⟩\n      · refine' mem_of_eq_of_mem (φ.orbitAtomMap_eq_of_needForwardImages hφ a ha) _\n        rw [haL]\n        exact ((φ.orbitSetEquiv _).symm _).prop\n      · have := φ.orbitAtomMap_eq_of_needForwardImages hφ a ha\n        obtain ⟨hm₁, hm₂⟩ := Subtype.coe_eq_iff.mp this.symm\n        rw [Equiv.symm_apply_eq, φ.orbitSetEquiv_congr hm₁ haL.symm] at hm₂\n        refine' mem_of_eq_of_mem hm₂.symm _\n        change\n          Sum.elim (fun b => b ∈ φ.nextBackwardImageDomain hφ L)\n            (fun b => b ∈ φ.nextForwardImageDomain hφ L) (inr (0, ⟨a, ha.1⟩))\n        refine' ⟨ha.2, _⟩\n        simp only [Subtype.coe_mk, Function.iterate_one]\n        exact haL.symm\n    · have := φ.orbitAtomMap_eq_of_mem_nextImageCoreDomain hφ a ha\n      rw [this, nextImageCore]\n      obtain ⟨_, ⟨L', rfl⟩, _, ⟨hL', rfl⟩, a, hbL, rfl⟩ := ha\n      set b := φ.orbitSetEquiv L' a with hb\n      clear_value b\n      simp only [mem_setOf_eq] at hbL\n      rw [← hb] at hbL\n      have haL' := (φ.orbitSet_subset _ a.prop).1\n      rw [mem_litterSet] at haL'\n      have := φ.orbitSetEquiv_congr (φ.mem_orbitSet_of_mem_nextImageCoreDomain hφ ?_)\n        (φ.orbitSet_subset _ a.prop).1\n      rw [Subtype.coe_eta] at this\n      rw [this, ← hb]\n      obtain ⟨_ | n, b⟩ | ⟨n, b⟩ := b <;>\n        simp only [needBackwardImages, needForwardImages, elim_inl, elim_inr,\n          nextBackwardImage, nextForwardImage] at hbL ⊢\n      · exact Or.inl b.prop.1\n      · refine' Or.inr (Or.inr _)\n        have hbL' := hbL.2\n        symm at hbL'\n        rw [Function.iterate_succ_apply',\n          PartialPerm.eq_symm_apply _ hL' ((φ.litterPerm hφ).symm.iterate_domain hbL.1)] at hbL'\n        refine' ⟨_, ⟨((φ.litterPerm hφ).symm^[n + 1]) (b : Atom).1, rfl⟩, _, ⟨_, rfl⟩,\n          ⟨(φ.orbitSetEquiv (φ.litterPerm hφ (a : Atom).1)).symm (inl (n, b)), _⟩, _⟩\n        · exact (φ.litterPerm hφ).symm.iterate_domain hbL.1\n        · rw [← hbL']\n          have := ((φ.orbitSetEquiv (φ.litterPerm hφ (a : Atom).1)).symm (inl (n, b))).prop\n          rw [haL'] at this ⊢\n          exact this\n        · simp only [Function.comp_apply, mem_setOf_eq, Subtype.coe_mk, eq_self_iff_true,\n            and_true_iff]\n          rw [φ.orbitSetEquiv_congr _ hbL'.symm,\n            φ.orbitSetEquiv_congr _ (congr_arg (φ.litterPerm hφ) haL'.symm)]\n          simp only [Subtype.coe_eta, Equiv.apply_symm_apply, elim_inl]\n          exact ⟨⟨hbL.1, rfl⟩, rfl⟩\n      · refine' Or.inr (Or.inr _)\n        refine'\n          ⟨_, ⟨(φ.litterPerm hφ)^[n + 2] (b : Atom).1, rfl⟩, _, ⟨_, rfl⟩,\n            ⟨(φ.orbitSetEquiv (φ.litterPerm hφ (a : Atom).1)).symm (inr (n + 1, b)), _⟩, _⟩\n        · exact (φ.litterPerm hφ).iterate_domain hbL.1\n        · rw [Function.iterate_succ_apply', hbL.2, haL']\n          exact ((φ.orbitSetEquiv _).symm _).prop\n        · simp only [Function.comp_apply, mem_setOf_eq, Subtype.coe_mk, eq_self_iff_true,\n            and_true_iff]\n          have := congr_arg (φ.litterPerm hφ) hbL.2\n          rw [← Function.iterate_succ_apply' (φ.litterPerm hφ) (n + 1)] at this\n          rw [φ.orbitSetEquiv_congr _ this,\n            φ.orbitSetEquiv_congr _ (congr_arg (φ.litterPerm hφ) haL'.symm)]\n          simp only [Function.iterate_succ, Function.comp_apply, Subtype.coe_eta,\n            Equiv.apply_symm_apply, elim_inr]\n          exact ⟨⟨hbL.1, rfl⟩, rfl⟩\n      · refine' ⟨_, ⟨L', rfl⟩, _, ⟨hL', rfl⟩, a, _, rfl⟩\n        rw [mem_setOf_eq, ← hb]\n        exact hbL\n  · rw [fillAtomOrbits_litterMap] at hL\n    rintro a ⟨ha₁ | ⟨ha₁, _⟩ | ha₁, ha₂⟩ <;>\n      simp only [fillAtomOrbits_atomMap, fillAtomOrbits_litterMap, orbitAtomMap_dom,\n        mem_inter_iff, mem_union, SetLike.mem_coe] at *\n    · by_cases ha₃ : a ∈ φ.atomMap.ran\n      · obtain ⟨b, hb₁, hb₂⟩ := ha₃\n        refine' ⟨b, Or.inl hb₁, _⟩\n        rw [orbitAtomMap_eq_of_mem_dom]\n        exact hb₂\n      · refine' ⟨(φ.orbitSetEquiv ((φ.litterPerm hφ).symm a.1)).symm (inl (0, ⟨a, ha₁, ha₃⟩)), _, _⟩\n        · refine' Or.inr (Or.inr ⟨_, ⟨(φ.litterPerm hφ).symm a.1, rfl⟩, _, ⟨_, rfl⟩, _⟩)\n          · exact (φ.litterPerm hφ).symm.map_domain\n              (fst_mem_litterPerm_domain_of_mem_map hφ hL ha₂)\n          refine' ⟨_, _, rfl⟩\n          simp only [mem_setOf_eq, Equiv.apply_symm_apply, elim_inl]\n          exact ⟨fst_mem_litterPerm_domain_of_mem_map hφ hL ha₂, rfl⟩\n        · have : ((φ.orbitSetEquiv ((φ.litterPerm hφ).symm a.fst)).symm\n            (inl (0, ⟨a, _⟩)) : Atom).fst = (φ.litterPerm hφ).symm a.fst\n          · exact (φ.orbitSet_subset _ ((φ.orbitSetEquiv _).symm _).prop).1\n          rw [orbitAtomMap_eq_of_mem_nextImageCoreDomain, nextImageCore]\n          rw [φ.orbitSetEquiv_congr _ this]\n          simp only [Subtype.coe_eta, Equiv.apply_symm_apply, elim_inl, nextBackwardImage]\n          refine' ⟨_, ⟨((φ.litterPerm hφ).symm) a.fst, rfl⟩, _, ⟨_, rfl⟩, _⟩\n          · exact (φ.litterPerm hφ).symm.map_domain (fst_mem_litterPerm_domain_of_dom hφ ha₁)\n          · refine' ⟨_, _, rfl⟩\n            simp only [mem_setOf_eq, Equiv.apply_symm_apply, elim_inl]\n            exact ⟨fst_mem_litterPerm_domain_of_dom hφ ha₁, rfl⟩\n    · obtain ⟨⟨b, hb₁, hb₂⟩, _⟩ := ha₁\n      rw [← hb₂]\n      refine' ⟨b, Or.inl hb₁, _⟩\n      rw [orbitAtomMap_eq_of_mem_dom]\n    · obtain ⟨a', ha'⟩ := (φ.orbitSetEquiv a.fst).symm.surjective\n        ⟨a, φ.mem_orbitSet_of_mem_nextImageCoreDomain hφ ha₁⟩\n      obtain ⟨n, a'⟩ | ⟨_ | n, a'⟩ := a'\n      · have :\n          ((φ.orbitSetEquiv (((φ.litterPerm hφ).symm^[n + 2]) (a' : Atom).fst)).symm\n                (inl (n + 1, a')) :\n              Atom) ∈\n            φ.nextImageCoreDomain hφ\n        · refine' ⟨_, ⟨((φ.litterPerm hφ).symm^[n + 2]) (a' : Atom).fst, rfl⟩, _, ⟨_, rfl⟩, _⟩\n          · exact (φ.litterPerm hφ).symm.iterate_domain\n              (fst_mem_litterPerm_domain_of_dom hφ a'.prop.1)\n          · refine' ⟨_, _, rfl⟩\n            simp only [mem_setOf_eq, Equiv.apply_symm_apply, elim_inl]\n            exact ⟨fst_mem_litterPerm_domain_of_dom hφ a'.prop.1, rfl⟩\n        refine' ⟨_, Or.inr (Or.inr this), _⟩\n        rw [φ.orbitAtomMap_eq_of_mem_nextImageCoreDomain hφ _ this]\n        rw [nextImageCore]\n        have :\n          ((φ.orbitSetEquiv (((φ.litterPerm hφ).symm^[n + 2]) (a' : Atom).fst)).symm\n                  (inl (n + 1, a')) :\n                Atom).fst =\n            ((φ.litterPerm hφ).symm^[n + 2]) (a' : Atom).fst :=\n          (φ.orbitSet_subset _ ((φ.orbitSetEquiv _).symm _).prop).1\n        rw [φ.orbitSetEquiv_congr _ this]\n        simp only [Subtype.coe_eta, Equiv.apply_symm_apply, elim_inl, nextBackwardImage]\n        have := congr_arg Subtype.val ha'\n        change _ = a at this\n        rw [← this]\n        refine' φ.orbitSetEquiv_symm_congr _\n        have := (φ.orbitSet_subset _\n          ((φ.orbitSetEquiv ((φ.litterPerm hφ).symm^[n + 2] (a' : Atom).1)).symm\n            (inl (n + 1, a'))).prop).1\n        rw [mem_litterSet] at this\n        rw [this]\n        have := φ.orbitSetEquiv_elim_of_mem_nextImageCoreDomain hφ ha₁\n        rw [← ha'] at this\n        simp only [Equiv.apply_symm_apply, elim_inl, nextBackwardImageDomain,\n          Function.comp_apply, mem_setOf_eq] at this\n        rw [← this.2, Function.iterate_succ_apply', PartialPerm.right_inv]\n        exact (φ.litterPerm hφ).symm.iterate_domain this.1\n      · have := φ.orbitSetEquiv_elim_of_mem_nextImageCoreDomain hφ ha₁\n        rw [← ha'] at this\n        simp only [nextForwardImageDomain, Function.iterate_succ, Function.comp_apply, mem_setOf_eq,\n          Nat.zero_eq, Equiv.apply_symm_apply, elim_inr, Function.iterate_zero, id_eq] at this\n        refine' ⟨a', Or.inr (Or.inl ⟨a'.prop, this.1⟩), _⟩\n        rw [orbitAtomMap_eq_of_needForwardImages, φ.orbitSetEquiv_symm_congr this.2,\n          Subtype.coe_eta, ha']\n        exact ⟨a'.prop, this.1⟩\n      · have :\n          ((φ.orbitSetEquiv ((φ.litterPerm hφ)^[n + 1] (a' : Atom).fst)).symm (inr (n, a')) :\n              Atom) ∈\n            φ.nextImageCoreDomain hφ\n        · refine' ⟨_, ⟨(φ.litterPerm hφ)^[n + 1] (a' : Atom).fst, rfl⟩, _, ⟨_, rfl⟩, _⟩\n          exact (φ.litterPerm hφ).iterate_domain (fst_mem_litterPerm_domain_of_ran hφ a'.prop.1)\n          refine' ⟨_, _, rfl⟩\n          simp only [mem_setOf_eq, Equiv.apply_symm_apply, elim_inl]\n          exact ⟨fst_mem_litterPerm_domain_of_ran hφ a'.prop.1, rfl⟩\n        refine' ⟨_, Or.inr (Or.inr this), _⟩\n        rw [φ.orbitAtomMap_eq_of_mem_nextImageCoreDomain hφ _ this]\n        rw [nextImageCore]\n        have :\n          ((φ.orbitSetEquiv ((φ.litterPerm hφ)^[n + 1] (a' : Atom).fst)).symm (inr (n, a')) :\n                Atom).fst =\n            (φ.litterPerm hφ)^[n + 1] (a' : Atom).fst :=\n          (φ.orbitSet_subset _ ((φ.orbitSetEquiv _).symm _).prop).1\n        rw [φ.orbitSetEquiv_congr _ this]\n        simp only [Subtype.coe_eta, Equiv.apply_symm_apply, elim_inl, nextBackwardImage]\n        have := congr_arg Subtype.val ha'\n        change _ = a at this\n        rw [← this]\n        refine' φ.orbitSetEquiv_symm_congr _\n        have := (φ.orbitSet_subset _ ((φ.orbitSetEquiv\n          ((φ.litterPerm hφ)^[n + 1] (a' : Atom).fst)).symm (inr (n, a'))).prop).1\n        rw [mem_litterSet] at this\n        rw [this]\n        have := φ.orbitSetEquiv_elim_of_mem_nextImageCoreDomain hφ ha₁\n        rw [← ha'] at this\n        simp only [Equiv.apply_symm_apply, elim_inr, nextForwardImageDomain, Function.comp_apply,\n          mem_setOf_eq] at this\n        rw [← this.2, Function.iterate_succ_apply', Function.iterate_succ_apply',\n          Function.iterate_succ_apply']\n", "additional_info": "", "used_premises": [1, 825, 62, 467, 824, 1123, 1114], "def_path": "ConNF/FOA/Action/FillAtomOrbits.lean", "pos": [704, 910], "informalization": "Given a lawful near litter action φ, if the symmetric difference of the litter set of any given litter L with the values of the litter map of φ applied to L (excluding any undefined values) is a subset of the range of the atom map of φ, then the near litter action obtained by filling the orbits of any undefined atoms under φ is precise."}
{"full_name": "ConNF.NearLitterAction.Precise", "url": "ConNF/FOA/Action/NearLitterAction.html#ConNF.NearLitterAction.Precise", "code_src": "con-nf", "ptype": "def", "header": "def ConNF.NearLitterAction.Precise [ConNF.Params🔗<|PREMISE|>🔗 ] (φ : ConNF.NearLitterAction) :Prop", "code": "def Precise : Prop :=\n  ∀ ⦃L⦄ (hL : (φ.litterMap L).Dom), φ.PreciseAt hL\n", "additional_info": "An action is precise if it is precise at every litter in its domain.\nEquations\n* 🗟ConNF.NearLitterAction.Precise🗟🔗../../.././ConNF/FOA/Action/NearLitterAction.html#ConNF.NearLitterAction.Precise🔗  φ 🗟=🗟🔗../../.././Init/Prelude.html#Eq🔗  ∀ ⦃L : ConNF.Litter⦄ (hL : (φ.litterMap L).Dom), 🗟ConNF.NearLitterAction.PreciseAt🗟🔗../../.././ConNF/FOA/Action/NearLitterAction.html#ConNF.NearLitterAction.PreciseAt🔗  φ hL\n\n", "used_premises": [1], "def_path": "ConNF/FOA/Action/NearLitterAction.lean", "pos": [225, 227], "informalization": "Function `ConNF.NearLitterAction.Precise` is a predicate that checks if a given near litter action `φ` is precise. A near litter action is precise if it is precise at every litter in its domain. This means that for every litter `L` in the domain of the litter map of `φ`, the action `φ` is precise at `L`."}
{"full_name": "Or.elim'_left", "url": "ConNF/FOA/Action/NearLitterAction.html#Or.elim'_left", "code_src": "con-nf", "ptype": "theorem", "header": "theorem Or.elim'_left {α : Sort u_1} {p : Prop } {q : Prop } (h : p ∨ q) (f : p → α) (g : q → α) (hp : p) :Or.elim'🔗<|PREMISE|>🔗 h f g = f hp", "code": "lemma Or.elim'_left {α : Sort _} {p q : Prop}\n    (h : p ∨ q) (f : p → α) (g : q → α) (hp : p) : h.elim' f g = f hp :=\n  by rw [Or.elim', dif_pos hp]\n", "additional_info": "", "used_premises": [1125], "def_path": "ConNF/FOA/Action/NearLitterAction.lean", "pos": [23, 26], "informalization": "`Or.elim'_left` is a theorem that states that if we have a disjunction `p ∨ q` and two functions `f : p → α` and `g : q → α`, and we know that `p` is true, then `Or.elim' h f g` is equal to `f hp`, where `hp` is a proof of `p`."}
{"full_name": "Or.elim'", "url": "ConNF/FOA/Action/NearLitterAction.html#Or.elim'", "code_src": "con-nf", "ptype": "noncomputable def", "header": "noncomputable def Or.elim' {α : Sort u_1} {p : Prop } {q : Prop } (h : p ∨ q) (f : p → α) (g : q → α) :α", "code": "noncomputable def Or.elim' {α : Sort _} {p q : Prop}\n    (h : p ∨ q) (f : p → α) (g : q → α) : α :=\n  if hp : p then f hp else g (h.resolve_left hp)\n", "additional_info": "Noncomputably eliminates a disjunction into a (possibly predicative) universe.\nEquations\n* 🗟Or.elim'🗟🔗../../.././ConNF/FOA/Action/NearLitterAction.html#Or.elim'🔗  h f g 🗟=🗟🔗../../.././Init/Prelude.html#Eq🔗  if hp : p then f hp else g ⋯\n\n", "used_premises": [], "def_path": "ConNF/FOA/Action/NearLitterAction.lean", "pos": [19, 22], "informalization": "`Or.elim'` is a noncomputable function that eliminates a disjunction into a possibly predicative universe. It takes a disjunction `p ∨ q` and two functions `f : p → α` and `g : q → α`, and returns an element of type `α`."}
{"full_name": "ConNF.NearLitterAction.ext", "url": "ConNF/FOA/Action/NearLitterAction.html#ConNF.NearLitterAction.ext", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterAction.ext :∀ {inst : ConNF.Params🔗<|PREMISE|>🔗 } (x y : ConNF.NearLitterAction), x.atomMap = y.atomMap → x.litterMap = y.litterMap → x = y", "code": "@[ext]\n", "additional_info": "", "used_premises": [1], "def_path": "ConNF/FOA/Action/NearLitterAction.lean", "pos": [35, 36], "informalization": "`ConNF.NearLitterAction.ext` is an extensionality theorem for the `ConNF.NearLitterAction` structure. It states that two `ConNF.NearLitterAction`s are equal if their `atomMap` and `litterMap` fields are equal."}
{"full_name": "ConNF.NearLitterAction.ext_iff", "url": "ConNF/FOA/Action/NearLitterAction.html#ConNF.NearLitterAction.ext_iff", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterAction.ext_iff :∀ {inst : ConNF.Params🔗<|PREMISE|>🔗 } (x y : ConNF.NearLitterAction), x = y ↔ x.atomMap = y.atomMap ∧ x.litterMap = y.litterMap", "code": "@[ext]\n", "additional_info": "", "used_premises": [1], "def_path": "ConNF/FOA/Action/NearLitterAction.lean", "pos": [35, 36], "informalization": "The `ConNF.NearLitterAction.ext_iff` theorem states that two `ConNF.NearLitterAction` objects are equal if and only if their `atomMap` and `litterMap` fields are equal."}
{"full_name": "ConNF.NearLitterAction.bannedLitter_iff", "url": "ConNF/FOA/Action/NearLitterAction.html#ConNF.NearLitterAction.bannedLitter_iff", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterAction.bannedLitter_iff [ConNF.Params🔗<|PREMISE|>🔗 ] (φ : ConNF.NearLitterAction) :∀ (a : ConNF.Litter), ConNF.NearLitterAction.BannedLitter🔗<|PREMISE|>🔗 φ a ↔ (∃ (a_1 : ConNF.Atom), (φ.atomMap a_1).Dom ∧ a = a_1.1) ∨ (φ.litterMap a).Dom ∨ (∃ (a_1 : ConNF.Atom) (h : (φ.atomMap a_1).Dom), a = ((φ.atomMap a_1).get h).1) ∨ (∃ (L : ConNF.Litter) (h : (φ.litterMap L).Dom), a = ((φ.litterMap L).get h).fst) ∨ ∃ (L : ConNF.Litter) (h : (φ.litterMap L).Dom), ∃ a_1 ∈ ↑((φ.litterMap L).get h) \\ ConNF.litterSet🔗<|PREMISE|>🔗 ((φ.litterMap L).get h).fst, a = a_1.1", "code": "@[mk_iff]\n", "additional_info": "", "used_premises": [1, 1065, 467], "def_path": "ConNF/FOA/Action/NearLitterAction.lean", "pos": [58, 59], "informalization": "The theorem `ConNF.NearLitterAction.bannedLitter_iff` states that a litter `a` is considered \"banned\" by a near litter action `φ` if and only if there exists an atom `a_1` such that `φ.atomMap a_1` is defined and `a = a_1.1`, or `φ.litterMap a` is defined, or there exists an atom `a_1` such that `φ.atomMap a_1` is defined and `a = ((φ.atomMap a_1).get h).1`, or there exists a litter `L` such that `φ.litterMap L` is defined and `a = ((φ.litterMap L).get h).fst`, or there exists a litter `L` such that `φ.litterMap L` is defined and there exists an atom `a_1` in `((φ.litterMap L).get h) \\ ConNF.litterSet ((φ.litterMap L).get h).fst` with `a = a_1.1`."}
{"full_name": "ConNF.NearLitterAction.BannedLitter.memMap", "url": "ConNF/FOA/Action/NearLitterAction.html#ConNF.NearLitterAction.BannedLitter.memMap", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterAction.BannedLitter.memMap [ConNF.Params🔗<|PREMISE|>🔗 ] (φ : ConNF.NearLitterAction) (a : ConNF.Atom) (L : ConNF.Litter) (hL : (φ.litterMap L).Dom) (ha : a ∈ ↑((φ.litterMap L).get hL)) :ConNF.NearLitterAction.BannedLitter🔗<|PREMISE|>🔗 φ a.1", "code": "theorem BannedLitter.memMap (a : Atom) (L : Litter) (hL)\n    (ha : a ∈ ((φ.litterMap L).get hL : Set Atom)) : φ.BannedLitter a.1 := by\n  by_cases h : a.1 = ((φ.litterMap L).get hL).1\n  · rw [h]\n    exact BannedLitter.litterMap L hL\n  · exact BannedLitter.diff L hL a ⟨ha, h⟩\n", "additional_info": "", "used_premises": [1, 1065], "def_path": "ConNF/FOA/Action/NearLitterAction.lean", "pos": [67, 73], "informalization": "The theorem `ConNF.NearLitterAction.BannedLitter.memMap` is a result in the context of Constructive Ordinal Notation (ConNF) which is a mathematical formalization of the Von Neumann universe of ordinals. The theorem is about the type `ConNF.NearLitterAction.BannedLitter`, which represents a litter that is not allowed as a sandbox because it appears somewhere that we need to preserve. The theorem states that if an atom `a` with a given litter `L` is in the domain of the litter map of a near litter action `φ`, and it is also in the image of the litter map, then the litter of `a` is banned."}
{"full_name": "ConNF.NearLitterAction.bannedLitter_small", "url": "ConNF/FOA/Action/NearLitterAction.html#ConNF.NearLitterAction.bannedLitter_small", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterAction.bannedLitter_small [ConNF.Params🔗<|PREMISE|>🔗 ] (φ : ConNF.NearLitterAction) :ConNF.Small🔗<|PREMISE|>🔗 {L : ConNF.Litter | ConNF.NearLitterAction.BannedLitter🔗<|PREMISE|>🔗 φ L}", "code": "theorem bannedLitter_small : Small {L | φ.BannedLitter L} := by\n  simp only [bannedLitter_iff, mem_diff, SetLike.mem_coe, mem_litterSet]\n  refine' Small.union _ (Small.union _ (Small.union _ (Small.union _ _)))\n  · refine' lt_of_le_of_lt _ φ.atomMap_dom_small\n    refine' ⟨⟨fun a => ⟨_, a.prop.choose_spec.1⟩, fun a₁ a₂ h => _⟩⟩\n    simp only [Subtype.mk_eq_mk, Prod.mk.inj_iff] at h\n    have := a₁.prop.choose_spec.2\n    rw [h] at this\n    exact Subtype.coe_injective (this.trans a₂.prop.choose_spec.2.symm)\n  · refine' lt_of_le_of_lt _ φ.litterMap_dom_small\n    refine' ⟨⟨fun L => ⟨_, L.prop⟩, fun L₁ L₂ h => _⟩⟩\n    simp only [Subtype.mk_eq_mk, Prod.mk.inj_iff] at h\n    exact Subtype.coe_injective h\n  · refine' lt_of_le_of_lt _ φ.atomMap_dom_small\n    refine' ⟨⟨fun L => ⟨_, L.prop.choose_spec.choose⟩, fun L₁ L₂ h => _⟩⟩\n    simp only [Subtype.mk_eq_mk, Prod.mk.inj_iff] at h\n    have := L₁.prop.choose_spec.choose_spec\n    simp_rw [h] at this\n    exact Subtype.coe_injective (this.trans L₂.prop.choose_spec.choose_spec.symm)\n  · refine' lt_of_le_of_lt _ φ.litterMap_dom_small\n    refine' ⟨⟨fun L => ⟨_, L.prop.choose_spec.choose⟩, fun L₁ L₂ h => _⟩⟩\n    simp only [Subtype.mk_eq_mk, Prod.mk.inj_iff] at h\n    have := L₁.prop.choose_spec.choose_spec\n    simp_rw [h] at this\n    exact Subtype.coe_injective (this.trans L₂.prop.choose_spec.choose_spec.symm)\n  · have : Small\n      (⋃ (L : Litter) (h : (φ.litterMap L).Dom),\n        ((φ.litterMap L).get h : Set Atom) \\ litterSet ((φ.litterMap L).get h).1)\n    · refine' Small.bUnion _ _\n      · refine' lt_of_le_of_lt _ φ.litterMap_dom_small\n        refine' ⟨⟨fun N => ⟨_, N.prop⟩, fun N₁ N₂ h => _⟩⟩\n        simp only [Subtype.mk_eq_mk, Prod.mk.inj_iff] at h\n        exact Subtype.coe_inj.mp h\n      · intro L hL\n        refine' Small.mono _ ((φ.litterMap L).get hL).2.prop\n        exact fun x hx => Or.inr hx\n    refine' lt_of_le_of_lt _ this\n    refine' ⟨⟨fun L => ⟨L.prop.choose_spec.choose_spec.choose, _⟩, fun L₁ L₂ h => _⟩⟩\n    · simp only [mem_iUnion]\n      exact ⟨_, _, L.prop.choose_spec.choose_spec.choose_spec.1⟩\n    simp only [Subtype.mk_eq_mk, Prod.mk.inj_iff] at h\n    have := L₁.prop.choose_spec.choose_spec.choose_spec.2\n    rw [h] at this\n    exact Subtype.coe_injective (this.trans L₂.prop.choose_spec.choose_spec.choose_spec.2.symm)\n", "additional_info": "There are only a small amount of banned litters.", "used_premises": [1, 233, 1065], "def_path": "ConNF/FOA/Action/NearLitterAction.lean", "pos": [75, 119], "informalization": "The theorem `ConNF.NearLitterAction.bannedLitter_small` states that the set of banned litters in the context of Constructive Ordinal Notation (ConNF) is small, meaning its cardinality is strictly less than the cardinality of the type `ConNF.κ`."}
{"full_name": "ConNF.NearLitterAction.mk_not_bannedLitter", "url": "ConNF/FOA/Action/NearLitterAction.html#ConNF.NearLitterAction.mk_not_bannedLitter", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterAction.mk_not_bannedLitter [ConNF.Params🔗<|PREMISE|>🔗 ] (φ : ConNF.NearLitterAction) :Cardinal.mk🔗<|PREMISE|>🔗 ↑{L : ConNF.Litter | ¬ ConNF.NearLitterAction.BannedLitter🔗<|PREMISE|>🔗 φ L} = Cardinal.mk🔗<|PREMISE|>🔗 ConNF.μ", "code": "theorem mk_not_bannedLitter : #{L | ¬φ.BannedLitter L} = #μ := by\n  have := mk_sum_compl {L | φ.BannedLitter L}\n  rw [compl_setOf, mk_litter] at this\n  rw [← this, add_eq_right]\n  · by_contra h\n    have h' := add_le_add (le_of_lt φ.bannedLitter_small) (le_of_not_le h)\n    rw [this] at h'\n    refine' not_lt_of_le h' _\n    refine' Cardinal.add_lt_of_lt Params.μ_isStrongLimit.isLimit.aleph0_le Params.κ_lt_μ _\n    exact lt_of_le_of_lt Params.κ_isRegular.aleph0_le Params.κ_lt_μ\n  · by_contra h\n    have h' := add_le_add (le_of_lt φ.bannedLitter_small) (le_of_not_le h)\n    rw [this] at h'\n    refine' not_lt_of_le h' _\n    refine' Cardinal.add_lt_of_lt Params.μ_isStrongLimit.isLimit.aleph0_le Params.κ_lt_μ _\n    exact lt_trans φ.bannedLitter_small Params.κ_lt_μ\n", "additional_info": "", "used_premises": [1, 29, 1065, 29], "def_path": "ConNF/FOA/Action/NearLitterAction.lean", "pos": [120, 136], "informalization": "The theorem `ConNF.NearLitterAction.mk_not_bannedLitter` states that the cardinality of the set of litters that are not banned by the near litter action `φ` is equal to the cardinality of the type `μ`."}
{"full_name": "ConNF.NearLitterAction.not_bannedLitter_nonempty", "url": "ConNF/FOA/Action/NearLitterAction.html#ConNF.NearLitterAction.not_bannedLitter_nonempty", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterAction.not_bannedLitter_nonempty [ConNF.Params🔗<|PREMISE|>🔗 ] (φ : ConNF.NearLitterAction) :Nonempty🔗<|PREMISE|>🔗 ↑{L : ConNF.Litter | ¬ ConNF.NearLitterAction.BannedLitter🔗<|PREMISE|>🔗 φ L}", "code": "theorem not_bannedLitter_nonempty : Nonempty {L | ¬φ.BannedLitter L} := by\n  simp only [← mk_ne_zero_iff, mk_not_bannedLitter, Ne.def, mk_ne_zero, not_false_iff]\n", "additional_info": "", "used_premises": [1, 212, 1065], "def_path": "ConNF/FOA/Action/NearLitterAction.lean", "pos": [137, 139], "informalization": "The theorem `ConNF.NearLitterAction.not_bannedLitter_nonempty` states that in the context of Constructive Ordinal Notation (ConNF), given a near litter action `φ`, there exists at least one litter `L` that is not banned, meaning it can be used as a sandbox."}
{"full_name": "ConNF.NearLitterAction.atomMapOrElse_of_dom", "url": "ConNF/FOA/Action/NearLitterAction.html#ConNF.NearLitterAction.atomMapOrElse_of_dom", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterAction.atomMapOrElse_of_dom [ConNF.Params🔗<|PREMISE|>🔗 ] (φ : ConNF.NearLitterAction) {a : ConNF.Atom} (ha : (φ.atomMap a).Dom) :ConNF.NearLitterAction.atomMapOrElse🔗<|PREMISE|>🔗 φ a = (φ.atomMap a).get ha", "code": "theorem atomMapOrElse_of_dom {a : Atom} (ha : (φ.atomMap a).Dom) :\n    φ.atomMapOrElse a = (φ.atomMap a).get ha := by rw [atomMapOrElse, Part.getOrElse_of_dom]\n", "additional_info": "", "used_premises": [1, 1134], "def_path": "ConNF/FOA/Action/NearLitterAction.lean", "pos": [144, 146], "informalization": "Given a `ConNF.NearLitterAction` object `φ` and an `ConNF.Atom` object `a`, if `a` is in the domain of `φ.atomMap`, then `ConNF.NearLitterAction.atomMapOrElse φ a` returns the value of `φ.atomMap a`."}
{"full_name": "ConNF.NearLitterAction.atomMapOrElse", "url": "ConNF/FOA/Action/NearLitterAction.html#ConNF.NearLitterAction.atomMapOrElse", "code_src": "con-nf", "ptype": "noncomputable def", "header": "noncomputable def ConNF.NearLitterAction.atomMapOrElse [ConNF.Params🔗<|PREMISE|>🔗 ] (φ : ConNF.NearLitterAction) (a : ConNF.Atom) :ConNF.Atom", "code": "noncomputable def atomMapOrElse (a : Atom) : Atom :=\n  (φ.atomMap a).getOrElse (Classical.arbitrary Atom)\n", "additional_info": "If `a` is in the domain, this is the atom map. Otherwise, this gives an arbitrary atom.\nEquations\n* 🗟ConNF.NearLitterAction.atomMapOrElse🗟🔗../../.././ConNF/FOA/Action/NearLitterAction.html#ConNF.NearLitterAction.atomMapOrElse🔗  φ a 🗟=🗟🔗../../.././Init/Prelude.html#Eq🔗  🗟Part.getOrElse🗟🔗../../.././Mathlib/Data/Part.html#Part.getOrElse🔗  (φ.atomMap a) (🗟Classical.arbitrary🗟🔗../../.././Mathlib/Logic/Nonempty.html#Classical.arbitrary🔗  ConNF.Atom)\n\n", "used_premises": [1], "def_path": "ConNF/FOA/Action/NearLitterAction.lean", "pos": [141, 143], "informalization": "Function `ConNF.NearLitterAction.atomMapOrElse` takes a `ConNF.NearLitterAction` object `φ` and an `ConNF.Atom` object `a`. If `a` is in the domain of `φ.atomMap`, it returns the value of `φ.atomMap a`. If `a` is not in the domain, it returns an arbitrary `ConNF.Atom`."}
{"full_name": "ConNF.NearLitterAction.atomMapOrElse_injective", "url": "ConNF/FOA/Action/NearLitterAction.html#ConNF.NearLitterAction.atomMapOrElse_injective", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterAction.atomMapOrElse_injective [ConNF.Params🔗<|PREMISE|>🔗 ] (φ : ConNF.NearLitterAction) (hφ : ConNF.NearLitterAction.Lawful🔗<|PREMISE|>🔗 φ) :Set.InjOn🔗<|PREMISE|>🔗 (ConNF.NearLitterAction.atomMapOrElse🔗<|PREMISE|>🔗 φ) (PFun.Dom🔗<|PREMISE|>🔗 φ.atomMap)", "code": "theorem atomMapOrElse_injective (hφ : φ.Lawful) : InjOn φ.atomMapOrElse φ.atomMap.Dom := by\n  intro a ha b hb h\n  rw [φ.atomMapOrElse_of_dom ha, φ.atomMapOrElse_of_dom hb] at h\n  exact hφ.atomMap_injective ha hb h\n", "additional_info": "", "used_premises": [1, 825, 111, 1134, 404], "def_path": "ConNF/FOA/Action/NearLitterAction.lean", "pos": [147, 151], "informalization": "The theorem `ConNF.NearLitterAction.atomMapOrElse_injective` states that the function `ConNF.NearLitterAction.atomMapOrElse` is injective when restricted to the domain of `φ.atomMap`. This means that for any two atoms `a₁` and `a₂` in the domain of `φ.atomMap`, if `ConNF.NearLitterAction.atomMapOrElse φ a₁ = ConNF.NearLitterAction.atomMapOrElse φ a₂`, then `a₁ = a₂`."}
{"full_name": "ConNF.NearLitterAction.litterMapOrElse_of_dom", "url": "ConNF/FOA/Action/NearLitterAction.html#ConNF.NearLitterAction.litterMapOrElse_of_dom", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterAction.litterMapOrElse_of_dom [ConNF.Params🔗<|PREMISE|>🔗 ] (φ : ConNF.NearLitterAction) {L : ConNF.Litter} (hL : (φ.litterMap L).Dom) :ConNF.NearLitterAction.litterMapOrElse🔗<|PREMISE|>🔗 φ L = (φ.litterMap L).get hL", "code": "theorem litterMapOrElse_of_dom {L : Litter} (hL : (φ.litterMap L).Dom) :\n    φ.litterMapOrElse L = (φ.litterMap L).get hL := by\n  rw [litterMapOrElse, Part.getOrElse_of_dom]\n", "additional_info": "", "used_premises": [1, 1137], "def_path": "ConNF/FOA/Action/NearLitterAction.lean", "pos": [157, 160], "informalization": "Function `ConNF.NearLitterAction.litterMapOrElse` takes a `ConNF.NearLitterAction` and a `ConNF.Litter`, and returns a `ConNF.NearLitter`. If the `ConNF.Litter` is in the domain of the `ConNF.NearLitterAction`, it returns the result of the litter map. Otherwise, it returns an arbitrary near-litter. The theorem `ConNF.NearLitterAction.litterMapOrElse_of_dom` states that if the `ConNF.Litter` is in the domain of the `ConNF.NearLitterAction`, then `ConNF.NearLitterAction.litterMapOrElse` returns the result of the litter map."}
{"full_name": "ConNF.NearLitterAction.litterMapOrElse", "url": "ConNF/FOA/Action/NearLitterAction.html#ConNF.NearLitterAction.litterMapOrElse", "code_src": "con-nf", "ptype": "noncomputable def", "header": "noncomputable def ConNF.NearLitterAction.litterMapOrElse [ConNF.Params🔗<|PREMISE|>🔗 ] (φ : ConNF.NearLitterAction) (L : ConNF.Litter) :ConNF.NearLitter", "code": "noncomputable def litterMapOrElse (L : Litter) : NearLitter :=\n  (φ.litterMap L).getOrElse (Classical.arbitrary NearLitter)\n", "additional_info": "If `L` is in the domain, this is the litter map.\nOtherwise, this gives an arbitrary near-litter.\nEquations\n* 🗟ConNF.NearLitterAction.litterMapOrElse🗟🔗../../.././ConNF/FOA/Action/NearLitterAction.html#ConNF.NearLitterAction.litterMapOrElse🔗  φ L 🗟=🗟🔗../../.././Init/Prelude.html#Eq🔗  🗟Part.getOrElse🗟🔗../../.././Mathlib/Data/Part.html#Part.getOrElse🔗  (φ.litterMap L) (🗟Classical.arbitrary🗟🔗../../.././Mathlib/Logic/Nonempty.html#Classical.arbitrary🔗  ConNF.NearLitter)\n\n", "used_premises": [1], "def_path": "ConNF/FOA/Action/NearLitterAction.lean", "pos": [154, 156], "informalization": "Function `ConNF.NearLitterAction.litterMapOrElse` takes a `ConNF.NearLitterAction` and a `ConNF.Litter`, and returns a `ConNF.NearLitter`. If the `ConNF.Litter` is in the domain of the `ConNF.NearLitterAction`, it returns the result of the litter map. Otherwise, it returns an arbitrary near-litter."}
{"full_name": "ConNF.NearLitterAction.roughLitterMapOrElse_of_dom", "url": "ConNF/FOA/Action/NearLitterAction.html#ConNF.NearLitterAction.roughLitterMapOrElse_of_dom", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterAction.roughLitterMapOrElse_of_dom [ConNF.Params🔗<|PREMISE|>🔗 ] (φ : ConNF.NearLitterAction) {L : ConNF.Litter} (hL : (φ.litterMap L).Dom) :ConNF.NearLitterAction.roughLitterMapOrElse🔗<|PREMISE|>🔗 φ L = ((φ.litterMap L).get hL).fst", "code": "theorem roughLitterMapOrElse_of_dom {L : Litter} (hL : (φ.litterMap L).Dom) :\n    φ.roughLitterMapOrElse L = ((φ.litterMap L).get hL).1 := by\n  rw [roughLitterMapOrElse, litterMapOrElse_of_dom]\n", "additional_info": "", "used_premises": [1, 1064], "def_path": "ConNF/FOA/Action/NearLitterAction.lean", "pos": [164, 167], "informalization": "Function `ConNF.NearLitterAction.roughLitterMapOrElse` takes a `ConNF.NearLitterAction` object `φ` and a `ConNF.Litter` object `L`, and returns the first component of the result of applying `ConNF.NearLitterAction.litterMapOrElse` to `φ` and `L`."}
{"full_name": "ConNF.NearLitterAction.Lawful.le", "url": "ConNF/FOA/Action/NearLitterAction.html#ConNF.NearLitterAction.Lawful.le", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterAction.Lawful.le [ConNF.Params🔗<|PREMISE|>🔗 ] {φ : ConNF.NearLitterAction} {ψ : ConNF.NearLitterAction} (h : ConNF.NearLitterAction.Lawful🔗<|PREMISE|>🔗 φ) (hψ : ψ ≤ φ) :ConNF.NearLitterAction.Lawful🔗<|PREMISE|>🔗 ψ", "code": "theorem Lawful.le {φ ψ : NearLitterAction} (h : φ.Lawful) (hψ : ψ ≤ φ) : ψ.Lawful :=\n  { atomMap_injective := by\n      intro a b ha hb hab\n      refine' h.atomMap_injective (hψ.1.dom_of_dom a ha) (hψ.1.dom_of_dom b hb) _\n      rwa [hψ.1.get_eq, hψ.1.get_eq] at hab\n    litterMap_injective := by\n      intro L₁ L₂ h₁ h₂ h₁₂\n      refine' h.litterMap_injective (hψ.2.dom_of_dom L₁ h₁) (hψ.2.dom_of_dom L₂ h₂) _\n      rwa [hψ.2.get_eq, hψ.2.get_eq] at h₁₂\n    atom_mem := by\n      intro a ha L hL\n      rw [h.atom_mem a (hψ.1.dom_of_dom a ha) L (hψ.2.dom_of_dom L hL), hψ.1.get_eq, hψ.2.get_eq] }\n", "additional_info": "", "used_premises": [1, 825, 825], "def_path": "ConNF/FOA/Action/NearLitterAction.lean", "pos": [203, 215], "informalization": "The theorem `ConNF.NearLitterAction.Lawful.le` states that if `φ` is a lawful near litter action and `ψ` is a near litter action that is less than or equal to `φ`, then `ψ` is also a lawful near litter action."}
{"full_name": "ConNF.NearLitterAction.preciseAt_iff", "url": "ConNF/FOA/Action/NearLitterAction.html#ConNF.NearLitterAction.preciseAt_iff", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterAction.preciseAt_iff [ConNF.Params🔗<|PREMISE|>🔗 ] (φ : ConNF.NearLitterAction) ⦃L : ConNF.Litter⦄ (hL : (φ.litterMap L).Dom) :ConNF.NearLitterAction.PreciseAt🔗<|PREMISE|>🔗 φ hL ↔ symmDiff🔗<|PREMISE|>🔗 (↑((φ.litterMap L).get hL)) (ConNF.litterSet🔗<|PREMISE|>🔗 ((φ.litterMap L).get hL).fst) ⊆ PFun.ran🔗<|PREMISE|>🔗 φ.atomMap ∧ (∀ (a : ConNF.Atom) (ha : (φ.atomMap a).Dom), (φ.atomMap a).get ha ∈ ConNF.litterSet🔗<|PREMISE|>🔗 L → (φ.atomMap ((φ.atomMap a).get ha)).Dom) ∧ PFun.Dom🔗<|PREMISE|>🔗 φ.atomMap ∩ ↑((φ.litterMap L).get hL) ⊆ PFun.ran🔗<|PREMISE|>🔗 φ.atomMap", "code": "@[mk_iff]\n", "additional_info": "", "used_premises": [1, 1141, 62, 467, 824, 467, 404, 824], "def_path": "ConNF/FOA/Action/NearLitterAction.lean", "pos": [218, 219], "informalization": "The theorem `ConNF.NearLitterAction.preciseAt_iff` states that a near litter action `φ` is precise at a litter `L` in its domain if and only if the symmetric difference of the image of `L` under `φ` and the litter set of `L` is a subset of the range of `φ`, and for any atom `a` in the domain of `φ`, if `φ(a)` is in the litter set of `L`, then `φ(φ(a))` is also in the domain of `φ`. Additionally, the intersection of the domain of `φ` and the image of `L` under `φ` is a subset of the range of `φ`."}
{"full_name": "ConNF.NearLitterAction.PreciseAt", "url": "ConNF/FOA/Action/NearLitterAction.html#ConNF.NearLitterAction.PreciseAt", "code_src": "con-nf", "ptype": "structure", "header": "structure ConNF.NearLitterAction.PreciseAt [ConNF.Params🔗<|PREMISE|>🔗 ] (φ : ConNF.NearLitterAction) ⦃L : ConNF.Litter⦄ (hL : (φ.litterMap L).Dom) :Prop\n | diff : symmDiff🔗<|PREMISE|>🔗  (↑((φ.litterMap L).get hL)) (ConNF.litterSet🔗<|PREMISE|>🔗  ((φ.litterMap L).get hL).fst) ⊆  PFun.ran🔗<|PREMISE|>🔗  φ.atomMap\n | fwd : ∀ (a : ConNF.Atom) (ha : (φ.atomMap a).Dom),\n (φ.atomMap a).get ha ∈  ConNF.litterSet🔗<|PREMISE|>🔗  L → (φ.atomMap ((φ.atomMap a).get ha)).Dom\n | back : PFun.Dom🔗<|PREMISE|>🔗  φ.atomMap ∩  ↑((φ.litterMap L).get hL) ⊆  PFun.ran🔗<|PREMISE|>🔗  φ.atomMap", "code": "structure PreciseAt ⦃L : Litter⦄ (hL : (φ.litterMap L).Dom) : Prop where\n  diff : ((φ.litterMap L).get hL : Set Atom) ∆ litterSet ((φ.litterMap L).get hL).1 ⊆ φ.atomMap.ran\n  fwd : ∀ a ha, (φ.atomMap a).get ha ∈ litterSet L → (φ.atomMap ((φ.atomMap a).get ha)).Dom\n  back : φ.atomMap.Dom ∩ (φ.litterMap L).get hL ⊆ φ.atomMap.ran\n", "additional_info": "An action is precise at a litter in its domain if all atoms in the symmetric\ndifference of its image are accounted for.\n", "used_premises": [1, 62, 467, 824, 467, 404, 824], "def_path": "ConNF/FOA/Action/NearLitterAction.lean", "pos": [219, 223], "informalization": "The structure `ConNF.NearLitterAction.PreciseAt` defines a property of a near litter action in the context of Constructive Ordinal Notation (ConNF). A near litter action `φ` is precise at a litter `L` in its domain if the symmetric difference of the image of `L` under `φ` and the litter set of `L` is a subset of the range of `φ`, and for any atom `a` in the domain of `φ`, if `φ(a)` is in the litter set of `L`, then `φ(φ(a))` is also in the domain of `φ`. Additionally, the intersection of the domain of `φ` and the image of `L` under `φ` is a subset of the range of `φ`."}
{"full_name": "ConNF.NearLitterAction.disjoint_dom_not_bannedLitter", "url": "ConNF/FOA/Action/NearLitterAction.html#ConNF.NearLitterAction.disjoint_dom_not_bannedLitter", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterAction.disjoint_dom_not_bannedLitter [ConNF.Params🔗<|PREMISE|>🔗 ] (φ : ConNF.NearLitterAction) :Disjoint🔗<|PREMISE|>🔗 (PFun.Dom🔗<|PREMISE|>🔗 φ.litterMap ∪ ConNF.NearLitterAction.roughLitterMapOrElse🔗<|PREMISE|>🔗 φ '' PFun.Dom🔗<|PREMISE|>🔗 φ.litterMap) {L : ConNF.Litter | ¬ ConNF.NearLitterAction.BannedLitter🔗<|PREMISE|>🔗 φ L}", "code": "theorem disjoint_dom_not_bannedLitter :\n    Disjoint (φ.litterMap.Dom ∪ φ.roughLitterMapOrElse '' φ.litterMap.Dom)\n      {L : Litter | ¬φ.BannedLitter L} := by\n  simp only [Set.disjoint_left, mem_union, PFun.mem_dom, mem_image, mem_setOf_eq,\n    Classical.not_not]\n  rintro _ (⟨_, hL, rfl⟩ | ⟨L, ⟨_, hL, rfl⟩, rfl⟩)\n  · exact BannedLitter.litterDom _ hL\n  · rw [φ.roughLitterMapOrElse_of_dom hL]\n    exact BannedLitter.litterMap _ hL\n", "additional_info": "", "used_premises": [1, 757, 404, 1064, 404, 1065], "def_path": "ConNF/FOA/Action/NearLitterAction.lean", "pos": [232, 241], "informalization": "The theorem `ConNF.NearLitterAction.disjoint_dom_not_bannedLitter` states that the union of the domain of the partial function `φ.litterMap` and the image of the domain of `φ.litterMap` under the function `ConNF.NearLitterAction.roughLitterMapOrElse` is disjoint from the set of litters that are not banned by `φ`."}
{"full_name": "ConNF.NearLitterAction.roughLitterMapOrElse_injOn", "url": "ConNF/FOA/Action/NearLitterAction.html#ConNF.NearLitterAction.roughLitterMapOrElse_injOn", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterAction.roughLitterMapOrElse_injOn [ConNF.Params🔗<|PREMISE|>🔗 ] (φ : ConNF.NearLitterAction) (hφ : ConNF.NearLitterAction.Lawful🔗<|PREMISE|>🔗 φ) :Set.InjOn🔗<|PREMISE|>🔗 (ConNF.NearLitterAction.roughLitterMapOrElse🔗<|PREMISE|>🔗 φ) (PFun.Dom🔗<|PREMISE|>🔗 φ.litterMap)", "code": "theorem roughLitterMapOrElse_injOn (hφ : φ.Lawful) :\n    InjOn φ.roughLitterMapOrElse φ.litterMap.Dom := by\n  intro L₁ hL₁ L₂ hL₂ h\n  rw [φ.roughLitterMapOrElse_of_dom hL₁, φ.roughLitterMapOrElse_of_dom hL₂] at h\n  exact hφ.litterMap_injective hL₁ hL₂ (NearLitter.inter_nonempty_of_fst_eq_fst h)\n", "additional_info": "", "used_premises": [1, 825, 111, 1064, 404], "def_path": "ConNF/FOA/Action/NearLitterAction.lean", "pos": [242, 247], "informalization": "The function `ConNF.NearLitterAction.roughLitterMapOrElse` is injective when restricted to the domain of `φ.litterMap`."}
{"full_name": "ConNF.NearLitterAction.mk_not_bannedLitter_and_flexible", "url": "ConNF/FOA/Action/NearLitterAction.html#ConNF.NearLitterAction.mk_not_bannedLitter_and_flexible", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterAction.mk_not_bannedLitter_and_flexible [ConNF.Params🔗<|PREMISE|>🔗 ] (φ : ConNF.NearLitterAction) [ConNF.Level] [ConNF.FOAAssumptions] {β : ConNF.Λ} {A : ConNF.ExtendedIndex🔗<|PREMISE|>🔗 ↑β} :Cardinal.mk🔗<|PREMISE|>🔗 ↑{L : ConNF.Litter | ¬ ConNF.NearLitterAction.BannedLitter🔗<|PREMISE|>🔗 φ L ∧ ConNF.Flexible🔗<|PREMISE|>🔗 A L} = Cardinal.mk🔗<|PREMISE|>🔗 ConNF.μ", "code": "theorem mk_not_bannedLitter_and_flexible : #{L | ¬φ.BannedLitter L ∧ Flexible A L} = #μ := by\n  refine' le_antisymm ((mk_subtype_le _).trans mk_litter.le) _\n  by_contra h\n  rw [not_le] at h\n  have h₁ := Cardinal.le_mk_diff_add_mk {L | Flexible A L} {L | φ.BannedLitter L}\n  rw [mk_flexible, diff_eq, inter_comm] at h₁\n  have h₂ := add_lt_of_lt Params.μ_isStrongLimit.isLimit.aleph0_le h\n    (lt_trans φ.bannedLitter_small Params.κ_lt_μ)\n  exact h₁.not_lt h₂\n", "additional_info": "", "used_premises": [1, 61, 29, 1065, 842, 29], "def_path": "ConNF/FOA/Action/NearLitterAction.lean", "pos": [250, 259], "informalization": "The theorem `ConNF.NearLitterAction.mk_not_bannedLitter_and_flexible` states that in the context of Constructive Ordinal Notation (ConNF), the cardinality of the set of litters that are not banned and are also flexible is equal to the cardinality of the base type `μ`. This theorem is crucial in ensuring that the construction of the natural numbers in ConNF is well-defined and consistent."}
{"full_name": "ConNF.NearLitterAction.mk_dom_inter_flexible_symmDiff_le", "url": "ConNF/FOA/Action/NearLitterAction.html#ConNF.NearLitterAction.mk_dom_inter_flexible_symmDiff_le", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterAction.mk_dom_inter_flexible_symmDiff_le [ConNF.Params🔗<|PREMISE|>🔗 ] (φ : ConNF.NearLitterAction) [ConNF.Level] [ConNF.FOAAssumptions] {β : ConNF.Λ} {A : ConNF.ExtendedIndex🔗<|PREMISE|>🔗 ↑β} :Cardinal.mk🔗<|PREMISE|>🔗 ↑(symmDiff🔗<|PREMISE|>🔗 (PFun.Dom🔗<|PREMISE|>🔗 φ.litterMap ∩ {L : ConNF.Litter | ConNF.Flexible🔗<|PREMISE|>🔗 A L}) (ConNF.NearLitterAction.roughLitterMapOrElse🔗<|PREMISE|>🔗 φ '' (PFun.Dom🔗<|PREMISE|>🔗 φ.litterMap ∩ {L : ConNF.Litter | ConNF.Flexible🔗<|PREMISE|>🔗 A L}))) ≤ Cardinal.mk🔗<|PREMISE|>🔗 ↑{L : ConNF.Litter | ¬ ConNF.NearLitterAction.BannedLitter🔗<|PREMISE|>🔗 φ L ∧ ConNF.Flexible🔗<|PREMISE|>🔗 A L}", "code": "theorem mk_dom_inter_flexible_symmDiff_le :\n    #((φ.litterMap.Dom ∩ {L | Flexible A L}) ∆\n        (φ.roughLitterMapOrElse '' (φ.litterMap.Dom ∩ {L | Flexible A L})) : Set Litter) ≤\n      #{L : Litter | ¬φ.BannedLitter L ∧ Flexible A L} := by\n  rw [mk_not_bannedLitter_and_flexible]\n  refine' le_trans (le_of_lt _) Params.κ_lt_μ.le\n  exact Small.symmDiff (Small.mono (inter_subset_left _ _) φ.litterMap_dom_small)\n    (Small.mono (inter_subset_left _ _) φ.litterMap_dom_small).image\n", "additional_info": "", "used_premises": [1, 61, 29, 62, 404, 842, 1064, 404, 842, 29, 1065, 842], "def_path": "ConNF/FOA/Action/NearLitterAction.lean", "pos": [260, 268], "informalization": "The theorem is proving an inequality involving the cardinalities of two sets related to Constructive Ordinal Notation (ConNF). The left-hand side of the inequality represents the cardinality of the symmetric difference between two sets of litters. The first set contains litters that are both in the domain of `φ.litterMap` and are considered *flexible* by `A`, while the second set contains the results of applying `ConNF.NearLitterAction.roughLitterMapOrElse` to the first set. The right-hand side of the inequality represents the cardinality of a set of litters that are both not *banned* and *flexible* by `A`. The theorem shows that the cardinality of the left-hand side is less than or equal to the cardinality of the right-hand side."}
{"full_name": "ConNF.NearLitterAction.aleph0_le_not_bannedLitter_and_flexible", "url": "ConNF/FOA/Action/NearLitterAction.html#ConNF.NearLitterAction.aleph0_le_not_bannedLitter_and_flexible", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterAction.aleph0_le_not_bannedLitter_and_flexible [ConNF.Params🔗<|PREMISE|>🔗 ] (φ : ConNF.NearLitterAction) [ConNF.Level] [ConNF.FOAAssumptions] {β : ConNF.Λ} {A : ConNF.ExtendedIndex🔗<|PREMISE|>🔗 ↑β} :Cardinal.aleph0🔗<|PREMISE|>🔗 ≤ Cardinal.mk🔗<|PREMISE|>🔗 ↑{L : ConNF.Litter | ¬ ConNF.NearLitterAction.BannedLitter🔗<|PREMISE|>🔗 φ L ∧ ConNF.Flexible🔗<|PREMISE|>🔗 A L}", "code": "theorem aleph0_le_not_bannedLitter_and_flexible :\n    ℵ₀ ≤ #{L | ¬φ.BannedLitter L ∧ Flexible A L} := by\n  rw [mk_not_bannedLitter_and_flexible]\n  exact Params.μ_isStrongLimit.isLimit.aleph0_le\n", "additional_info": "", "used_premises": [1, 61, 510, 29, 1065, 842], "def_path": "ConNF/FOA/Action/NearLitterAction.lean", "pos": [269, 273], "informalization": "The theorem `ConNF.NearLitterAction.aleph0_le_not_bannedLitter_and_flexible` states that the cardinality of the set of litters that are not banned and are considered flexible is at least as large as the cardinality of the natural numbers (denoted as `ℵ₀`). This theorem is an important step in the proof that the natural numbers can be constructed within the context of Constructive Ordinal Notation (ConNF), using the properties of litters and f-maps."}
{"full_name": "ConNF.NearLitterAction.disjoint_dom_inter_flexible_not_bannedLitter", "url": "ConNF/FOA/Action/NearLitterAction.html#ConNF.NearLitterAction.disjoint_dom_inter_flexible_not_bannedLitter", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterAction.disjoint_dom_inter_flexible_not_bannedLitter [ConNF.Params🔗<|PREMISE|>🔗 ] (φ : ConNF.NearLitterAction) [ConNF.Level] [ConNF.FOAAssumptions] {β : ConNF.Λ} {A : ConNF.ExtendedIndex🔗<|PREMISE|>🔗 ↑β} :Disjoint🔗<|PREMISE|>🔗 (PFun.Dom🔗<|PREMISE|>🔗 φ.litterMap ∩ {L : ConNF.Litter | ConNF.Flexible🔗<|PREMISE|>🔗 A L} ∪ ConNF.NearLitterAction.roughLitterMapOrElse🔗<|PREMISE|>🔗 φ '' (PFun.Dom🔗<|PREMISE|>🔗 φ.litterMap ∩ {L : ConNF.Litter | ConNF.Flexible🔗<|PREMISE|>🔗 A L})) {L : ConNF.Litter | ¬ ConNF.NearLitterAction.BannedLitter🔗<|PREMISE|>🔗 φ L ∧ ConNF.Flexible🔗<|PREMISE|>🔗 A L}", "code": "theorem disjoint_dom_inter_flexible_not_bannedLitter :\n    Disjoint\n      (φ.litterMap.Dom ∩ {L | Flexible A L} ∪\n        φ.roughLitterMapOrElse '' (φ.litterMap.Dom ∩ {L | Flexible A L}))\n      {L : Litter | ¬φ.BannedLitter L ∧ Flexible A L} := by\n  refine' disjoint_of_subset _ (inter_subset_left _ _) φ.disjoint_dom_not_bannedLitter\n  rintro a (ha | ⟨b, hb, rfl⟩)\n  exact Or.inl ha.1\n  exact Or.inr ⟨b, hb.1, rfl⟩\n", "additional_info": "", "used_premises": [1, 61, 757, 404, 842, 1064, 404, 842, 1065, 842], "def_path": "ConNF/FOA/Action/NearLitterAction.lean", "pos": [274, 283], "informalization": "In the context of Constructive Ordinal Notation (ConNF), this result establishes that the intersection of the domain of the litter map of a `ConNF.NearLitterAction` object and the set of `ConNF.Flexible` litters is disjoint from the set of litters that are not `ConNF.NearLitterAction.BannedLitter` and are `ConNF.Flexible`. This is an important property that ensures the consistency of the construction of the natural numbers in ConNF."}
{"full_name": "ConNF.NearLitterAction.roughLitterMapOrElse_injOn_dom_inter_flexible", "url": "ConNF/FOA/Action/NearLitterAction.html#ConNF.NearLitterAction.roughLitterMapOrElse_injOn_dom_inter_flexible", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterAction.roughLitterMapOrElse_injOn_dom_inter_flexible [ConNF.Params🔗<|PREMISE|>🔗 ] (φ : ConNF.NearLitterAction) [ConNF.Level] [ConNF.FOAAssumptions] {β : ConNF.Λ} {A : ConNF.ExtendedIndex🔗<|PREMISE|>🔗 ↑β} (hφ : ConNF.NearLitterAction.Lawful🔗<|PREMISE|>🔗 φ) :Set.InjOn🔗<|PREMISE|>🔗 (ConNF.NearLitterAction.roughLitterMapOrElse🔗<|PREMISE|>🔗 φ) (PFun.Dom🔗<|PREMISE|>🔗 φ.litterMap ∩ {L : ConNF.Litter | ConNF.Flexible🔗<|PREMISE|>🔗 A L})", "code": "theorem roughLitterMapOrElse_injOn_dom_inter_flexible (hφ : φ.Lawful) :\n    InjOn φ.roughLitterMapOrElse (φ.litterMap.Dom ∩ {L | Flexible A L}) :=\n  (φ.roughLitterMapOrElse_injOn hφ).mono (inter_subset_left _ _)\n", "additional_info": "", "used_premises": [1, 61, 825, 111, 1064, 404, 842], "def_path": "ConNF/FOA/Action/NearLitterAction.lean", "pos": [284, 287], "informalization": "The theorem `ConNF.NearLitterAction.roughLitterMapOrElse_injOn_dom_inter_flexible` states that the function `ConNF.NearLitterAction.roughLitterMapOrElse`, which takes a `ConNF.NearLitterAction` object `φ` and a `ConNF.Litter` object `L`, and returns the first component of the result of applying `ConNF.NearLitterAction.litterMapOrElse` to `φ` and `L`, is injective when restricted to the intersection of the domain of `φ.litterMap` and the set of *flexible* litters. This property is crucial in ensuring that the construction of the natural numbers in ConNF is well-defined and consistent."}
{"full_name": "ConNF.NearLitterAction.flexibleLitterPartialPerm_apply_eq", "url": "ConNF/FOA/Action/NearLitterAction.html#ConNF.NearLitterAction.flexibleLitterPartialPerm_apply_eq", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterAction.flexibleLitterPartialPerm_apply_eq [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.FOAAssumptions] {β : ConNF.Λ} {A : ConNF.ExtendedIndex🔗<|PREMISE|>🔗 ↑β} {φ : ConNF.NearLitterAction} {hφ : ConNF.NearLitterAction.Lawful🔗<|PREMISE|>🔗 φ} (L : ConNF.Litter) (hL₁ : L ∈ PFun.Dom🔗<|PREMISE|>🔗 φ.litterMap) (hL₂ : ConNF.Flexible🔗<|PREMISE|>🔗 A L) :(ConNF.NearLitterAction.flexibleLitterPartialPerm🔗<|PREMISE|>🔗 φ hφ A).toFun L = ConNF.NearLitterAction.roughLitterMapOrElse🔗<|PREMISE|>🔗 φ L", "code": "theorem flexibleLitterPartialPerm_apply_eq {φ : NearLitterAction} {hφ : φ.Lawful} (L : Litter)\n    (hL₁ : L ∈ φ.litterMap.Dom) (hL₂ : Flexible A L) :\n    φ.flexibleLitterPartialPerm hφ A L = φ.roughLitterMapOrElse L :=\n  PartialPerm.complete_apply_eq _ _ _ ⟨hL₁, hL₂⟩\n", "additional_info": "", "used_premises": [1, 61, 825, 404, 842, 1150, 1064], "def_path": "ConNF/FOA/Action/NearLitterAction.lean", "pos": [294, 298], "informalization": "To summarize the explanation of the Lean 4 object `ConNF.NearLitterAction.flexibleLitterPartialPerm_apply_eq` in one line, it states that the application of the partial permutation `ConNF.NearLitterAction.flexibleLitterPartialPerm` to a litter `L` that is both not banned and flexible with respect to the extended index `A` yields the same result as applying the `ConNF.NearLitterAction.roughLitterMapOrElse` to `L`."}
{"full_name": "ConNF.NearLitterAction.flexibleLitterPartialPerm", "url": "ConNF/FOA/Action/NearLitterAction.html#ConNF.NearLitterAction.flexibleLitterPartialPerm", "code_src": "con-nf", "ptype": "noncomputable def", "header": "noncomputable def ConNF.NearLitterAction.flexibleLitterPartialPerm [ConNF.Params🔗<|PREMISE|>🔗 ] (φ : ConNF.NearLitterAction) [ConNF.Level] [ConNF.FOAAssumptions] {β : ConNF.Λ} (hφ : ConNF.NearLitterAction.Lawful🔗<|PREMISE|>🔗 φ) (A : ConNF.ExtendedIndex🔗<|PREMISE|>🔗 ↑β) :PartialPerm🔗<|PREMISE|>🔗 ConNF.Litter", "code": "noncomputable def flexibleLitterPartialPerm (hφ : φ.Lawful) (A : ExtendedIndex β) : PartialPerm Litter :=\n  PartialPerm.complete φ.roughLitterMapOrElse (φ.litterMap.Dom ∩ {L | Flexible A L})\n    {L | ¬φ.BannedLitter L ∧ Flexible A L} φ.mk_dom_inter_flexible_symmDiff_le\n    φ.aleph0_le_not_bannedLitter_and_flexible φ.disjoint_dom_inter_flexible_not_bannedLitter\n    (φ.roughLitterMapOrElse_injOn_dom_inter_flexible hφ)\n", "additional_info": "Equations\n* One or more equations did not get rendered due to their size.\n\n", "used_premises": [1, 825, 61, 645], "def_path": "ConNF/FOA/Action/NearLitterAction.lean", "pos": [288, 293], "informalization": "Function `ConNF.NearLitterAction.flexibleLitterPartialPerm` is a partial permutation on the set of litters in the context of Constructive Ordinal Notation (ConNF). Given a lawful near litter action `φ` and an extended index `A`, it constructs a partial permutation on the set of litters by completing the rough litter map `φ.roughLitterMapOrElse` on the intersection of its domain with the set of litters that are both not banned and flexible with respect to `A`."}
{"full_name": "ConNF.NearLitterAction.flexibleLitterPartialPerm_domain_small", "url": "ConNF/FOA/Action/NearLitterAction.html#ConNF.NearLitterAction.flexibleLitterPartialPerm_domain_small", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterAction.flexibleLitterPartialPerm_domain_small [ConNF.Params🔗<|PREMISE|>🔗 ] (φ : ConNF.NearLitterAction) [ConNF.Level] [ConNF.FOAAssumptions] {β : ConNF.Λ} {A : ConNF.ExtendedIndex🔗<|PREMISE|>🔗 ↑β} (hφ : ConNF.NearLitterAction.Lawful🔗<|PREMISE|>🔗 φ) :ConNF.Small🔗<|PREMISE|>🔗 (ConNF.NearLitterAction.flexibleLitterPartialPerm🔗<|PREMISE|>🔗 φ hφ A).domain", "code": "theorem flexibleLitterPartialPerm_domain_small (hφ : φ.Lawful) :\n    Small (φ.flexibleLitterPartialPerm hφ A).domain := by\n  refine' Small.union (Small.union _ _) _\n  · exact φ.litterMap_dom_small.mono (inter_subset_left _ _)\n  · exact (φ.litterMap_dom_small.mono (inter_subset_left _ _)).image\n  · rw [Small]\n    rw [Cardinal.mk_congr (PartialPerm.sandboxSubsetEquiv _ _)]\n    simp only [mk_sum, mk_prod, mk_denumerable, lift_aleph0, lift_uzero, lift_id]\n    refine' add_lt_of_lt Params.κ_isRegular.aleph0_le _ _ <;>\n      refine' mul_lt_of_lt Params.κ_isRegular.aleph0_le\n        (lt_of_le_of_lt aleph0_le_mk_Λ Params.Λ_lt_κ) _ <;>\n      refine' lt_of_le_of_lt (mk_subtype_mono (diff_subset _ _)) _\n    exact φ.litterMap_dom_small.mono (inter_subset_left _ _)\n    exact (φ.litterMap_dom_small.mono (inter_subset_left _ _)).image\n", "additional_info": "", "used_premises": [1, 61, 825, 233, 1150], "def_path": "ConNF/FOA/Action/NearLitterAction.lean", "pos": [299, 313], "informalization": "In the context of Constructive Ordinal Notation (ConNF), given a lawful near litter action `φ` and an extended index `A`, the domain of the partial permutation `ConNF.NearLitterAction.flexibleLitterPartialPerm φ hφ A` is small, meaning its cardinality is strictly less than the cardinality of the type `ConNF.κ`."}
{"full_name": "ConNF.NearLitterAction.refineLawful", "url": "ConNF/FOA/Action/Refine.html#ConNF.NearLitterAction.refineLawful", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterAction.refineLawful [ConNF.Params🔗<|PREMISE|>🔗 ] {φ : ConNF.NearLitterAction} {hφ : ConNF.NearLitterAction.Lawful🔗<|PREMISE|>🔗 φ} :ConNF.NearLitterAction.Lawful🔗<|PREMISE|>🔗 (ConNF.NearLitterAction.refine🔗<|PREMISE|>🔗 φ hφ)", "code": "theorem refineLawful : (φ.refine hφ).Lawful :=\n  fillAtomOrbitsLawful _ _ (fillAtomRange_symmDiff_subset_ran hφ)\n", "additional_info": "", "used_premises": [1, 825, 825, 1153], "def_path": "ConNF/FOA/Action/Refine.lean", "pos": [26, 28], "informalization": "Function `ConNF.NearLitterAction.refine` takes a lawful near litter action `φ` and refines it to ensure that the atom and litter maps are injective and that the images of atoms in litters are mapped to atoms inside the corresponding near-litters. The theorem `ConNF.NearLitterAction.refineLawful` asserts that the refined near litter action is lawful."}
{"full_name": "ConNF.NearLitterAction.refine", "url": "ConNF/FOA/Action/Refine.html#ConNF.NearLitterAction.refine", "code_src": "con-nf", "ptype": "noncomputable def", "header": "noncomputable def ConNF.NearLitterAction.refine [ConNF.Params🔗<|PREMISE|>🔗 ] (φ : ConNF.NearLitterAction) (hφ : ConNF.NearLitterAction.Lawful🔗<|PREMISE|>🔗 φ) :ConNF.NearLitterAction", "code": "noncomputable def refine (hφ : φ.Lawful) : NearLitterAction :=\n  φ.fillAtomRange.fillAtomOrbits (φ.fillAtomRangeLawful hφ)\n", "additional_info": "Equations\n* 🗟ConNF.NearLitterAction.refine🗟🔗../../.././ConNF/FOA/Action/Refine.html#ConNF.NearLitterAction.refine🔗  φ hφ 🗟=🗟🔗../../.././Init/Prelude.html#Eq🔗  🗟ConNF.NearLitterAction.fillAtomOrbits🗟🔗../../.././ConNF/FOA/Action/FillAtomOrbits.html#ConNF.NearLitterAction.fillAtomOrbits🔗  (🗟ConNF.NearLitterAction.fillAtomRange🗟🔗../../.././ConNF/FOA/Action/FillAtomRange.html#ConNF.NearLitterAction.fillAtomRange🔗  φ) ⋯\n\n", "used_premises": [1, 825], "def_path": "ConNF/FOA/Action/Refine.lean", "pos": [21, 23], "informalization": "Function `ConNF.NearLitterAction.refine` takes a lawful near litter action `φ` and refines it to ensure that the atom and litter maps are injective and that the images of atoms in litters are mapped to atoms inside the corresponding near-litters."}
{"full_name": "ConNF.NearLitterAction.refine_atomMap", "url": "ConNF/FOA/Action/Refine.html#ConNF.NearLitterAction.refine_atomMap", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.NearLitterAction.refine_atomMap [ConNF.Params🔗<|PREMISE|>🔗 ] {φ : ConNF.NearLitterAction} {hφ : ConNF.NearLitterAction.Lawful🔗<|PREMISE|>🔗 φ} {a : ConNF.Atom} (ha : (φ.atomMap a).Dom) :(ConNF.NearLitterAction.refine🔗<|PREMISE|>🔗 φ hφ).atomMap a = φ.atomMap a", "code": "theorem refine_atomMap {a : Atom} (ha : (φ.atomMap a).Dom) :\n    (φ.refine hφ).atomMap a = φ.atomMap a := by\n  unfold refine\n  refine' Part.ext' _ _\n  · simp only [ha, fillAtomOrbits_atomMap, orbitAtomMap_dom_iff,\n      fillAtomRange_atomMap, iff_true_iff]\n    exact Or.inl (Or.inl ha)\n  intros\n  refine' (φ.fillAtomRange.orbitAtomMap_eq_of_mem_dom _ _ (Or.inl ha)).trans _\n  exact φ.supportedAction_eq_of_dom ha\n", "additional_info": "", "used_premises": [1, 825, 1153], "def_path": "ConNF/FOA/Action/Refine.lean", "pos": [30, 40], "informalization": "Function `ConNF.NearLitterAction.refine_atomMap` is a part of the Constructive Ordinal Notation (ConNF) library in Lean 4. It states that the refined atom map of a lawful near litter action `φ` is equal to the original atom map of `φ`."}
{"full_name": "ConNF.NearLitterAction.refine_litterMap", "url": "ConNF/FOA/Action/Refine.html#ConNF.NearLitterAction.refine_litterMap", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.NearLitterAction.refine_litterMap [ConNF.Params🔗<|PREMISE|>🔗 ] {φ : ConNF.NearLitterAction} {hφ : ConNF.NearLitterAction.Lawful🔗<|PREMISE|>🔗 φ} :(ConNF.NearLitterAction.refine🔗<|PREMISE|>🔗 φ hφ).litterMap = φ.litterMap", "code": "theorem refine_litterMap : (φ.refine hφ).litterMap = φ.litterMap :=\n  rfl\n", "additional_info": "", "used_premises": [1, 825, 1153], "def_path": "ConNF/FOA/Action/Refine.lean", "pos": [47, 49], "informalization": "The function `ConNF.NearLitterAction.refine` takes a lawful near litter action `φ` and refines it to ensure that the atom and litter maps are injective and that the images of atoms in litters are mapped to atoms inside the corresponding near-litters. The theorem `ConNF.NearLitterAction.refine_litterMap` states that the refined litter map is equal to the original litter map."}
{"full_name": "ConNF.NearLitterAction.refine_precise", "url": "ConNF/FOA/Action/Refine.html#ConNF.NearLitterAction.refine_precise", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterAction.refine_precise [ConNF.Params🔗<|PREMISE|>🔗 ] {φ : ConNF.NearLitterAction} {hφ : ConNF.NearLitterAction.Lawful🔗<|PREMISE|>🔗 φ} :ConNF.NearLitterAction.Precise🔗<|PREMISE|>🔗 (ConNF.NearLitterAction.refine🔗<|PREMISE|>🔗 φ hφ)", "code": "theorem refine_precise : Precise (φ.refine hφ) :=\n  fillAtomOrbits_precise _ (fillAtomRange_symmDiff_subset_ran hφ)\n", "additional_info": "", "used_premises": [1, 825, 1123, 1153], "def_path": "ConNF/FOA/Action/Refine.lean", "pos": [50, 52], "informalization": "The function `ConNF.NearLitterAction.refine` takes a lawful near litter action `φ` and refines it to ensure that the atom and litter maps are injective and that the images of atoms in litters are mapped to atoms inside the corresponding near-litters. The theorem `ConNF.NearLitterAction.refine_precise` states that the refined near litter action is precise, meaning it is precise at every litter in its domain."}
{"full_name": "ConNF.StructAction.refine_lawful", "url": "ConNF/FOA/Action/Refine.html#ConNF.StructAction.refine_lawful", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.StructAction.refine_lawful [ConNF.Params🔗<|PREMISE|>🔗 ] {β : ConNF.TypeIndex} {φ : ConNF.StructAction🔗<|PREMISE|>🔗 β} {hφ : ConNF.StructAction.Lawful🔗<|PREMISE|>🔗 φ} :ConNF.StructAction.Lawful🔗<|PREMISE|>🔗 (ConNF.StructAction.refine🔗<|PREMISE|>🔗 φ hφ)", "code": "theorem refine_lawful : (φ.refine hφ).Lawful := fun _ => NearLitterAction.refineLawful\n", "additional_info": "", "used_premises": [1, 808, 809, 809, 1158], "def_path": "ConNF/FOA/Action/Refine.lean", "pos": [63, 64], "informalization": "Function `ConNF.StructAction.refine_lawful` proves that the refined `β`-structural action satisfies the lawfulness condition for each `β`-extended index."}
{"full_name": "ConNF.StructAction.refine", "url": "ConNF/FOA/Action/Refine.html#ConNF.StructAction.refine", "code_src": "con-nf", "ptype": "noncomputable def", "header": "noncomputable def ConNF.StructAction.refine [ConNF.Params🔗<|PREMISE|>🔗 ] {β : ConNF.TypeIndex} (φ : ConNF.StructAction🔗<|PREMISE|>🔗 β) (hφ : ConNF.StructAction.Lawful🔗<|PREMISE|>🔗 φ) :ConNF.StructAction🔗<|PREMISE|>🔗 β", "code": "noncomputable def refine : StructAction β := fun A => (φ A).refine (hφ A)\n", "additional_info": "Equations\n* 🗟ConNF.StructAction.refine🗟🔗../../.././ConNF/FOA/Action/Refine.html#ConNF.StructAction.refine🔗  φ hφ A 🗟=🗟🔗../../.././Init/Prelude.html#Eq🔗  🗟ConNF.NearLitterAction.refine🗟🔗../../.././ConNF/FOA/Action/Refine.html#ConNF.NearLitterAction.refine🔗  (φ A) ⋯\n\n", "used_premises": [1, 808, 809, 808], "def_path": "ConNF/FOA/Action/Refine.lean", "pos": [59, 60], "informalization": "Function `ConNF.StructAction.refine` takes a `β`-structural action `φ` and a proof that `φ` satisfies the lawfulness condition for each `β`-extended index, and returns a refined `β`-structural action."}
{"full_name": "ConNF.StructAction.refine_precise", "url": "ConNF/FOA/Action/Refine.html#ConNF.StructAction.refine_precise", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.StructAction.refine_precise [ConNF.Params🔗<|PREMISE|>🔗 ] {β : ConNF.TypeIndex} {φ : ConNF.StructAction🔗<|PREMISE|>🔗 β} {hφ : ConNF.StructAction.Lawful🔗<|PREMISE|>🔗 φ} :ConNF.StructAction.Precise🔗<|PREMISE|>🔗 (ConNF.StructAction.refine🔗<|PREMISE|>🔗 φ hφ)", "code": "theorem refine_precise : Precise (φ.refine hφ) := fun _ => NearLitterAction.refine_precise\n", "additional_info": "", "used_premises": [1, 808, 809, 1160, 1158], "def_path": "ConNF/FOA/Action/Refine.lean", "pos": [83, 84], "informalization": "The theorem `ConNF.StructAction.refine_precise` states that if `φ` is a `β`-structural action that satisfies the lawfulness condition for each `β`-extended index, then the refined `β`-structural action `ConNF.StructAction.refine φ hφ` is precise, meaning it assigns a precise near-litter action to each `β`-extended index."}
{"full_name": "ConNF.StructAction.Precise", "url": "ConNF/FOA/Action/StructAction.html#ConNF.StructAction.Precise", "code_src": "con-nf", "ptype": "def", "header": "def ConNF.StructAction.Precise [ConNF.Params🔗<|PREMISE|>🔗 ] {β : ConNF.TypeIndex} (φ : ConNF.StructAction🔗<|PREMISE|>🔗 β) :Prop", "code": "def Precise {β : TypeIndex} (φ : StructAction β) : Prop :=\n  ∀ B, (φ B).Precise\n", "additional_info": "Equations\n* 🗟ConNF.StructAction.Precise🗟🔗../../.././ConNF/FOA/Action/StructAction.html#ConNF.StructAction.Precise🔗  φ 🗟=🗟🔗../../.././Init/Prelude.html#Eq🔗  ∀ (B : 🗟ConNF.ExtendedIndex🗟🔗../../.././ConNF/Structural/Index.html#ConNF.ExtendedIndex🔗  β), 🗟ConNF.NearLitterAction.Precise🗟🔗../../.././ConNF/FOA/Action/NearLitterAction.html#ConNF.NearLitterAction.Precise🔗  (φ B)\n\n", "used_premises": [1, 808], "def_path": "ConNF/FOA/Action/StructAction.lean", "pos": [35, 37], "informalization": "Function `ConNF.StructAction.Precise` checks if a `β`-structural action `φ` is precise, meaning it assigns a precise near-litter action to each `β`-extended index."}
{"full_name": "ConNF.StructAction.rc_smul_atom_eq", "url": "ConNF/FOA/Action/Refine.html#ConNF.StructAction.rc_smul_atom_eq", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.StructAction.rc_smul_atom_eq [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.FOAAssumptions] {β : ConNF.Λ} {φ : ConNF.StructAction🔗<|PREMISE|>🔗 ↑β} {h : ConNF.StructAction.Lawful🔗<|PREMISE|>🔗 φ} {B : ConNF.ExtendedIndex🔗<|PREMISE|>🔗 ↑β} {a : ConNF.Atom} (ha : ((φ B).atomMap a).Dom) :ConNF.StructAction.rc🔗<|PREMISE|>🔗 φ h B • a = ((φ B).atomMap a).get ha", "code": "theorem rc_smul_atom_eq {φ : StructAction β} {h : φ.Lawful} {B : ExtendedIndex β} {a : Atom}\n    (ha : ((φ B).atomMap a).Dom) : φ.rc h B • a = ((φ B).atomMap a).get ha := by\n  refine' (NearLitterAction.complete_smul_atom_eq _ _).trans _\n  · exact Or.inl (Or.inl ha)\n  · simp only [refine_apply, refine_atomMap ha]\n", "additional_info": "", "used_premises": [1, 808, 809, 61, 810], "def_path": "ConNF/FOA/Action/Refine.lean", "pos": [95, 100], "informalization": "The theorem `ConNF.StructAction.rc_smul_atom_eq` is a part of the Constructive Ordinal Notation (ConNF) project in Lean 4. It states that for any `β`-structural action `φ` that is lawful, any `β`-extended index `B`, and any `Atom` `a`, if the domain of `φ B`'s atom map on `a` is not empty, then the `β`-structural approximation of `φ` applied to `B` and `a` is equal to the value of `φ B`'s atom map on `a` at the given domain element. This indicates that the `β`-structural approximation correctly extends the `β`-structural action."}
{"full_name": "ConNF.StructAction.rc_free", "url": "ConNF/FOA/Action/Refine.html#ConNF.StructAction.rc_free", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.StructAction.rc_free [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.FOAAssumptions] {β : ConNF.Λ} (φ : ConNF.StructAction🔗<|PREMISE|>🔗 ↑β) (h₁ : ConNF.StructAction.Lawful🔗<|PREMISE|>🔗 φ) (h₂ : ConNF.StructAction.MapFlexible🔗<|PREMISE|>🔗 φ) :ConNF.StructApprox.Free🔗<|PREMISE|>🔗 (ConNF.StructAction.rc🔗<|PREMISE|>🔗 φ h₁)", "code": "theorem rc_free (φ : StructAction β) (h₁ : φ.Lawful) (h₂ : φ.MapFlexible) :\n    (φ.rc h₁).Free := by\n  rintro B L' ((hL' | ⟨L', hL', rfl⟩) | hL')\n  · exact hL'.2\n  · rw [NearLitterAction.roughLitterMapOrElse_of_dom _ hL'.1]\n    exact h₂ B L' hL'.1 hL'.2\n  · exact (PartialPerm.sandboxSubset_subset _ _ hL').2\n", "additional_info": "", "used_premises": [1, 808, 809, 814, 782, 810], "def_path": "ConNF/FOA/Action/Refine.lean", "pos": [110, 117], "informalization": "The `ConNF.StructAction.rc_free` theorem proves that the `β`-structural approximation `ConNF.StructAction.rc φ h₁` is free. This means that for every `β`-extended index `A`, the near-litter approximation `(π₀ A)` is free with respect to `A`. This theorem is a key part of the ConNF construction, which aims to define a well-founded, transitive relation on the ordinals using a recursive process that leverages the properties of `β`-extended indices, near-litters, and `β`-structural approximations."}
{"full_name": "ConNF.StructAction.smul_atom_eq", "url": "ConNF/FOA/Action/StructAction.html#ConNF.StructAction.smul_atom_eq", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.StructAction.smul_atom_eq [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.FOAAssumptions] {β : ConNF.Λ} (φ : ConNF.StructAction🔗<|PREMISE|>🔗 ↑β) {hφ : ConNF.StructAction.Lawful🔗<|PREMISE|>🔗 φ} {π : ConNF.StructPerm🔗<|PREMISE|>🔗 ↑β} (hπ : ConNF.StructApprox.ExactlyApproximates🔗<|PREMISE|>🔗 (ConNF.StructAction.complete🔗<|PREMISE|>🔗 φ hφ) π) {a : ConNF.Atom} {B : ConNF.ExtendedIndex🔗<|PREMISE|>🔗 ↑β} (ha : ((φ B).atomMap a).Dom) :π B • a = ((φ B).atomMap a).get ha", "code": "theorem smul_atom_eq {hφ : φ.Lawful} {π : StructPerm β} (hπ : (φ.complete hφ).ExactlyApproximates π)\n    {a : Atom} {B : ExtendedIndex β} (ha : ((φ B).atomMap a).Dom) :\n    π B • a = ((φ B).atomMap a).get ha :=\n  (φ B).smul_atom_eq (hπ B) ha\n", "additional_info": "", "used_premises": [1, 808, 809, 55, 803, 1164, 61], "def_path": "ConNF/FOA/Action/StructAction.lean", "pos": [46, 50], "informalization": "The theorem `ConNF.StructAction.smul_atom_eq` is a part of the Constructive Ordinal Notation (ConNF) framework in Lean 4. It states that for a lawful `β`-structural action `φ`, the action of a `β`-structural permutation `π` on an atom `a` at an extended index `B` is equal to the value of the atom map at `a` given the domain condition `ha`. This theorem is crucial for ensuring that the `β`-structural approximation is an exact approximation of the `β`-structural permutation in the context of ConNF."}
{"full_name": "ConNF.StructAction.complete", "url": "ConNF/FOA/Action/StructAction.html#ConNF.StructAction.complete", "code_src": "con-nf", "ptype": "noncomputable def", "header": "noncomputable def ConNF.StructAction.complete [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.FOAAssumptions] {β : ConNF.Λ} (φ : ConNF.StructAction🔗<|PREMISE|>🔗 ↑β) (hφ : ConNF.StructAction.Lawful🔗<|PREMISE|>🔗 φ) :ConNF.StructApprox🔗<|PREMISE|>🔗 ↑β", "code": "noncomputable def complete (hφ : φ.Lawful) : StructApprox β := fun B => (φ B).complete (hφ B) B\n", "additional_info": "Equations\n* 🗟ConNF.StructAction.complete🗟🔗../../.././ConNF/FOA/Action/StructAction.html#ConNF.StructAction.complete🔗  φ hφ B 🗟=🗟🔗../../.././Init/Prelude.html#Eq🔗  🗟ConNF.NearLitterAction.complete🗟🔗../../.././ConNF/FOA/Action/Complete.html#ConNF.NearLitterAction.complete🔗  (φ B) ⋯ B\n\n", "used_premises": [1, 808, 809, 781], "def_path": "ConNF/FOA/Action/StructAction.lean", "pos": [40, 41], "informalization": "Function `ConNF.StructAction.complete` constructs a `β`-structural approximation from a `β`-structural action that satisfies the lawfulness condition."}
{"full_name": "ConNF.StructAction.smul_toNearLitter_eq_of_precise", "url": "ConNF/FOA/Action/StructAction.html#ConNF.StructAction.smul_toNearLitter_eq_of_precise", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.StructAction.smul_toNearLitter_eq_of_precise [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.FOAAssumptions] {β : ConNF.Λ} (φ : ConNF.StructAction🔗<|PREMISE|>🔗 ↑β) {hφ : ConNF.StructAction.Lawful🔗<|PREMISE|>🔗 φ} (hφp : ConNF.StructAction.Precise🔗<|PREMISE|>🔗 φ) {π : ConNF.StructPerm🔗<|PREMISE|>🔗 ↑β} (hπ : ConNF.StructApprox.ExactlyApproximates🔗<|PREMISE|>🔗 (ConNF.StructAction.complete🔗<|PREMISE|>🔗 φ hφ) π) {L : ConNF.Litter} {B : ConNF.ExtendedIndex🔗<|PREMISE|>🔗 ↑β} (hL : ((φ B).litterMap L).Dom) (hπL : π B • L = (((φ B).litterMap L).get hL).fst) :π B • ConNF.Litter.toNearLitter🔗<|PREMISE|>🔗 L = ((φ B).litterMap L).get hL", "code": "theorem smul_toNearLitter_eq_of_precise {hφ : φ.Lawful} (hφp : φ.Precise) {π : StructPerm β}\n    (hπ : (φ.complete hφ).ExactlyApproximates π) {L : Litter} {B : ExtendedIndex β}\n    (hL : ((φ B).litterMap L).Dom)\n    (hπL : π B • L = (((φ B).litterMap L).get hL).1) :\n    π B • L.toNearLitter = ((φ B).litterMap L).get hL :=\n  (φ B).smul_toNearLitter_eq_of_preciseAt (hπ B) hL (hφp B hL) hπL\n", "additional_info": "", "used_premises": [1, 808, 809, 1160, 55, 803, 1164, 61, 483], "def_path": "ConNF/FOA/Action/StructAction.lean", "pos": [51, 57], "informalization": "In the context of Constructive Ordinal Notation (ConNF), the theorem `ConNF.StructAction.smul_toNearLitter_eq_of_precise` states that if a `β`-structural action `φ` is precise, meaning it assigns a precise near-litter action to each `β`-extended index, and if a `β`-structural permutation `π` exactly approximates the `β`-structural approximation constructed from `φ`, then for any `β`-extended index `B` and any litter `L` such that the near-litter action of `φ` at `B` applied to `L` is defined, the near-litter action of `π` at `B` applied to the near-litter `L` is equal to the precise near-litter action of `φ` at `B` applied to `L`."}
{"full_name": "ConNF.StructAction.Lawful.le", "url": "ConNF/FOA/Action/StructAction.html#ConNF.StructAction.Lawful.le", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.StructAction.Lawful.le [ConNF.Params🔗<|PREMISE|>🔗 ] {β : ConNF.TypeIndex} {φ : ConNF.StructAction🔗<|PREMISE|>🔗 β} {ψ : ConNF.StructAction🔗<|PREMISE|>🔗 β} (h : ConNF.StructAction.Lawful🔗<|PREMISE|>🔗 φ) (hψ : ψ ≤ φ) :ConNF.StructAction.Lawful🔗<|PREMISE|>🔗 ψ", "code": "theorem Lawful.le {β : TypeIndex} {φ ψ : StructAction β} (h : φ.Lawful) (hψ : ψ ≤ φ) : ψ.Lawful :=\n  fun B => (h B).le (hψ B)\n", "additional_info": "", "used_premises": [1, 808, 808, 809, 809], "def_path": "ConNF/FOA/Action/StructAction.lean", "pos": [78, 80], "informalization": "The theorem `ConNF.StructAction.Lawful.le` states that if `φ` is a lawful `β`-structural action and `ψ` is a `β`-structural action that is less than or equal to `φ`, then `ψ` is also a lawful `β`-structural action."}
{"full_name": "ConNF.StructAction.le_comp", "url": "ConNF/FOA/Action/StructAction.html#ConNF.StructAction.le_comp", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.StructAction.le_comp [ConNF.Params🔗<|PREMISE|>🔗 ] {β : ConNF.TypeIndex} {γ : ConNF.TypeIndex} {φ : ConNF.StructAction🔗<|PREMISE|>🔗 β} {ψ : ConNF.StructAction🔗<|PREMISE|>🔗 β} (h : φ ≤ ψ) (A : Quiver.Path🔗<|PREMISE|>🔗 β γ) :ConNF.Tree.comp🔗<|PREMISE|>🔗 A φ ≤ ConNF.Tree.comp🔗<|PREMISE|>🔗 A ψ", "code": "theorem le_comp {β γ : TypeIndex} {φ ψ : StructAction β} (h : φ ≤ ψ) (A : Path β γ) :\n    φ.comp A ≤ ψ.comp A := fun B => h (A.comp B)\n", "additional_info": "", "used_premises": [1, 808, 808, 76, 304, 304], "def_path": "ConNF/FOA/Action/StructAction.lean", "pos": [81, 83], "informalization": "Given a `β`-structural action `φ` that is less than or equal to another `β`-structural action `ψ`, and a path `A` from type index `β` to type index `γ`, the derivative functor `ConNF.Tree.comp A φ` is less than or equal to the derivative functor `ConNF.Tree.comp A ψ`."}
{"full_name": "ConNF.StructAction.Lawful.comp", "url": "ConNF/FOA/Action/StructAction.html#ConNF.StructAction.Lawful.comp", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.StructAction.Lawful.comp [ConNF.Params🔗<|PREMISE|>🔗 ] {β : ConNF.TypeIndex} {γ : ConNF.TypeIndex} {φ : ConNF.StructAction🔗<|PREMISE|>🔗 β} (h : ConNF.StructAction.Lawful🔗<|PREMISE|>🔗 φ) (A : Quiver.Path🔗<|PREMISE|>🔗 β γ) :ConNF.StructAction.Lawful🔗<|PREMISE|>🔗 (ConNF.Tree.comp🔗<|PREMISE|>🔗 A φ)", "code": "theorem Lawful.comp {β γ : TypeIndex} {φ : StructAction β} (h : φ.Lawful) (A : Path β γ) :\n    Lawful (φ.comp A) := fun B =>\n  { atomMap_injective := (h (A.comp B)).atomMap_injective\n    litterMap_injective := (h (A.comp B)).litterMap_injective\n    atom_mem := (h (A.comp B)).atom_mem }\n", "additional_info": "", "used_premises": [1, 808, 809, 76, 809, 304], "def_path": "ConNF/FOA/Action/StructAction.lean", "pos": [84, 89], "informalization": "The theorem `ConNF.StructAction.Lawful.comp` states that if `φ` is a lawful `β`-structural action, then the composition of `φ` with any path `A` from `β` to `γ` is also lawful, forming a lawful `γ`-structural action. This property is crucial for showing that every lawful `β`-structural action can be extended to a lawful `γ`-structural action, which is a key step in the proof of the consistency of Constructive Ordinal Notation (ConNF) with ZFC."}
{"full_name": "ConNF.NearLitterAction.sandboxLitter_not_banned", "url": "ConNF/FOA/Action/Complete.html#ConNF.NearLitterAction.sandboxLitter_not_banned", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterAction.sandboxLitter_not_banned [ConNF.Params🔗<|PREMISE|>🔗 ] (φ : ConNF.NearLitterAction) :¬ ConNF.NearLitterAction.BannedLitter🔗<|PREMISE|>🔗 φ (ConNF.NearLitterAction.sandboxLitter🔗<|PREMISE|>🔗 φ)", "code": "theorem sandboxLitter_not_banned : ¬φ.BannedLitter φ.sandboxLitter :=\n  φ.not_bannedLitter_nonempty.some.prop\n", "additional_info": "", "used_premises": [1, 1065, 1170], "def_path": "ConNF/FOA/Action/Complete.lean", "pos": [24, 26], "informalization": "The sandbox litter for a near-litter action is not banned."}
{"full_name": "ConNF.NearLitterAction.sandboxLitter", "url": "ConNF/FOA/Action/Complete.html#ConNF.NearLitterAction.sandboxLitter", "code_src": "con-nf", "ptype": "noncomputable def", "header": "noncomputable def ConNF.NearLitterAction.sandboxLitter [ConNF.Params🔗<|PREMISE|>🔗 ] (φ : ConNF.NearLitterAction) :ConNF.Litter", "code": "noncomputable def sandboxLitter : Litter :=\n  φ.not_bannedLitter_nonempty.some\n", "additional_info": "The *sandbox litter* for a near-litter action is an arbitrarily chosen litter that\nisn't banned.\nEquations\n* 🗟ConNF.NearLitterAction.sandboxLitter🗟🔗../../.././ConNF/FOA/Action/Complete.html#ConNF.NearLitterAction.sandboxLitter🔗  φ 🗟=🗟🔗../../.././Init/Prelude.html#Eq🔗  ↑(🗟Nonempty.some🗟🔗../../.././Mathlib/Logic/Nonempty.html#Nonempty.some🔗  ⋯)\n\n", "used_premises": [1], "def_path": "ConNF/FOA/Action/Complete.lean", "pos": [21, 23], "informalization": "The sandbox litter for a near-litter action is an arbitrarily chosen litter that isn't banned."}
{"full_name": "ConNF.NearLitterAction.mk_atomMap_image_le_mk_sandbox", "url": "ConNF/FOA/Action/Complete.html#ConNF.NearLitterAction.mk_atomMap_image_le_mk_sandbox", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterAction.mk_atomMap_image_le_mk_sandbox [ConNF.Params🔗<|PREMISE|>🔗 ] (φ : ConNF.NearLitterAction) :Cardinal.mk🔗<|PREMISE|>🔗 ↑(symmDiff🔗<|PREMISE|>🔗 (PFun.Dom🔗<|PREMISE|>🔗 φ.atomMap) (ConNF.NearLitterAction.atomMapOrElse🔗<|PREMISE|>🔗 φ '' PFun.Dom🔗<|PREMISE|>🔗 φ.atomMap)) ≤ Cardinal.mk🔗<|PREMISE|>🔗 ↑(ConNF.litterSet🔗<|PREMISE|>🔗 (ConNF.NearLitterAction.sandboxLitter🔗<|PREMISE|>🔗 φ))", "code": "theorem mk_atomMap_image_le_mk_sandbox :\n    #(φ.atomMap.Dom ∆ (φ.atomMapOrElse '' φ.atomMap.Dom) : Set Atom) ≤\n      #(litterSet φ.sandboxLitter) := by\n  rw [mk_litterSet]\n  refine' le_trans (mk_subtype_mono symmDiff_subset_union) (le_trans (mk_union_le _ _) _)\n  refine' add_le_of_le Params.κ_isRegular.aleph0_le _ _\n  exact le_of_lt φ.atomMap_dom_small\n  exact le_trans mk_image_le (le_of_lt φ.atomMap_dom_small)\n", "additional_info": "", "used_premises": [1, 29, 62, 404, 1134, 404, 29, 467, 1170], "def_path": "ConNF/FOA/Action/Complete.lean", "pos": [27, 35], "informalization": "The theorem `ConNF.NearLitterAction.mk_atomMap_image_le_mk_sandbox` in Lean 4 is a statement about the sizes of two sets related to a `ConNF.NearLitterAction` object `φ`. It asserts that the cardinality of the symmetric difference between the domain of `φ.atomMap` and its image under `φ.atomMapOrElse`, is less than or equal to the cardinality of the litter set corresponding to the sandbox litter of `φ`. This theorem is crucial in the ConNF theory for proving the existence of a member of a specific litter in the context of Constructive Ordinal Notation."}
{"full_name": "ConNF.NearLitterAction.disjoint_sandbox", "url": "ConNF/FOA/Action/Complete.html#ConNF.NearLitterAction.disjoint_sandbox", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterAction.disjoint_sandbox [ConNF.Params🔗<|PREMISE|>🔗 ] (φ : ConNF.NearLitterAction) :Disjoint🔗<|PREMISE|>🔗 (PFun.Dom🔗<|PREMISE|>🔗 φ.atomMap ∪ ConNF.NearLitterAction.atomMapOrElse🔗<|PREMISE|>🔗 φ '' PFun.Dom🔗<|PREMISE|>🔗 φ.atomMap) (ConNF.litterSet🔗<|PREMISE|>🔗 (ConNF.NearLitterAction.sandboxLitter🔗<|PREMISE|>🔗 φ))", "code": "theorem disjoint_sandbox :\n    Disjoint (φ.atomMap.Dom ∪ φ.atomMapOrElse '' φ.atomMap.Dom) (litterSet φ.sandboxLitter) := by\n  rw [disjoint_iff_inter_eq_empty, eq_empty_iff_forall_not_mem]\n  rintro a ⟨ha₁, ha₂⟩\n  rw [mem_litterSet] at ha₂\n  have hnb := φ.sandboxLitter_not_banned\n  rw [← ha₂] at hnb\n  obtain (ha₁ | ha₁) := ha₁\n  · exact hnb (BannedLitter.atomDom a ha₁)\n  · refine' hnb _\n    simp only [mem_image, PFun.mem_dom] at ha₁\n    obtain ⟨b, ⟨_, hb, rfl⟩, rfl⟩ := ha₁\n    rw [φ.atomMapOrElse_of_dom hb]\n    exact BannedLitter.atomMap b hb\n", "additional_info": "", "used_premises": [1, 757, 404, 1134, 404, 467, 1170], "def_path": "ConNF/FOA/Action/Complete.lean", "pos": [36, 50], "informalization": "The theorem `ConNF.NearLitterAction.disjoint_sandbox` in Lean 4 states that for any near-litter action `φ`, the union of the domain of `φ.atomMap` and its image under `ConNF.NearLitterAction.atomMapOrElse` is disjoint from the litter set corresponding to the sandbox litter of `φ`. This theorem is crucial for the construction of the natural numbers in the context of Constructive Ordinal Notation (ConNF), as it ensures that the sandbox litter is distinct from the atoms that are relevant for the definition of natural numbers."}
{"full_name": "ConNF.NearLitterAction.atomPartialPerm_domain_small", "url": "ConNF/FOA/Action/Complete.html#ConNF.NearLitterAction.atomPartialPerm_domain_small", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterAction.atomPartialPerm_domain_small [ConNF.Params🔗<|PREMISE|>🔗 ] (φ : ConNF.NearLitterAction) (hφ : ConNF.NearLitterAction.Lawful🔗<|PREMISE|>🔗 φ) :ConNF.Small🔗<|PREMISE|>🔗 (ConNF.NearLitterAction.atomPartialPerm🔗<|PREMISE|>🔗 φ hφ).domain", "code": "theorem atomPartialPerm_domain_small (hφ : φ.Lawful) : Small (φ.atomPartialPerm hφ).domain :=\n  Small.union (Small.union φ.atomMap_dom_small (lt_of_le_of_lt mk_image_le φ.atomMap_dom_small))\n    φ.sandboxSubset_small\n", "additional_info": "", "used_premises": [1, 825, 233, 1174], "def_path": "ConNF/FOA/Action/Complete.lean", "pos": [75, 78], "informalization": "The theorem `ConNF.NearLitterAction.atomPartialPerm_domain_small` asserts that the domain of the partial permutation `ConNF.NearLitterAction.atomPartialPerm φ hφ` is small, meaning its cardinality is strictly less than the cardinality of the type `ConNF.κ` in the context of Constructive Ordinal Notation (ConNF)."}
{"full_name": "ConNF.NearLitterAction.atomPartialPerm", "url": "ConNF/FOA/Action/Complete.html#ConNF.NearLitterAction.atomPartialPerm", "code_src": "con-nf", "ptype": "noncomputable def", "header": "noncomputable def ConNF.NearLitterAction.atomPartialPerm [ConNF.Params🔗<|PREMISE|>🔗 ] (φ : ConNF.NearLitterAction) (hφ : ConNF.NearLitterAction.Lawful🔗<|PREMISE|>🔗 φ) :PartialPerm🔗<|PREMISE|>🔗 ConNF.Atom", "code": "noncomputable def atomPartialPerm (hφ : φ.Lawful) : PartialPerm Atom :=\n  PartialPerm.complete φ.atomMapOrElse φ.atomMap.Dom (litterSet φ.sandboxLitter)\n    φ.mk_atomMap_image_le_mk_sandbox\n    (by simpa only [mk_litterSet] using Params.κ_isRegular.aleph0_le)\n    φ.disjoint_sandbox (φ.atomMapOrElse_injective hφ)\n", "additional_info": "A local permutation induced by completing the orbits of atoms in a near-litter action.\nThis function creates forward and backward images of atoms in the *sandbox litter*,\na litter which is away from the domain and range of the approximation in question, so it should\nnot interfere with other constructions.\nEquations\n* One or more equations did not get rendered due to their size.\n\n", "used_premises": [1, 825, 645], "def_path": "ConNF/FOA/Action/Complete.lean", "pos": [55, 60], "informalization": "Function `ConNF.NearLitterAction.atomPartialPerm` completes the orbits of atoms in a near-litter action, creating forward and backward images of atoms in the sandbox litter, which is away from the domain and range of the approximation in question, ensuring it does not interfere with other constructions."}
{"full_name": "ConNF.NearLitterAction.atomPartialPerm_apply_eq", "url": "ConNF/FOA/Action/Complete.html#ConNF.NearLitterAction.atomPartialPerm_apply_eq", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterAction.atomPartialPerm_apply_eq [ConNF.Params🔗<|PREMISE|>🔗 ] (φ : ConNF.NearLitterAction) (hφ : ConNF.NearLitterAction.Lawful🔗<|PREMISE|>🔗 φ) {a : ConNF.Atom} (ha : (φ.atomMap a).Dom) :(ConNF.NearLitterAction.atomPartialPerm🔗<|PREMISE|>🔗 φ hφ).toFun a = (φ.atomMap a).get ha", "code": "theorem atomPartialPerm_apply_eq (hφ : φ.Lawful) {a : Atom} (ha : (φ.atomMap a).Dom) :\n    φ.atomPartialPerm hφ a = (φ.atomMap a).get ha := by\n  rwa [atomPartialPerm, PartialPerm.complete_apply_eq, atomMapOrElse_of_dom]\n", "additional_info": "", "used_premises": [1, 825, 1174], "def_path": "ConNF/FOA/Action/Complete.lean", "pos": [88, 91], "informalization": "The function `ConNF.NearLitterAction.atomPartialPerm_apply_eq` establishes an equality between the application of the function `ConNF.NearLitterAction.atomPartialPerm` to an atom `a` and the value obtained by applying the atom map `φ.atomMap a` directly. This function is crucial in showing that the near-litter action is lawful by ensuring that the atom permutation is well-defined and that the resulting action does not alter the essential properties of the `ConNF.Params` structure."}
{"full_name": "ConNF.NearLitterAction.complete_smul_atom_eq", "url": "ConNF/FOA/Action/Complete.html#ConNF.NearLitterAction.complete_smul_atom_eq", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterAction.complete_smul_atom_eq [ConNF.Params🔗<|PREMISE|>🔗 ] (φ : ConNF.NearLitterAction) [ConNF.Level] [ConNF.FOAAssumptions] {β : ConNF.Λ} {A : ConNF.ExtendedIndex🔗<|PREMISE|>🔗 ↑β} {hφ : ConNF.NearLitterAction.Lawful🔗<|PREMISE|>🔗 φ} {a : ConNF.Atom} (ha : (φ.atomMap a).Dom) :ConNF.NearLitterAction.complete🔗<|PREMISE|>🔗 φ hφ A • a = (φ.atomMap a).get ha", "code": "theorem complete_smul_atom_eq {hφ : φ.Lawful} {a : Atom} (ha : (φ.atomMap a).Dom) :\n    φ.complete hφ A • a = (φ.atomMap a).get ha :=\n  φ.atomPartialPerm_apply_eq hφ ha\n", "additional_info": "", "used_premises": [1, 61, 825, 1177], "def_path": "ConNF/FOA/Action/Complete.lean", "pos": [92, 95], "informalization": "Given a lawful near-litter action φ, a finite path A from a type β to the base type ⊥, and an atom a that is mapped to a near-litter by φ, the near-litter approximation (φ.complete A) applied to a is equal to the atom a itself."}
{"full_name": "ConNF.NearLitterAction.complete", "url": "ConNF/FOA/Action/Complete.html#ConNF.NearLitterAction.complete", "code_src": "con-nf", "ptype": "noncomputable def", "header": "noncomputable def ConNF.NearLitterAction.complete [ConNF.Params🔗<|PREMISE|>🔗 ] (φ : ConNF.NearLitterAction) [ConNF.Level] [ConNF.FOAAssumptions] {β : ConNF.Λ} (hφ : ConNF.NearLitterAction.Lawful🔗<|PREMISE|>🔗 φ) (A : ConNF.ExtendedIndex🔗<|PREMISE|>🔗 ↑β) :ConNF.NearLitterApprox", "code": "noncomputable def complete (hφ : φ.Lawful) (A : ExtendedIndex β) : NearLitterApprox\n    where\n  atomPerm := φ.atomPartialPerm hφ\n  litterPerm := φ.flexibleLitterPartialPerm hφ A\n  domain_small _ := Small.mono (inter_subset_right _ _) (φ.atomPartialPerm_domain_small hφ)\n", "additional_info": "A near-litter approximation built from this near-litter action.\nIts action on atoms matches that of the action, and its rough action on litters\nmatches the given litter permutation.\nEquations\n* 🗟ConNF.NearLitterAction.complete🗟🔗../../.././ConNF/FOA/Action/Complete.html#ConNF.NearLitterAction.complete🔗  φ hφ A 🗟=🗟🔗../../.././Init/Prelude.html#Eq🔗  { atomPerm := 🗟ConNF.NearLitterAction.atomPartialPerm🗟🔗../../.././ConNF/FOA/Action/Complete.html#ConNF.NearLitterAction.atomPartialPerm🔗  φ hφ,\n litterPerm := 🗟ConNF.NearLitterAction.flexibleLitterPartialPerm🗟🔗../../.././ConNF/FOA/Action/NearLitterAction.html#ConNF.NearLitterAction.flexibleLitterPartialPerm🔗  φ hφ A, domain_small := ⋯ }\n\n", "used_premises": [1, 825, 61], "def_path": "ConNF/FOA/Action/Complete.lean", "pos": [82, 87], "informalization": "Function `ConNF.NearLitterAction.complete` constructs a near-litter approximation in the context of Constructive Ordinal Notation (ConNF), given a lawful near-litter action `φ` and a finite path `A` from a type `β` to the base type `⊥`. The near-litter approximation consists of an atom permutation and a litter permutation. The atom permutation matches the action of the near-litter action on atoms, and the litter permutation matches the given litter permutation."}
{"full_name": "ConNF.NearLitterAction.complete_smul_litter_eq", "url": "ConNF/FOA/Action/Complete.html#ConNF.NearLitterAction.complete_smul_litter_eq", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.NearLitterAction.complete_smul_litter_eq [ConNF.Params🔗<|PREMISE|>🔗 ] (φ : ConNF.NearLitterAction) [ConNF.Level] [ConNF.FOAAssumptions] {β : ConNF.Λ} {A : ConNF.ExtendedIndex🔗<|PREMISE|>🔗 ↑β} {hφ : ConNF.NearLitterAction.Lawful🔗<|PREMISE|>🔗 φ} (L : ConNF.Litter) :ConNF.NearLitterAction.complete🔗<|PREMISE|>🔗 φ hφ A • L = (ConNF.NearLitterAction.flexibleLitterPartialPerm🔗<|PREMISE|>🔗 φ hφ A).toFun L", "code": "theorem complete_smul_litter_eq {hφ : φ.Lawful} (L : Litter) :\n    φ.complete hφ A • L = φ.flexibleLitterPartialPerm hφ A L :=\n  rfl\n", "additional_info": "", "used_premises": [1, 61, 825, 1177, 1150], "def_path": "ConNF/FOA/Action/Complete.lean", "pos": [97, 100], "informalization": "The theorem `ConNF.NearLitterAction.complete_smul_litter_eq` is a simplification of the action of a lawful near-litter action on a litter in the context of Constructive Ordinal Notation (ConNF). It states that the action of a near-litter approximation (which is constructed by completing a near-litter action on a finite path from a type to the base type) on a litter is equal to the action of a partial permutation on the set of litters. This theorem is important because it helps in understanding the relationship between the abstract actions of the near-litter approximation and the concrete actions of the partial permutation."}
{"full_name": "ConNF.NearLitterAction.smul_atom_eq", "url": "ConNF/FOA/Action/Complete.html#ConNF.NearLitterAction.smul_atom_eq", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterAction.smul_atom_eq [ConNF.Params🔗<|PREMISE|>🔗 ] (φ : ConNF.NearLitterAction) [ConNF.Level] [ConNF.FOAAssumptions] {β : ConNF.Λ} {A : ConNF.ExtendedIndex🔗<|PREMISE|>🔗 ↑β} {hφ : ConNF.NearLitterAction.Lawful🔗<|PREMISE|>🔗 φ} {π : ConNF.NearLitterPerm} (hπ : ConNF.NearLitterApprox.ExactlyApproximates🔗<|PREMISE|>🔗 (ConNF.NearLitterAction.complete🔗<|PREMISE|>🔗 φ hφ A) π) {a : ConNF.Atom} (ha : (φ.atomMap a).Dom) :π • a = (φ.atomMap a).get ha", "code": "theorem smul_atom_eq {hφ : φ.Lawful} {π : NearLitterPerm}\n    (hπ : (φ.complete hφ A).ExactlyApproximates π) {a : Atom} (ha : (φ.atomMap a).Dom) :\n    π • a = (φ.atomMap a).get ha := by\n  rw [← hπ.map_atom a (Or.inl (Or.inl ha)), φ.complete_smul_atom_eq ha]\n", "additional_info": "", "used_premises": [1, 61, 825, 1180, 1177], "def_path": "ConNF/FOA/Action/Complete.lean", "pos": [101, 105], "informalization": "The theorem `ConNF.NearLitterAction.smul_atom_eq` in Lean 4 is a statement about a lawful near-litter action `φ` in the context of Constructive Ordinal Notation (ConNF). It states that if `φ` is lawful and `π` is a near-litter permutation that exactly approximates the near-litter action `complete φ hφ A` where `A` is a finite path from a type `β` to the base type `⊥`, then for any atom `a` in the domain of `φ.atomMap`, the action of `π` on `a` is equal to the value obtained by applying `φ.atomMap` to `a`. This means that the action of the near-litter permutation on atoms is consistent with the action defined by the near-litter action."}
{"full_name": "ConNF.NearLitterApprox.ExactlyApproximates", "url": "ConNF/FOA/Approximation/NearLitterApprox.html#ConNF.NearLitterApprox.ExactlyApproximates", "code_src": "con-nf", "ptype": "structure", "header": "structure ConNF.NearLitterApprox.ExactlyApproximates [ConNF.Params🔗<|PREMISE|>🔗 ] (π₀ : ConNF.NearLitterApprox) (π : ConNF.NearLitterPerm) extends ConNF.NearLitterApprox.Approximates🔗<|PREMISE|>🔗 :Prop\n | map_atom : ∀ a ∈ π₀.atomPerm.domain, π₀ •  a =  π •  a\n | map_litter : ∀ L ∈ π₀.litterPerm.domain, π₀ •  L =  π •  L\n | exception_mem : ∀ (a : ConNF.Atom), ConNF.NearLitterPerm.IsException🔗<|PREMISE|>🔗  π a → a ∈  π₀.atomPerm.domain", "code": "structure ExactlyApproximates (π₀ : NearLitterApprox) (π : NearLitterPerm) extends\n    Approximates π₀ π : Prop where\n  exception_mem : ∀ a, π.IsException a → a ∈ π₀.atomPerm.domain\n", "additional_info": "", "used_premises": [1, 1181, 801], "def_path": "ConNF/FOA/Approximation/NearLitterApprox.lean", "pos": [177, 180], "informalization": "`ConNF.NearLitterApprox.ExactlyApproximates` is a structure in the context of Constructive Ordinal Notation (ConNF) that defines a relationship between two objects of type `ConNF.NearLitterApprox` and `ConNF.NearLitterPerm`. It consists of three conditions: `map_atom`, `map_litter`, and `exception_mem`. The `map_atom` condition states that for any atom `a` in the domain of `π₀.atomPerm`, the action of `π₀` on `a` is the same as the action of `π` on `a`. Similarly, the `map_litter` condition states that for any litter `L` in the domain of `π₀.litterPerm`, the action of `π₀` on `L` is the same as the action of `π` on `L`. These conditions ensure that `π₀` approximates `π` in the sense that their actions on atoms and litters are consistent. The `exception_mem` condition states that for any atom `a`, if `π` is an exception with respect to `a`, then `a` must be in the domain of `π₀.atomPerm`."}
{"full_name": "ConNF.NearLitterApprox.Approximates", "url": "ConNF/FOA/Approximation/NearLitterApprox.html#ConNF.NearLitterApprox.Approximates", "code_src": "con-nf", "ptype": "structure", "header": "structure ConNF.NearLitterApprox.Approximates [ConNF.Params🔗<|PREMISE|>🔗 ] (π₀ : ConNF.NearLitterApprox) (π : ConNF.NearLitterPerm) :Prop\n | map_atom : ∀ a ∈ π₀.atomPerm.domain, π₀ •  a =  π •  a\n | map_litter : ∀ L ∈ π₀.litterPerm.domain, π₀ •  L =  π •  L", "code": "structure Approximates (π₀ : NearLitterApprox) (π : NearLitterPerm) : Prop where\n  map_atom : ∀ a, a ∈ π₀.atomPerm.domain → π₀ • a = π • a\n  map_litter : ∀ L, L ∈ π₀.litterPerm.domain → π₀ • L = π • L\n", "additional_info": "", "used_premises": [1], "def_path": "ConNF/FOA/Approximation/NearLitterApprox.lean", "pos": [156, 159], "informalization": "Structure `Approximates` in the context of Constructive Ordinal Notation (ConNF) defines a relationship between two objects of type `ConNF.NearLitterApprox` and `ConNF.NearLitterPerm`. It consists of two conditions: `map_atom` and `map_litter`. The `map_atom` condition states that for any atom `a` in the domain of `π₀.atomPerm`, the action of `π₀` on `a` is the same as the action of `π` on `a`. Similarly, the `map_litter` condition states that for any litter `L` in the domain of `π₀.litterPerm`, the action of `π₀` on `L` is the same as the action of `π` on `L`. These conditions ensure that `π₀` approximates `π` in the sense that their actions on atoms and litters are consistent."}
{"full_name": "ConNF.NearLitterAction.smul_toNearLitter_eq_of_preciseAt", "url": "ConNF/FOA/Action/Complete.html#ConNF.NearLitterAction.smul_toNearLitter_eq_of_preciseAt", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterAction.smul_toNearLitter_eq_of_preciseAt [ConNF.Params🔗<|PREMISE|>🔗 ] (φ : ConNF.NearLitterAction) [ConNF.Level] [ConNF.FOAAssumptions] {β : ConNF.Λ} {A : ConNF.ExtendedIndex🔗<|PREMISE|>🔗 ↑β} {hφ : ConNF.NearLitterAction.Lawful🔗<|PREMISE|>🔗 φ} {π : ConNF.NearLitterPerm} (hπ : ConNF.NearLitterApprox.ExactlyApproximates🔗<|PREMISE|>🔗 (ConNF.NearLitterAction.complete🔗<|PREMISE|>🔗 φ hφ A) π) {L : ConNF.Litter} (hL : (φ.litterMap L).Dom) (hφL : ConNF.NearLitterAction.PreciseAt🔗<|PREMISE|>🔗 φ hL) (hπL : π • L = ((φ.litterMap L).get hL).fst) :π • ConNF.Litter.toNearLitter🔗<|PREMISE|>🔗 L = (φ.litterMap L).get hL", "code": "theorem smul_toNearLitter_eq_of_preciseAt {hφ : φ.Lawful} {π : NearLitterPerm}\n    (hπ : (φ.complete hφ A).ExactlyApproximates π) {L : Litter} (hL : (φ.litterMap L).Dom)\n    (hφL : φ.PreciseAt hL) (hπL : π • L = ((φ.litterMap L).get hL).1) :\n    π • L.toNearLitter = (φ.litterMap L).get hL := by\n  refine' SetLike.coe_injective _\n  ext a : 1\n  simp only [mem_smul_set_iff_inv_smul_mem, NearLitterPerm.smul_nearLitter_coe, Litter.coe_toNearLitter,\n    mem_litterSet, SetLike.mem_coe]\n  constructor\n  · intro ha\n    by_cases h : π.IsException a\n    · suffices h' : π⁻¹ • a ∈ φ.atomMap.Dom\n      · rw [hφ.atom_mem _ h' L hL] at ha\n        have := hπ.map_atom _ (Or.inl (Or.inl h'))\n        rw [φ.complete_smul_atom_eq h'] at this\n        rw [this, smul_inv_smul] at ha\n        exact ha\n      rw [← hπ.symm_map_atom a (hπ.exception_mem _ h)] at ha ⊢\n      obtain (hdom | hdom) | hdom :=\n        (φ.complete hφ A).atomPerm.symm.map_domain (hπ.exception_mem _ h)\n      · exact hdom\n      · obtain ⟨c, hc₁, hc₂⟩ := hdom\n        rw [φ.atomMapOrElse_of_dom hc₁] at hc₂\n        have := hφL.fwd c hc₁ (by rwa [hc₂])\n        rw [hc₂] at this\n        exact this\n      · exfalso\n        refine φ.sandboxLitter_not_banned ?_\n        rw [← eq_of_mem_litterSet_of_mem_litterSet ha (PartialPerm.sandboxSubset_subset _ _ hdom)]\n        exact BannedLitter.litterDom L hL\n    · by_contra h'\n      simp only [NearLitterPerm.IsException, mem_litterSet, not_or, Classical.not_not, ha] at h\n      obtain ⟨b, hb, rfl⟩ :=\n        hφL.diff (Or.inr ⟨by rw [← hπL, h.2, smul_inv_smul, mem_litterSet], h'⟩)\n      refine' h' ((hφ.atom_mem b hb L hL).mp _)\n      have := hπ.map_atom b (Or.inl (Or.inl hb))\n      rw [φ.complete_smul_atom_eq hb] at this\n      rw [this, inv_smul_smul] at ha\n      exact ha\n  · intro ha\n    by_cases h : π⁻¹ • a ∈ φ.atomMap.Dom\n    · rw [hφ.atom_mem _ h L hL]\n      have := hπ.map_atom _ (Or.inl (Or.inl h))\n      rw [φ.complete_smul_atom_eq h] at this\n      rw [this, smul_inv_smul]\n      exact ha\n    have haL : a ∈ litterSet ((φ.litterMap L).get hL).fst\n    · by_contra h'\n      obtain ⟨b, hb, rfl⟩ := hφL.diff (Or.inl ⟨ha, h'⟩)\n      have := hπ.map_atom b (Or.inl (Or.inl hb))\n      rw [φ.complete_smul_atom_eq hb] at this\n      rw [this, inv_smul_smul] at h\n      exact h hb\n    by_contra h'\n    have hex : π.IsException a\n    · refine' Or.inr fun h'' => h' (h''.trans _)\n      rw [inv_smul_eq_iff, hπL]\n      exact haL\n    obtain (hdom | ⟨b, hb₁, hb₂⟩) | hdom := hπ.exception_mem a hex\n    · obtain ⟨b, hb₁, hb₂⟩ := hφL.back ⟨hdom, ha⟩\n      have := hπ.map_atom b (Or.inl (Or.inl hb₁))\n      rw [φ.complete_smul_atom_eq hb₁] at this\n      rw [this, smul_eq_iff_eq_inv_smul] at hb₂\n      rw [hb₂] at hb₁\n      exact h hb₁\n    · rw [φ.atomMapOrElse_of_dom hb₁] at hb₂\n      have := hπ.map_atom b (Or.inl (Or.inl hb₁))\n      rw [φ.complete_smul_atom_eq hb₁, hb₂, ← inv_smul_eq_iff] at this\n      rw [this] at h\n      exact h hb₁\n    · refine' φ.sandboxLitter_not_banned _\n      rw [eq_of_mem_litterSet_of_mem_litterSet (PartialPerm.sandboxSubset_subset _ _ hdom) haL]\n      exact BannedLitter.litterMap L hL\n", "additional_info": "", "used_premises": [1, 61, 825, 1180, 1177, 1141, 483], "def_path": "ConNF/FOA/Action/Complete.lean", "pos": [106, 179], "informalization": "In the context of Constructive Ordinal Notation (ConNF), given a lawful near-litter action `φ`, a finite path `A` from a type `β` to the base type `⊥`, and a near-litter approximation `π` that exactly approximates `φ` along `A`, if `φ` is precise at a litter `L` in its domain, and `π` acts on `L` in the same way as `φ` does, then `π` acts on the near-litter corresponding to `L` in the same way as `φ` does."}
{"full_name": "ConNF.NearLitterAction.preimageLitter_not_banned", "url": "ConNF/FOA/Action/FillAtomRange.html#ConNF.NearLitterAction.preimageLitter_not_banned", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterAction.preimageLitter_not_banned [ConNF.Params🔗<|PREMISE|>🔗 ] (φ : ConNF.NearLitterAction) :¬ ConNF.NearLitterAction.BannedLitter🔗<|PREMISE|>🔗 φ (ConNF.NearLitterAction.preimageLitter🔗<|PREMISE|>🔗 φ)", "code": "theorem preimageLitter_not_banned : ¬φ.BannedLitter φ.preimageLitter :=\n  φ.not_bannedLitter_nonempty.some.prop\n", "additional_info": "", "used_premises": [1, 1065, 1184], "def_path": "ConNF/FOA/Action/FillAtomRange.lean", "pos": [24, 26], "informalization": "The theorem `ConNF.NearLitterAction.preimageLitter_not_banned` states that for any `ConNF.NearLitterAction` object `φ`, the `ConNF.NearLitterAction.preimageLitter` of `φ` is not a `ConNF.NearLitterAction.BannedLitter`. This means that the litter returned by the `preimageLitter` method is not a litter that is not allowed to be used as a sandbox because it appears somewhere that we need to preserve."}
{"full_name": "ConNF.NearLitterAction.preimageLitter", "url": "ConNF/FOA/Action/FillAtomRange.html#ConNF.NearLitterAction.preimageLitter", "code_src": "con-nf", "ptype": "noncomputable def", "header": "noncomputable def ConNF.NearLitterAction.preimageLitter [ConNF.Params🔗<|PREMISE|>🔗 ] (φ : ConNF.NearLitterAction) :ConNF.Litter", "code": "noncomputable def preimageLitter : Litter :=\n  φ.not_bannedLitter_nonempty.some\n", "additional_info": "Equations\n* 🗟ConNF.NearLitterAction.preimageLitter🗟🔗../../.././ConNF/FOA/Action/FillAtomRange.html#ConNF.NearLitterAction.preimageLitter🔗  φ 🗟=🗟🔗../../.././Init/Prelude.html#Eq🔗  ↑(🗟Nonempty.some🗟🔗../../.././Mathlib/Logic/Nonempty.html#Nonempty.some🔗  ⋯)\n\n", "used_premises": [1], "def_path": "ConNF/FOA/Action/FillAtomRange.lean", "pos": [21, 23], "informalization": "Function `ConNF.NearLitterAction.preimageLitter` is a method that takes a `ConNF.NearLitterAction` object `φ` and returns a `ConNF.Litter` object. The `ConNF.Litter` object represents a \"litter\" in the context of Constructive Ordinal Notation (ConNF), which is a set of ordinals that are related to each other in a specific way. The `ConNF.NearLitterAction` object `φ` encodes a relationship between two litters, and the `preimageLitter` method returns one of the litters involved in this relationship."}
{"full_name": "ConNF.NearLitterAction.withoutPreimage_iff", "url": "ConNF/FOA/Action/FillAtomRange.html#ConNF.NearLitterAction.withoutPreimage_iff", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterAction.withoutPreimage_iff [ConNF.Params🔗<|PREMISE|>🔗 ] (φ : ConNF.NearLitterAction) (a : ConNF.Atom) :ConNF.NearLitterAction.WithoutPreimage🔗<|PREMISE|>🔗 φ a ↔ (∃ (L : ConNF.Litter) (hL : (φ.litterMap L).Dom), a ∈ ConNF.litterSet🔗<|PREMISE|>🔗 ((φ.litterMap L).get hL).fst) ∧ (∀ (L : ConNF.Litter) (hL : (φ.litterMap L).Dom), a ∉ (φ.litterMap L).get hL) ∧ a ∉ PFun.ran🔗<|PREMISE|>🔗 φ.atomMap", "code": "@[mk_iff]\n", "additional_info": "", "used_premises": [1, 1186, 467, 824], "def_path": "ConNF/FOA/Action/FillAtomRange.lean", "pos": [31, 32], "informalization": "In the context of Constructive Ordinal Notation (ConNF), an atom is called \"without preimage\" if it is not in the range of the approximation, but it is in a litter near some near-litter in the range. Atoms without preimage need to have something map to it, so that the resulting map that we use in the freedom of action theorem actually maps to the correct near-litter. The theorem `ConNF.NearLitterAction.withoutPreimage_iff` states that an atom is without preimage if and only if there exists a litter `L` such that the first projection of `a` is equal to `L`, and `a` is not in the range of the atom map."}
{"full_name": "ConNF.NearLitterAction.WithoutPreimage", "url": "ConNF/FOA/Action/FillAtomRange.html#ConNF.NearLitterAction.WithoutPreimage", "code_src": "con-nf", "ptype": "structure", "header": "structure ConNF.NearLitterAction.WithoutPreimage [ConNF.Params🔗<|PREMISE|>🔗 ] (φ : ConNF.NearLitterAction) (a : ConNF.Atom) :Prop\n | mem_map : ∃ (L : ConNF.Litter) (hL : (φ.litterMap L).Dom), a ∈  ConNF.litterSet🔗<|PREMISE|>🔗  ((φ.litterMap L).get hL).fst\n | not_mem_map : ∀ (L : ConNF.Litter) (hL : (φ.litterMap L).Dom), a ∉ (φ.litterMap L).get hL\n | not_mem_ran : a ∉ PFun.ran🔗<|PREMISE|>🔗  φ.atomMap", "code": "structure WithoutPreimage (a : Atom) : Prop where\n  mem_map : ∃ (L : Litter) (hL : (φ.litterMap L).Dom), a ∈ litterSet ((φ.litterMap L).get hL).1\n  not_mem_map : ∀ (L : Litter) (hL : (φ.litterMap L).Dom), a ∉ (φ.litterMap L).get hL\n  not_mem_ran : a ∉ φ.atomMap.ran\n", "additional_info": "An atom is called *without preimage* if it is not in the range of the approximation,\nbut it is in a litter near some near-litter in the range.\nAtoms without preimage need to have something map to it, so that the resulting map that we use in\nthe freedom of action theorem actually maps to the correct near-litter.\n", "used_premises": [1, 467, 824], "def_path": "ConNF/FOA/Action/FillAtomRange.lean", "pos": [32, 36], "informalization": "An atom is called \"without preimage\" if it is not in the range of the approximation, but it is in a litter near some near-litter in the range. Atoms without preimage need to have something map to it, so that the resulting map that we use in the freedom of action theorem actually maps to the correct near-litter."}
{"full_name": "ConNF.NearLitterAction.withoutPreimage_small", "url": "ConNF/FOA/Action/FillAtomRange.html#ConNF.NearLitterAction.withoutPreimage_small", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterAction.withoutPreimage_small [ConNF.Params🔗<|PREMISE|>🔗 ] (φ : ConNF.NearLitterAction) :ConNF.Small🔗<|PREMISE|>🔗 {a : ConNF.Atom | ConNF.NearLitterAction.WithoutPreimage🔗<|PREMISE|>🔗 φ a}", "code": "theorem withoutPreimage_small : Small {a | φ.WithoutPreimage a} := by\n  simp only [withoutPreimage_iff, setOf_and]\n  rw [← inter_assoc]\n  refine' Small.mono (inter_subset_left _ _) _\n  suffices\n    Small (⋃ (L : Litter) (hL), litterSet ((φ.litterMap L).get hL).1 \\ (φ.litterMap L).get hL) by\n    refine' Small.mono _ this\n    rintro a ⟨⟨L, hL, ha₁⟩, ha₂⟩\n    simp only [mem_iUnion]\n    exact ⟨L, hL, ha₁, ha₂ _ _⟩\n  refine' Small.bUnion _ _\n  · refine' lt_of_le_of_lt _ φ.litterMap_dom_small\n    refine' ⟨⟨fun L => ⟨_, L.prop⟩, _⟩⟩\n    intro L₁ L₂ h\n    simp only [Subtype.mk_eq_mk, Prod.mk.inj_iff, eq_self_iff_true, and_true_iff,\n      Litter.toNearLitter_injective.eq_iff, Subtype.coe_inj] at h\n    exact h\n  · intro L hL\n    refine' Small.mono _ ((φ.litterMap L).get hL).2.prop\n    exact fun x hx => Or.inl hx\n", "additional_info": "", "used_premises": [1, 233, 1186], "def_path": "ConNF/FOA/Action/FillAtomRange.lean", "pos": [37, 57], "informalization": "In the context of Constructive Ordinal Notation (ConNF), the theorem `ConNF.NearLitterAction.withoutPreimage_small` states that the set of \"without preimage\" atoms, which are atoms that are not in the range of the approximation but are in a litter near some near-litter in the range, has a cardinality that is strictly less than the cardinality of the type `ConNF.κ`."}
{"full_name": "ConNF.NearLitterAction.preimageLitterSubset_spec", "url": "ConNF/FOA/Action/FillAtomRange.html#ConNF.NearLitterAction.preimageLitterSubset_spec", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterAction.preimageLitterSubset_spec [ConNF.Params🔗<|PREMISE|>🔗 ] (φ : ConNF.NearLitterAction) :ConNF.NearLitterAction.preimageLitterSubset🔗<|PREMISE|>🔗 φ ⊆ ConNF.litterSet🔗<|PREMISE|>🔗 (ConNF.NearLitterAction.preimageLitter🔗<|PREMISE|>🔗 φ) ∧ Cardinal.mk🔗<|PREMISE|>🔗 ↑(ConNF.NearLitterAction.preimageLitterSubset🔗<|PREMISE|>🔗 φ) = Cardinal.mk🔗<|PREMISE|>🔗 ↑{a : ConNF.Atom | ConNF.NearLitterAction.WithoutPreimage🔗<|PREMISE|>🔗 φ a}", "code": "theorem preimageLitterSubset_spec :\n    φ.preimageLitterSubset ⊆ litterSet φ.preimageLitter ∧\n      (#φ.preimageLitterSubset) = (#{a : Atom | φ.WithoutPreimage a}) :=\n  (le_mk_iff_exists_subset.mp\n      (lt_of_lt_of_eq φ.withoutPreimage_small (mk_litterSet φ.preimageLitter).symm).le).choose_spec\n", "additional_info": "", "used_premises": [1, 1189, 467, 1184, 29, 1189, 29, 1186], "def_path": "ConNF/FOA/Action/FillAtomRange.lean", "pos": [64, 69], "informalization": "Function `ConNF.NearLitterAction.preimageLitterSubset` is a subset of the preimage litter that is put in correspondence with the set of atoms without preimage in the context of Constructive Ordinal Notation. The theorem `ConNF.NearLitterAction.preimageLitterSubset_spec` states that this subset is a subset of the litter set corresponding to the preimage litter and has the same cardinality as the set of atoms without preimage."}
{"full_name": "ConNF.NearLitterAction.preimageLitterSubset", "url": "ConNF/FOA/Action/FillAtomRange.html#ConNF.NearLitterAction.preimageLitterSubset", "code_src": "con-nf", "ptype": "def", "header": "def ConNF.NearLitterAction.preimageLitterSubset [ConNF.Params🔗<|PREMISE|>🔗 ] (φ : ConNF.NearLitterAction) :Set🔗<|PREMISE|>🔗 ConNF.Atom", "code": "def preimageLitterSubset : Set Atom :=\n  (le_mk_iff_exists_subset.mp\n      (lt_of_lt_of_eq φ.withoutPreimage_small (mk_litterSet φ.preimageLitter).symm).le).choose\n", "additional_info": "The subset of the preimage litter that is put in correspondence with the set of\natoms without preimage.\nEquations\n* 🗟ConNF.NearLitterAction.preimageLitterSubset🗟🔗../../.././ConNF/FOA/Action/FillAtomRange.html#ConNF.NearLitterAction.preimageLitterSubset🔗  φ 🗟=🗟🔗../../.././Init/Prelude.html#Eq🔗  🗟Exists.choose🗟🔗../../.././Init/Classical.html#Exists.choose🔗  ⋯\n\n", "used_premises": [1, 69], "def_path": "ConNF/FOA/Action/FillAtomRange.lean", "pos": [60, 63], "informalization": "Function `ConNF.NearLitterAction.preimageLitterSubset` is a subset of the preimage litter that is put in correspondence with the set of atoms without preimage in the context of Constructive Ordinal Notation."}
{"full_name": "ConNF.NearLitterAction.preimageLitterSubset_subset", "url": "ConNF/FOA/Action/FillAtomRange.html#ConNF.NearLitterAction.preimageLitterSubset_subset", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterAction.preimageLitterSubset_subset [ConNF.Params🔗<|PREMISE|>🔗 ] (φ : ConNF.NearLitterAction) :ConNF.NearLitterAction.preimageLitterSubset🔗<|PREMISE|>🔗 φ ⊆ ConNF.litterSet🔗<|PREMISE|>🔗 (ConNF.NearLitterAction.preimageLitter🔗<|PREMISE|>🔗 φ)", "code": "theorem preimageLitterSubset_subset : φ.preimageLitterSubset ⊆ litterSet φ.preimageLitter :=\n  φ.preimageLitterSubset_spec.1\n", "additional_info": "", "used_premises": [1, 1189, 467, 1184], "def_path": "ConNF/FOA/Action/FillAtomRange.lean", "pos": [70, 72], "informalization": "Function `ConNF.NearLitterAction.preimageLitterSubset` is a subset of the preimage litter that is put in correspondence with the set of atoms without preimage in the context of Constructive Ordinal Notation. The theorem `ConNF.NearLitterAction.preimageLitterSubset_subset` states that this subset is a subset of the litter set corresponding to the preimage litter."}
{"full_name": "ConNF.NearLitterAction.preimageLitterSubset_small", "url": "ConNF/FOA/Action/FillAtomRange.html#ConNF.NearLitterAction.preimageLitterSubset_small", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterAction.preimageLitterSubset_small [ConNF.Params🔗<|PREMISE|>🔗 ] (φ : ConNF.NearLitterAction) :ConNF.Small🔗<|PREMISE|>🔗 (ConNF.NearLitterAction.preimageLitterSubset🔗<|PREMISE|>🔗 φ)", "code": "theorem preimageLitterSubset_small : Small φ.preimageLitterSubset :=\n  lt_of_eq_of_lt φ.preimageLitterSubset_spec.2 φ.withoutPreimage_small\n", "additional_info": "", "used_premises": [1, 233, 1189], "def_path": "ConNF/FOA/Action/FillAtomRange.lean", "pos": [73, 75], "informalization": "Function `ConNF.NearLitterAction.preimageLitterSubset_small` proves that the subset of the preimage litter that is put in correspondence with the set of atoms without preimage in the context of Constructive Ordinal Notation has a cardinality strictly less than the cardinality of the type `ConNF.κ`."}
{"full_name": "ConNF.NearLitterAction.mappedOutside_iff", "url": "ConNF/FOA/Action/FillAtomRange.html#ConNF.NearLitterAction.mappedOutside_iff", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterAction.mappedOutside_iff [ConNF.Params🔗<|PREMISE|>🔗 ] (φ : ConNF.NearLitterAction) (L : ConNF.Litter) (hL : (φ.litterMap L).Dom) (a : ConNF.Atom) :ConNF.NearLitterAction.MappedOutside🔗<|PREMISE|>🔗 φ L hL a ↔ a ∈ (φ.litterMap L).get hL ∧ a ∉ ConNF.litterSet🔗<|PREMISE|>🔗 ((φ.litterMap L).get hL).fst ∧ a ∉ PFun.ran🔗<|PREMISE|>🔗 φ.atomMap", "code": "@[mk_iff]\n", "additional_info": "", "used_premises": [1, 1193, 467, 824], "def_path": "ConNF/FOA/Action/FillAtomRange.lean", "pos": [82, 83], "informalization": "The theorem `ConNF.NearLitterAction.mappedOutside_iff` provides a criterion for determining whether an atom is \"mapped outside\" a litter in the context of Constructive Ordinal Notation (ConNF). Specifically, it states that an atom `a` is mapped outside a litter `L` if and only if `a` is an image of an atom in `L` under the partial function `φ.litterMap L`, but `a` is not in the domain of `φ.litterMap L`, and `a` is not in the range of `φ.atomMap`. This condition is crucial to ensure the correctness of the ConNF construction."}
{"full_name": "ConNF.NearLitterAction.MappedOutside", "url": "ConNF/FOA/Action/FillAtomRange.html#ConNF.NearLitterAction.MappedOutside", "code_src": "con-nf", "ptype": "structure", "header": "structure ConNF.NearLitterAction.MappedOutside [ConNF.Params🔗<|PREMISE|>🔗 ] (φ : ConNF.NearLitterAction) (L : ConNF.Litter) (hL : (φ.litterMap L).Dom) (a : ConNF.Atom) :Prop\n | mem_map : a ∈  (φ.litterMap L).get hL\n | not_mem_map : a ∉ ConNF.litterSet🔗<|PREMISE|>🔗  ((φ.litterMap L).get hL).fst\n | not_mem_ran : a ∉ PFun.ran🔗<|PREMISE|>🔗  φ.atomMap", "code": "structure MappedOutside (L : Litter) (hL : (φ.litterMap L).Dom) (a : Atom) : Prop where\n  mem_map : a ∈ (φ.litterMap L).get hL\n  not_mem_map : a ∉ litterSet ((φ.litterMap L).get hL).1\n  not_mem_ran : a ∉ φ.atomMap.ran\n", "additional_info": "The images of atoms in a litter `L` that were mapped outside the target litter, but\nwere not in the domain.\n", "used_premises": [1, 467, 824], "def_path": "ConNF/FOA/Action/FillAtomRange.lean", "pos": [83, 87], "informalization": "The structure `ConNF.NearLitterAction.MappedOutside` defines a condition for an atom `a` in the context of Constructive Ordinal Notation (ConNF). This condition is satisfied when `a` is an image of an atom in a litter `L` under a partial function `φ.litterMap L`, but `a` is not in the domain of `φ.litterMap L`, and `a` is not in the range of `φ.atomMap`. This condition is crucial for ensuring the correctness of the construction of ordinals in ConNF."}
{"full_name": "ConNF.NearLitterAction.mappedOutside_small", "url": "ConNF/FOA/Action/FillAtomRange.html#ConNF.NearLitterAction.mappedOutside_small", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterAction.mappedOutside_small [ConNF.Params🔗<|PREMISE|>🔗 ] (φ : ConNF.NearLitterAction) (L : ConNF.Litter) (hL : (φ.litterMap L).Dom) :ConNF.Small🔗<|PREMISE|>🔗 {a : ConNF.Atom | ConNF.NearLitterAction.MappedOutside🔗<|PREMISE|>🔗 φ L hL a}", "code": "theorem mappedOutside_small (L : Litter) (hL : (φ.litterMap L).Dom) :\n    Small {a | φ.MappedOutside L hL a} := by\n  simp only [mappedOutside_iff, setOf_and]\n  rw [← inter_assoc]\n  refine' Small.mono (inter_subset_left _ _) _\n  refine' Small.mono _ ((φ.litterMap L).get hL).2.prop\n  exact fun x hx => Or.inr hx\n", "additional_info": "There are only `< κ`-many atoms in a litter `L` that are mapped outside the image litter,\nand that are not already in the domain.", "used_premises": [1, 233, 1193], "def_path": "ConNF/FOA/Action/FillAtomRange.lean", "pos": [90, 97], "informalization": "The theorem `ConNF.NearLitterAction.mappedOutside_small` states that in the context of Constructive Ordinal Notation (ConNF), there are only `< κ`-many atoms in a litter `L` that are mapped outside the image litter, and that are not already in the domain. This result is crucial for ensuring the correctness of the construction of ordinals in ConNF."}
{"full_name": "ConNF.NearLitterAction.WithoutPreimage.not_mappedOutside", "url": "ConNF/FOA/Action/FillAtomRange.html#ConNF.NearLitterAction.WithoutPreimage.not_mappedOutside", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterAction.WithoutPreimage.not_mappedOutside [ConNF.Params🔗<|PREMISE|>🔗 ] (φ : ConNF.NearLitterAction) {a : ConNF.Atom} (ha : ConNF.NearLitterAction.WithoutPreimage🔗<|PREMISE|>🔗 φ a) (L : ConNF.Litter) (hL : (φ.litterMap L).Dom) :¬ ConNF.NearLitterAction.MappedOutside🔗<|PREMISE|>🔗 φ L hL a", "code": "theorem WithoutPreimage.not_mappedOutside {a : Atom} (ha : φ.WithoutPreimage a) (L : Litter)\n    (hL : (φ.litterMap L).Dom) : ¬φ.MappedOutside L hL a := fun ha' =>\n  ha.not_mem_map L hL ha'.mem_map\n", "additional_info": "", "used_premises": [1, 1186, 1193], "def_path": "ConNF/FOA/Action/FillAtomRange.lean", "pos": [98, 101], "informalization": "The theorem `ConNF.NearLitterAction.WithoutPreimage.not_mappedOutside` states that if an atom `a` is \"without preimage\" under a partial function `φ.litterMap L`, then `a` is not an image of any atom in the litter `L` under `φ.litterMap L`. This is a key property used in the ConNF (Constructive Ordinal Notation) project to ensure the correctness of the construction of ordinals."}
{"full_name": "ConNF.NearLitterAction.MappedOutside.not_withoutPreimage", "url": "ConNF/FOA/Action/FillAtomRange.html#ConNF.NearLitterAction.MappedOutside.not_withoutPreimage", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterAction.MappedOutside.not_withoutPreimage [ConNF.Params🔗<|PREMISE|>🔗 ] (φ : ConNF.NearLitterAction) {a : ConNF.Atom} {L : ConNF.Litter} {hL : (φ.litterMap L).Dom} (ha : ConNF.NearLitterAction.MappedOutside🔗<|PREMISE|>🔗 φ L hL a) :¬ ConNF.NearLitterAction.WithoutPreimage🔗<|PREMISE|>🔗 φ a", "code": "theorem MappedOutside.not_withoutPreimage {a : Atom} {L : Litter} {hL : (φ.litterMap L).Dom}\n    (ha : φ.MappedOutside L hL a) : ¬φ.WithoutPreimage a := fun ha' =>\n  ha'.not_mem_map L hL ha.mem_map\n", "additional_info": "", "used_premises": [1, 1193, 1186], "def_path": "ConNF/FOA/Action/FillAtomRange.lean", "pos": [102, 105], "informalization": "The theorem `ConNF.NearLitterAction.MappedOutside.not_withoutPreimage` in the context of Constructive Ordinal Notation (ConNF) states that if an atom `a` is an image of an atom in a litter `L` under a partial function `φ.litterMap L`, but `a` is not in the domain of `φ.litterMap L`, and `a` is not in the range of `φ.atomMap`, then `a` cannot be \"without preimage\". This means that `a` must have something that maps to it in order to satisfy the condition for the Freedom of Action theorem."}
{"full_name": "ConNF.NearLitterAction.mk_mapped_outside_domain", "url": "ConNF/FOA/Action/FillAtomRange.html#ConNF.NearLitterAction.mk_mapped_outside_domain", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterAction.mk_mapped_outside_domain [ConNF.Params🔗<|PREMISE|>🔗 ] (φ : ConNF.NearLitterAction) (L : ConNF.Litter) :Cardinal.mk🔗<|PREMISE|>🔗 ↑(ConNF.litterSet🔗<|PREMISE|>🔗 L \\ PFun.Dom🔗<|PREMISE|>🔗 φ.atomMap) = Cardinal.mk🔗<|PREMISE|>🔗 ConNF.κ", "code": "theorem mk_mapped_outside_domain (L : Litter) :\n    (#(litterSet L \\ φ.atomMap.Dom : Set Atom)) = (#κ) := by\n  refine' le_antisymm _ _\n  · rw [← mk_litterSet]\n    exact mk_subtype_mono fun x hx => hx.1\n  by_contra h\n  have := Small.union (lt_of_not_le h) φ.atomMap_dom_small\n  rw [diff_union_self] at this\n  exact (mk_litterSet L).not_lt (Small.mono (subset_union_left _ _) this)\n", "additional_info": "The amount of atoms in a litter that are not in the domain already is `κ`.", "used_premises": [1, 29, 467, 404, 29], "def_path": "ConNF/FOA/Action/FillAtomRange.lean", "pos": [107, 116], "informalization": "The theorem `ConNF.NearLitterAction.mk_mapped_outside_domain` states that the cardinality of the set of atoms in a litter `L` that are not in the domain of the partial function `φ.atomMap` is equal to the cardinality of the type `κ`."}
{"full_name": "ConNF.NearLitterAction.mappedOutsideSubset_spec", "url": "ConNF/FOA/Action/FillAtomRange.html#ConNF.NearLitterAction.mappedOutsideSubset_spec", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterAction.mappedOutsideSubset_spec [ConNF.Params🔗<|PREMISE|>🔗 ] (φ : ConNF.NearLitterAction) (L : ConNF.Litter) (hL : (φ.litterMap L).Dom) :ConNF.NearLitterAction.mappedOutsideSubset🔗<|PREMISE|>🔗 φ L hL ⊆ ConNF.litterSet🔗<|PREMISE|>🔗 L \\ PFun.Dom🔗<|PREMISE|>🔗 φ.atomMap ∧ Cardinal.mk🔗<|PREMISE|>🔗 ↑(ConNF.NearLitterAction.mappedOutsideSubset🔗<|PREMISE|>🔗 φ L hL) = Cardinal.mk🔗<|PREMISE|>🔗 ↑{a : ConNF.Atom | ConNF.NearLitterAction.MappedOutside🔗<|PREMISE|>🔗 φ L hL a}", "code": "theorem mappedOutsideSubset_spec (L : Litter) (hL : (φ.litterMap L).Dom) :\n    φ.mappedOutsideSubset L hL ⊆ litterSet L \\ φ.atomMap.Dom ∧\n      #(φ.mappedOutsideSubset L hL) = #{a : Atom | φ.MappedOutside L hL a} :=\n  (le_mk_iff_exists_subset.mp\n      (lt_of_lt_of_eq (φ.mappedOutside_small L hL)\n          (φ.mk_mapped_outside_domain L).symm).le).choose_spec\n", "additional_info": "", "used_premises": [1, 1199, 467, 404, 29, 1199, 29, 1193], "def_path": "ConNF/FOA/Action/FillAtomRange.lean", "pos": [122, 128], "informalization": "Function `ConNF.NearLitterAction.mappedOutsideSubset` defines a subset of atoms that are mapped outside a given litter `L`, under the condition that `L` is within the domain of the litter map `φ.litterMap L`. The theorem `ConNF.NearLitterAction.mappedOutsideSubset_spec` states that this subset is a subset of the litter set `ConNF.litterSet L` minus the domain of the atom map `φ.atomMap`, and that the cardinality of this subset is equal to the cardinality of the set of atoms that satisfy the condition `ConNF.NearLitterAction.MappedOutside`."}
{"full_name": "ConNF.NearLitterAction.mappedOutsideSubset", "url": "ConNF/FOA/Action/FillAtomRange.html#ConNF.NearLitterAction.mappedOutsideSubset", "code_src": "con-nf", "ptype": "def", "header": "def ConNF.NearLitterAction.mappedOutsideSubset [ConNF.Params🔗<|PREMISE|>🔗 ] (φ : ConNF.NearLitterAction) (L : ConNF.Litter) (hL : (φ.litterMap L).Dom) :Set🔗<|PREMISE|>🔗 ConNF.Atom", "code": "def mappedOutsideSubset (L : Litter) (hL : (φ.litterMap L).Dom) : Set Atom :=\n  (le_mk_iff_exists_subset.mp\n      (lt_of_lt_of_eq (φ.mappedOutside_small L hL) (φ.mk_mapped_outside_domain L).symm).le).choose\n", "additional_info": "To each litter we associate a subset which is to contain the atoms mapped outside it.\nEquations\n* 🗟ConNF.NearLitterAction.mappedOutsideSubset🗟🔗../../.././ConNF/FOA/Action/FillAtomRange.html#ConNF.NearLitterAction.mappedOutsideSubset🔗  φ L hL 🗟=🗟🔗../../.././Init/Prelude.html#Eq🔗  🗟Exists.choose🗟🔗../../.././Init/Classical.html#Exists.choose🔗  ⋯\n\n", "used_premises": [1, 69], "def_path": "ConNF/FOA/Action/FillAtomRange.lean", "pos": [118, 121], "informalization": "Function `ConNF.NearLitterAction.mappedOutsideSubset` is used in the context of Constructive Ordinal Notation (ConNF) to define a subset of atoms that are mapped outside a given litter `L`, under the condition that `L` is within the domain of the litter map `φ.litterMap L`."}
{"full_name": "ConNF.NearLitterAction.mappedOutsideSubset_subset", "url": "ConNF/FOA/Action/FillAtomRange.html#ConNF.NearLitterAction.mappedOutsideSubset_subset", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterAction.mappedOutsideSubset_subset [ConNF.Params🔗<|PREMISE|>🔗 ] (φ : ConNF.NearLitterAction) (L : ConNF.Litter) (hL : (φ.litterMap L).Dom) :ConNF.NearLitterAction.mappedOutsideSubset🔗<|PREMISE|>🔗 φ L hL ⊆ ConNF.litterSet🔗<|PREMISE|>🔗 L", "code": "theorem mappedOutsideSubset_subset (L : Litter) (hL : (φ.litterMap L).Dom) :\n    φ.mappedOutsideSubset L hL ⊆ litterSet L := fun _ hx =>\n  ((φ.mappedOutsideSubset_spec L hL).1 hx).1\n", "additional_info": "", "used_premises": [1, 1199, 467], "def_path": "ConNF/FOA/Action/FillAtomRange.lean", "pos": [129, 132], "informalization": "The theorem `ConNF.NearLitterAction.mappedOutsideSubset_subset` states that the subset of atoms that are mapped outside a given litter `L`, under the condition that `L` is within the domain of the litter map `φ.litterMap L`, is a subset of the set corresponding to `L`."}
{"full_name": "ConNF.NearLitterAction.mappedOutsideSubset_closure", "url": "ConNF/FOA/Action/FillAtomRange.html#ConNF.NearLitterAction.mappedOutsideSubset_closure", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterAction.mappedOutsideSubset_closure [ConNF.Params🔗<|PREMISE|>🔗 ] (φ : ConNF.NearLitterAction) (L : ConNF.Litter) (hL : (φ.litterMap L).Dom) :ConNF.NearLitterAction.mappedOutsideSubset🔗<|PREMISE|>🔗 φ L hL ⊆ (PFun.Dom🔗<|PREMISE|>🔗 φ.atomMap)ᶜ", "code": "theorem mappedOutsideSubset_closure (L : Litter) (hL : (φ.litterMap L).Dom) :\n    φ.mappedOutsideSubset L hL ⊆ φ.atomMap.Domᶜ := fun _ hx =>\n  ((φ.mappedOutsideSubset_spec L hL).1 hx).2\n", "additional_info": "", "used_premises": [1, 1199, 404], "def_path": "ConNF/FOA/Action/FillAtomRange.lean", "pos": [133, 136], "informalization": "The theorem `ConNF.NearLitterAction.mappedOutsideSubset_closure` states that the set of atoms that are mapped outside a given litter `L`, under the condition that `L` is within the domain of the litter map `φ.litterMap L`, is a subset of the complement of the domain of the atom map `φ.atomMap`."}
{"full_name": "ConNF.NearLitterAction.mappedOutsideSubset_small", "url": "ConNF/FOA/Action/FillAtomRange.html#ConNF.NearLitterAction.mappedOutsideSubset_small", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterAction.mappedOutsideSubset_small [ConNF.Params🔗<|PREMISE|>🔗 ] (φ : ConNF.NearLitterAction) (L : ConNF.Litter) (hL : (φ.litterMap L).Dom) :ConNF.Small🔗<|PREMISE|>🔗 (ConNF.NearLitterAction.mappedOutsideSubset🔗<|PREMISE|>🔗 φ L hL)", "code": "theorem mappedOutsideSubset_small (L : Litter) (hL : (φ.litterMap L).Dom) :\n    Small (φ.mappedOutsideSubset L hL) :=\n  lt_of_eq_of_lt (φ.mappedOutsideSubset_spec L hL).2 (φ.mappedOutside_small L hL)\n", "additional_info": "", "used_premises": [1, 233, 1199], "def_path": "ConNF/FOA/Action/FillAtomRange.lean", "pos": [137, 140], "informalization": "The theorem `ConNF.NearLitterAction.mappedOutsideSubset_small` states that the set of atoms that are mapped outside a given litter `L`, under the condition that `L` is within the domain of the litter map `φ.litterMap L`, has a cardinality strictly less than the cardinality of the type `ConNF.κ` in the context of Constructive Ordinal Notation (ConNF)."}
{"full_name": "ConNF.NearLitterAction.mem_supportedActionAtomMapCore_dom_iff", "url": "ConNF/FOA/Action/FillAtomRange.html#ConNF.NearLitterAction.mem_supportedActionAtomMapCore_dom_iff", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterAction.mem_supportedActionAtomMapCore_dom_iff [ConNF.Params🔗<|PREMISE|>🔗 ] (φ : ConNF.NearLitterAction) (a : ConNF.Atom) :(ConNF.NearLitterAction.supportedActionAtomMapCore🔗<|PREMISE|>🔗 φ a).Dom ↔ a ∈ PFun.Dom🔗<|PREMISE|>🔗 φ.atomMap ∪ ConNF.NearLitterAction.preimageLitterSubset🔗<|PREMISE|>🔗 φ ∪ ⋃ (L : ConNF.Litter), ⋃ (hL : (φ.litterMap L).Dom), ConNF.NearLitterAction.mappedOutsideSubset🔗<|PREMISE|>🔗 φ L hL", "code": "theorem mem_supportedActionAtomMapCore_dom_iff (a : Atom) :\n    (φ.supportedActionAtomMapCore a).Dom ↔\n      a ∈ φ.atomMap.Dom ∪ φ.preimageLitterSubset ∪ ⋃ (L) (hL), φ.mappedOutsideSubset L hL := by\n  rw [supportedActionAtomMapCore]\n  simp only [PFun.dom_mk, mem_setOf_eq, mem_union, mem_iUnion]\n  rw [or_assoc]\n  rfl\n", "additional_info": "", "used_premises": [1, 1204, 404, 1189, 1199], "def_path": "ConNF/FOA/Action/FillAtomRange.lean", "pos": [155, 162], "informalization": "The theorem `ConNF.NearLitterAction.mem_supportedActionAtomMapCore_dom_iff` states that an atom `a` is in the domain of the partial function `ConNF.NearLitterAction.supportedActionAtomMapCore φ a` if and only if `a` is in the union of three sets: the domain of the atom map `φ.atomMap`, the preimage litter subset `ConNF.NearLitterAction.preimageLitterSubset φ`, and the union of the mapped outside subsets `ConNF.NearLitterAction.mappedOutsideSubset φ L hL` for all litters `L` within the domain of the litter map `φ.litterMap L`."}
{"full_name": "ConNF.NearLitterAction.supportedActionAtomMapCore", "url": "ConNF/FOA/Action/FillAtomRange.html#ConNF.NearLitterAction.supportedActionAtomMapCore", "code_src": "con-nf", "ptype": "noncomputable def", "header": "noncomputable def ConNF.NearLitterAction.supportedActionAtomMapCore [ConNF.Params🔗<|PREMISE|>🔗 ] (φ : ConNF.NearLitterAction) :ConNF.Atom →. ConNF.Atom", "code": "noncomputable def supportedActionAtomMapCore : Atom →. Atom := fun a =>\n  { Dom := (φ.atomMap a).Dom ∨ a ∈ φ.preimageLitterSubset ∨ ∃ L hL, a ∈ φ.mappedOutsideSubset L hL\n    get := fun h =>\n      h.elim' (φ.atomMap a).get fun h =>\n        h.elim' (fun h => φ.preimageLitterEquiv ⟨a, h⟩) fun h =>\n          φ.mappedOutsideEquiv h.choose h.choose_spec.choose ⟨a, h.choose_spec.choose_spec⟩ }\n", "additional_info": "Equations\n* One or more equations did not get rendered due to their size.\n\n", "used_premises": [1], "def_path": "ConNF/FOA/Action/FillAtomRange.lean", "pos": [148, 154], "informalization": "Function `ConNF.NearLitterAction.supportedActionAtomMapCore` defines a partial function from `ConNF.Atom` to `ConNF.Atom`, which is used in the construction of the natural numbers in the context of Constructive Ordinal Notation (ConNF). This function is part of the `ConNF.Params` class, which defines a set of parameters that are used in the construction of the natural numbers in the context of Constructive Ordinal Notation (ConNF). These parameters include the types `Λ`, `κ`, and `μ`, along with various properties and relationships between these types, such as linear orders, well-orders, zero elements, successor orders, and subtraction operations. Additionally, there are conditions on the cardinalities of these types and their cofinalities."}
{"full_name": "ConNF.NearLitterAction.supportedActionAtomMapCore_dom_eq", "url": "ConNF/FOA/Action/FillAtomRange.html#ConNF.NearLitterAction.supportedActionAtomMapCore_dom_eq", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterAction.supportedActionAtomMapCore_dom_eq [ConNF.Params🔗<|PREMISE|>🔗 ] (φ : ConNF.NearLitterAction) :PFun.Dom🔗<|PREMISE|>🔗 (ConNF.NearLitterAction.supportedActionAtomMapCore🔗<|PREMISE|>🔗 φ) = PFun.Dom🔗<|PREMISE|>🔗 φ.atomMap ∪ ConNF.NearLitterAction.preimageLitterSubset🔗<|PREMISE|>🔗 φ ∪ ⋃ (L : ConNF.Litter), ⋃ (hL : (φ.litterMap L).Dom), ConNF.NearLitterAction.mappedOutsideSubset🔗<|PREMISE|>🔗 φ L hL", "code": "theorem supportedActionAtomMapCore_dom_eq :\n    φ.supportedActionAtomMapCore.Dom =\n      φ.atomMap.Dom ∪ φ.preimageLitterSubset ∪ ⋃ (L) (hL), φ.mappedOutsideSubset L hL := by\n  ext a : 1\n  exact φ.mem_supportedActionAtomMapCore_dom_iff a\n", "additional_info": "", "used_premises": [1, 404, 1204, 404, 1189, 1199], "def_path": "ConNF/FOA/Action/FillAtomRange.lean", "pos": [163, 168], "informalization": "The theorem `ConNF.NearLitterAction.supportedActionAtomMapCore_dom_eq` states that the domain of the partial function `ConNF.NearLitterAction.supportedActionAtomMapCore` is equal to the union of three sets: the domain of the partial function `φ.atomMap`, the set `ConNF.NearLitterAction.preimageLitterSubset`, and the union of the sets `ConNF.NearLitterAction.mappedOutsideSubset` over all litters `L` in the domain of the litter map `φ.litterMap L`."}
{"full_name": "ConNF.NearLitterAction.supportedActionAtomMapCore_dom_small", "url": "ConNF/FOA/Action/FillAtomRange.html#ConNF.NearLitterAction.supportedActionAtomMapCore_dom_small", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterAction.supportedActionAtomMapCore_dom_small [ConNF.Params🔗<|PREMISE|>🔗 ] (φ : ConNF.NearLitterAction) :ConNF.Small🔗<|PREMISE|>🔗 (PFun.Dom🔗<|PREMISE|>🔗 (ConNF.NearLitterAction.supportedActionAtomMapCore🔗<|PREMISE|>🔗 φ))", "code": "theorem supportedActionAtomMapCore_dom_small : Small φ.supportedActionAtomMapCore.Dom := by\n  rw [supportedActionAtomMapCore_dom_eq]\n  refine' Small.union (Small.union φ.atomMap_dom_small _) _\n  · exact φ.preimageLitterSubset_small\n  · refine' Small.bUnion _ _\n    · refine' lt_of_le_of_lt _ φ.litterMap_dom_small\n      refine' ⟨⟨fun L => ⟨_, L.prop⟩, fun L₁ L₂ h => _⟩⟩\n      simp only [Subtype.mk_eq_mk, Prod.mk.inj_iff, eq_self_iff_true, and_true_iff,\n        Litter.toNearLitter_injective.eq_iff, Subtype.coe_inj] at h\n      exact h\n    · intro L hL\n      exact φ.mappedOutsideSubset_small L hL\n", "additional_info": "", "used_premises": [1, 233, 404, 1204], "def_path": "ConNF/FOA/Action/FillAtomRange.lean", "pos": [169, 181], "informalization": "The theorem `ConNF.NearLitterAction.supportedActionAtomMapCore_dom_small` states that the domain of the partial function `ConNF.NearLitterAction.supportedActionAtomMapCore`, which is used in the construction of the natural numbers in the context of Constructive Ordinal Notation (ConNF), is a small set in the sense that its cardinality is strictly less than the cardinality of the type `ConNF.κ`."}
{"full_name": "ConNF.NearLitterAction.supportedActionAtomMapCore_injective", "url": "ConNF/FOA/Action/FillAtomRange.html#ConNF.NearLitterAction.supportedActionAtomMapCore_injective", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterAction.supportedActionAtomMapCore_injective [ConNF.Params🔗<|PREMISE|>🔗 ] (φ : ConNF.NearLitterAction) ⦃a : ConNF.Atom⦄ ⦃b : ConNF.Atom⦄ (hφ : ConNF.NearLitterAction.Lawful🔗<|PREMISE|>🔗 φ) (ha : (ConNF.NearLitterAction.supportedActionAtomMapCore🔗<|PREMISE|>🔗 φ a).Dom) (hb : (ConNF.NearLitterAction.supportedActionAtomMapCore🔗<|PREMISE|>🔗 φ b).Dom) (hab : (ConNF.NearLitterAction.supportedActionAtomMapCore🔗<|PREMISE|>🔗 φ a).get ha = (ConNF.NearLitterAction.supportedActionAtomMapCore🔗<|PREMISE|>🔗 φ b).get hb) :a = b", "code": "theorem supportedActionAtomMapCore_injective ⦃a b : Atom⦄ (hφ : φ.Lawful)\n    (ha : (supportedActionAtomMapCore φ a).Dom) (hb : (supportedActionAtomMapCore φ b).Dom)\n    (hab : (φ.supportedActionAtomMapCore a).get ha = (φ.supportedActionAtomMapCore b).get hb) :\n    a = b := by\n  obtain ha | ha | ⟨L, hL, ha⟩ := ha <;> obtain hb | hb | ⟨L', hL', hb⟩ := hb\n  · have := (supportedAction_eq_of_dom _ ha).symm.trans (hab.trans (supportedAction_eq_of_dom _ hb))\n    exact hφ.atomMap_injective ha hb this\n  · have := (supportedAction_eq_of_dom _ ha).symm.trans\n      (hab.trans (supportedAction_eq_of_mem_preimageLitterSubset _ hb))\n    obtain ⟨hab, -⟩ := Subtype.coe_eq_iff.mp this.symm\n    cases hab.not_mem_ran ⟨a, ha, rfl⟩\n  · have := (supportedAction_eq_of_dom _ ha).symm.trans\n      (hab.trans (supportedAction_eq_of_mem_mappedOutsideSubset _ hb))\n    obtain ⟨hab, -⟩ := Subtype.coe_eq_iff.mp this.symm\n    cases hab.not_mem_ran ⟨a, ha, rfl⟩\n  · have := (supportedAction_eq_of_mem_preimageLitterSubset _ ha).symm.trans\n      (hab.trans (supportedAction_eq_of_dom _ hb))\n    obtain ⟨hab, -⟩ := Subtype.coe_eq_iff.mp this\n    cases hab.not_mem_ran ⟨b, hb, rfl⟩\n  · have := (supportedAction_eq_of_mem_preimageLitterSubset _ ha).symm.trans\n      (hab.trans (supportedAction_eq_of_mem_preimageLitterSubset _ hb))\n    rw [Subtype.coe_inj, EmbeddingLike.apply_eq_iff_eq] at this\n    exact Subtype.coe_inj.mpr this\n  · have := (supportedAction_eq_of_mem_preimageLitterSubset _ ha).symm.trans\n      (hab.trans (supportedAction_eq_of_mem_mappedOutsideSubset _ hb))\n    obtain ⟨hab, -⟩ := Subtype.coe_eq_iff.mp this\n    cases WithoutPreimage.not_mappedOutside φ hab _ hL' (φ.mappedOutsideEquiv L' hL' ⟨b, hb⟩).prop\n  · have := (supportedAction_eq_of_mem_mappedOutsideSubset _ ha).symm.trans\n      (hab.trans (supportedAction_eq_of_dom _ hb))\n    obtain ⟨hab, -⟩ := Subtype.coe_eq_iff.mp this\n    cases hab.not_mem_ran ⟨b, hb, rfl⟩\n  · have := (supportedAction_eq_of_mem_mappedOutsideSubset _ ha).symm.trans\n      (hab.trans (supportedAction_eq_of_mem_preimageLitterSubset _ hb))\n    obtain ⟨hab, -⟩ := Subtype.coe_eq_iff.mp this.symm\n    cases WithoutPreimage.not_mappedOutside φ hab _ hL (φ.mappedOutsideEquiv L hL ⟨a, ha⟩).prop\n  · have := (supportedAction_eq_of_mem_mappedOutsideSubset _ ha).symm.trans\n      (hab.trans (supportedAction_eq_of_mem_mappedOutsideSubset _ hb))\n    have := hφ.litterMap_injective hL hL' ?_\n    · cases this\n      simp only [mem_setOf_eq, coe_setOf, Subtype.coe_inj, EmbeddingLike.apply_eq_iff_eq,\n        Subtype.mk.injEq] at this\n      exact this\n    · obtain ⟨hab, -⟩ := Subtype.coe_eq_iff.mp this\n      exact ⟨_, hab.1, (φ.mappedOutsideEquiv L' hL' ⟨b, hb⟩).prop.1⟩\n", "additional_info": "", "used_premises": [1, 825, 1204, 1204, 1204, 1204], "def_path": "ConNF/FOA/Action/FillAtomRange.lean", "pos": [232, 276], "informalization": "The theorem `ConNF.NearLitterAction.supportedActionAtomMapCore_injective` states that the partial function `ConNF.NearLitterAction.supportedActionAtomMapCore` is injective. This function is part of the `ConNF.Params` class, which defines a set of parameters that are used in the construction of the natural numbers in the context of Constructive Ordinal Notation (ConNF). These parameters include the types `Λ`, `κ`, and `μ`, along with various properties and relationships between these types, such as linear orders, well-orders, zero elements, successor orders, and subtraction operations. Additionally, there are conditions on the cardinalities of these types and their cofinalities."}
{"full_name": "ConNF.NearLitterAction.supportedActionAtomMapCore_mem", "url": "ConNF/FOA/Action/FillAtomRange.html#ConNF.NearLitterAction.supportedActionAtomMapCore_mem", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterAction.supportedActionAtomMapCore_mem [ConNF.Params🔗<|PREMISE|>🔗 ] (φ : ConNF.NearLitterAction) (hφ : ConNF.NearLitterAction.Lawful🔗<|PREMISE|>🔗 φ) (a : ConNF.Atom) (ha : (ConNF.NearLitterAction.supportedActionAtomMapCore🔗<|PREMISE|>🔗 φ a).Dom) (L : ConNF.Litter) (hL : (φ.litterMap L).Dom) :a.1 = L ↔ (ConNF.NearLitterAction.supportedActionAtomMapCore🔗<|PREMISE|>🔗 φ a).get ha ∈ (φ.litterMap L).get hL", "code": "theorem supportedActionAtomMapCore_mem (hφ : φ.Lawful) (a : Atom)\n    (ha : (φ.supportedActionAtomMapCore a).Dom) (L : Litter) (hL : (φ.litterMap L).Dom) :\n    a.fst = L ↔ (φ.supportedActionAtomMapCore a).get ha ∈ (φ.litterMap L).get hL := by\n  obtain ha | ha | ⟨L', hL', ha⟩ := ha\n  · rw [hφ.atom_mem a ha L hL, supportedAction_eq_of_dom]\n  · rw [supportedAction_eq_of_mem_preimageLitterSubset]\n    constructor\n    · rintro rfl\n      have := φ.preimageLitterSubset_subset ha\n      rw [mem_litterSet] at this\n      rw [this] at hL\n      have := BannedLitter.litterDom _ hL\n      cases φ.preimageLitter_not_banned this\n    · intro h\n      cases (φ.preimageLitterEquiv ⟨a, ha⟩).prop.not_mem_map L hL h\n  · cases φ.mappedOutsideSubset_subset L' hL' ha\n    rw [supportedAction_eq_of_mem_mappedOutsideSubset]\n    constructor\n    · rintro rfl\n      exact (φ.mappedOutsideEquiv _ _ ⟨a, ha⟩).prop.mem_map\n    · intro h\n      refine' hφ.litterMap_injective hL' hL ⟨_, _, h⟩\n      exact (φ.mappedOutsideEquiv _ _ ⟨a, ha⟩).prop.mem_map\n", "additional_info": "", "used_premises": [1, 825, 1204, 1204], "def_path": "ConNF/FOA/Action/FillAtomRange.lean", "pos": [277, 300], "informalization": "The theorem `ConNF.NearLitterAction.supportedActionAtomMapCore_mem` is a statement about the constructible ordinal notation (ConNF) in Lean 4. It describes a property of the function `ConNF.NearLitterAction.supportedActionAtomMapCore`, which is a partial function from `ConNF.Atom` to `ConNF.Atom`. The theorem states that, given a near litter action `φ` and an atom `a` with a certain property, if `a` is in the litter `L`, then the output of the `supportedActionAtomMapCore` function on `a` is in the near litter `φ.litterMap L`. This property is crucial for ensuring that the natural numbers constructed in ConNF are well-defined and follow the rules of the notation."}
{"full_name": "ConNF.NearLitterAction.fillAtomRangeLawful", "url": "ConNF/FOA/Action/FillAtomRange.html#ConNF.NearLitterAction.fillAtomRangeLawful", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterAction.fillAtomRangeLawful [ConNF.Params🔗<|PREMISE|>🔗 ] (φ : ConNF.NearLitterAction) (hφ : ConNF.NearLitterAction.Lawful🔗<|PREMISE|>🔗 φ) :ConNF.NearLitterAction.Lawful🔗<|PREMISE|>🔗 (ConNF.NearLitterAction.fillAtomRange🔗<|PREMISE|>🔗 φ)", "code": "theorem fillAtomRangeLawful (hφ : φ.Lawful) : φ.fillAtomRange.Lawful\n    where\n  atomMap_injective := fun _ _ => φ.supportedActionAtomMapCore_injective hφ\n  litterMap_injective := hφ.litterMap_injective\n  atom_mem := φ.supportedActionAtomMapCore_mem hφ\n", "additional_info": "", "used_premises": [1, 825, 825, 1210], "def_path": "ConNF/FOA/Action/FillAtomRange.lean", "pos": [308, 313], "informalization": "`ConNF.NearLitterAction.fillAtomRange φ` returns a new `ConNF.NearLitterAction`, adjusted to have a small domain for the `atomMap`, and the resulting action is lawful. This theorem ensures that the adjusted action still satisfies the conditions for being lawful, meaning that the atom and litter maps are injective and the images of atoms in litters are mapped to atoms inside the corresponding near-litters."}
{"full_name": "ConNF.NearLitterAction.fillAtomRange", "url": "ConNF/FOA/Action/FillAtomRange.html#ConNF.NearLitterAction.fillAtomRange", "code_src": "con-nf", "ptype": "noncomputable def", "header": "noncomputable def ConNF.NearLitterAction.fillAtomRange [ConNF.Params🔗<|PREMISE|>🔗 ] (φ : ConNF.NearLitterAction) :ConNF.NearLitterAction", "code": "noncomputable def fillAtomRange : NearLitterAction\n    where\n  atomMap := φ.supportedActionAtomMapCore\n  litterMap := φ.litterMap\n  atomMap_dom_small := φ.supportedActionAtomMapCore_dom_small\n  litterMap_dom_small := φ.litterMap_dom_small\n", "additional_info": "Equations\n* 🗟ConNF.NearLitterAction.fillAtomRange🗟🔗../../.././ConNF/FOA/Action/FillAtomRange.html#ConNF.NearLitterAction.fillAtomRange🔗  φ 🗟=🗟🔗../../.././Init/Prelude.html#Eq🔗  { atomMap := 🗟ConNF.NearLitterAction.supportedActionAtomMapCore🗟🔗../../.././ConNF/FOA/Action/FillAtomRange.html#ConNF.NearLitterAction.supportedActionAtomMapCore🔗  φ, litterMap := φ.litterMap, atomMap_dom_small := ⋯,\n litterMap_dom_small := ⋯ }\n\n", "used_premises": [1], "def_path": "ConNF/FOA/Action/FillAtomRange.lean", "pos": [301, 307], "informalization": "Function `ConNF.NearLitterAction.fillAtomRange` is a noncomputable function that takes a `ConNF.NearLitterAction` object `φ` and returns a new `ConNF.NearLitterAction` object. The returned object has the same `litterMap` as `φ`, but its `atomMap` is adjusted to ensure that the domain of `atomMap` is small. This adjustment is necessary because the domain of `atomMap` in `φ` might not be small, which is a requirement for `ConNF.NearLitterAction`."}
{"full_name": "ConNF.NearLitterAction.fillAtomRange_atomMap", "url": "ConNF/FOA/Action/FillAtomRange.html#ConNF.NearLitterAction.fillAtomRange_atomMap", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.NearLitterAction.fillAtomRange_atomMap [ConNF.Params🔗<|PREMISE|>🔗 ] {φ : ConNF.NearLitterAction} :(ConNF.NearLitterAction.fillAtomRange🔗<|PREMISE|>🔗 φ).atomMap = ConNF.NearLitterAction.supportedActionAtomMapCore🔗<|PREMISE|>🔗 φ", "code": "theorem fillAtomRange_atomMap : φ.fillAtomRange.atomMap = φ.supportedActionAtomMapCore :=\n  rfl\n", "additional_info": "", "used_premises": [1, 1210, 1204], "def_path": "ConNF/FOA/Action/FillAtomRange.lean", "pos": [317, 319], "informalization": "The `ConNF.NearLitterAction.fillAtomRange_atomMap` theorem states that the `atomMap` of the `ConNF.NearLitterAction` object returned by the `ConNF.NearLitterAction.fillAtomRange` function is equal to the `ConNF.NearLitterAction.supportedActionAtomMapCore` function."}
{"full_name": "ConNF.NearLitterAction.fillAtomRange_litterMap", "url": "ConNF/FOA/Action/FillAtomRange.html#ConNF.NearLitterAction.fillAtomRange_litterMap", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.NearLitterAction.fillAtomRange_litterMap [ConNF.Params🔗<|PREMISE|>🔗 ] {φ : ConNF.NearLitterAction} :(ConNF.NearLitterAction.fillAtomRange🔗<|PREMISE|>🔗 φ).litterMap = φ.litterMap", "code": "theorem fillAtomRange_litterMap : φ.fillAtomRange.litterMap = φ.litterMap :=\n  rfl\n", "additional_info": "", "used_premises": [1, 1210], "def_path": "ConNF/FOA/Action/FillAtomRange.lean", "pos": [321, 323], "informalization": "Function `ConNF.NearLitterAction.fillAtomRange` is a noncomputable function that takes a `ConNF.NearLitterAction` object `φ` and returns a new `ConNF.NearLitterAction` object. The returned object has the same `litterMap` as `φ`, but its `atomMap` is adjusted to ensure that the domain of `atomMap` is small. This adjustment is necessary because the domain of `atomMap` in `φ` might not be small, which is a requirement for `ConNF.NearLitterAction`. The theorem `ConNF.NearLitterAction.fillAtomRange_litterMap` states that the `litterMap` of the returned object is equal to the `litterMap` of the original object `φ`."}
{"full_name": "ConNF.NearLitterAction.subset_supportedActionAtomMapCore_dom", "url": "ConNF/FOA/Action/FillAtomRange.html#ConNF.NearLitterAction.subset_supportedActionAtomMapCore_dom", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterAction.subset_supportedActionAtomMapCore_dom [ConNF.Params🔗<|PREMISE|>🔗 ] {φ : ConNF.NearLitterAction} :PFun.Dom🔗<|PREMISE|>🔗 φ.atomMap ⊆ PFun.Dom🔗<|PREMISE|>🔗 (ConNF.NearLitterAction.supportedActionAtomMapCore🔗<|PREMISE|>🔗 φ)", "code": "theorem subset_supportedActionAtomMapCore_dom :\n    φ.atomMap.Dom ⊆ φ.supportedActionAtomMapCore.Dom :=\n  subset_union_left _ _\n", "additional_info": "", "used_premises": [1, 404, 404, 1204], "def_path": "ConNF/FOA/Action/FillAtomRange.lean", "pos": [324, 327], "informalization": "The theorem `ConNF.NearLitterAction.subset_supportedActionAtomMapCore_dom` states that the domain of the partial function `φ.atomMap` is a subset of the domain of the partial function `ConNF.NearLitterAction.supportedActionAtomMapCore φ`. This theorem is part of the `ConNF.Params` class, which defines a set of parameters that are used in the construction of the natural numbers in the context of Constructive Ordinal Notation (ConNF). These parameters include the types `Λ`, `κ`, and `μ`, along with various properties and relationships between these types, such as linear orders, well-orders, zero elements, successor orders, and subtraction operations. Additionally, there are conditions on the cardinalities of these types and their cofinalities."}
{"full_name": "ConNF.NearLitterAction.subset_supportedActionAtomMapCore_ran", "url": "ConNF/FOA/Action/FillAtomRange.html#ConNF.NearLitterAction.subset_supportedActionAtomMapCore_ran", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterAction.subset_supportedActionAtomMapCore_ran [ConNF.Params🔗<|PREMISE|>🔗 ] {φ : ConNF.NearLitterAction} :PFun.ran🔗<|PREMISE|>🔗 φ.atomMap ⊆ PFun.ran🔗<|PREMISE|>🔗 (ConNF.NearLitterAction.supportedActionAtomMapCore🔗<|PREMISE|>🔗 φ)", "code": "theorem subset_supportedActionAtomMapCore_ran :\n    φ.atomMap.ran ⊆ φ.supportedActionAtomMapCore.ran := by\n  rintro _ ⟨a, ha, rfl⟩\n  exact ⟨a, subset_supportedActionAtomMapCore_dom ha, φ.supportedAction_eq_of_dom _⟩\n", "additional_info": "", "used_premises": [1, 824, 824, 1204], "def_path": "ConNF/FOA/Action/FillAtomRange.lean", "pos": [328, 332], "informalization": "The theorem `ConNF.NearLitterAction.subset_supportedActionAtomMapCore_ran` states that the range of the partial function `φ.atomMap` is a subset of the range of the partial function `ConNF.NearLitterAction.supportedActionAtomMapCore φ`. This theorem is part of the `ConNF.Params` class, which defines a set of parameters that are used in the construction of the natural numbers in the context of Constructive Ordinal Notation (ConNF). These parameters include the types `Λ`, `κ`, and `μ`, along with various properties and relationships between these types, such as linear orders, well-orders, zero elements, successor orders, and subtraction operations. Additionally, there are conditions on the cardinalities of these types and their cofinalities."}
{"full_name": "ConNF.NearLitterAction.fillAtomRange_symmDiff_subset_ran", "url": "ConNF/FOA/Action/FillAtomRange.html#ConNF.NearLitterAction.fillAtomRange_symmDiff_subset_ran", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterAction.fillAtomRange_symmDiff_subset_ran [ConNF.Params🔗<|PREMISE|>🔗 ] {φ : ConNF.NearLitterAction} (hφ : ConNF.NearLitterAction.Lawful🔗<|PREMISE|>🔗 φ) (L : ConNF.Litter) (hL : ((ConNF.NearLitterAction.fillAtomRange🔗<|PREMISE|>🔗 φ).litterMap L).Dom) :symmDiff🔗<|PREMISE|>🔗 (↑(((ConNF.NearLitterAction.fillAtomRange🔗<|PREMISE|>🔗 φ).litterMap L).get hL)) (ConNF.litterSet🔗<|PREMISE|>🔗 (((ConNF.NearLitterAction.fillAtomRange🔗<|PREMISE|>🔗 φ).litterMap L).get hL).fst) ⊆ PFun.ran🔗<|PREMISE|>🔗 (ConNF.NearLitterAction.fillAtomRange🔗<|PREMISE|>🔗 φ).atomMap", "code": "theorem fillAtomRange_symmDiff_subset_ran (hφ : φ.Lawful) (L : Litter)\n    (hL : (φ.fillAtomRange.litterMap L).Dom) :\n    ((φ.fillAtomRange.litterMap L).get hL : Set Atom) ∆\n        litterSet ((φ.fillAtomRange.litterMap L).get hL).fst ⊆\n      φ.fillAtomRange.atomMap.ran := by\n  intro a\n  by_cases ha₁ : a ∈ φ.atomMap.ran\n  · obtain ⟨b, hb, rfl⟩ := ha₁\n    exact fun _ => ⟨b, Or.inl hb, φ.supportedAction_eq_of_dom hb⟩\n  rintro (⟨ha₂, ha₃⟩ | ⟨ha₂, ha₃⟩)\n  · refine' ⟨(φ.mappedOutsideEquiv L hL).symm ⟨a, ha₂, ha₃, ha₁⟩, _, _⟩\n    · exact Or.inr (Or.inr ⟨L, hL, ((φ.mappedOutsideEquiv L hL).symm _).prop⟩)\n    · simp only [fillAtomRange_atomMap]\n      refine' (φ.supportedAction_eq_of_mem_mappedOutsideSubset\n        ((φ.mappedOutsideEquiv L hL).symm _).prop).trans _\n      simp only [Subtype.coe_eta, Equiv.apply_symm_apply, Subtype.coe_mk]\n  · by_cases ha₄ : ∀ (L' : Litter) (hL' : (φ.litterMap L').Dom), a ∉ (φ.litterMap L').get hL'\n    · refine' ⟨φ.preimageLitterEquiv.symm ⟨a, ⟨L, hL, ha₂⟩, ha₄, ha₁⟩, _, _⟩\n      · exact Or.inr (Or.inl (φ.preimageLitterEquiv.symm _).prop)\n      · simp only [fillAtomRange_atomMap]\n        refine' (φ.supportedAction_eq_of_mem_preimageLitterSubset\n          (φ.preimageLitterEquiv.symm _).prop).trans _\n        simp only [Subtype.coe_eta, Equiv.apply_symm_apply, Subtype.coe_mk]\n    · push_neg at ha₄\n      obtain ⟨L', hL', ha₄⟩ := ha₄\n      refine' ⟨(φ.mappedOutsideEquiv L' hL').symm ⟨a, ha₄, _, ha₁⟩, _, _⟩\n      · intro ha\n        have := NearLitter.inter_nonempty_of_fst_eq_fst\n          (eq_of_mem_litterSet_of_mem_litterSet ha₂ ha)\n        cases hφ.litterMap_injective hL hL' this\n        exact ha₃ ha₄\n      · exact Or.inr (Or.inr ⟨L', hL', ((φ.mappedOutsideEquiv L' hL').symm _).prop⟩)\n      · simp only [fillAtomRange_atomMap]\n        refine' (φ.supportedAction_eq_of_mem_mappedOutsideSubset\n          ((φ.mappedOutsideEquiv L' hL').symm _).prop).trans _\n        simp only [Subtype.coe_eta, Equiv.apply_symm_apply, Subtype.coe_mk]\n", "additional_info": "", "used_premises": [1, 825, 1210, 62, 1210, 467, 1210, 824, 1210], "def_path": "ConNF/FOA/Action/FillAtomRange.lean", "pos": [333, 369], "informalization": "The theorem `ConNF.NearLitterAction.fillAtomRange_symmDiff_subset_ran` is a part of the Constructive Ordinal Notation (ConNF) project in Lean 4. It states that for a lawful near litter action `φ`, the symmetric difference between the set of atoms in a litter `L` and the litter set corresponding to `L` is a subset of the range of the atom map of the filled atom range of `φ`."}
{"full_name": "ConNF.NearLitterApprox.ext", "url": "ConNF/FOA/Approximation/NearLitterApprox.html#ConNF.NearLitterApprox.ext", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterApprox.ext :∀ {inst : ConNF.Params🔗<|PREMISE|>🔗 } (x y : ConNF.NearLitterApprox), x.atomPerm = y.atomPerm → x.litterPerm = y.litterPerm → x = y", "code": "@[ext]\n", "additional_info": "", "used_premises": [1], "def_path": "ConNF/FOA/Approximation/NearLitterApprox.lean", "pos": [18, 19], "informalization": "The `ConNF.NearLitterApprox.ext` theorem states that two `ConNF.NearLitterApprox` objects are equal if their `atomPerm` and `litterPerm` fields are equal."}
{"full_name": "ConNF.NearLitterApprox.ext_iff", "url": "ConNF/FOA/Approximation/NearLitterApprox.html#ConNF.NearLitterApprox.ext_iff", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterApprox.ext_iff :∀ {inst : ConNF.Params🔗<|PREMISE|>🔗 } (x y : ConNF.NearLitterApprox), x = y ↔ x.atomPerm = y.atomPerm ∧ x.litterPerm = y.litterPerm", "code": "@[ext]\n", "additional_info": "", "used_premises": [1], "def_path": "ConNF/FOA/Approximation/NearLitterApprox.lean", "pos": [18, 19], "informalization": "The `ConNF.NearLitterApprox.ext_iff` theorem states that two `ConNF.NearLitterApprox` objects are equal if and only if their `atomPerm` and `litterPerm` fields are equal."}
{"full_name": "ConNF.NearLitterApprox.smul_atom_eq", "url": "ConNF/FOA/Approximation/NearLitterApprox.html#ConNF.NearLitterApprox.smul_atom_eq", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterApprox.smul_atom_eq [ConNF.Params🔗<|PREMISE|>🔗 ] (π : ConNF.NearLitterApprox) {a : ConNF.Atom} :π.atomPerm.toFun a = π • a", "code": "theorem smul_atom_eq {a : Atom} : π.atomPerm a = π • a :=\n  rfl\n", "additional_info": "", "used_premises": [1], "def_path": "ConNF/FOA/Approximation/NearLitterApprox.lean", "pos": [34, 36], "informalization": "The theorem `ConNF.NearLitterApprox.smul_atom_eq` states that for any `ConNF.NearLitterApprox` object `π` and any `ConNF.Atom` object `a`, the function `π.atomPerm.toFun` applied to `a` is equal to the action of `π` on `a`, denoted as `π • a`."}
{"full_name": "ConNF.NearLitterApprox.smul_litter_eq", "url": "ConNF/FOA/Approximation/NearLitterApprox.html#ConNF.NearLitterApprox.smul_litter_eq", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterApprox.smul_litter_eq [ConNF.Params🔗<|PREMISE|>🔗 ] (π : ConNF.NearLitterApprox) {L : ConNF.Litter} :π.litterPerm.toFun L = π • L", "code": "theorem smul_litter_eq {L : Litter} : π.litterPerm L = π • L :=\n  rfl\n", "additional_info": "", "used_premises": [1], "def_path": "ConNF/FOA/Approximation/NearLitterApprox.lean", "pos": [37, 39], "informalization": "The theorem `ConNF.NearLitterApprox.smul_litter_eq` states that for any `ConNF.NearLitterApprox` object `π` and a `ConNF.Litter` object `L`, the permutation action of `π` on `L` (denoted as `π.litterPerm.toFun L`) is equal to the scalar multiplication of `π` with `L` (denoted as `π • L`)."}
{"full_name": "ConNF.NearLitterApprox.smul_eq_smul_atom", "url": "ConNF/FOA/Approximation/NearLitterApprox.html#ConNF.NearLitterApprox.smul_eq_smul_atom", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterApprox.smul_eq_smul_atom [ConNF.Params🔗<|PREMISE|>🔗 ] (π : ConNF.NearLitterApprox) {a₁ : ConNF.Atom} {a₂ : ConNF.Atom} (h₁ : a₁ ∈ π.atomPerm.domain) (h₂ : a₂ ∈ π.atomPerm.domain) :π • a₁ = π • a₂ ↔ a₁ = a₂", "code": "theorem smul_eq_smul_atom {a₁ a₂ : Atom} (h₁ : a₁ ∈ π.atomPerm.domain)\n    (h₂ : a₂ ∈ π.atomPerm.domain) : π • a₁ = π • a₂ ↔ a₁ = a₂ := by\n  rw [mk_smul_atom, mk_smul_atom,\n    ← π.atomPerm.eq_symm_apply h₁ (π.atomPerm.map_domain h₂), PartialPerm.left_inv _ h₂]\n", "additional_info": "", "used_premises": [1], "def_path": "ConNF/FOA/Approximation/NearLitterApprox.lean", "pos": [52, 56], "informalization": "The theorem `ConNF.NearLitterApprox.smul_eq_smul_atom` states that for any two atoms `a₁` and `a₂` in the domain of a near litter approximation `π`, `π • a₁ = π • a₂` if and only if `a₁ = a₂`."}
{"full_name": "ConNF.NearLitterApprox.smul_eq_smul_litter", "url": "ConNF/FOA/Approximation/NearLitterApprox.html#ConNF.NearLitterApprox.smul_eq_smul_litter", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterApprox.smul_eq_smul_litter [ConNF.Params🔗<|PREMISE|>🔗 ] (π : ConNF.NearLitterApprox) {L₁ : ConNF.Litter} {L₂ : ConNF.Litter} (h₁ : L₁ ∈ π.litterPerm.domain) (h₂ : L₂ ∈ π.litterPerm.domain) :π • L₁ = π • L₂ ↔ L₁ = L₂", "code": "theorem smul_eq_smul_litter {L₁ L₂ : Litter} (h₁ : L₁ ∈ π.litterPerm.domain)\n    (h₂ : L₂ ∈ π.litterPerm.domain) : π • L₁ = π • L₂ ↔ L₁ = L₂ := by\n  rw [mk_smul_litter, mk_smul_litter,\n    ← π.litterPerm.eq_symm_apply h₁ (π.litterPerm.map_domain h₂), PartialPerm.left_inv _ h₂]\n", "additional_info": "", "used_premises": [1], "def_path": "ConNF/FOA/Approximation/NearLitterApprox.lean", "pos": [57, 61], "informalization": "The theorem `ConNF.NearLitterApprox.smul_eq_smul_litter` states that for any two litters `L₁` and `L₂` in the domain of a near litter approximation `π`, `π • L₁ = π • L₂` if and only if `L₁ = L₂`."}
{"full_name": "ConNF.NearLitterApprox.symm_atomPerm", "url": "ConNF/FOA/Approximation/NearLitterApprox.html#ConNF.NearLitterApprox.symm_atomPerm", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.NearLitterApprox.symm_atomPerm [ConNF.Params🔗<|PREMISE|>🔗 ] (π : ConNF.NearLitterApprox) :(ConNF.NearLitterApprox.symm🔗<|PREMISE|>🔗 π).atomPerm = PartialPerm.symm🔗<|PREMISE|>🔗 π.atomPerm", "code": "theorem symm_atomPerm : π.symm.atomPerm = π.atomPerm.symm :=\n  rfl\n", "additional_info": "", "used_premises": [1, 1223, 644], "def_path": "ConNF/FOA/Approximation/NearLitterApprox.lean", "pos": [68, 70], "informalization": "The theorem `ConNF.NearLitterApprox.symm_atomPerm` states that the `atomPerm` component of the symmetric of a `ConNF.NearLitterApprox` object `π` is equal to the inverse of the `atomPerm` component of `π`."}
{"full_name": "ConNF.NearLitterApprox.symm", "url": "ConNF/FOA/Approximation/NearLitterApprox.html#ConNF.NearLitterApprox.symm", "code_src": "con-nf", "ptype": "def", "header": "def ConNF.NearLitterApprox.symm [ConNF.Params🔗<|PREMISE|>🔗 ] (π : ConNF.NearLitterApprox) :ConNF.NearLitterApprox", "code": "def symm : NearLitterApprox where\n  atomPerm := π.atomPerm.symm\n  litterPerm := π.litterPerm.symm\n  domain_small := π.domain_small\n", "additional_info": "Equations\n* 🗟ConNF.NearLitterApprox.symm🗟🔗../../.././ConNF/FOA/Approximation/NearLitterApprox.html#ConNF.NearLitterApprox.symm🔗  π 🗟=🗟🔗../../.././Init/Prelude.html#Eq🔗  { atomPerm := 🗟PartialPerm.symm🗟🔗../../.././ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm.symm🔗  π.atomPerm, litterPerm := 🗟PartialPerm.symm🗟🔗../../.././ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm.symm🔗  π.litterPerm, domain_small := ⋯ }\n\n", "used_premises": [1], "def_path": "ConNF/FOA/Approximation/NearLitterApprox.lean", "pos": [62, 66], "informalization": "Function `ConNF.NearLitterApprox.symm` is a method that takes a `ConNF.NearLitterApprox` object `π` and returns a new `ConNF.NearLitterApprox` object, where the `atomPerm` and `litterPerm` components of `π` are replaced by their symmetric counterparts. The `domain_small` component remains unchanged."}
{"full_name": "ConNF.NearLitterApprox.symm_litterPerm", "url": "ConNF/FOA/Approximation/NearLitterApprox.html#ConNF.NearLitterApprox.symm_litterPerm", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.NearLitterApprox.symm_litterPerm [ConNF.Params🔗<|PREMISE|>🔗 ] (π : ConNF.NearLitterApprox) :(ConNF.NearLitterApprox.symm🔗<|PREMISE|>🔗 π).litterPerm = PartialPerm.symm🔗<|PREMISE|>🔗 π.litterPerm", "code": "theorem symm_litterPerm : π.symm.litterPerm = π.litterPerm.symm :=\n  rfl\n", "additional_info": "", "used_premises": [1, 1223, 644], "def_path": "ConNF/FOA/Approximation/NearLitterApprox.lean", "pos": [72, 74], "informalization": "The theorem `ConNF.NearLitterApprox.symm_litterPerm` states that the `litterPerm` component of the symmetric of a `ConNF.NearLitterApprox` object `π` is equal to the inverse of the `litterPerm` component of `π`."}
{"full_name": "ConNF.NearLitterApprox.left_inv_atom", "url": "ConNF/FOA/Approximation/NearLitterApprox.html#ConNF.NearLitterApprox.left_inv_atom", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.NearLitterApprox.left_inv_atom [ConNF.Params🔗<|PREMISE|>🔗 ] (π : ConNF.NearLitterApprox) {a : ConNF.Atom} :a ∈ π.atomPerm.domain → ConNF.NearLitterApprox.symm🔗<|PREMISE|>🔗 π • π • a = a", "code": "theorem left_inv_atom {a} : a ∈ π.atomPerm.domain → π.symm • π • a = a :=\n  π.atomPerm.left_inv\n", "additional_info": "", "used_premises": [1, 1223], "def_path": "ConNF/FOA/Approximation/NearLitterApprox.lean", "pos": [76, 78], "informalization": "The theorem `ConNF.NearLitterApprox.left_inv_atom` states that for any `ConNF.NearLitterApprox` object `π`, if an `ConNF.Atom` `a` is in the domain of `π.atomPerm`, then applying `ConNF.NearLitterApprox.symm π` followed by `π` to `a` results in `a` itself. This theorem is a part of the proof that `ConNF.NearLitterApprox` forms a group action on `ConNF.Atom`."}
{"full_name": "ConNF.NearLitterApprox.left_inv_litter", "url": "ConNF/FOA/Approximation/NearLitterApprox.html#ConNF.NearLitterApprox.left_inv_litter", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.NearLitterApprox.left_inv_litter [ConNF.Params🔗<|PREMISE|>🔗 ] (π : ConNF.NearLitterApprox) {L : ConNF.Litter} :L ∈ π.litterPerm.domain → ConNF.NearLitterApprox.symm🔗<|PREMISE|>🔗 π • π • L = L", "code": "theorem left_inv_litter {L} : L ∈ π.litterPerm.domain → π.symm • π • L = L :=\n  π.litterPerm.left_inv\n", "additional_info": "", "used_premises": [1, 1223], "def_path": "ConNF/FOA/Approximation/NearLitterApprox.lean", "pos": [80, 82], "informalization": "The theorem `ConNF.NearLitterApprox.left_inv_litter` states that for any `ConNF.NearLitterApprox` object `π` and a `ConNF.Litter` object `L`, if `L` is in the domain of the `litterPerm` component of `π`, then applying `ConNF.NearLitterApprox.symm π` followed by `π` to `L` results in `L` itself."}
{"full_name": "ConNF.NearLitterApprox.right_inv_atom", "url": "ConNF/FOA/Approximation/NearLitterApprox.html#ConNF.NearLitterApprox.right_inv_atom", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.NearLitterApprox.right_inv_atom [ConNF.Params🔗<|PREMISE|>🔗 ] (π : ConNF.NearLitterApprox) {a : ConNF.Atom} :a ∈ π.atomPerm.domain → π • ConNF.NearLitterApprox.symm🔗<|PREMISE|>🔗 π • a = a", "code": "theorem right_inv_atom {a} : a ∈ π.atomPerm.domain → π • π.symm • a = a :=\n  π.atomPerm.right_inv\n", "additional_info": "", "used_premises": [1, 1223], "def_path": "ConNF/FOA/Approximation/NearLitterApprox.lean", "pos": [84, 86], "informalization": "The theorem `ConNF.NearLitterApprox.right_inv_atom` states that for any `ConNF.NearLitterApprox` object `π` and any `ConNF.Atom` `a` that is in the domain of `π.atomPerm`, applying `π` and then its symmetric counterpart `ConNF.NearLitterApprox.symm π` to `a` results in `a` itself. This property is crucial for establishing that `ConNF.NearLitterApprox` objects form a group action on `ConNF.Atom`s."}
{"full_name": "ConNF.NearLitterApprox.right_inv_litter", "url": "ConNF/FOA/Approximation/NearLitterApprox.html#ConNF.NearLitterApprox.right_inv_litter", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.NearLitterApprox.right_inv_litter [ConNF.Params🔗<|PREMISE|>🔗 ] (π : ConNF.NearLitterApprox) {L : ConNF.Litter} :L ∈ π.litterPerm.domain → π • ConNF.NearLitterApprox.symm🔗<|PREMISE|>🔗 π • L = L", "code": "theorem right_inv_litter {L} : L ∈ π.litterPerm.domain → π • π.symm • L = L :=\n  π.litterPerm.right_inv\n", "additional_info": "", "used_premises": [1, 1223], "def_path": "ConNF/FOA/Approximation/NearLitterApprox.lean", "pos": [88, 90], "informalization": "The theorem `ConNF.NearLitterApprox.right_inv_litter` states that for any `ConNF.NearLitterApprox` object `π` and any `ConNF.Litter` object `L`, if `L` is in the domain of `π.litterPerm`, then `π • ConNF.NearLitterApprox.symm π • L = L`. This means that applying `π` and then its symmetric counterpart `ConNF.NearLitterApprox.symm π` to `L` results in `L` itself."}
{"full_name": "ConNF.NearLitterApprox.symm_smul_atom_eq_iff", "url": "ConNF/FOA/Approximation/NearLitterApprox.html#ConNF.NearLitterApprox.symm_smul_atom_eq_iff", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterApprox.symm_smul_atom_eq_iff [ConNF.Params🔗<|PREMISE|>🔗 ] (π : ConNF.NearLitterApprox) {a : ConNF.Atom} {b : ConNF.Atom} :a ∈ π.atomPerm.domain → b ∈ π.atomPerm.domain → (ConNF.NearLitterApprox.symm🔗<|PREMISE|>🔗 π • a = b ↔ a = π • b)", "code": "theorem symm_smul_atom_eq_iff {a b} :\n    a ∈ π.atomPerm.domain → b ∈ π.atomPerm.domain → (π.symm • a = b ↔ a = π • b) :=\n  by\n  intro ha hb\n  constructor\n  · rintro rfl\n    exact (π.right_inv_atom ha).symm\n  · rintro rfl\n    exact π.left_inv_atom hb\n", "additional_info": "", "used_premises": [1, 1223], "def_path": "ConNF/FOA/Approximation/NearLitterApprox.lean", "pos": [91, 100], "informalization": "Given a `ConNF.NearLitterApprox` object `π`, this theorem states that for any two `ConNF.Atom`s `a` and `b` in the domain of `π.atomPerm`, `a = π • b` if and only if `ConNF.NearLitterApprox.symm π • a = b`. This theorem is used to relate actions of the `ConNF.NearLitterApprox` object `π` and its symmetric counterpart `ConNF.NearLitterApprox.symm π`."}
{"full_name": "ConNF.NearLitterApprox.symm_smul_litter_eq_iff", "url": "ConNF/FOA/Approximation/NearLitterApprox.html#ConNF.NearLitterApprox.symm_smul_litter_eq_iff", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterApprox.symm_smul_litter_eq_iff [ConNF.Params🔗<|PREMISE|>🔗 ] (π : ConNF.NearLitterApprox) {L₁ : ConNF.Litter} {L₂ : ConNF.Litter} :L₁ ∈ π.litterPerm.domain → L₂ ∈ π.litterPerm.domain → (ConNF.NearLitterApprox.symm🔗<|PREMISE|>🔗 π • L₁ = L₂ ↔ L₁ = π • L₂)", "code": "theorem symm_smul_litter_eq_iff {L₁ L₂} :\n    L₁ ∈ π.litterPerm.domain → L₂ ∈ π.litterPerm.domain → (π.symm • L₁ = L₂ ↔ L₁ = π • L₂) :=\n  by\n  intro hL₁ hL₂\n  constructor\n  · rintro rfl\n    exact (π.right_inv_litter hL₁).symm\n  · rintro rfl\n    exact π.left_inv_litter hL₂\n", "additional_info": "", "used_premises": [1, 1223], "def_path": "ConNF/FOA/Approximation/NearLitterApprox.lean", "pos": [101, 110], "informalization": "The theorem `ConNF.NearLitterApprox.symm_smul_litter_eq_iff` states that for a `ConNF.NearLitterApprox` object `π` and two litters `L₁` and `L₂`, if `L₁` and `L₂` are both in the domain of `π.litterPerm`, then `ConNF.NearLitterApprox.symm π • L₁ = L₂` if and only if `L₁ = π • L₂`."}
{"full_name": "ConNF.NearLitterApprox.eq_symm_apply_atom", "url": "ConNF/FOA/Approximation/NearLitterApprox.html#ConNF.NearLitterApprox.eq_symm_apply_atom", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterApprox.eq_symm_apply_atom [ConNF.Params🔗<|PREMISE|>🔗 ] (π : ConNF.NearLitterApprox) {a₁ : ConNF.Atom} {a₂ : ConNF.Atom} :a₁ ∈ π.atomPerm.domain → a₂ ∈ π.atomPerm.domain → (a₁ = ConNF.NearLitterApprox.symm🔗<|PREMISE|>🔗 π • a₂ ↔ π • a₁ = a₂)", "code": "theorem eq_symm_apply_atom {a₁ a₂} :\n    a₁ ∈ π.atomPerm.domain → a₂ ∈ π.atomPerm.domain → (a₁ = π.symm • a₂ ↔ π • a₁ = a₂) :=\n  π.atomPerm.eq_symm_apply\n", "additional_info": "", "used_premises": [1, 1223], "def_path": "ConNF/FOA/Approximation/NearLitterApprox.lean", "pos": [111, 114], "informalization": "Function `ConNF.NearLitterApprox.symm` is a method that takes a `ConNF.NearLitterApprox` object `π` and returns a new `ConNF.NearLitterApprox` object, where the `atomPerm` and `litterPerm` components of `π` are replaced by their symmetric counterparts. The `domain_small` component remains unchanged. The theorem `ConNF.NearLitterApprox.eq_symm_apply_atom` states that for any two atoms `a₁` and `a₂` in the domain of `π.atomPerm`, `a₁` is equal to `ConNF.NearLitterApprox.symm π • a₂` if and only if `π • a₁` is equal to `a₂`."}
{"full_name": "ConNF.NearLitterApprox.eq_symm_apply_litter", "url": "ConNF/FOA/Approximation/NearLitterApprox.html#ConNF.NearLitterApprox.eq_symm_apply_litter", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterApprox.eq_symm_apply_litter [ConNF.Params🔗<|PREMISE|>🔗 ] (π : ConNF.NearLitterApprox) {L₁ : ConNF.Litter} {L₂ : ConNF.Litter} :L₁ ∈ π.litterPerm.domain → L₂ ∈ π.litterPerm.domain → (L₁ = ConNF.NearLitterApprox.symm🔗<|PREMISE|>🔗 π • L₂ ↔ π • L₁ = L₂)", "code": "theorem eq_symm_apply_litter {L₁ L₂} :\n    L₁ ∈ π.litterPerm.domain → L₂ ∈ π.litterPerm.domain → (L₁ = π.symm • L₂ ↔ π • L₁ = L₂) :=\n  π.litterPerm.eq_symm_apply\n", "additional_info": "", "used_premises": [1, 1223], "def_path": "ConNF/FOA/Approximation/NearLitterApprox.lean", "pos": [115, 118], "informalization": "Function `ConNF.NearLitterApprox.symm` is a method that takes a `ConNF.NearLitterApprox` object `π` and returns a new `ConNF.NearLitterApprox` object, where the `atomPerm` and `litterPerm` components of `π` are replaced by their symmetric counterparts. The `domain_small` component remains unchanged. The theorem `ConNF.NearLitterApprox.eq_symm_apply_litter` states that for any two litters `L₁` and `L₂` in the domain of `π.litterPerm`, `L₁` equals `ConNF.NearLitterApprox.symm π • L₂` if and only if `π • L₁` equals `L₂`."}
{"full_name": "ConNF.NearLitterApprox.nearLitter_domain_small", "url": "ConNF/FOA/Approximation/NearLitterApprox.html#ConNF.NearLitterApprox.nearLitter_domain_small", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterApprox.nearLitter_domain_small [ConNF.Params🔗<|PREMISE|>🔗 ] (π : ConNF.NearLitterApprox) (N : ConNF.NearLitter) :ConNF.Small🔗<|PREMISE|>🔗 (↑N ∩ π.atomPerm.domain)", "code": "theorem nearLitter_domain_small (N : NearLitter) : Small ((N : Set Atom) ∩ π.atomPerm.domain) := by\n  rw [← symmDiff_symmDiff_cancel_left (litterSet N.fst) N, inter_symmDiff_distrib_right]\n  exact Small.symmDiff (π.domain_small N.fst) (Small.mono (inter_subset_left _ _) N.2.prop)\n", "additional_info": "", "used_premises": [1, 233], "def_path": "ConNF/FOA/Approximation/NearLitterApprox.lean", "pos": [119, 122], "informalization": "In the context of Constructive Ordinal Notation (ConNF), the theorem `ConNF.NearLitterApprox.nearLitter_domain_small` states that the intersection of a near-litter `N` and the domain of a near-litter approximation `π` is a small set, meaning its cardinality is strictly less than the cardinality of the type `ConNF.κ`."}
{"full_name": "ConNF.NearLitterApprox.largestSublitter_litter", "url": "ConNF/FOA/Approximation/NearLitterApprox.html#ConNF.NearLitterApprox.largestSublitter_litter", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.NearLitterApprox.largestSublitter_litter [ConNF.Params🔗<|PREMISE|>🔗 ] (π : ConNF.NearLitterApprox) (L : ConNF.Litter) :(ConNF.NearLitterApprox.largestSublitter🔗<|PREMISE|>🔗 π L).litter = L", "code": "theorem largestSublitter_litter (L : Litter) : (π.largestSublitter L).litter = L :=\n  rfl\n", "additional_info": "", "used_premises": [1, 1235], "def_path": "ConNF/FOA/Approximation/NearLitterApprox.lean", "pos": [134, 136], "informalization": "The function `ConNF.NearLitterApprox.largestSublitter` returns the largest sublitter of `π` on which `π.atom_perm` is not defined. The theorem `ConNF.NearLitterApprox.largestSublitter_litter` states that the litter of the largest sublitter of `π` is equal to `L`."}
{"full_name": "ConNF.NearLitterApprox.largestSublitter", "url": "ConNF/FOA/Approximation/NearLitterApprox.html#ConNF.NearLitterApprox.largestSublitter", "code_src": "con-nf", "ptype": "def", "header": "def ConNF.NearLitterApprox.largestSublitter [ConNF.Params🔗<|PREMISE|>🔗 ] (π : ConNF.NearLitterApprox) (L : ConNF.Litter) :ConNF.Sublitter", "code": "def largestSublitter (L : Litter) : Sublitter\n    where\n  litter := L\n  carrier := litterSet L \\ π.atomPerm.domain\n  subset := diff_subset _ _\n  diff_small := by simpa only [sdiff_sdiff_right_self, inf_eq_inter] using π.domain_small L\n", "additional_info": "Gives the largest sublitter of `π` on which `π.atom_perm` is not defined.\nEquations\n* 🗟ConNF.NearLitterApprox.largestSublitter🗟🔗../../.././ConNF/FOA/Approximation/NearLitterApprox.html#ConNF.NearLitterApprox.largestSublitter🔗  π L 🗟=🗟🔗../../.././Init/Prelude.html#Eq🔗  { litter := L, carrier := 🗟ConNF.litterSet🗟🔗../../.././ConNF/BaseType/Atom.html#ConNF.litterSet🔗  L 🗟\\🗟🔗../../.././Init/Core.html#SDiff.sdiff🔗  π.atomPerm.domain, subset := ⋯, diff_small := ⋯ }\n\n", "used_premises": [1], "def_path": "ConNF/FOA/Approximation/NearLitterApprox.lean", "pos": [126, 132], "informalization": "Function `ConNF.NearLitterApprox.largestSublitter` returns the largest sublitter of `π` on which `π.atom_perm` is not defined."}
{"full_name": "ConNF.NearLitterApprox.coe_largestSublitter", "url": "ConNF/FOA/Approximation/NearLitterApprox.html#ConNF.NearLitterApprox.coe_largestSublitter", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.NearLitterApprox.coe_largestSublitter [ConNF.Params🔗<|PREMISE|>🔗 ] (π : ConNF.NearLitterApprox) (L : ConNF.Litter) :↑(ConNF.NearLitterApprox.largestSublitter🔗<|PREMISE|>🔗 π L) = ConNF.litterSet🔗<|PREMISE|>🔗 L \\ π.atomPerm.domain", "code": "theorem coe_largestSublitter (L : Litter) :\n    (π.largestSublitter L : Set Atom) = litterSet L \\ π.atomPerm.domain :=\n  rfl\n", "additional_info": "", "used_premises": [1, 1235, 467], "def_path": "ConNF/FOA/Approximation/NearLitterApprox.lean", "pos": [138, 141], "informalization": "The theorem `ConNF.NearLitterApprox.coe_largestSublitter` states that the largest sublitter of `π` on which `π.atom_perm` is not defined is equal to the set of all atoms `a` such that the first projection of `a` is equal to `L`, minus the domain of `π.atom_perm`."}
{"full_name": "ConNF.NearLitterApprox.mem_largestSublitter_of_not_mem_domain", "url": "ConNF/FOA/Approximation/NearLitterApprox.html#ConNF.NearLitterApprox.mem_largestSublitter_of_not_mem_domain", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterApprox.mem_largestSublitter_of_not_mem_domain [ConNF.Params🔗<|PREMISE|>🔗 ] (π : ConNF.NearLitterApprox) (a : ConNF.Atom) (h : a ∉ π.atomPerm.domain) :a ∈ ConNF.NearLitterApprox.largestSublitter🔗<|PREMISE|>🔗 π a.1", "code": "theorem mem_largestSublitter_of_not_mem_domain (a : Atom) (h : a ∉ π.atomPerm.domain) :\n    a ∈ π.largestSublitter a.1 :=\n  ⟨rfl, h⟩\n", "additional_info": "", "used_premises": [1, 1235], "def_path": "ConNF/FOA/Approximation/NearLitterApprox.lean", "pos": [142, 145], "informalization": "Given a `ConNF.NearLitterApprox` object `π` and an `ConNF.Atom` object `a`, if `a` is not in the domain of `π.atomPerm`, then `a` is in the largest sublitter of `π` on which `π.atom_perm` is not defined."}
{"full_name": "ConNF.NearLitterApprox.not_mem_domain_of_mem_largestSublitter", "url": "ConNF/FOA/Approximation/NearLitterApprox.html#ConNF.NearLitterApprox.not_mem_domain_of_mem_largestSublitter", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterApprox.not_mem_domain_of_mem_largestSublitter [ConNF.Params🔗<|PREMISE|>🔗 ] (π : ConNF.NearLitterApprox) {a : ConNF.Atom} {L : ConNF.Litter} (h : a ∈ ConNF.NearLitterApprox.largestSublitter🔗<|PREMISE|>🔗 π L) :a ∉ π.atomPerm.domain", "code": "theorem not_mem_domain_of_mem_largestSublitter {a : Atom} {L : Litter}\n    (h : a ∈ π.largestSublitter L) : a ∉ π.atomPerm.domain :=\n  h.2\n", "additional_info": "", "used_premises": [1, 1235], "def_path": "ConNF/FOA/Approximation/NearLitterApprox.lean", "pos": [146, 149], "informalization": "The theorem `ConNF.NearLitterApprox.not_mem_domain_of_mem_largestSublitter` states that if an atom `a` belongs to the largest sublitter of a near litter approximation `π` on which `π.atom_perm` is not defined, then `a` does not belong to the domain of `π.atom_perm`."}
{"full_name": "ConNF.NearLitterApprox.approximates_iff", "url": "ConNF/FOA/Approximation/NearLitterApprox.html#ConNF.NearLitterApprox.approximates_iff", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterApprox.approximates_iff [ConNF.Params🔗<|PREMISE|>🔗 ] (π₀ : ConNF.NearLitterApprox) (π : ConNF.NearLitterPerm) :ConNF.NearLitterApprox.Approximates🔗<|PREMISE|>🔗 π₀ π ↔ (∀ a ∈ π₀.atomPerm.domain, π₀ • a = π • a) ∧ ∀ L ∈ π₀.litterPerm.domain, π₀ • L = π • L", "code": "@[mk_iff]\n", "additional_info": "", "used_premises": [1, 1181], "def_path": "ConNF/FOA/Approximation/NearLitterApprox.lean", "pos": [155, 156], "informalization": "`ConNF.NearLitterApprox.approximates_iff` is a theorem in the context of Constructive Ordinal Notation (ConNF), which defines a relationship between two objects of type `ConNF.NearLitterApprox` and `ConNF.NearLitterPerm`. It states that a `ConNF.NearLitterApprox` object `π₀` approximates a `ConNF.NearLitterPerm` object `π` if and only if for any atom `a` in the domain of `π₀.atomPerm`, the action of `π₀` on `a` is the same as the action of `π` on `a`, and for any litter `L` in the domain of `π₀.litterPerm`, the action of `π₀` on `L` is the same as the action of `π` on `L`."}
{"full_name": "ConNF.NearLitterApprox.Approximates.symm_map_atom", "url": "ConNF/FOA/Approximation/NearLitterApprox.html#ConNF.NearLitterApprox.Approximates.symm_map_atom", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterApprox.Approximates.symm_map_atom [ConNF.Params🔗<|PREMISE|>🔗 ] {π₀ : ConNF.NearLitterApprox} {π : ConNF.NearLitterPerm} (hπ : ConNF.NearLitterApprox.Approximates🔗<|PREMISE|>🔗 π₀ π) (a : ConNF.Atom) (ha : a ∈ π₀.atomPerm.domain) :ConNF.NearLitterApprox.symm🔗<|PREMISE|>🔗 π₀ • a = π⁻¹ • a", "code": "theorem Approximates.symm_map_atom {π₀ : NearLitterApprox} {π : NearLitterPerm}\n    (hπ : π₀.Approximates π) (a : Atom) (ha : a ∈ π₀.atomPerm.domain) :\n    π₀.symm • a = π⁻¹ • a := by\n  have := hπ.map_atom (π₀.symm • a) (π₀.symm.atomPerm.map_domain ha)\n  rw [← inv_smul_eq_iff] at this\n  rw [← this, smul_left_cancel_iff]\n  exact π₀.atomPerm.right_inv ha\n", "additional_info": "", "used_premises": [1, 1181, 1223], "def_path": "ConNF/FOA/Approximation/NearLitterApprox.lean", "pos": [160, 167], "informalization": "The theorem states that for any `ConNF.NearLitterApprox` object `π₀`, any `ConNF.NearLitterPerm` object `π`, and an `ConNF.Atom` `a` that is in the domain of `π₀.atomPerm`, the symmetric action of `π₀` on `a` is equal to the inverse action of `π` on `a`. This is proven under the assumption that `π₀` approximates `π` in the sense defined by the `ConNF.NearLitterApprox.Approximates` structure."}
{"full_name": "ConNF.NearLitterApprox.Approximates.symm_map_litter", "url": "ConNF/FOA/Approximation/NearLitterApprox.html#ConNF.NearLitterApprox.Approximates.symm_map_litter", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterApprox.Approximates.symm_map_litter [ConNF.Params🔗<|PREMISE|>🔗 ] {π₀ : ConNF.NearLitterApprox} {π : ConNF.NearLitterPerm} (hπ : ConNF.NearLitterApprox.Approximates🔗<|PREMISE|>🔗 π₀ π) (L : ConNF.Litter) (hL : L ∈ π₀.litterPerm.domain) :ConNF.NearLitterApprox.symm🔗<|PREMISE|>🔗 π₀ • L = π⁻¹ • L", "code": "theorem Approximates.symm_map_litter {π₀ : NearLitterApprox} {π : NearLitterPerm}\n    (hπ : π₀.Approximates π) (L : Litter) (hL : L ∈ π₀.litterPerm.domain) :\n    π₀.symm • L = π⁻¹ • L := by\n  have := hπ.map_litter (π₀.symm • L) (π₀.symm.litterPerm.map_domain hL)\n  rw [← inv_smul_eq_iff] at this\n  rw [← this, smul_left_cancel_iff]\n  exact π₀.litterPerm.right_inv hL\n", "additional_info": "", "used_premises": [1, 1181, 1223], "def_path": "ConNF/FOA/Approximation/NearLitterApprox.lean", "pos": [168, 175], "informalization": "`ConNF.NearLitterApprox.Approximates.symm_map_litter` is a theorem in the `ConNF` library, which is a part of the `mathlib` library for formalizing Constructive Ordinal Notation (ConNF) in the Lean 4 proof assistant. This theorem states that if `π₀` is an approximation of `π` (in the sense defined by the `ConNF.NearLitterApprox.Approximates` structure), then the symmetric version of `π₀` (obtained by taking the symmetric permutation of both the `atomPerm` and `litterPerm` components) applied to a litter `L` in the domain of `π₀` is the same as the inverse of `π` applied to `L`."}
{"full_name": "ConNF.NearLitterApprox.exactlyApproximates_iff", "url": "ConNF/FOA/Approximation/NearLitterApprox.html#ConNF.NearLitterApprox.exactlyApproximates_iff", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterApprox.exactlyApproximates_iff [ConNF.Params🔗<|PREMISE|>🔗 ] (π₀ : ConNF.NearLitterApprox) (π : ConNF.NearLitterPerm) :ConNF.NearLitterApprox.ExactlyApproximates🔗<|PREMISE|>🔗 π₀ π ↔ ConNF.NearLitterApprox.Approximates🔗<|PREMISE|>🔗 π₀ π ∧ ∀ (a : ConNF.Atom), ConNF.NearLitterPerm.IsException🔗<|PREMISE|>🔗 π a → a ∈ π₀.atomPerm.domain", "code": "@[mk_iff]\n", "additional_info": "", "used_premises": [1, 1180, 1181, 801], "def_path": "ConNF/FOA/Approximation/NearLitterApprox.lean", "pos": [176, 177], "informalization": "The theorem `ConNF.NearLitterApprox.exactlyApproximates_iff` states that a near litter approximation `π₀` exactly approximates a near litter permutation `π` if and only if `π₀` approximates `π` in the sense that their actions on atoms and litters are consistent, and for any atom `a`, if `π` is an exception with respect to `a`, then `a` must be in the domain of `π₀.atomPerm`."}
{"full_name": "ConNF.NearLitterApprox.ExactlyApproximates.of_isException", "url": "ConNF/FOA/Approximation/NearLitterApprox.html#ConNF.NearLitterApprox.ExactlyApproximates.of_isException", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterApprox.ExactlyApproximates.of_isException [ConNF.Params🔗<|PREMISE|>🔗 ] {π₀ : ConNF.NearLitterApprox} {π : ConNF.NearLitterPerm} (hπ : ConNF.NearLitterApprox.ExactlyApproximates🔗<|PREMISE|>🔗 π₀ π) (a : ConNF.Atom) (ha : a.1 ∈ π₀.litterPerm.domain) :ConNF.NearLitterPerm.IsException🔗<|PREMISE|>🔗 π a → π₀ • a ∉ ConNF.litterSet🔗<|PREMISE|>🔗 (π₀ • a.1) ∨ ConNF.NearLitterApprox.symm🔗<|PREMISE|>🔗 π₀ • a ∉ ConNF.litterSet🔗<|PREMISE|>🔗 (ConNF.NearLitterApprox.symm🔗<|PREMISE|>🔗 π₀ • a.1)", "code": "theorem ExactlyApproximates.of_isException {π₀ : NearLitterApprox} {π : NearLitterPerm}\n    (hπ : π₀.ExactlyApproximates π) (a : Atom) (ha : a.1 ∈ π₀.litterPerm.domain) :\n    π.IsException a → π₀ • a ∉ litterSet (π₀ • a.1) ∨ π₀.symm • a ∉ litterSet (π₀.symm • a.1) :=\n  by\n  intro h\n  rw [hπ.map_litter a.fst ha, hπ.symm_map_litter a.fst ha, hπ.map_atom a (hπ.exception_mem a h),\n    hπ.symm_map_atom a (hπ.exception_mem a h)]\n  exact h\n", "additional_info": "", "used_premises": [1, 1180, 801, 467, 1223, 467, 1223], "def_path": "ConNF/FOA/Approximation/NearLitterApprox.lean", "pos": [181, 189], "informalization": "In the context of Constructive Ordinal Notation (ConNF), `ConNF.NearLitterApprox.ExactlyApproximates.of_isException` is a theorem that proves a property of near liter `ConNF.NearLitterApprox` objects. It states that if `π` is an exception with respect to an atom `a`, and `π₀` exactly approximates `π`, then either `π₀ • a` is not in the litter set corresponding to `π₀ • a.1`, or `ConNF.NearLitterApprox.symm π₀ • a` is not in the litter set corresponding to `ConNF.NearLitterApprox.symm π₀ • a.1`. This theorem is crucial in the construction of `ConNF`, as it helps to determine the behavior of approximations when they are exceptions."}
{"full_name": "ConNF.NearLitterApprox.ExactlyApproximates.mem_litterSet", "url": "ConNF/FOA/Approximation/NearLitterApprox.html#ConNF.NearLitterApprox.ExactlyApproximates.mem_litterSet", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterApprox.ExactlyApproximates.mem_litterSet [ConNF.Params🔗<|PREMISE|>🔗 ] {π₀ : ConNF.NearLitterApprox} {π : ConNF.NearLitterPerm} (hπ : ConNF.NearLitterApprox.ExactlyApproximates🔗<|PREMISE|>🔗 π₀ π) (a : ConNF.Atom) (ha : a ∉ π₀.atomPerm.domain) :π • a ∈ ConNF.litterSet🔗<|PREMISE|>🔗 (π • a.1)", "code": "theorem ExactlyApproximates.mem_litterSet {π₀ : NearLitterApprox} {π : NearLitterPerm}\n    (hπ : π₀.ExactlyApproximates π) (a : Atom) (ha : a ∉ π₀.atomPerm.domain) :\n    π • a ∈ litterSet (π • a.1) := by contrapose! ha; exact hπ.exception_mem _ (Or.inl ha)\n", "additional_info": "", "used_premises": [1, 1180, 467], "def_path": "ConNF/FOA/Approximation/NearLitterApprox.lean", "pos": [190, 193], "informalization": "The theorem `ConNF.NearLitterApprox.ExactlyApproximates.mem_litterSet` in the context of Constructive Ordinal Notation (ConNF) states that if `π₀` exactly approximates `π`, and `a` is an atom not in the domain of `π₀.atomPerm`, then the action of `π` on `a` results in an element of the litter set corresponding to the first projection of `π • a`."}
{"full_name": "ConNF.NearLitterApprox.ExactlyApproximates.mem_litterSet_inv", "url": "ConNF/FOA/Approximation/NearLitterApprox.html#ConNF.NearLitterApprox.ExactlyApproximates.mem_litterSet_inv", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterApprox.ExactlyApproximates.mem_litterSet_inv [ConNF.Params🔗<|PREMISE|>🔗 ] {π₀ : ConNF.NearLitterApprox} {π : ConNF.NearLitterPerm} (hπ : ConNF.NearLitterApprox.ExactlyApproximates🔗<|PREMISE|>🔗 π₀ π) (a : ConNF.Atom) (ha : a ∉ π₀.atomPerm.domain) :π⁻¹ • a ∈ ConNF.litterSet🔗<|PREMISE|>🔗 (π⁻¹ • a.1)", "code": "theorem ExactlyApproximates.mem_litterSet_inv {π₀ : NearLitterApprox} {π : NearLitterPerm}\n    (hπ : π₀.ExactlyApproximates π) (a : Atom) (ha : a ∉ π₀.atomPerm.domain) :\n    π⁻¹ • a ∈ litterSet (π⁻¹ • a.1) := by contrapose! ha; exact hπ.exception_mem _ (Or.inr ha)\n", "additional_info": "", "used_premises": [1, 1180, 467], "def_path": "ConNF/FOA/Approximation/NearLitterApprox.lean", "pos": [194, 197], "informalization": "This theorem states that if `π` is an exactly approximating permutation that does not map an atom `a` to itself, then the inverse permutation `π⁻¹` applied to `a` results in an atom that is an element of the litter set corresponding to the litter `π⁻¹ • a.1`."}
{"full_name": "ConNF.StructApprox.Approximates.comp", "url": "ConNF/FOA/Approximation/StructApprox.html#ConNF.StructApprox.Approximates.comp", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.StructApprox.Approximates.comp [ConNF.Params🔗<|PREMISE|>🔗 ] {β : ConNF.TypeIndex} {γ : ConNF.TypeIndex} {π₀ : ConNF.StructApprox🔗<|PREMISE|>🔗 β} {π : ConNF.StructPerm🔗<|PREMISE|>🔗 β} (h : ConNF.StructApprox.Approximates🔗<|PREMISE|>🔗 π₀ π) (A : Quiver.Path🔗<|PREMISE|>🔗 β γ) :ConNF.StructApprox.Approximates🔗<|PREMISE|>🔗 (ConNF.Tree.comp🔗<|PREMISE|>🔗 A π₀) (ConNF.Tree.comp🔗<|PREMISE|>🔗 A π)", "code": "theorem Approximates.comp {β γ : TypeIndex} {π₀ : StructApprox β} {π : StructPerm β}\n    (h : π₀.Approximates π) (A : Path β γ) :\n    StructApprox.Approximates (π₀.comp A) (Tree.comp A π) :=\n  fun B => h (A.comp B)\n", "additional_info": "", "used_premises": [1, 781, 55, 1247, 76, 1247, 304, 304], "def_path": "ConNF/FOA/Approximation/StructApprox.lean", "pos": [34, 38], "informalization": "Function `ConNF.StructApprox.Approximates.comp` proves that if a `β`-structural approximation `π₀` approximates a `β`-structural permutation `π`, then for any path `A` from type index `β` to type index `γ`, the `γ`-structural approximation obtained by composing `π₀` with `A` approximates the `γ`-structural permutation obtained by composing `π` with `A`."}
{"full_name": "ConNF.StructApprox.Approximates", "url": "ConNF/FOA/Approximation/StructApprox.html#ConNF.StructApprox.Approximates", "code_src": "con-nf", "ptype": "def", "header": "def ConNF.StructApprox.Approximates [ConNF.Params🔗<|PREMISE|>🔗 ] {β : ConNF.TypeIndex} (π₀ : ConNF.StructApprox🔗<|PREMISE|>🔗 β) (π : ConNF.StructPerm🔗<|PREMISE|>🔗 β) :Prop", "code": "def Approximates {β : TypeIndex} (π₀ : StructApprox β) (π : StructPerm β) : Prop :=\n  ∀ A, (π₀ A).Approximates (π A)\n", "additional_info": "Equations\n* 🗟ConNF.StructApprox.Approximates🗟🔗../../.././ConNF/FOA/Approximation/StructApprox.html#ConNF.StructApprox.Approximates🔗  π₀ π 🗟=🗟🔗../../.././Init/Prelude.html#Eq🔗  ∀ (A : 🗟ConNF.ExtendedIndex🗟🔗../../.././ConNF/Structural/Index.html#ConNF.ExtendedIndex🔗  β), 🗟ConNF.NearLitterApprox.Approximates🗟🔗../../.././ConNF/FOA/Approximation/NearLitterApprox.html#ConNF.NearLitterApprox.Approximates🔗  (π₀ A) (π A)\n\n", "used_premises": [1, 781, 55], "def_path": "ConNF/FOA/Approximation/StructApprox.lean", "pos": [23, 25], "informalization": "Function `ConNF.StructApprox.Approximates` checks if a `β`-structural approximation `π₀` approximates a `β`-structural permutation `π`, meaning that for each `β`-extended index `A`, the near-litter approximation `π₀ A` approximates the near-litter permutation `π A`."}
{"full_name": "ConNF.StructApprox.ExactlyApproximates.comp", "url": "ConNF/FOA/Approximation/StructApprox.html#ConNF.StructApprox.ExactlyApproximates.comp", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.StructApprox.ExactlyApproximates.comp [ConNF.Params🔗<|PREMISE|>🔗 ] {β : ConNF.TypeIndex} {γ : ConNF.TypeIndex} {π₀ : ConNF.StructApprox🔗<|PREMISE|>🔗 β} {π : ConNF.StructPerm🔗<|PREMISE|>🔗 β} (h : ConNF.StructApprox.ExactlyApproximates🔗<|PREMISE|>🔗 π₀ π) (A : Quiver.Path🔗<|PREMISE|>🔗 β γ) :ConNF.StructApprox.ExactlyApproximates🔗<|PREMISE|>🔗 (ConNF.Tree.comp🔗<|PREMISE|>🔗 A π₀) (ConNF.Tree.comp🔗<|PREMISE|>🔗 A π)", "code": "theorem ExactlyApproximates.comp {β γ : TypeIndex} {π₀ : StructApprox β} {π : StructPerm β}\n    (h : π₀.ExactlyApproximates π) (A : Path β γ) :\n    StructApprox.ExactlyApproximates (π₀.comp A) (Tree.comp A π) :=\n  fun B => h (A.comp B)\n", "additional_info": "", "used_premises": [1, 781, 55, 803, 76, 803, 304, 304], "def_path": "ConNF/FOA/Approximation/StructApprox.lean", "pos": [39, 43], "informalization": "Function `ConNF.StructApprox.ExactlyApproximates.comp` proves that if a `β`-structural approximation `π₀` exactly approximates a `β`-structural permutation `π`, then for any path `A` from type index `β` to type index `γ`, the `γ`-structural approximation `ConNF.Tree.comp A π₀` exactly approximates the `γ`-structural permutation `ConNF.Tree.comp A π`."}
{"full_name": "ConNF.StructBehaviour.withLitters_lawful", "url": "ConNF/FOA/Behaviour/StructBehaviour.html#ConNF.StructBehaviour.withLitters_lawful", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.StructBehaviour.withLitters_lawful [ConNF.Params🔗<|PREMISE|>🔗 ] {β : ConNF.TypeIndex} (ξ : ConNF.StructBehaviour🔗<|PREMISE|>🔗 β) (hξ : ConNF.StructBehaviour.Lawful🔗<|PREMISE|>🔗 ξ) :ConNF.StructBehaviour.Lawful🔗<|PREMISE|>🔗 (ConNF.StructBehaviour.withLitters🔗<|PREMISE|>🔗 ξ hξ)", "code": "theorem withLitters_lawful (ξ : StructBehaviour β) (hξ : ξ.Lawful) : (ξ.withLitters hξ).Lawful :=\n  fun A => (ξ A).withLitters_lawful (hξ A)\n", "additional_info": "", "used_premises": [1, 828, 829, 829, 1250], "def_path": "ConNF/FOA/Behaviour/StructBehaviour.lean", "pos": [29, 31], "informalization": "The theorem `ConNF.StructBehaviour.withLitters_lawful` states that if `ξ` is a lawful `β`-structural action, then the `β`-structural action obtained by replacing each near-litter action in `ξ` with its lawful version is also lawful."}
{"full_name": "ConNF.StructBehaviour.withLitters", "url": "ConNF/FOA/Behaviour/StructBehaviour.html#ConNF.StructBehaviour.withLitters", "code_src": "con-nf", "ptype": "noncomputable def", "header": "noncomputable def ConNF.StructBehaviour.withLitters [ConNF.Params🔗<|PREMISE|>🔗 ] {β : ConNF.TypeIndex} (ξ : ConNF.StructBehaviour🔗<|PREMISE|>🔗 β) (hξ : ConNF.StructBehaviour.Lawful🔗<|PREMISE|>🔗 ξ) :ConNF.StructBehaviour🔗<|PREMISE|>🔗 β", "code": "noncomputable def withLitters (ξ : StructBehaviour β) (hξ : ξ.Lawful) : StructBehaviour β :=\n  fun A => (ξ A).withLitters (hξ A)\n", "additional_info": "Equations\n* 🗟ConNF.StructBehaviour.withLitters🗟🔗../../.././ConNF/FOA/Behaviour/StructBehaviour.html#ConNF.StructBehaviour.withLitters🔗  ξ hξ A 🗟=🗟🔗../../.././Init/Prelude.html#Eq🔗  🗟ConNF.NearLitterBehaviour.withLitters🗟🔗../../.././ConNF/FOA/Behaviour/NearLitterBehaviour.html#ConNF.NearLitterBehaviour.withLitters🔗  (ξ A) ⋯\n\n", "used_premises": [1, 828, 829, 828], "def_path": "ConNF/FOA/Behaviour/StructBehaviour.lean", "pos": [26, 28], "informalization": "Function `ConNF.StructBehaviour.withLitters` takes a `β`-structural action `ξ` and a proof `hξ` that `ξ` is lawful, and returns a new `β`-structural action where each near-litter action is replaced by its lawful version."}
{"full_name": "ConNF.NearLitterBehaviour.ext_iff", "url": "ConNF/FOA/Behaviour/NearLitterBehaviour.html#ConNF.NearLitterBehaviour.ext_iff", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterBehaviour.ext_iff :∀ {inst : ConNF.Params🔗<|PREMISE|>🔗 } (x y : ConNF.NearLitterBehaviour), x = y ↔ x.atomMap = y.atomMap ∧ x.nearLitterMap = y.nearLitterMap", "code": "@[ext]\n", "additional_info": "", "used_premises": [1], "def_path": "ConNF/FOA/Behaviour/NearLitterBehaviour.lean", "pos": [12, 13], "informalization": "`ConNF.NearLitterBehaviour.ext_iff` is an extensionality theorem for the `ConNF.NearLitterBehaviour` structure. It states that two instances of `ConNF.NearLitterBehaviour` are equal if and only if their `atomMap` and `nearLitterMap` fields are equal."}
{"full_name": "ConNF.NearLitterBehaviour.ext", "url": "ConNF/FOA/Behaviour/NearLitterBehaviour.html#ConNF.NearLitterBehaviour.ext", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterBehaviour.ext :∀ {inst : ConNF.Params🔗<|PREMISE|>🔗 } (x y : ConNF.NearLitterBehaviour), x.atomMap = y.atomMap → x.nearLitterMap = y.nearLitterMap → x = y", "code": "@[ext]\n", "additional_info": "", "used_premises": [1], "def_path": "ConNF/FOA/Behaviour/NearLitterBehaviour.lean", "pos": [12, 13], "informalization": "The `ConNF.NearLitterBehaviour.ext` theorem states that two `ConNF.NearLitterBehaviour` objects are equal if their `atomMap` and `nearLitterMap` fields are equal."}
{"full_name": "ConNF.NearLitterBehaviour.map_nearLitter_fst", "url": "ConNF/FOA/Behaviour/NearLitterBehaviour.html#ConNF.NearLitterBehaviour.map_nearLitter_fst", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterBehaviour.map_nearLitter_fst [ConNF.Params🔗<|PREMISE|>🔗 ] {ξ : ConNF.NearLitterBehaviour} (hξ : ConNF.NearLitterBehaviour.Lawful🔗<|PREMISE|>🔗 ξ) ⦃N₁ : ConNF.NearLitter⦄ ⦃N₂ : ConNF.NearLitter⦄ (hN₁ : (ξ.nearLitterMap N₁).Dom) (hN₂ : (ξ.nearLitterMap N₂).Dom) :N₁.fst = N₂.fst ↔ ((ξ.nearLitterMap N₁).get hN₁).fst = ((ξ.nearLitterMap N₂).get hN₂).fst", "code": "theorem map_nearLitter_fst {ξ : NearLitterBehaviour} (hξ : ξ.Lawful) ⦃N₁ N₂ : NearLitter⦄\n    (hN₁ : (ξ.nearLitterMap N₁).Dom) (hN₂ : (ξ.nearLitterMap N₂).Dom) :\n    N₁.fst = N₂.fst ↔ ((ξ.nearLitterMap N₁).get hN₁).fst = ((ξ.nearLitterMap N₂).get hN₂).fst := by\n  constructor\n  · intro h\n    rw [← NearLitter.isNear_iff_fst_eq_fst]\n    refine (Small.pFun_image (f := ξ.atomMap) ξ.atomMap_dom_small).mono ?_\n    intro a ha\n    obtain ⟨b, hb, rfl⟩ := hξ.ran_of_mem_symmDiff a h hN₁ hN₂ ha\n    exact ⟨b, hb, hb, rfl⟩\n  · intro h\n    by_contra h'\n    suffices : Small (((ξ.nearLitterMap N₁).get hN₁ : Set Atom) ∩ (ξ.nearLitterMap N₂).get hN₂)\n    · rw [Small, NearLitter.mk_inter_of_fst_eq_fst h, lt_self_iff_false] at this\n      exact this\n    refine (Small.pFun_image (f := ξ.atomMap) ξ.atomMap_dom_small).mono ?_\n    intro a ha\n    obtain ⟨b, hb, rfl⟩ := hξ.ran_of_mem_inter a h' hN₁ hN₂ ha\n    exact ⟨b, hb, hb, rfl⟩\n", "additional_info": "", "used_premises": [1, 823], "def_path": "ConNF/FOA/Behaviour/NearLitterBehaviour.lean", "pos": [42, 61], "informalization": "The theorem `ConNF.NearLitterBehaviour.map_nearLitter_fst` states that for two near-litters `N₁` and `N₂`, the first component of `N₁` is equal to the first component of `N₂` if and only if the first component of the image of `N₁` under the near-litter map is equal to the first component of the image of `N₂` under the near-litter map."}
{"full_name": "ConNF.NearLitterBehaviour.extraAtoms_small", "url": "ConNF/FOA/Behaviour/NearLitterBehaviour.html#ConNF.NearLitterBehaviour.extraAtoms_small", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterBehaviour.extraAtoms_small [ConNF.Params🔗<|PREMISE|>🔗 ] (ξ : ConNF.NearLitterBehaviour) :ConNF.Small🔗<|PREMISE|>🔗 (ConNF.NearLitterBehaviour.extraAtoms🔗<|PREMISE|>🔗 ξ)", "code": "theorem extraAtoms_small (ξ : NearLitterBehaviour) : Small ξ.extraAtoms :=\n  Small.bUnion ξ.nearLitterMap_dom_small (fun N _ => N.2.2.mono (fun _ => Or.inl))\n", "additional_info": "", "used_premises": [1, 233, 1255], "def_path": "ConNF/FOA/Behaviour/NearLitterBehaviour.lean", "pos": [68, 70], "informalization": "The theorem `ConNF.NearLitterBehaviour.extraAtoms_small` states that for any `ConNF.NearLitterBehaviour` object `ξ`, the cardinality of the set `ConNF.NearLitterBehaviour.extraAtoms ξ` is strictly less than the cardinality of the type `ConNF.κ` in the context of Constructive Ordinal Notation (ConNF)."}
{"full_name": "ConNF.NearLitterBehaviour.extraAtoms", "url": "ConNF/FOA/Behaviour/NearLitterBehaviour.html#ConNF.NearLitterBehaviour.extraAtoms", "code_src": "con-nf", "ptype": "def", "header": "def ConNF.NearLitterBehaviour.extraAtoms [ConNF.Params🔗<|PREMISE|>🔗 ] (ξ : ConNF.NearLitterBehaviour) :Set🔗<|PREMISE|>🔗 ConNF.Atom", "code": "def extraAtoms (ξ : NearLitterBehaviour) : Set Atom :=\n  ⋃ (N ∈ ξ.nearLitterMap.Dom), litterSet N.1 \\ N\n", "additional_info": "Equations\n* 🗟ConNF.NearLitterBehaviour.extraAtoms🗟🔗../../.././ConNF/FOA/Behaviour/NearLitterBehaviour.html#ConNF.NearLitterBehaviour.extraAtoms🔗  ξ 🗟=🗟🔗../../.././Init/Prelude.html#Eq🔗  ⋃ N ∈ 🗟PFun.Dom🗟🔗../../.././Mathlib/Data/PFun.html#PFun.Dom🔗  ξ.nearLitterMap, 🗟ConNF.litterSet🗟🔗../../.././ConNF/BaseType/Atom.html#ConNF.litterSet🔗  N.fst 🗟\\🗟🔗../../.././Init/Core.html#SDiff.sdiff🔗  ↑N\n\n", "used_premises": [1, 69], "def_path": "ConNF/FOA/Behaviour/NearLitterBehaviour.lean", "pos": [65, 67], "informalization": "`ConNF.NearLitterBehaviour.extraAtoms` is a function that takes a `ConNF.NearLitterBehaviour` object `ξ` and returns a set of `ConNF.Atom`s. This set is defined as the union of the differences between the `ConNF.litterSet` of each `N` in the domain of `ξ.nearLitterMap` and `N` itself."}
{"full_name": "ConNF.NearLitterBehaviour.bannedLitter_iff", "url": "ConNF/FOA/Behaviour/NearLitterBehaviour.html#ConNF.NearLitterBehaviour.bannedLitter_iff", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterBehaviour.bannedLitter_iff [ConNF.Params🔗<|PREMISE|>🔗 ] (ξ : ConNF.NearLitterBehaviour) :∀ (a : ConNF.Litter), ConNF.NearLitterBehaviour.BannedLitter🔗<|PREMISE|>🔗 ξ a ↔ (∃ (a_1 : ConNF.Atom) (h : (ξ.atomMap a_1).Dom), a = ((ξ.atomMap a_1).get h).1) ∨ (∃ (N : ConNF.NearLitter) (h : (ξ.nearLitterMap N).Dom), a = ((ξ.nearLitterMap N).get h).fst) ∨ ∃ (N : ConNF.NearLitter) (h : (ξ.nearLitterMap N).Dom), ∃ a_1 ∈ ↑((ξ.nearLitterMap N).get h) \\ ConNF.litterSet🔗<|PREMISE|>🔗 ((ξ.nearLitterMap N).get h).fst, a = a_1.1", "code": "@[mk_iff]\n", "additional_info": "", "used_premises": [1, 1257, 467], "def_path": "ConNF/FOA/Behaviour/NearLitterBehaviour.lean", "pos": [71, 72], "informalization": "In the context of Constructive Ordinal Notation (ConNF), a litter is considered \"banned\" if it is the image of an atom under the atom map, the image of a near-litter under the near-litter map, or if it is the difference of a near-litter's image under the near-litter map and its own litter set. The theorem `ConNF.NearLitterBehaviour.bannedLitter_iff` states that a litter is banned if and only if it satisfies one of these three conditions."}
{"full_name": "ConNF.NearLitterBehaviour.BannedLitter", "url": "ConNF/FOA/Behaviour/NearLitterBehaviour.html#ConNF.NearLitterBehaviour.BannedLitter", "code_src": "con-nf", "ptype": "inductive", "header": "inductive ConNF.NearLitterBehaviour.BannedLitter [ConNF.Params🔗<|PREMISE|>🔗 ] (ξ : ConNF.NearLitterBehaviour) :ConNF.Litter → Prop", "code": "inductive BannedLitter (ξ : NearLitterBehaviour) : Litter → Prop\n  | atomMap (a : Atom) (h) : BannedLitter ξ ((ξ.atomMap a).get h).1\n  | nearLitterMap (N : NearLitter) (h) : BannedLitter ξ ((ξ.nearLitterMap N).get h).1\n  | diff (N : NearLitter) (h) (a : Atom) :\n    a ∈ ((ξ.nearLitterMap N).get h : Set Atom) \\ litterSet ((ξ.nearLitterMap N).get h).1 →\n    BannedLitter ξ a.1\n", "additional_info": "", "used_premises": [1], "def_path": "ConNF/FOA/Behaviour/NearLitterBehaviour.lean", "pos": [72, 78], "informalization": "The `ConNF.NearLitterBehaviour.BannedLitter` inductive type defines the conditions under which a litter is considered \"banned\" in the context of Constructive Ordinal Notation (ConNF). A litter is banned if it is the image of an atom under the atom map, the image of a near-litter under the near-litter map, or if it is the difference of a near-litter's image under the near-litter map and its own litter set."}
{"full_name": "ConNF.NearLitterBehaviour.bannedLitter_of_mem", "url": "ConNF/FOA/Behaviour/NearLitterBehaviour.html#ConNF.NearLitterBehaviour.bannedLitter_of_mem", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterBehaviour.bannedLitter_of_mem [ConNF.Params🔗<|PREMISE|>🔗 ] {ξ : ConNF.NearLitterBehaviour} (a : ConNF.Atom) (N : ConNF.NearLitter) (hN : (ξ.nearLitterMap N).Dom) (ha : a ∈ (ξ.nearLitterMap N).get hN) :ConNF.NearLitterBehaviour.BannedLitter🔗<|PREMISE|>🔗 ξ a.1", "code": "theorem bannedLitter_of_mem {ξ : NearLitterBehaviour} (a : Atom) (N : NearLitter)\n    (hN : (ξ.nearLitterMap N).Dom) (ha : a ∈ (ξ.nearLitterMap N).get hN) : ξ.BannedLitter a.1 := by\n  by_cases h : a.1 = (Part.get (nearLitterMap ξ N) hN).1\n  · rw [h]\n    exact BannedLitter.nearLitterMap N hN\n  · exact BannedLitter.diff N hN _ ⟨ha, h⟩\n", "additional_info": "", "used_premises": [1, 1257], "def_path": "ConNF/FOA/Behaviour/NearLitterBehaviour.lean", "pos": [79, 85], "informalization": "The theorem `ConNF.NearLitterBehaviour.bannedLitter_of_mem` states that if an atom `a` is a member of the image of a near-litter `N` under the near-litter map `ξ.nearLitterMap N`, then `a` is a banned litter in the context of Constructive Ordinal Notation (ConNF)."}
{"full_name": "ConNF.NearLitterBehaviour.bannedLitter_small", "url": "ConNF/FOA/Behaviour/NearLitterBehaviour.html#ConNF.NearLitterBehaviour.bannedLitter_small", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterBehaviour.bannedLitter_small [ConNF.Params🔗<|PREMISE|>🔗 ] (ξ : ConNF.NearLitterBehaviour) :ConNF.Small🔗<|PREMISE|>🔗 {L : ConNF.Litter | ConNF.NearLitterBehaviour.BannedLitter🔗<|PREMISE|>🔗 ξ L}", "code": "theorem bannedLitter_small (ξ : NearLitterBehaviour) : Small {L | ξ.BannedLitter L} := by\n  simp only [bannedLitter_iff, mem_diff, SetLike.mem_coe, mem_litterSet]\n  refine Small.union ?_ (Small.union ?_ ?_)\n  · refine' lt_of_le_of_lt _ ξ.atomMap_dom_small\n    refine' ⟨⟨fun L => ⟨_, L.prop.choose_spec.choose⟩, fun L₁ L₂ h => _⟩⟩\n    simp only [Subtype.mk_eq_mk, Prod.mk.inj_iff] at h\n    have := L₁.prop.choose_spec.choose_spec\n    simp_rw [h] at this\n    exact Subtype.coe_injective (this.trans L₂.prop.choose_spec.choose_spec.symm)\n  · refine' lt_of_le_of_lt _ ξ.nearLitterMap_dom_small\n    refine' ⟨⟨fun L => ⟨_, L.prop.choose_spec.choose⟩, fun L₁ L₂ h => _⟩⟩\n    simp only [Subtype.mk_eq_mk, Prod.mk.inj_iff] at h\n    have := L₁.prop.choose_spec.choose_spec\n    simp_rw [h] at this\n    exact Subtype.coe_injective (this.trans L₂.prop.choose_spec.choose_spec.symm)\n  · have : Small\n      (⋃ (L : NearLitter) (h : (ξ.nearLitterMap L).Dom),\n        ((ξ.nearLitterMap L).get h : Set Atom) \\ litterSet ((ξ.nearLitterMap L).get h).1)\n    · refine' Small.bUnion _ _\n      · refine' lt_of_le_of_lt _ ξ.nearLitterMap_dom_small\n        refine' ⟨⟨fun N => ⟨_, N.prop⟩, fun N₁ N₂ h => _⟩⟩\n        simp only [Subtype.mk_eq_mk, Prod.mk.inj_iff] at h\n        exact Subtype.coe_inj.mp h\n      · intro L hL\n        refine' Small.mono _ ((ξ.nearLitterMap L).get hL).2.prop\n        exact fun x hx => Or.inr hx\n    refine' lt_of_le_of_lt _ this\n    refine' ⟨⟨fun L => ⟨L.prop.choose_spec.choose_spec.choose, _⟩, fun L₁ L₂ h => _⟩⟩\n    · simp only [mem_iUnion]\n      exact ⟨_, _, L.prop.choose_spec.choose_spec.choose_spec.1⟩\n    simp only [Subtype.mk_eq_mk, Prod.mk.inj_iff] at h\n    have := L₁.prop.choose_spec.choose_spec.choose_spec.2\n    rw [h] at this\n    exact Subtype.coe_injective (this.trans L₂.prop.choose_spec.choose_spec.choose_spec.2.symm)\n", "additional_info": "", "used_premises": [1, 233, 1257], "def_path": "ConNF/FOA/Behaviour/NearLitterBehaviour.lean", "pos": [86, 120], "informalization": "The theorem `ConNF.NearLitterBehaviour.bannedLitter_small` states that the set of litters that are considered \"banned\" in the context of Constructive Ordinal Notation (ConNF) has a cardinality that is strictly less than the cardinality of the type `ConNF.κ`."}
{"full_name": "ConNF.NearLitterBehaviour.mk_not_bannedLitter", "url": "ConNF/FOA/Behaviour/NearLitterBehaviour.html#ConNF.NearLitterBehaviour.mk_not_bannedLitter", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterBehaviour.mk_not_bannedLitter [ConNF.Params🔗<|PREMISE|>🔗 ] (ξ : ConNF.NearLitterBehaviour) :Cardinal.mk🔗<|PREMISE|>🔗 ↑{L : ConNF.Litter | ¬ ConNF.NearLitterBehaviour.BannedLitter🔗<|PREMISE|>🔗 ξ L} = Cardinal.mk🔗<|PREMISE|>🔗 ConNF.μ", "code": "theorem mk_not_bannedLitter (ξ : NearLitterBehaviour) : #{L | ¬ξ.BannedLitter L} = #μ := by\n  have := mk_sum_compl {L | ξ.BannedLitter L}\n  rw [compl_setOf, mk_litter] at this\n  rw [← this, add_eq_right]\n  · by_contra h\n    have h' := add_le_add (le_of_lt ξ.bannedLitter_small) (le_of_not_le h)\n    rw [this] at h'\n    refine' not_lt_of_le h' _\n    refine' Cardinal.add_lt_of_lt Params.μ_isStrongLimit.isLimit.aleph0_le Params.κ_lt_μ _\n    exact lt_of_le_of_lt Params.κ_isRegular.aleph0_le Params.κ_lt_μ\n  · by_contra h\n    have h' := add_le_add (le_of_lt ξ.bannedLitter_small) (le_of_not_le h)\n    rw [this] at h'\n    refine' not_lt_of_le h' _\n    refine' Cardinal.add_lt_of_lt Params.μ_isStrongLimit.isLimit.aleph0_le Params.κ_lt_μ _\n    exact lt_trans ξ.bannedLitter_small Params.κ_lt_μ\n", "additional_info": "", "used_premises": [1, 29, 1257, 29], "def_path": "ConNF/FOA/Behaviour/NearLitterBehaviour.lean", "pos": [121, 137], "informalization": "The theorem `ConNF.NearLitterBehaviour.mk_not_bannedLitter` states that the cardinality of the set of litters that are not considered \"banned\" in the context of Constructive Ordinal Notation (ConNF) is equal to the cardinality of the type `μ` from the `ConNF.Params` class."}
{"full_name": "ConNF.NearLitterBehaviour.not_bannedLitter_nonempty", "url": "ConNF/FOA/Behaviour/NearLitterBehaviour.html#ConNF.NearLitterBehaviour.not_bannedLitter_nonempty", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterBehaviour.not_bannedLitter_nonempty [ConNF.Params🔗<|PREMISE|>🔗 ] (ξ : ConNF.NearLitterBehaviour) :Nonempty🔗<|PREMISE|>🔗 ↑{L : ConNF.Litter | ¬ ConNF.NearLitterBehaviour.BannedLitter🔗<|PREMISE|>🔗 ξ L}", "code": "theorem not_bannedLitter_nonempty (ξ : NearLitterBehaviour) : Nonempty {L | ¬ξ.BannedLitter L} := by\n  simp only [← mk_ne_zero_iff, mk_not_bannedLitter, Ne.def, mk_ne_zero, not_false_iff]\n", "additional_info": "", "used_premises": [1, 212, 1257], "def_path": "ConNF/FOA/Behaviour/NearLitterBehaviour.lean", "pos": [138, 140], "informalization": "The theorem `ConNF.NearLitterBehaviour.not_bannedLitter_nonempty` asserts that for any `ConNF.NearLitterBehaviour` `ξ`, there exists at least one `ConNF.Litter` that is not `ConNF.NearLitterBehaviour.BannedLitter`."}
{"full_name": "ConNF.NearLitterBehaviour.sandboxLitter_not_banned", "url": "ConNF/FOA/Behaviour/NearLitterBehaviour.html#ConNF.NearLitterBehaviour.sandboxLitter_not_banned", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterBehaviour.sandboxLitter_not_banned [ConNF.Params🔗<|PREMISE|>🔗 ] (ξ : ConNF.NearLitterBehaviour) :¬ ConNF.NearLitterBehaviour.BannedLitter🔗<|PREMISE|>🔗 ξ (ConNF.NearLitterBehaviour.sandboxLitter🔗<|PREMISE|>🔗 ξ)", "code": "theorem sandboxLitter_not_banned (ξ : NearLitterBehaviour) : ¬ξ.BannedLitter ξ.sandboxLitter :=\n  ξ.not_bannedLitter_nonempty.some.prop\n", "additional_info": "", "used_premises": [1, 1257, 1263], "def_path": "ConNF/FOA/Behaviour/NearLitterBehaviour.lean", "pos": [144, 146], "informalization": "Function `ConNF.NearLitterBehaviour.sandboxLitter` takes a `ConNF.NearLitterBehaviour` object `ξ` and returns a `ConNF.Litter` object that is not banned by `ξ`."}
{"full_name": "ConNF.NearLitterBehaviour.sandboxLitter", "url": "ConNF/FOA/Behaviour/NearLitterBehaviour.html#ConNF.NearLitterBehaviour.sandboxLitter", "code_src": "con-nf", "ptype": "noncomputable def", "header": "noncomputable def ConNF.NearLitterBehaviour.sandboxLitter [ConNF.Params🔗<|PREMISE|>🔗 ] (ξ : ConNF.NearLitterBehaviour) :ConNF.Litter", "code": "noncomputable def sandboxLitter (ξ : NearLitterBehaviour) : Litter :=\n  ξ.not_bannedLitter_nonempty.some\n", "additional_info": "Equations\n* 🗟ConNF.NearLitterBehaviour.sandboxLitter🗟🔗../../.././ConNF/FOA/Behaviour/NearLitterBehaviour.html#ConNF.NearLitterBehaviour.sandboxLitter🔗  ξ 🗟=🗟🔗../../.././Init/Prelude.html#Eq🔗  ↑(🗟Nonempty.some🗟🔗../../.././Mathlib/Logic/Nonempty.html#Nonempty.some🔗  ⋯)\n\n", "used_premises": [1], "def_path": "ConNF/FOA/Behaviour/NearLitterBehaviour.lean", "pos": [141, 143], "informalization": "Function `ConNF.NearLitterBehaviour.sandboxLitter` takes a `ConNF.NearLitterBehaviour` object `ξ` and returns a `ConNF.Litter` object, which represents a litter in the context of Constructive Ordinal Notation (ConNF). The returned litter is chosen from the non-empty set of litters that are not banned by `ξ`."}
{"full_name": "ConNF.NearLitterBehaviour.mem_innerAtoms_iff", "url": "ConNF/FOA/Behaviour/NearLitterBehaviour.html#ConNF.NearLitterBehaviour.mem_innerAtoms_iff", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterBehaviour.mem_innerAtoms_iff [ConNF.Params🔗<|PREMISE|>🔗 ] {ξ : ConNF.NearLitterBehaviour} (L : ConNF.Litter) (hL : ConNF.NearLitterBehaviour.LitterPresent🔗<|PREMISE|>🔗 ξ L) (a : ConNF.Atom) :a ∈ ConNF.NearLitterBehaviour.innerAtoms🔗<|PREMISE|>🔗 ξ L ↔ a.1 ≠ L ∧ ∀ (N : ConNF.NearLitter), (ξ.nearLitterMap N).Dom ∧ N.fst = L → a ∈ N", "code": "theorem mem_innerAtoms_iff {ξ : NearLitterBehaviour}\n    (L : Litter) (hL : ξ.LitterPresent L) (a : Atom) :\n    a ∈ ξ.innerAtoms L ↔ a.1 ≠ L ∧ ∀ N (_ : (ξ.nearLitterMap N).Dom ∧ N.1 = L), a ∈ N := by\n  obtain ⟨N, hN, rfl⟩ := hL\n  rw [innerAtoms]\n  aesop\n", "additional_info": "", "used_premises": [1, 838, 1265], "def_path": "ConNF/FOA/Behaviour/NearLitterBehaviour.lean", "pos": [159, 165], "informalization": "The theorem `ConNF.NearLitterBehaviour.mem_innerAtoms_iff` states that an atom `a` belongs to the inner atoms of a near litter `L` if and only if the first component of `a` is not equal to `L` and for all near litters `N` such that the near litter map `ξ.nearLitterMap N` is defined and the first component of `N` is equal to `L`, `a` belongs to `N`."}
{"full_name": "ConNF.NearLitterBehaviour.innerAtoms", "url": "ConNF/FOA/Behaviour/NearLitterBehaviour.html#ConNF.NearLitterBehaviour.innerAtoms", "code_src": "con-nf", "ptype": "def", "header": "def ConNF.NearLitterBehaviour.innerAtoms [ConNF.Params🔗<|PREMISE|>🔗 ] (ξ : ConNF.NearLitterBehaviour) (L : ConNF.Litter) :Set🔗<|PREMISE|>🔗 ConNF.Atom", "code": "def innerAtoms (ξ : NearLitterBehaviour) (L : Litter) : Set Atom :=\n  ⋂ (N : NearLitter) (_ : (ξ.nearLitterMap N).Dom ∧ N.1 = L), N \\ litterSet L\n", "additional_info": "Equations\n* 🗟ConNF.NearLitterBehaviour.innerAtoms🗟🔗../../.././ConNF/FOA/Behaviour/NearLitterBehaviour.html#ConNF.NearLitterBehaviour.innerAtoms🔗  ξ L 🗟=🗟🔗../../.././Init/Prelude.html#Eq🔗  ⋂ (N : ConNF.NearLitter), ⋂ (_ : (ξ.nearLitterMap N).Dom 🗟∧🗟🔗../../.././Init/Prelude.html#And🔗  N.fst 🗟=🗟🔗../../.././Init/Prelude.html#Eq🔗  L), ↑N 🗟\\🗟🔗../../.././Init/Core.html#SDiff.sdiff🔗  🗟ConNF.litterSet🗟🔗../../.././ConNF/BaseType/Atom.html#ConNF.litterSet🔗  L\n\n", "used_premises": [1, 69], "def_path": "ConNF/FOA/Behaviour/NearLitterBehaviour.lean", "pos": [150, 152], "informalization": "Function `ConNF.NearLitterBehaviour.innerAtoms` computes the inner atoms of a near litter `L` in the context of Constructive Ordinal Notation (ConNF). It is defined as the intersection of all near litters `N` such that `ξ.nearLitterMap N` is defined and `N.1 = L`, excluding the litter set of `L`."}
{"full_name": "ConNF.NearLitterBehaviour.mem_outerAtoms_iff", "url": "ConNF/FOA/Behaviour/NearLitterBehaviour.html#ConNF.NearLitterBehaviour.mem_outerAtoms_iff", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.NearLitterBehaviour.mem_outerAtoms_iff [ConNF.Params🔗<|PREMISE|>🔗 ] {ξ : ConNF.NearLitterBehaviour} (L : ConNF.Litter) (a : ConNF.Atom) :a ∈ ConNF.NearLitterBehaviour.outerAtoms🔗<|PREMISE|>🔗 ξ L ↔ a.1 = L ∧ ∀ (N : ConNF.NearLitter), (ξ.nearLitterMap N).Dom → a ∉ N", "code": "theorem mem_outerAtoms_iff {ξ : NearLitterBehaviour} (L : Litter) (a : Atom) :\n    a ∈ ξ.outerAtoms L ↔ a.1 = L ∧ ∀ N, (ξ.nearLitterMap N).Dom → a ∉ N :=\n  by simp only [outerAtoms, mem_diff, mem_litterSet, mem_iUnion, SetLike.mem_coe,\n    exists_prop, not_exists, not_and]\n", "additional_info": "", "used_premises": [1, 1267], "def_path": "ConNF/FOA/Behaviour/NearLitterBehaviour.lean", "pos": [167, 171], "informalization": "The theorem `ConNF.NearLitterBehaviour.mem_outerAtoms_iff` is a membership condition for the set of outer atoms of a given litter `L` in the context of Constructive Ordinal Notation (ConNF). It states that an atom `a` belongs to the set of outer atoms of `L` if and only if `a` is equal to `L` and `a` does not belong to any near litter `N` for which the near litter map `ξ.nearLitterMap N` is defined."}
{"full_name": "ConNF.NearLitterBehaviour.outerAtoms", "url": "ConNF/FOA/Behaviour/NearLitterBehaviour.html#ConNF.NearLitterBehaviour.outerAtoms", "code_src": "con-nf", "ptype": "def", "header": "def ConNF.NearLitterBehaviour.outerAtoms [ConNF.Params🔗<|PREMISE|>🔗 ] (ξ : ConNF.NearLitterBehaviour) (L : ConNF.Litter) :Set🔗<|PREMISE|>🔗 ConNF.Atom", "code": "def outerAtoms (ξ : NearLitterBehaviour) (L : Litter) : Set Atom :=\n  litterSet L \\ (⋃ (N : NearLitter) (_ : (ξ.nearLitterMap N).Dom), N)\n", "additional_info": "Equations\n* 🗟ConNF.NearLitterBehaviour.outerAtoms🗟🔗../../.././ConNF/FOA/Behaviour/NearLitterBehaviour.html#ConNF.NearLitterBehaviour.outerAtoms🔗  ξ L 🗟=🗟🔗../../.././Init/Prelude.html#Eq🔗  🗟ConNF.litterSet🗟🔗../../.././ConNF/BaseType/Atom.html#ConNF.litterSet🔗  L 🗟\\🗟🔗../../.././Init/Core.html#SDiff.sdiff🔗  ⋃ (N : ConNF.NearLitter), ⋃ (_ : (ξ.nearLitterMap N).Dom), ↑N\n\n", "used_premises": [1, 69], "def_path": "ConNF/FOA/Behaviour/NearLitterBehaviour.lean", "pos": [153, 155], "informalization": "Function `ConNF.NearLitterBehaviour.outerAtoms` defines the set of outer atoms of a given litter `L` in the context of Constructive Ordinal Notation (ConNF). This set is obtained by subtracting the union of all near litters from the litter set of `L`."}
{"full_name": "ConNF.NearLitterBehaviour.mem_allOuterAtoms_iff", "url": "ConNF/FOA/Behaviour/NearLitterBehaviour.html#ConNF.NearLitterBehaviour.mem_allOuterAtoms_iff", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.NearLitterBehaviour.mem_allOuterAtoms_iff [ConNF.Params🔗<|PREMISE|>🔗 ] {ξ : ConNF.NearLitterBehaviour} (a : ConNF.Atom) :a ∈ ConNF.NearLitterBehaviour.allOuterAtoms🔗<|PREMISE|>🔗 ξ ↔ ConNF.NearLitterBehaviour.LitterPresent🔗<|PREMISE|>🔗 ξ a.1 ∧ ∀ (N : ConNF.NearLitter), (ξ.nearLitterMap N).Dom → a ∉ N", "code": "theorem mem_allOuterAtoms_iff {ξ : NearLitterBehaviour} (a : Atom) :\n    a ∈ ξ.allOuterAtoms ↔ ξ.LitterPresent a.1 ∧ ∀ N, (ξ.nearLitterMap N).Dom → a ∉ N :=\n  by simp only [allOuterAtoms, mem_iUnion, mem_outerAtoms_iff, exists_and_left,\n    exists_prop, exists_eq_left']\n", "additional_info": "", "used_premises": [1, 1269, 838], "def_path": "ConNF/FOA/Behaviour/NearLitterBehaviour.lean", "pos": [173, 177], "informalization": "The theorem `ConNF.NearLitterBehaviour.mem_allOuterAtoms_iff` states that an atom `a` is an element of the set `ConNF.NearLitterBehaviour.allOuterAtoms ξ` if and only if there exists a near litter `N` such that the near litter map `ξ.nearLitterMap N` is defined and the first component of `N` is equal to `a.1`, and for all near litters `N` such that `ξ.nearLitterMap N` is defined, `a` is not an element of `N`."}
{"full_name": "ConNF.NearLitterBehaviour.allOuterAtoms", "url": "ConNF/FOA/Behaviour/NearLitterBehaviour.html#ConNF.NearLitterBehaviour.allOuterAtoms", "code_src": "con-nf", "ptype": "def", "header": "def ConNF.NearLitterBehaviour.allOuterAtoms [ConNF.Params🔗<|PREMISE|>🔗 ] (ξ : ConNF.NearLitterBehaviour) :Set🔗<|PREMISE|>🔗 ConNF.Atom", "code": "def allOuterAtoms (ξ : NearLitterBehaviour) : Set Atom :=\n  ⋃ (L : Litter) (_ : ξ.LitterPresent L), ξ.outerAtoms L\n", "additional_info": "Equations\n* 🗟ConNF.NearLitterBehaviour.allOuterAtoms🗟🔗../../.././ConNF/FOA/Behaviour/NearLitterBehaviour.html#ConNF.NearLitterBehaviour.allOuterAtoms🔗  ξ 🗟=🗟🔗../../.././Init/Prelude.html#Eq🔗  ⋃ (L : ConNF.Litter), ⋃ (_ : 🗟ConNF.NearLitterBehaviour.LitterPresent🗟🔗../../.././ConNF/FOA/Behaviour/NearLitterBehaviour.html#ConNF.NearLitterBehaviour.LitterPresent🔗  ξ L), 🗟ConNF.NearLitterBehaviour.outerAtoms🗟🔗../../.././ConNF/FOA/Behaviour/NearLitterBehaviour.html#ConNF.NearLitterBehaviour.outerAtoms🔗  ξ L\n\n", "used_premises": [1, 69], "def_path": "ConNF/FOA/Behaviour/NearLitterBehaviour.lean", "pos": [156, 158], "informalization": "Function `ConNF.NearLitterBehaviour.allOuterAtoms` defines a set of `ConNF.Atom`s, which are atoms in the context of Constructive Ordinal Notation (ConNF). This set is constructed by taking the union of the sets of outer atoms for each litter `L` that is present in the near litter behaviour `ξ`, as determined by the condition `ConNF.NearLitterBehaviour.LitterPresent`."}
{"full_name": "ConNF.NearLitterBehaviour.litterPresent_small", "url": "ConNF/FOA/Behaviour/NearLitterBehaviour.html#ConNF.NearLitterBehaviour.litterPresent_small", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterBehaviour.litterPresent_small [ConNF.Params🔗<|PREMISE|>🔗 ] (ξ : ConNF.NearLitterBehaviour) :ConNF.Small🔗<|PREMISE|>🔗 {L : ConNF.Litter | ConNF.NearLitterBehaviour.LitterPresent🔗<|PREMISE|>🔗 ξ L}", "code": "theorem litterPresent_small (ξ : NearLitterBehaviour) : Small {L | ξ.LitterPresent L} := by\n  have : Small (⋃ (N : NearLitter) (_ : (ξ.nearLitterMap N).Dom), {N.1})\n  · refine Small.bUnion ξ.nearLitterMap_dom_small ?_\n    simp only [PFun.mem_dom, small_singleton, forall_exists_index, implies_true, forall_const]\n  refine Small.mono ?_ this\n  simp only [LitterPresent]\n  rintro _ ⟨N, hN, rfl⟩\n  exact ⟨_, ⟨N, rfl⟩, _, ⟨hN, rfl⟩, rfl⟩\n", "additional_info": "", "used_premises": [1, 233, 838], "def_path": "ConNF/FOA/Behaviour/NearLitterBehaviour.lean", "pos": [178, 186], "informalization": "The theorem `ConNF.NearLitterBehaviour.litterPresent_small` states that the set of litters `L` for which there exists a near litter `N` such that the near litter map `ξ.nearLitterMap N` is defined and the first component of `N` is equal to `L`, has a cardinality strictly less than the cardinality of the type `ConNF.κ`."}
{"full_name": "ConNF.NearLitterBehaviour.litterPresent_small'", "url": "ConNF/FOA/Behaviour/NearLitterBehaviour.html#ConNF.NearLitterBehaviour.litterPresent_small'", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterBehaviour.litterPresent_small' [ConNF.Params🔗<|PREMISE|>🔗 ] (ξ : ConNF.NearLitterBehaviour) :ConNF.Small🔗<|PREMISE|>🔗 {N : ConNF.NearLitter | ConNF.NearLitter.IsLitter🔗<|PREMISE|>🔗 N ∧ ∃ (N' : ConNF.NearLitter), (ξ.nearLitterMap N').Dom ∧ N'.fst = N.fst}", "code": "theorem litterPresent_small' (ξ : NearLitterBehaviour) :\n    Small {N : NearLitter | N.IsLitter ∧ ∃ N', (nearLitterMap ξ N').Dom ∧ N'.fst = N.fst} := by\n  have : Small {L | ∃ N, (nearLitterMap ξ N).Dom ∧ N.fst = L}\n  · refine (ξ.nearLitterMap_dom_small.image (f := fun N => N.1)).mono ?_\n    rintro _ ⟨N, hN, rfl⟩\n    exact ⟨N, hN, rfl⟩\n  refine (this.image (f := Litter.toNearLitter)).mono ?_\n  rintro _ ⟨⟨L⟩, N, hN, rfl⟩\n  refine ⟨N.1, ⟨N, hN, rfl⟩, rfl⟩\n", "additional_info": "", "used_premises": [1, 233, 495], "def_path": "ConNF/FOA/Behaviour/NearLitterBehaviour.lean", "pos": [187, 196], "informalization": "The theorem `ConNF.NearLitterBehaviour.litterPresent_small'` states that the set of near-litters that are of the form `L.toNearLitter` for some litter `L` and for which there exists a near-litter `N'` such that `ξ.nearLitterMap N'` is defined and `N'.fst = N.fst`, has a cardinality that is strictly less than the cardinality of the type `ConNF.κ`."}
{"full_name": "ConNF.NearLitterBehaviour.innerAtoms_small", "url": "ConNF/FOA/Behaviour/NearLitterBehaviour.html#ConNF.NearLitterBehaviour.innerAtoms_small", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterBehaviour.innerAtoms_small [ConNF.Params🔗<|PREMISE|>🔗 ] {ξ : ConNF.NearLitterBehaviour} (L : ConNF.Litter) (hL : ConNF.NearLitterBehaviour.LitterPresent🔗<|PREMISE|>🔗 ξ L) :ConNF.Small🔗<|PREMISE|>🔗 (ConNF.NearLitterBehaviour.innerAtoms🔗<|PREMISE|>🔗 ξ L)", "code": "theorem innerAtoms_small {ξ : NearLitterBehaviour} (L : Litter) (hL : ξ.LitterPresent L) :\n    Small (ξ.innerAtoms L) := by\n  obtain ⟨N, hN, rfl⟩ := hL\n  refine Small.mono (biInter_subset_of_mem ⟨hN, rfl⟩) ?_\n  exact Small.mono (fun _ => Or.inr) N.2.prop\n", "additional_info": "", "used_premises": [1, 838, 233, 1265], "def_path": "ConNF/FOA/Behaviour/NearLitterBehaviour.lean", "pos": [197, 202], "informalization": "Function `ConNF.NearLitterBehaviour.innerAtoms_small` proves that the inner atoms of a near litter `L` in the context of Constructive Ordinal Notation (ConNF) are small, meaning their cardinality is strictly less than the cardinality of the type `ConNF.κ`."}
{"full_name": "ConNF.NearLitterBehaviour.outerAtoms_small", "url": "ConNF/FOA/Behaviour/NearLitterBehaviour.html#ConNF.NearLitterBehaviour.outerAtoms_small", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterBehaviour.outerAtoms_small [ConNF.Params🔗<|PREMISE|>🔗 ] {ξ : ConNF.NearLitterBehaviour} (L : ConNF.Litter) (hL : ConNF.NearLitterBehaviour.LitterPresent🔗<|PREMISE|>🔗 ξ L) :ConNF.Small🔗<|PREMISE|>🔗 (ConNF.NearLitterBehaviour.outerAtoms🔗<|PREMISE|>🔗 ξ L)", "code": "theorem outerAtoms_small {ξ : NearLitterBehaviour} (L : Litter) (hL : ξ.LitterPresent L) :\n    Small (ξ.outerAtoms L) := by\n  obtain ⟨N, hN, rfl⟩ := hL\n  rw [outerAtoms]\n  refine Small.mono ?_ (Small.mono (fun _ => Or.inl) N.2.prop)\n  refine Set.diff_subset_diff_right ?_\n  intro a ha\n  exact ⟨_, ⟨N, rfl⟩, _, ⟨hN, rfl⟩, ha⟩\n", "additional_info": "", "used_premises": [1, 838, 233, 1267], "def_path": "ConNF/FOA/Behaviour/NearLitterBehaviour.lean", "pos": [203, 211], "informalization": "The theorem `ConNF.NearLitterBehaviour.outerAtoms_small` states that the set of outer atoms of a given litter `L` in the context of Constructive Ordinal Notation (ConNF) is small, meaning its cardinality is strictly less than the cardinality of the type `ConNF.κ`."}
{"full_name": "ConNF.NearLitterBehaviour.allOuterAtoms_small", "url": "ConNF/FOA/Behaviour/NearLitterBehaviour.html#ConNF.NearLitterBehaviour.allOuterAtoms_small", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterBehaviour.allOuterAtoms_small [ConNF.Params🔗<|PREMISE|>🔗 ] {ξ : ConNF.NearLitterBehaviour} :ConNF.Small🔗<|PREMISE|>🔗 (ConNF.NearLitterBehaviour.allOuterAtoms🔗<|PREMISE|>🔗 ξ)", "code": "theorem allOuterAtoms_small {ξ : NearLitterBehaviour} : Small ξ.allOuterAtoms :=\n  Small.bUnion ξ.litterPresent_small ξ.outerAtoms_small\n", "additional_info": "", "used_premises": [1, 233, 1269], "def_path": "ConNF/FOA/Behaviour/NearLitterBehaviour.lean", "pos": [212, 214], "informalization": "The theorem `ConNF.NearLitterBehaviour.allOuterAtoms_small` states that the set of all outer atoms in the context of Constructive Ordinal Notation (ConNF) is small, meaning its cardinality is strictly less than the cardinality of the type `ConNF.κ`."}
{"full_name": "ConNF.NearLitterBehaviour.innerAtomsCod_subset", "url": "ConNF/FOA/Behaviour/NearLitterBehaviour.html#ConNF.NearLitterBehaviour.innerAtomsCod_subset", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterBehaviour.innerAtomsCod_subset [ConNF.Params🔗<|PREMISE|>🔗 ] (ξ : ConNF.NearLitterBehaviour) (N : ConNF.NearLitter) (hN : (ξ.nearLitterMap N).Dom) :ConNF.NearLitterBehaviour.innerAtomsCod🔗<|PREMISE|>🔗 ξ N.fst ⊆ ↑((ξ.nearLitterMap N).get hN)", "code": "theorem innerAtomsCod_subset (ξ : NearLitterBehaviour)\n    (N : NearLitter) (hN : (ξ.nearLitterMap N).Dom) :\n    ξ.innerAtomsCod N.1 ⊆ (ξ.nearLitterMap N).get hN := by\n  intro a ha\n  refine ha.1 _ ⟨N, subset_antisymm ?_ ?_⟩\n  · intro a' ha'\n    exact ha' _ ⟨⟨hN, rfl⟩, rfl⟩\n  · rintro a' ha' _ ⟨_, rfl⟩\n    exact ha'\n", "additional_info": "", "used_premises": [1, 1276], "def_path": "ConNF/FOA/Behaviour/NearLitterBehaviour.lean", "pos": [226, 235], "informalization": "Function `ConNF.NearLitterBehaviour.innerAtomsCod` computes the set of inner atoms for a given litter `L` in the context of Constructive Ordinal Notation (ConNF). This set is defined as the intersection of the images of all near litters `N` that map to `L` under `ξ.nearLitterMap`, excluding the range of `ξ.atomMap`. The theorem `ConNF.NearLitterBehaviour.innerAtomsCod_subset` states that the set of inner atoms for a given litter `L` is a subset of the image of any near litter `N` that maps to `L` under `ξ.nearLitterMap`."}
{"full_name": "ConNF.NearLitterBehaviour.innerAtomsCod", "url": "ConNF/FOA/Behaviour/NearLitterBehaviour.html#ConNF.NearLitterBehaviour.innerAtomsCod", "code_src": "con-nf", "ptype": "def", "header": "def ConNF.NearLitterBehaviour.innerAtomsCod [ConNF.Params🔗<|PREMISE|>🔗 ] (ξ : ConNF.NearLitterBehaviour) (L : ConNF.Litter) :Set🔗<|PREMISE|>🔗 ConNF.Atom", "code": "def innerAtomsCod (ξ : NearLitterBehaviour) (L : Litter) : Set Atom :=\n  (⋂ (N : NearLitter) (hN : (ξ.nearLitterMap N).Dom ∧ N.1 = L), (ξ.nearLitterMap N).get hN.1) \\\n    ξ.atomMap.ran\n", "additional_info": "The codomain for the inner atoms.\nEquations\n* 🗟ConNF.NearLitterBehaviour.innerAtomsCod🗟🔗../../.././ConNF/FOA/Behaviour/NearLitterBehaviour.html#ConNF.NearLitterBehaviour.innerAtomsCod🔗  ξ L 🗟=🗟🔗../../.././Init/Prelude.html#Eq🔗  (⋂ (N : ConNF.NearLitter), ⋂ (hN : (ξ.nearLitterMap N).Dom 🗟∧🗟🔗../../.././Init/Prelude.html#And🔗  N.fst 🗟=🗟🔗../../.././Init/Prelude.html#Eq🔗  L), ↑((ξ.nearLitterMap N).get ⋯)) 🗟\\🗟🔗../../.././Init/Core.html#SDiff.sdiff🔗  🗟PFun.ran🗟🔗../../.././Mathlib/Data/PFun.html#PFun.ran🔗  ξ.atomMap\n\n", "used_premises": [1, 69], "def_path": "ConNF/FOA/Behaviour/NearLitterBehaviour.lean", "pos": [216, 219], "informalization": "Function `ConNF.NearLitterBehaviour.innerAtomsCod` computes the set of inner atoms for a given litter `L` in the context of Constructive Ordinal Notation (ConNF). This set is defined as the intersection of the images of all near litters `N` that map to `L` under `ξ.nearLitterMap`, excluding the range of `ξ.atomMap`."}
{"full_name": "ConNF.NearLitterBehaviour.mk_innerAtomsCod", "url": "ConNF/FOA/Behaviour/NearLitterBehaviour.html#ConNF.NearLitterBehaviour.mk_innerAtomsCod", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterBehaviour.mk_innerAtomsCod [ConNF.Params🔗<|PREMISE|>🔗 ] {ξ : ConNF.NearLitterBehaviour} (hξ : ConNF.NearLitterBehaviour.Lawful🔗<|PREMISE|>🔗 ξ) (L : ConNF.Litter) (hL : ConNF.NearLitterBehaviour.LitterPresent🔗<|PREMISE|>🔗 ξ L) :Cardinal.mk🔗<|PREMISE|>🔗 ↑(ConNF.NearLitterBehaviour.innerAtomsCod🔗<|PREMISE|>🔗 ξ L) = Cardinal.mk🔗<|PREMISE|>🔗 ConNF.κ", "code": "theorem mk_innerAtomsCod {ξ : NearLitterBehaviour} (hξ : ξ.Lawful)\n    (L : Litter) (hL : ξ.LitterPresent L) : #(ξ.innerAtomsCod L) = #κ := by\n  obtain ⟨N, hN, rfl⟩ := hL\n  refine le_antisymm ?_ ?_\n  · refine (mk_le_mk_of_subset (ξ.innerAtomsCod_subset N hN)).trans ?_\n    simp only [SetLike.coe_sort_coe, mk_nearLitter'', le_refl]\n  · rw [innerAtomsCod_eq N hN]\n    by_contra! h\n    have := Small.union h (ξ.innerAtomsCod_eq_aux hξ N hN)\n    rw [diff_union_self] at this\n    refine (Small.mono (fun _ => Or.inl) this).not_le ?_\n    simp only [SetLike.coe_sort_coe, mk_nearLitter'', le_refl]\n", "additional_info": "", "used_premises": [1, 823, 838, 29, 1276, 29], "def_path": "ConNF/FOA/Behaviour/NearLitterBehaviour.lean", "pos": [271, 283], "informalization": "The function `ConNF.NearLitterBehaviour.innerAtomsCod` computes the set of inner atoms for a given litter `L` in the context of Constructive Ordinal Notation (ConNF). This set is defined as the intersection of the images of all near litters `N` that map to `L` under `ξ.nearLitterMap`, excluding the range of `ξ.atomMap`. The theorem `ConNF.NearLitterBehaviour.mk_innerAtomsCod` states that the cardinality of the set of inner atoms for `L` is equal to the cardinality of `ConNF.κ`."}
{"full_name": "ConNF.NearLitterBehaviour.mk_innerAtoms_lt", "url": "ConNF/FOA/Behaviour/NearLitterBehaviour.html#ConNF.NearLitterBehaviour.mk_innerAtoms_lt", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterBehaviour.mk_innerAtoms_lt [ConNF.Params🔗<|PREMISE|>🔗 ] {ξ : ConNF.NearLitterBehaviour} (hξ : ConNF.NearLitterBehaviour.Lawful🔗<|PREMISE|>🔗 ξ) (L : ConNF.Litter) (hL : ConNF.NearLitterBehaviour.LitterPresent🔗<|PREMISE|>🔗 ξ L) :Cardinal.mk🔗<|PREMISE|>🔗 ↑(ConNF.NearLitterBehaviour.innerAtoms🔗<|PREMISE|>🔗 ξ L) < Cardinal.mk🔗<|PREMISE|>🔗 ↑(ConNF.NearLitterBehaviour.innerAtomsCod🔗<|PREMISE|>🔗 ξ L)", "code": "theorem mk_innerAtoms_lt {ξ : NearLitterBehaviour} (hξ : ξ.Lawful)\n    (L : Litter) (hL : ξ.LitterPresent L) :\n    #(ξ.innerAtoms L) < #(ξ.innerAtomsCod L) := by\n  rw [mk_innerAtomsCod hξ L hL]\n  exact ξ.innerAtoms_small L hL\n", "additional_info": "", "used_premises": [1, 823, 838, 29, 1265, 29, 1276], "def_path": "ConNF/FOA/Behaviour/NearLitterBehaviour.lean", "pos": [284, 289], "informalization": "The theorem `ConNF.NearLitterBehaviour.mk_innerAtoms_lt` states that the cardinality of the set of inner atoms of a near litter `L` in the context of Constructive Ordinal Notation (ConNF) is strictly less than the cardinality of the set of inner atoms for `L`, excluding the range of the atom map."}
{"full_name": "ConNF.NearLitterBehaviour.eq_of_mem_innerAtoms", "url": "ConNF/FOA/Behaviour/NearLitterBehaviour.html#ConNF.NearLitterBehaviour.eq_of_mem_innerAtoms", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterBehaviour.eq_of_mem_innerAtoms [ConNF.Params🔗<|PREMISE|>🔗 ] {ξ : ConNF.NearLitterBehaviour} (hξ : ConNF.NearLitterBehaviour.Lawful🔗<|PREMISE|>🔗 ξ) (a : ConNF.Atom) (ha : ¬ (ξ.atomMap a).Dom) {L₁ : ConNF.Litter} {L₂ : ConNF.Litter} (hL₁ : ConNF.NearLitterBehaviour.LitterPresent🔗<|PREMISE|>🔗 ξ L₁) (hL₂ : ConNF.NearLitterBehaviour.LitterPresent🔗<|PREMISE|>🔗 ξ L₂) (ha₁ : a ∈ ConNF.NearLitterBehaviour.innerAtoms🔗<|PREMISE|>🔗 ξ L₁) (ha₂ : a ∈ ConNF.NearLitterBehaviour.innerAtoms🔗<|PREMISE|>🔗 ξ L₂) :L₁ = L₂", "code": "theorem eq_of_mem_innerAtoms {ξ : NearLitterBehaviour} (hξ : ξ.Lawful) (a : Atom)\n    (ha : ¬(ξ.atomMap a).Dom) {L₁ L₂ : Litter}\n    (hL₁ : ξ.LitterPresent L₁) (hL₂ : ξ.LitterPresent L₂)\n    (ha₁ : a ∈ ξ.innerAtoms L₁) (ha₂ : a ∈ ξ.innerAtoms L₂) : L₁ = L₂ := by\n  rw [mem_innerAtoms_iff L₁ hL₁] at ha₁\n  rw [mem_innerAtoms_iff L₂ hL₂] at ha₂\n  obtain ⟨N₁, hN₁, rfl⟩ := hL₁\n  obtain ⟨N₂, hN₂, rfl⟩ := hL₂\n  have h₁ := ha₁.2 N₁ ⟨hN₁, rfl⟩\n  have h₂ := ha₂.2 N₂ ⟨hN₂, rfl⟩\n  by_contra h\n  exact ha (hξ.dom_of_mem_inter a h hN₁ hN₂ ⟨h₁, h₂⟩)\n", "additional_info": "", "used_premises": [1, 823, 838, 838, 1265, 1265], "def_path": "ConNF/FOA/Behaviour/NearLitterBehaviour.lean", "pos": [300, 312], "informalization": "The theorem `ConNF.NearLitterBehaviour.eq_of_mem_innerAtoms` states that if `a` is an inner atom of two near litters `L₁` and `L₂`, then `L₁` must be equal to `L₂`."}
{"full_name": "ConNF.NearLitterBehaviour.innerAtoms_allOuterAtoms", "url": "ConNF/FOA/Behaviour/NearLitterBehaviour.html#ConNF.NearLitterBehaviour.innerAtoms_allOuterAtoms", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterBehaviour.innerAtoms_allOuterAtoms [ConNF.Params🔗<|PREMISE|>🔗 ] {ξ : ConNF.NearLitterBehaviour} (a : ConNF.Atom) {L : ConNF.Litter} (hL : ConNF.NearLitterBehaviour.LitterPresent🔗<|PREMISE|>🔗 ξ L) (ha₁ : a ∈ ConNF.NearLitterBehaviour.innerAtoms🔗<|PREMISE|>🔗 ξ L) (ha₂ : a ∈ ConNF.NearLitterBehaviour.allOuterAtoms🔗<|PREMISE|>🔗 ξ) :False🔗<|PREMISE|>🔗", "code": "theorem innerAtoms_allOuterAtoms {ξ : NearLitterBehaviour} (a : Atom)\n    {L : Litter} (hL : ξ.LitterPresent L)\n    (ha₁ : a ∈ ξ.innerAtoms L) (ha₂ : a ∈ ξ.allOuterAtoms) : False := by\n  rw [mem_innerAtoms_iff L hL] at ha₁\n  rw [mem_allOuterAtoms_iff] at ha₂\n  obtain ⟨N, hN, rfl⟩ := hL\n  refine ha₂.2 N hN (ha₁.2 N ⟨hN, rfl⟩)\n", "additional_info": "", "used_premises": [1, 838, 1265, 1269, 891], "def_path": "ConNF/FOA/Behaviour/NearLitterBehaviour.lean", "pos": [313, 320], "informalization": "The theorem `ConNF.NearLitterBehaviour.innerAtoms_allOuterAtoms` states that in the context of Constructive Ordinal Notation (ConNF), given a near litter behaviour `ξ`, an atom `a`, and a litter `L` that is present in `ξ`, if `a` is an inner atom of `L` and `a` is also an outer atom of `ξ`, then there is a logical contradiction, represented by `False`."}
{"full_name": "ConNF.NearLitterBehaviour.extraAtomMap_dom_small", "url": "ConNF/FOA/Behaviour/NearLitterBehaviour.html#ConNF.NearLitterBehaviour.extraAtomMap_dom_small", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterBehaviour.extraAtomMap_dom_small [ConNF.Params🔗<|PREMISE|>🔗 ] (ξ : ConNF.NearLitterBehaviour) (hξ : ConNF.NearLitterBehaviour.Lawful🔗<|PREMISE|>🔗 ξ) :ConNF.Small🔗<|PREMISE|>🔗 (PFun.Dom🔗<|PREMISE|>🔗 (ConNF.NearLitterBehaviour.extraAtomMap🔗<|PREMISE|>🔗 ξ hξ))", "code": "theorem extraAtomMap_dom_small (ξ : NearLitterBehaviour) (hξ : ξ.Lawful) :\n    Small (ξ.extraAtomMap hξ).Dom := by\n  refine Small.union ξ.atomMap_dom_small (Small.union ?_ ξ.allOuterAtoms_small)\n  suffices : Small (⋃ (L : Litter) (_ :  ξ.LitterPresent L), ξ.innerAtoms L)\n  · refine Small.mono ?_ this\n    rintro a ⟨L, hL, ha⟩\n    exact ⟨_, ⟨L, rfl⟩, _, ⟨hL, rfl⟩, ha⟩\n  refine Small.bUnion ξ.litterPresent_small ?_\n  intro L hL\n  exact ξ.innerAtoms_small L hL\n", "additional_info": "", "used_premises": [1, 823, 233, 404, 1282], "def_path": "ConNF/FOA/Behaviour/NearLitterBehaviour.lean", "pos": [329, 339], "informalization": "The theorem `ConNF.NearLitterBehaviour.extraAtomMap_dom_small` states that the domain of the partial function `ConNF.NearLitterBehaviour.extraAtomMap`, which is used to extend the domain of the near-litter-behaviour's atom map, is strictly less than the cardinality of the type `ConNF.κ` in the context of Constructive Ordinal Notation (ConNF)."}
{"full_name": "ConNF.NearLitterBehaviour.extraAtomMap", "url": "ConNF/FOA/Behaviour/NearLitterBehaviour.html#ConNF.NearLitterBehaviour.extraAtomMap", "code_src": "con-nf", "ptype": "noncomputable def", "header": "noncomputable def ConNF.NearLitterBehaviour.extraAtomMap [ConNF.Params🔗<|PREMISE|>🔗 ] (ξ : ConNF.NearLitterBehaviour) (hξ : ConNF.NearLitterBehaviour.Lawful🔗<|PREMISE|>🔗 ξ) :ConNF.Atom →. ConNF.Atom", "code": "noncomputable def extraAtomMap (ξ : NearLitterBehaviour) (hξ : ξ.Lawful) : Atom →. Atom :=\n  fun a => ⟨\n    (ξ.atomMap a).Dom ∨ (∃ L, ξ.LitterPresent L ∧ a ∈ ξ.innerAtoms L) ∨\n      a ∈ ξ.allOuterAtoms,\n    fun h => h.elim' (ξ.atomMap a).get (fun h => h.elim'\n      (fun h => ξ.innerAtomsEmbedding hξ _ h.choose_spec.1 ⟨a, h.choose_spec.2⟩)\n      (fun h => ξ.outerAtomsEmbedding ⟨a, h⟩))⟩\n", "additional_info": "Equations\n* One or more equations did not get rendered due to their size.\n\n", "used_premises": [1, 823], "def_path": "ConNF/FOA/Behaviour/NearLitterBehaviour.lean", "pos": [321, 328], "informalization": "Function `ConNF.NearLitterBehaviour.extraAtomMap` is a noncomputable function defined in the context of Constructive Ordinal Notation (ConNF) in Lean 4. It takes as input a lawful near-litter-behaviour `ξ` and returns a partial function from `ConNF.Atom` to `ConNF.Atom`. This function is used to extend the domain of the near-litter-behaviour's atom map, ensuring that every `ConNF.Atom` has an image under the atom map."}
{"full_name": "ConNF.NearLitterBehaviour.innerAtomsEmbedding_ne_atomMap", "url": "ConNF/FOA/Behaviour/NearLitterBehaviour.html#ConNF.NearLitterBehaviour.innerAtomsEmbedding_ne_atomMap", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterBehaviour.innerAtomsEmbedding_ne_atomMap [ConNF.Params🔗<|PREMISE|>🔗 ] {ξ : ConNF.NearLitterBehaviour} {hξ : ConNF.NearLitterBehaviour.Lawful🔗<|PREMISE|>🔗 ξ} {a : ConNF.Atom} (ha : (ξ.atomMap a).Dom) {L : ConNF.Litter} {hL : ConNF.NearLitterBehaviour.LitterPresent🔗<|PREMISE|>🔗 ξ L} (b : ↑(ConNF.NearLitterBehaviour.innerAtoms🔗<|PREMISE|>🔗 ξ L)) :(ξ.atomMap a).get ha ≠ ↑((ConNF.NearLitterBehaviour.innerAtomsEmbedding🔗<|PREMISE|>🔗 hξ L hL) b)", "code": "theorem innerAtomsEmbedding_ne_atomMap {ξ : NearLitterBehaviour} {hξ : ξ.Lawful}\n    {a : Atom} (ha : (ξ.atomMap a).Dom)\n    {L : Litter} {hL : ξ.LitterPresent L} (b : ξ.innerAtoms L) :\n    (ξ.atomMap a).get ha ≠ ξ.innerAtomsEmbedding hξ L hL b := by\n  intro h\n  have := (ξ.innerAtomsEmbedding hξ L hL b).prop\n  rw [← h] at this\n  exact this.2 ⟨a, ha, rfl⟩\n", "additional_info": "", "used_premises": [1, 823, 838, 1265, 1284], "def_path": "ConNF/FOA/Behaviour/NearLitterBehaviour.lean", "pos": [369, 377], "informalization": "The theorem `ConNF.NearLitterBehaviour.innerAtomsEmbedding_ne_atomMap` in Lean 4 states that the atom map of an atom `a` is not equal to the inner atoms embedding of a near litter `L` for any inner atom `b` in the set of inner atoms of `L`. This is part of the correctness proof for the inner atoms definition in the context of Constructive Ordinal Notation (ConNF)."}
{"full_name": "ConNF.NearLitterBehaviour.innerAtomsEmbedding", "url": "ConNF/FOA/Behaviour/NearLitterBehaviour.html#ConNF.NearLitterBehaviour.innerAtomsEmbedding", "code_src": "con-nf", "ptype": "noncomputable def", "header": "@[irreducible]noncomputable def ConNF.NearLitterBehaviour.innerAtomsEmbedding [ConNF.Params🔗<|PREMISE|>🔗 ] {ξ : ConNF.NearLitterBehaviour} (hξ : ConNF.NearLitterBehaviour.Lawful🔗<|PREMISE|>🔗 ξ) (L : ConNF.Litter) (hL : ConNF.NearLitterBehaviour.LitterPresent🔗<|PREMISE|>🔗 ξ L) :↑(ConNF.NearLitterBehaviour.innerAtoms🔗<|PREMISE|>🔗 ξ L) ↪ ↑(ConNF.NearLitterBehaviour.innerAtomsCod🔗<|PREMISE|>🔗 ξ L)", "code": "noncomputable irreducible_def innerAtomsEmbedding {ξ : NearLitterBehaviour} (hξ : ξ.Lawful)\n    (L : Litter) (hL : ξ.LitterPresent L) :\n    ξ.innerAtoms L ↪ ξ.innerAtomsCod L :=\n  ((Cardinal.le_def _ _).mp (mk_innerAtoms_lt hξ L hL).le).some\n", "additional_info": "Equations\n* @🗟ConNF.NearLitterBehaviour.innerAtomsEmbedding🗟🔗../../.././ConNF/FOA/Behaviour/NearLitterBehaviour.html#ConNF.NearLitterBehaviour.innerAtomsEmbedding🔗 🗟=🗟🔗../../.././Init/Prelude.html#Eq🔗  🗟ConNF.NearLitterBehaviour.wrapped✝🗟🔗../../.././ConNF/FOA/Behaviour/NearLitterBehaviour.html#ConNF.NearLitterBehaviour.wrapped._@.ConNF.FOA.Behaviour.NearLitterBehaviour._hyg.3119🔗 .1\n\n", "used_premises": [1, 823, 838, 1265, 1276], "def_path": "ConNF/FOA/Behaviour/NearLitterBehaviour.lean", "pos": [290, 294], "informalization": "Function `ConNF.NearLitterBehaviour.innerAtomsEmbedding` defines an embedding from the set of inner atoms of a near litter `L` in the context of Constructive Ordinal Notation (ConNF) to the set of inner atoms for `L`, excluding the range of the atom map."}
{"full_name": "ConNF.NearLitterBehaviour.outerAtomsEmbedding_ne_atomMap", "url": "ConNF/FOA/Behaviour/NearLitterBehaviour.html#ConNF.NearLitterBehaviour.outerAtomsEmbedding_ne_atomMap", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterBehaviour.outerAtomsEmbedding_ne_atomMap [ConNF.Params🔗<|PREMISE|>🔗 ] {ξ : ConNF.NearLitterBehaviour} {a : ConNF.Atom} (ha : (ξ.atomMap a).Dom) (b : ↑(ConNF.NearLitterBehaviour.allOuterAtoms🔗<|PREMISE|>🔗 ξ)) :(ξ.atomMap a).get ha ≠ ↑((ConNF.NearLitterBehaviour.outerAtomsEmbedding🔗<|PREMISE|>🔗 ξ) b)", "code": "theorem outerAtomsEmbedding_ne_atomMap {ξ : NearLitterBehaviour}\n    {a : Atom} (ha : (ξ.atomMap a).Dom) (b : ξ.allOuterAtoms) :\n    (ξ.atomMap a).get ha ≠ ξ.outerAtomsEmbedding b := by\n  intro h\n  have := (ξ.outerAtomsEmbedding b).prop\n  rw [← h] at this\n  refine sandboxLitter_not_banned ξ ?_\n  rw [← this]\n  exact BannedLitter.atomMap a ha\n", "additional_info": "", "used_premises": [1, 1269, 1286], "def_path": "ConNF/FOA/Behaviour/NearLitterBehaviour.lean", "pos": [378, 387], "informalization": "Function `ConNF.NearLitterBehaviour.outerAtomsEmbedding` defines an embedding from the set of all outer atoms in the context of Constructive Ordinal Notation (ConNF), as determined by the near litter behaviour `ξ`, into the set of all atoms whose first projection is equal to the sandbox litter of `ξ`. The theorem `ConNF.NearLitterBehaviour.outerAtomsEmbedding_ne_atomMap` states that for any atom `a` whose first projection is equal to the sandbox litter of `ξ`, and any outer atom `b` in the context of `ξ`, the image of `b` under the embedding is not equal to `a`."}
{"full_name": "ConNF.NearLitterBehaviour.outerAtomsEmbedding", "url": "ConNF/FOA/Behaviour/NearLitterBehaviour.html#ConNF.NearLitterBehaviour.outerAtomsEmbedding", "code_src": "con-nf", "ptype": "noncomputable def", "header": "@[irreducible]noncomputable def ConNF.NearLitterBehaviour.outerAtomsEmbedding [ConNF.Params🔗<|PREMISE|>🔗 ] (ξ : ConNF.NearLitterBehaviour) :↑(ConNF.NearLitterBehaviour.allOuterAtoms🔗<|PREMISE|>🔗 ξ) ↪ ↑(ConNF.litterSet🔗<|PREMISE|>🔗 (ConNF.NearLitterBehaviour.sandboxLitter🔗<|PREMISE|>🔗 ξ))", "code": "noncomputable irreducible_def outerAtomsEmbedding (ξ : NearLitterBehaviour) :\n    ξ.allOuterAtoms ↪ litterSet ξ.sandboxLitter :=\n  ((Cardinal.le_def _ _).mp (allOuterAtoms_small.le.trans\n    (le_of_eq ((mk_litterSet _).symm)))).some\n", "additional_info": "Equations\n* @🗟ConNF.NearLitterBehaviour.outerAtomsEmbedding🗟🔗../../.././ConNF/FOA/Behaviour/NearLitterBehaviour.html#ConNF.NearLitterBehaviour.outerAtomsEmbedding🔗 🗟=🗟🔗../../.././Init/Prelude.html#Eq🔗  🗟ConNF.NearLitterBehaviour.wrapped✝🗟🔗../../.././ConNF/FOA/Behaviour/NearLitterBehaviour.html#ConNF.NearLitterBehaviour.wrapped._@.ConNF.FOA.Behaviour.NearLitterBehaviour._hyg.3263🔗 .1\n\n", "used_premises": [1, 1269, 467, 1263], "def_path": "ConNF/FOA/Behaviour/NearLitterBehaviour.lean", "pos": [295, 299], "informalization": "Function `ConNF.NearLitterBehaviour.outerAtomsEmbedding` defines an embedding from the set of all outer atoms in the context of Constructive Ordinal Notation (ConNF), as determined by the near litter behaviour `ξ`, into the set of all atoms whose first projection is equal to the sandbox litter of `ξ`."}
{"full_name": "ConNF.NearLitterBehaviour.extraAtomMap_injective", "url": "ConNF/FOA/Behaviour/NearLitterBehaviour.html#ConNF.NearLitterBehaviour.extraAtomMap_injective", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterBehaviour.extraAtomMap_injective [ConNF.Params🔗<|PREMISE|>🔗 ] {ξ : ConNF.NearLitterBehaviour} {hξ : ConNF.NearLitterBehaviour.Lawful🔗<|PREMISE|>🔗 ξ} ⦃a : ConNF.Atom⦄ ⦃b : ConNF.Atom⦄ (ha : (ConNF.NearLitterBehaviour.extraAtomMap🔗<|PREMISE|>🔗 ξ hξ a).Dom) (hb : (ConNF.NearLitterBehaviour.extraAtomMap🔗<|PREMISE|>🔗 ξ hξ b).Dom) (h : (ConNF.NearLitterBehaviour.extraAtomMap🔗<|PREMISE|>🔗 ξ hξ a).get ha = (ConNF.NearLitterBehaviour.extraAtomMap🔗<|PREMISE|>🔗 ξ hξ b).get hb) :a = b", "code": "theorem extraAtomMap_injective {ξ : NearLitterBehaviour} {hξ : ξ.Lawful} ⦃a b : Atom⦄\n    (ha : (ξ.extraAtomMap hξ a).Dom) (hb : (ξ.extraAtomMap hξ b).Dom)\n    (h : (ξ.extraAtomMap hξ a).get ha = (ξ.extraAtomMap hξ b).get hb) : a = b := by\n  by_cases ha' : (ξ.atomMap a).Dom <;> by_cases hb' : (ξ.atomMap b).Dom\n  · rw [extraAtomMap_eq_of_dom a ha', extraAtomMap_eq_of_dom b hb'] at h\n    exact hξ.atomMap_injective ha' hb' h\n  · obtain (hb | ⟨Lb, hLb₁, hLb₂⟩ | hb) := hb\n    · cases hb' hb\n    · rw [extraAtomMap_eq_of_dom a ha', extraAtomMap_eq_of_innerAtoms b hb' Lb hLb₁ hLb₂] at h\n      cases innerAtomsEmbedding_ne_atomMap _ _ h\n    · rw [extraAtomMap_eq_of_dom a ha', extraAtomMap_eq_of_allOuterAtoms b hb' hb] at h\n      cases outerAtomsEmbedding_ne_atomMap _ _ h\n  · obtain (ha | ⟨La, hLa₁, hLa₂⟩ | ha) := ha\n    · cases ha' ha\n    · rw [extraAtomMap_eq_of_innerAtoms a ha' La hLa₁ hLa₂, extraAtomMap_eq_of_dom b hb'] at h\n      cases innerAtomsEmbedding_ne_atomMap _ _ h.symm\n    · rw [extraAtomMap_eq_of_allOuterAtoms a ha' ha, extraAtomMap_eq_of_dom b hb'] at h\n      cases outerAtomsEmbedding_ne_atomMap _ _ h.symm\n  · obtain (ha | ⟨La, hLa₁, hLa₂⟩ | ha) := ha\n    · cases ha' ha\n    · obtain (hb | ⟨Lb, hLb₁, hLb₂⟩ | hb) := hb\n      · cases hb' hb\n      · rw [extraAtomMap_eq_of_innerAtoms a ha' La hLa₁ hLa₂,\n          extraAtomMap_eq_of_innerAtoms b hb' Lb hLb₁ hLb₂] at h\n        cases innerAtomsEmbedding_disjoint _ _ h\n        cases (EmbeddingLike.apply_eq_iff_eq _).mp (Subtype.coe_injective h)\n        rfl\n      · rw [extraAtomMap_eq_of_innerAtoms a ha' La hLa₁ hLa₂,\n          extraAtomMap_eq_of_allOuterAtoms b hb' hb] at h\n        cases innerAtomsEmbedding_ne_outerAtomsEmbedding _ _ h\n    · obtain (hb | ⟨Lb, hLb₁, hLb₂⟩ | hb) := hb\n      · cases hb' hb\n      · rw [extraAtomMap_eq_of_allOuterAtoms a ha' ha,\n          extraAtomMap_eq_of_innerAtoms b hb' Lb hLb₁ hLb₂] at h\n        cases innerAtomsEmbedding_ne_outerAtomsEmbedding _ _ h.symm\n      · rw [extraAtomMap_eq_of_allOuterAtoms a ha' ha,\n          extraAtomMap_eq_of_allOuterAtoms b hb' hb] at h\n        cases (EmbeddingLike.apply_eq_iff_eq _).mp (Subtype.coe_injective h)\n        rfl\n", "additional_info": "", "used_premises": [1, 823, 1282, 1282, 1282, 1282], "def_path": "ConNF/FOA/Behaviour/NearLitterBehaviour.lean", "pos": [416, 455], "informalization": "The theorem `ConNF.NearLitterBehaviour.extraAtomMap_injective` states that the `extraAtomMap` function defined in the context of Constructive Ordinal Notation (ConNF) in Lean 4 is injective. This function is used to extend the domain of the near-litter-behaviour's atom map, ensuring that every `ConNF.Atom` has an image under the atom map."}
{"full_name": "ConNF.NearLitterBehaviour.mem_iff_of_mem_innerAtoms", "url": "ConNF/FOA/Behaviour/NearLitterBehaviour.html#ConNF.NearLitterBehaviour.mem_iff_of_mem_innerAtoms", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterBehaviour.mem_iff_of_mem_innerAtoms [ConNF.Params🔗<|PREMISE|>🔗 ] {ξ : ConNF.NearLitterBehaviour} (hξ : ConNF.NearLitterBehaviour.Lawful🔗<|PREMISE|>🔗 ξ) {a : ConNF.Atom} {L : ConNF.Litter} (hL : ConNF.NearLitterBehaviour.LitterPresent🔗<|PREMISE|>🔗 ξ L) (ha' : ¬ (ξ.atomMap a).Dom) (ha : a ∈ ConNF.NearLitterBehaviour.innerAtoms🔗<|PREMISE|>🔗 ξ L) {N : ConNF.NearLitter} (hN : (ξ.nearLitterMap N).Dom) :a ∈ N ↔ N.fst = L", "code": "theorem mem_iff_of_mem_innerAtoms {ξ : NearLitterBehaviour} (hξ : ξ.Lawful)\n    {a : Atom} {L : Litter} (hL : ξ.LitterPresent L)\n    (ha' : ¬(ξ.atomMap a).Dom) (ha : a ∈ ξ.innerAtoms L)\n    {N : NearLitter} (hN : (ξ.nearLitterMap N).Dom) :\n    a ∈ N ↔ N.1 = L := by\n  constructor\n  · intro h\n    obtain ⟨N', hN', rfl⟩ := hL\n    have := ha _ ⟨N', rfl⟩ _ ⟨⟨hN', rfl⟩, rfl⟩\n    by_contra! hNN'\n    exact ha' (hξ.dom_of_mem_inter _ hNN' hN hN' ⟨h, this.1⟩)\n  · rintro rfl\n    exact (ha _ ⟨N, rfl⟩ _ ⟨⟨hN, rfl⟩, rfl⟩).1\n", "additional_info": "", "used_premises": [1, 823, 838, 1265], "def_path": "ConNF/FOA/Behaviour/NearLitterBehaviour.lean", "pos": [456, 469], "informalization": "In the context of Constructive Ordinal Notation (ConNF) in Lean 4, the theorem `ConNF.NearLitterBehaviour.mem_iff_of_mem_innerAtoms` states that for a lawful near-litter-behaviour `ξ`, an atom `a` is a member of a near-litter `N` if and only if the first component of `N` is equal to the given litter `L`, provided that `a` is not in the domain of the atom map `ξ.atomMap`, `a` is in the inner atoms of `L`, and the near-litter map `ξ.nearLitterMap N` is defined."}
{"full_name": "ConNF.NearLitterBehaviour.extraAtomMap_mem_iff", "url": "ConNF/FOA/Behaviour/NearLitterBehaviour.html#ConNF.NearLitterBehaviour.extraAtomMap_mem_iff", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterBehaviour.extraAtomMap_mem_iff [ConNF.Params🔗<|PREMISE|>🔗 ] {ξ : ConNF.NearLitterBehaviour} {hξ : ConNF.NearLitterBehaviour.Lawful🔗<|PREMISE|>🔗 ξ} ⦃a : ConNF.Atom⦄ (ha : (ConNF.NearLitterBehaviour.extraAtomMap🔗<|PREMISE|>🔗 ξ hξ a).Dom) ⦃N : ConNF.NearLitter⦄ (hN : (ξ.nearLitterMap N).Dom) :(ConNF.NearLitterBehaviour.extraAtomMap🔗<|PREMISE|>🔗 ξ hξ a).get ha ∈ (ξ.nearLitterMap N).get hN ↔ a ∈ N", "code": "theorem extraAtomMap_mem_iff {ξ : NearLitterBehaviour} {hξ : ξ.Lawful}\n    ⦃a : Atom⦄ (ha : (ξ.extraAtomMap hξ a).Dom)\n    ⦃N : NearLitter⦄ (hN : (ξ.nearLitterMap N).Dom) :\n    (ξ.extraAtomMap hξ a).get ha ∈ (ξ.nearLitterMap N).get hN ↔ a ∈ N := by\n  by_cases ha' : (ξ.atomMap a).Dom\n  · rw [extraAtomMap_eq_of_dom a ha']\n    exact hξ.atom_mem_iff ha' hN\n  obtain (ha | ⟨L, hL₁, hL₂⟩ | ha) := ha\n  · cases ha' ha\n  · rw [extraAtomMap_eq_of_innerAtoms a ha' L hL₁ hL₂,\n      mem_iff_of_mem_innerAtoms hξ hL₁ ha' hL₂ hN]\n    obtain ⟨N', hN', rfl⟩ := hL₁\n    constructor\n    · intro h\n      by_contra hNN'\n      have ha := (innerAtomsEmbedding hξ N'.1 ⟨N', hN', rfl⟩ ⟨a, hL₂⟩).prop.1\n        _ ⟨N', rfl⟩ _ ⟨⟨hN', rfl⟩, rfl⟩\n      exact (innerAtomsEmbedding hξ N'.1 ⟨N', hN', rfl⟩ ⟨a, hL₂⟩).prop.2\n        (hξ.ran_of_mem_inter _ hNN' hN hN' ⟨h, ha⟩)\n    · intro h\n      exact (innerAtomsEmbedding hξ N'.1 ⟨N', hN', rfl⟩ ⟨a, hL₂⟩).prop.1\n        _ ⟨N, rfl⟩ _ ⟨⟨hN, h⟩, rfl⟩\n  · rw [extraAtomMap_eq_of_allOuterAtoms a ha' ha]\n    constructor\n    · intro h\n      have := bannedLitter_of_mem _ _ _ h\n      rw [(ξ.outerAtomsEmbedding ⟨a, ha⟩).prop] at this\n      cases ξ.sandboxLitter_not_banned this\n    · intro h\n      obtain ⟨_, ⟨L, rfl⟩, _, ⟨hL, rfl⟩, ha⟩ := ha\n      cases ha.2 ⟨_, ⟨N, rfl⟩, _, ⟨hN, rfl⟩, h⟩\n", "additional_info": "", "used_premises": [1, 823, 1282, 1282], "def_path": "ConNF/FOA/Behaviour/NearLitterBehaviour.lean", "pos": [470, 501], "informalization": "The theorem `ConNF.NearLitterBehaviour.extraAtomMap_mem_iff` states that for a lawful near-litter-behaviour `ξ`, an atom `a` belongs to a near-litter `N` if and only if the image of `a` under the extended atom map belongs to the image of `N` under the near-litter map."}
{"full_name": "ConNF.NearLitterBehaviour.extraAtomMap_dom_of_mem_symmDiff", "url": "ConNF/FOA/Behaviour/NearLitterBehaviour.html#ConNF.NearLitterBehaviour.extraAtomMap_dom_of_mem_symmDiff", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterBehaviour.extraAtomMap_dom_of_mem_symmDiff [ConNF.Params🔗<|PREMISE|>🔗 ] {ξ : ConNF.NearLitterBehaviour} (hξ : ConNF.NearLitterBehaviour.Lawful🔗<|PREMISE|>🔗 ξ) {N : ConNF.NearLitter} (hN : (ξ.nearLitterMap N).Dom) {a : ConNF.Atom} (ha : a ∈ symmDiff🔗<|PREMISE|>🔗 (ConNF.litterSet🔗<|PREMISE|>🔗 N.fst) ↑N) :(ConNF.NearLitterBehaviour.extraAtomMap🔗<|PREMISE|>🔗 ξ hξ a).Dom", "code": "theorem extraAtomMap_dom_of_mem_symmDiff {ξ : NearLitterBehaviour} (hξ : ξ.Lawful)\n    {N : NearLitter} (hN : (ξ.nearLitterMap N).Dom) {a : Atom} (ha : a ∈ litterSet N.1 ∆ N) :\n    (ξ.extraAtomMap hξ a).Dom := by\n  by_cases ha' : (ξ.atomMap a).Dom\n  · exact Or.inl ha'\n  by_cases ha'' : ∃ N', (ξ.nearLitterMap N').Dom ∧ a ∈ N'\n  · obtain ⟨N', hN', haN'⟩ := ha''\n    refine Or.inr (Or.inl ?_)\n    refine ⟨N'.1, ⟨N', hN', rfl⟩, ?_⟩\n    rw [mem_innerAtoms_iff _ ⟨N', hN', rfl⟩]\n    have : ∀ N'', (ξ.nearLitterMap N'').Dom ∧ N''.fst = N'.fst → a ∈ N''\n    · intro N'' hN''\n      by_contra haN''\n      exact ha' (hξ.dom_of_mem_symmDiff a hN''.2 hN''.1 hN' (Or.inr ⟨haN', haN''⟩))\n    refine ⟨?_, this⟩\n    intro h\n    obtain (ha | ha) := ha\n    · refine ha.2 (this N ⟨hN, ?_⟩)\n      rw [← ha.1, h]\n    · refine ha' (hξ.dom_of_mem_inter a ?_ hN hN' ⟨ha.1, haN'⟩)\n      rw [← h]\n      exact Ne.symm ha.2\n  · push_neg at ha''\n    refine Or.inr (Or.inr ?_)\n    simp only [mem_allOuterAtoms_iff]\n    refine ⟨?_, ha''⟩\n    obtain (ha | ha) := ha\n    · rw [ha.1]\n      exact ⟨N, hN, rfl⟩\n    · cases ha'' N hN ha.1\n", "additional_info": "", "used_premises": [1, 823, 62, 467, 1282], "def_path": "ConNF/FOA/Behaviour/NearLitterBehaviour.lean", "pos": [502, 532], "informalization": "The theorem `ConNF.NearLitterBehaviour.extraAtomMap_dom_of_mem_symmDiff` is a result in the context of Constructive Ordinal Notation (ConNF) in Lean 4. It states that if `ξ` is a lawful near-litter-behaviour, `N` is a near-litter, and `a` is an atom that belongs to the symmetric difference of the litter set of `N`'s first projection and `N` itself, then the domain of `ConNF.NearLitterBehaviour.extraAtomMap ξ hξ a` is nonempty, meaning `a` has an image under the extended atom map."}
{"full_name": "ConNF.NearLitterBehaviour.extraAtomMap_dom_of_mem_inter", "url": "ConNF/FOA/Behaviour/NearLitterBehaviour.html#ConNF.NearLitterBehaviour.extraAtomMap_dom_of_mem_inter", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterBehaviour.extraAtomMap_dom_of_mem_inter [ConNF.Params🔗<|PREMISE|>🔗 ] {ξ : ConNF.NearLitterBehaviour} (hξ : ConNF.NearLitterBehaviour.Lawful🔗<|PREMISE|>🔗 ξ) {N : ConNF.NearLitter} (hN : (ξ.nearLitterMap N).Dom) {L : ConNF.Litter} (h : N.fst ≠ L) {a : ConNF.Atom} (ha₁ : a ∈ N) (ha₂ : a.1 = L) :(ConNF.NearLitterBehaviour.extraAtomMap🔗<|PREMISE|>🔗 ξ hξ a).Dom", "code": "theorem extraAtomMap_dom_of_mem_inter {ξ : NearLitterBehaviour} (hξ : ξ.Lawful)\n    {N : NearLitter} (hN : (ξ.nearLitterMap N).Dom) {L : Litter}\n    (h : N.1 ≠ L) {a : Atom} (ha₁ : a ∈ N) (ha₂ : a.1 = L) :\n    (ξ.extraAtomMap hξ a).Dom := by\n  by_cases ha' : (ξ.atomMap a).Dom\n  · exact Or.inl ha'\n  refine Or.inr (Or.inl ⟨_, ⟨N, hN, rfl⟩, ?_⟩)\n  rw [mem_innerAtoms_iff _ ⟨N, hN, rfl⟩]\n  constructor\n  · rw [ha₂]\n    exact h.symm\n  · intro N' hN'\n    by_contra ha''\n    exact ha' (hξ.dom_of_mem_symmDiff a hN'.2 hN'.1 hN (Or.inr ⟨ha₁, ha''⟩))\n", "additional_info": "", "used_premises": [1, 823, 1282], "def_path": "ConNF/FOA/Behaviour/NearLitterBehaviour.lean", "pos": [533, 547], "informalization": "Given a lawful near-litter-behaviour $\\xi$, an extension of the near-litter-behaviour's atom map is defined to ensure that every `ConNF.Atom` has an image under the atom map. The theorem states that if an atom `a` belongs to a near-litter `N` with a different source litter `L`, and `a`'s source is equal to `L`, then the domain of the extended atom map is nonempty for `a`."}
{"full_name": "ConNF.NearLitterBehaviour.extraLitterMap'_subset", "url": "ConNF/FOA/Behaviour/NearLitterBehaviour.html#ConNF.NearLitterBehaviour.extraLitterMap'_subset", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterBehaviour.extraLitterMap'_subset [ConNF.Params🔗<|PREMISE|>🔗 ] {ξ : ConNF.NearLitterBehaviour} {hξ : ConNF.NearLitterBehaviour.Lawful🔗<|PREMISE|>🔗 ξ} {N₁ : ConNF.NearLitter} {N₂ : ConNF.NearLitter} (h : N₁.fst = N₂.fst) (hN₁ : (ξ.nearLitterMap N₁).Dom) (hN₂ : (ξ.nearLitterMap N₂).Dom) :ConNF.NearLitterBehaviour.extraLitterMap'🔗<|PREMISE|>🔗 ξ hξ N₁ hN₁ ⊆ ConNF.NearLitterBehaviour.extraLitterMap'🔗<|PREMISE|>🔗 ξ hξ N₂ hN₂", "code": "theorem extraLitterMap'_subset {ξ : NearLitterBehaviour} {hξ : ξ.Lawful}\n    {N₁ N₂ : NearLitter} (h : N₁.1 = N₂.1)\n    (hN₁ : (ξ.nearLitterMap N₁).Dom) (hN₂ : (ξ.nearLitterMap N₂).Dom) :\n    ξ.extraLitterMap' hξ N₁ hN₁ ⊆ ξ.extraLitterMap' hξ N₂ hN₂ := by\n  rintro a (⟨ha₁, ha₂⟩ | ⟨ha₁, ha₂⟩)\n  · simp only [mem_iUnion, mem_singleton_iff, not_exists] at ha₂\n    by_cases ha₃ : a ∈ (ξ.nearLitterMap N₂).get hN₂\n    · refine Or.inl ⟨ha₃, ?_⟩\n      simp only [mem_iUnion, mem_singleton_iff, not_exists]\n      rintro a ha rfl\n      simp only [SetLike.mem_coe, extraAtomMap_mem_iff] at ha₁ ha₃\n      obtain (ha | ha) := ha\n      · cases ha.2 ha₃\n      · refine ha₂ a (Or.inr ⟨ha₁, ?_⟩) rfl\n        rw [h]\n        exact ha.2\n    · obtain ⟨a, ha', rfl⟩ := hξ.ran_of_mem_symmDiff a h hN₁ hN₂ (Or.inl ⟨ha₁, ha₃⟩)\n      refine Or.inr ⟨?_, ha₃⟩\n      simp only [mem_iUnion, mem_singleton_iff]\n      simp only [SetLike.mem_coe, hξ.atom_mem_iff] at ha₁ ha₃\n      have ha₄ : a.1 = N₁.1\n      · by_contra ha₄\n        refine ha₂ a (Or.inr ⟨ha₁, ha₄⟩) ?_\n        rw [extraAtomMap_eq_of_dom]\n      refine ⟨a, Or.inl ⟨ha₄.trans h, ha₃⟩, ?_⟩\n      rw [extraAtomMap_eq_of_dom _ ha']\n  · simp only [mem_iUnion, mem_singleton_iff] at ha₁\n    obtain ⟨a, ha₁, rfl⟩ := ha₁\n    rw [SetLike.mem_coe, extraAtomMap_mem_iff] at ha₂\n    obtain (⟨ha₁, -⟩ | ⟨ha₁, -⟩) := ha₁\n    · by_cases ha₃ : a ∈ N₂\n      · refine Or.inl ⟨?_, ?_⟩\n        · rw [SetLike.mem_coe, extraAtomMap_mem_iff]\n          exact ha₃\n        · simp only [mem_iUnion, mem_singleton_iff, not_exists]\n          intro b hb hab\n          cases extraAtomMap_injective _ _ hab\n          obtain (hb | hb) := hb\n          · cases hb.2 ha₃\n          · rw [h] at ha₁\n            cases hb.2 ha₁\n      · refine Or.inr ⟨?_, ?_⟩\n        · simp only [mem_iUnion, mem_singleton_iff]\n          refine ⟨a, Or.inl ⟨?_, ha₃⟩, rfl⟩\n          rw [← h]\n          exact ha₁\n        · rw [SetLike.mem_coe, extraAtomMap_mem_iff]\n          exact ha₃\n    · cases ha₂ ha₁\n", "additional_info": "", "used_premises": [1, 823, 1293, 1293], "def_path": "ConNF/FOA/Behaviour/NearLitterBehaviour.lean", "pos": [554, 603], "informalization": "Given a lawful near-litter-behaviour `ξ`, two near-litters `N₁` and `N₂` with the same litter set, and proofs that both `N₁` and `N₂` are in the domain of the near-litter map of `ξ`, the extra litter map of `N₁` is a subset of the extra litter map of `N₂`."}
{"full_name": "ConNF.NearLitterBehaviour.extraLitterMap'", "url": "ConNF/FOA/Behaviour/NearLitterBehaviour.html#ConNF.NearLitterBehaviour.extraLitterMap'", "code_src": "con-nf", "ptype": "def", "header": "def ConNF.NearLitterBehaviour.extraLitterMap' [ConNF.Params🔗<|PREMISE|>🔗 ] (ξ : ConNF.NearLitterBehaviour) (hξ : ConNF.NearLitterBehaviour.Lawful🔗<|PREMISE|>🔗 ξ) (N : ConNF.NearLitter) (hN : (ξ.nearLitterMap N).Dom) :Set🔗<|PREMISE|>🔗 ConNF.Atom", "code": "def extraLitterMap' (ξ : NearLitterBehaviour) (hξ : ξ.Lawful)\n    (N : NearLitter) (hN : (ξ.nearLitterMap N).Dom) : Set Atom :=\n  (ξ.nearLitterMap N).get hN ∆\n    ⋃ (a : Atom) (ha : a ∈ litterSet N.1 ∆ N),\n      {(ξ.extraAtomMap hξ a).get (extraAtomMap_dom_of_mem_symmDiff hξ hN ha)}\n", "additional_info": "Equations\n* One or more equations did not get rendered due to their size.\n\n", "used_premises": [1, 823, 69], "def_path": "ConNF/FOA/Behaviour/NearLitterBehaviour.lean", "pos": [548, 553], "informalization": "The Lean 4 object `ConNF.NearLitterBehaviour.extraLitterMap'` is a function that, given a lawful near-litter-behaviour `ξ`, a near-litter `N`, and a proof that `N` is in the domain of the near-litter map of `ξ`, returns a set of atoms. This set is defined as the symmetric difference of the image of `N` under the near-litter map of `ξ` and the union of the images of the atoms in the symmetric difference of the litter set of `N` and `N` itself, under the extra-atom map of `ξ`."}
{"full_name": "ConNF.NearLitterBehaviour.extraLitterMap'_eq", "url": "ConNF/FOA/Behaviour/NearLitterBehaviour.html#ConNF.NearLitterBehaviour.extraLitterMap'_eq", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterBehaviour.extraLitterMap'_eq [ConNF.Params🔗<|PREMISE|>🔗 ] {ξ : ConNF.NearLitterBehaviour} {hξ : ConNF.NearLitterBehaviour.Lawful🔗<|PREMISE|>🔗 ξ} {N₁ : ConNF.NearLitter} {N₂ : ConNF.NearLitter} (h : N₁.fst = N₂.fst) (hN₁ : (ξ.nearLitterMap N₁).Dom) (hN₂ : (ξ.nearLitterMap N₂).Dom) :ConNF.NearLitterBehaviour.extraLitterMap'🔗<|PREMISE|>🔗 ξ hξ N₁ hN₁ = ConNF.NearLitterBehaviour.extraLitterMap'🔗<|PREMISE|>🔗 ξ hξ N₂ hN₂", "code": "theorem extraLitterMap'_eq {ξ : NearLitterBehaviour} {hξ : ξ.Lawful}\n    {N₁ N₂ : NearLitter} (h : N₁.1 = N₂.1)\n    (hN₁ : (ξ.nearLitterMap N₁).Dom) (hN₂ : (ξ.nearLitterMap N₂).Dom) :\n    ξ.extraLitterMap' hξ N₁ hN₁ = ξ.extraLitterMap' hξ N₂ hN₂ :=\n  subset_antisymm (extraLitterMap'_subset h hN₁ hN₂) (extraLitterMap'_subset h.symm hN₂ hN₁)\n", "additional_info": "", "used_premises": [1, 823, 1293, 1293], "def_path": "ConNF/FOA/Behaviour/NearLitterBehaviour.lean", "pos": [604, 609], "informalization": "Given a lawful near-litter-behaviour `ξ`, two near-litters `N₁` and `N₂` with the same litter set, and proofs that both `N₁` and `N₂` are in the domain of the near-litter map of `ξ`, the function `ConNF.NearLitterBehaviour.extraLitterMap'` returns the same set of atoms for both `N₁` and `N₂`."}
{"full_name": "ConNF.NearLitterBehaviour.extraLitterMap'_isNearLitter", "url": "ConNF/FOA/Behaviour/NearLitterBehaviour.html#ConNF.NearLitterBehaviour.extraLitterMap'_isNearLitter", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterBehaviour.extraLitterMap'_isNearLitter [ConNF.Params🔗<|PREMISE|>🔗 ] {ξ : ConNF.NearLitterBehaviour} (hξ : ConNF.NearLitterBehaviour.Lawful🔗<|PREMISE|>🔗 ξ) {N : ConNF.NearLitter} (hN : (ξ.nearLitterMap N).Dom) :ConNF.IsNearLitter🔗<|PREMISE|>🔗 ((ξ.nearLitterMap N).get hN).fst (ConNF.NearLitterBehaviour.extraLitterMap'🔗<|PREMISE|>🔗 ξ hξ N hN)", "code": "theorem extraLitterMap'_isNearLitter {ξ : NearLitterBehaviour} (hξ : ξ.Lawful)\n    {N : NearLitter} (hN : (ξ.nearLitterMap N).Dom) :\n    IsNearLitter ((ξ.nearLitterMap N).get hN).1 (ξ.extraLitterMap' hξ N hN) := by\n  rw [extraLitterMap']\n  refine ((ξ.nearLitterMap N).get hN).2.prop.trans ?_\n  erw [IsNear, symmDiff_symmDiff_cancel_left]\n  refine Small.bUnion N.2.prop ?_\n  intro a ha\n  exact small_singleton _\n", "additional_info": "", "used_premises": [1, 823, 466, 1293], "def_path": "ConNF/FOA/Behaviour/NearLitterBehaviour.lean", "pos": [610, 619], "informalization": "Given a lawful near-litter-behaviour `ξ`, a near-litter `N`, and a proof that `N` is in the domain of the near-litter map of `ξ`, the function `ConNF.NearLitterBehaviour.extraLitterMap' ξ hξ N hN` returns a set of atoms that is near the litter set of `N`."}
{"full_name": "ConNF.NearLitterBehaviour.extraLitterMap'_disjoint", "url": "ConNF/FOA/Behaviour/NearLitterBehaviour.html#ConNF.NearLitterBehaviour.extraLitterMap'_disjoint", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterBehaviour.extraLitterMap'_disjoint [ConNF.Params🔗<|PREMISE|>🔗 ] {ξ : ConNF.NearLitterBehaviour} {hξ : ConNF.NearLitterBehaviour.Lawful🔗<|PREMISE|>🔗 ξ} {N₁ : ConNF.NearLitter} {N₂ : ConNF.NearLitter} (h : N₁.fst ≠ N₂.fst) (hN₁ : (ξ.nearLitterMap N₁).Dom) (hN₂ : (ξ.nearLitterMap N₂).Dom) (a : ConNF.Atom) :a ∉ ConNF.NearLitterBehaviour.extraLitterMap'🔗<|PREMISE|>🔗 ξ hξ N₁ hN₁ ∩ ConNF.NearLitterBehaviour.extraLitterMap'🔗<|PREMISE|>🔗 ξ hξ N₂ hN₂", "code": "theorem extraLitterMap'_disjoint {ξ : NearLitterBehaviour} {hξ : ξ.Lawful}\n    {N₁ N₂ : NearLitter} (h : N₁.1 ≠ N₂.1)\n    (hN₁ : (ξ.nearLitterMap N₁).Dom) (hN₂ : (ξ.nearLitterMap N₂).Dom) (a : Atom) :\n    a ∉ ξ.extraLitterMap' hξ N₁ hN₁ ∩ ξ.extraLitterMap' hξ N₂ hN₂ := by\n  intro h\n  simp only [extraLitterMap', mem_inter_iff] at h\n  obtain ⟨ha₁ | ha₁, ha₂ | ha₂⟩ := h\n  · simp only [mem_diff, SetLike.mem_coe, mem_iUnion, mem_singleton_iff, not_exists] at ha₁ ha₂\n    obtain ⟨a, ha, rfl⟩ := hξ.ran_of_mem_inter a h hN₁ hN₂ ⟨ha₁.1, ha₂.1⟩\n    rw [hξ.atom_mem_iff] at ha₁ ha₂\n    by_cases ha₃ : a.1 = N₁.1\n    · refine ha₂.2 a (Or.inr ⟨ha₂.1, ?_⟩) ?_\n      · rw [mem_litterSet, ha₃]\n        exact h\n      · rw [extraAtomMap_eq_of_dom]\n    · refine ha₁.2 a (Or.inr ⟨ha₁.1, ha₃⟩) ?_\n      rw [extraAtomMap_eq_of_dom]\n  · simp only [mem_diff, SetLike.mem_coe, mem_iUnion, mem_singleton_iff, not_exists] at ha₁\n    simp only [mem_diff, mem_iUnion, mem_singleton_iff, SetLike.mem_coe] at ha₂\n    obtain ⟨⟨b, hb, rfl⟩, ha₂⟩ := ha₂\n    rw [extraAtomMap_mem_iff] at ha₁ ha₂\n    refine ha₁.2 b (Or.inr ⟨ha₁.1, ?_⟩) rfl\n    obtain (hb | hb) := hb\n    · rw [mem_litterSet, hb.1]\n      exact h.symm\n    · cases ha₂ hb.1\n  · simp only [mem_diff, SetLike.mem_coe, mem_iUnion, mem_singleton_iff, not_exists] at ha₂\n    simp only [mem_diff, mem_iUnion, mem_singleton_iff, SetLike.mem_coe] at ha₁\n    obtain ⟨⟨b, hb, rfl⟩, ha₁⟩ := ha₁\n    rw [extraAtomMap_mem_iff] at ha₁ ha₂\n    refine ha₂.2 b (Or.inr ⟨ha₂.1, ?_⟩) rfl\n    obtain (hb | hb) := hb\n    · rw [mem_litterSet, hb.1]\n      exact h\n    · cases ha₁ hb.1\n  · simp only [mem_diff, mem_iUnion, mem_singleton_iff, SetLike.mem_coe] at ha₁ ha₂\n    obtain ⟨⟨b, hb, rfl⟩, ha₁⟩ := ha₁\n    obtain ⟨⟨c, hc, hc'⟩, ha₂⟩ := ha₂\n    cases extraAtomMap_injective _ _ hc'\n    rw [extraAtomMap_mem_iff] at ha₁ ha₂\n    obtain (hb | hb) := hb\n    · obtain (hc | hc) := hc\n      · cases h (hb.1.symm.trans hc.1)\n      · cases ha₂ hc.1\n    · cases ha₁ hb.1\n", "additional_info": "", "used_premises": [1, 823, 1293, 1293], "def_path": "ConNF/FOA/Behaviour/NearLitterBehaviour.lean", "pos": [620, 665], "informalization": "The theorem `ConNF.NearLitterBehaviour.extraLitterMap'_disjoint` asserts that the intersection of the sets `ConNF.NearLitterBehaviour.extraLitterMap' ξ hξ N₁ hN₁` and `ConNF.NearLitterBehaviour.extraLitterMap' ξ hξ N₂ hN₂` is empty, i.e., the two sets are disjoint. This is true provided that `N₁` and `N₂` are different near-litters, and both `N₁` and `N₂` are in the domain of the near-litter map of `ξ`. The proof involves using properties of the near-litter-behaviour `ξ` and the fact that `N₁` and `N₂` are different."}
{"full_name": "ConNF.NearLitterBehaviour.mem_extraLitterMap_iff", "url": "ConNF/FOA/Behaviour/NearLitterBehaviour.html#ConNF.NearLitterBehaviour.mem_extraLitterMap_iff", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterBehaviour.mem_extraLitterMap_iff [ConNF.Params🔗<|PREMISE|>🔗 ] {ξ : ConNF.NearLitterBehaviour} {hξ : ConNF.NearLitterBehaviour.Lawful🔗<|PREMISE|>🔗 ξ} {N : ConNF.NearLitter} {hN : (ξ.nearLitterMap N).Dom} (a : ConNF.Atom) :a ∈ ConNF.NearLitterBehaviour.extraLitterMap🔗<|PREMISE|>🔗 ξ hξ N hN ↔ a ∈ ConNF.NearLitterBehaviour.extraLitterMap'🔗<|PREMISE|>🔗 ξ hξ N hN", "code": "theorem mem_extraLitterMap_iff {ξ : NearLitterBehaviour} {hξ : ξ.Lawful}\n    {N : NearLitter} {hN : (ξ.nearLitterMap N).Dom} (a : Atom) :\n    a ∈ ξ.extraLitterMap hξ N hN ↔ a ∈ ξ.extraLitterMap' hξ N hN :=\n  Iff.rfl\n", "additional_info": "", "used_premises": [1, 823, 1298, 1293], "def_path": "ConNF/FOA/Behaviour/NearLitterBehaviour.lean", "pos": [670, 674], "informalization": "The theorem `ConNF.NearLitterBehaviour.mem_extraLitterMap_iff` states that for a lawful near-litter-behaviour `ξ`, a near-litter `N`, and a proof that `N` is in the domain of the near-litter map of `ξ`, an atom `a` is in the extra-litter map of `ξ` applied to `N` if and only if `a` is in the extra-litter map' of `ξ` applied to `N`."}
{"full_name": "ConNF.NearLitterBehaviour.extraLitterMap", "url": "ConNF/FOA/Behaviour/NearLitterBehaviour.html#ConNF.NearLitterBehaviour.extraLitterMap", "code_src": "con-nf", "ptype": "def", "header": "def ConNF.NearLitterBehaviour.extraLitterMap [ConNF.Params🔗<|PREMISE|>🔗 ] (ξ : ConNF.NearLitterBehaviour) (hξ : ConNF.NearLitterBehaviour.Lawful🔗<|PREMISE|>🔗 ξ) (N : ConNF.NearLitter) (hN : (ξ.nearLitterMap N).Dom) :ConNF.NearLitter", "code": "def extraLitterMap (ξ : NearLitterBehaviour) (hξ : ξ.Lawful)\n    (N : NearLitter) (hN : (ξ.nearLitterMap N).Dom) : NearLitter :=\n  ⟨((ξ.nearLitterMap N).get hN).1, ξ.extraLitterMap' hξ N hN, extraLitterMap'_isNearLitter hξ hN⟩\n", "additional_info": "Equations\n* 🗟ConNF.NearLitterBehaviour.extraLitterMap🗟🔗../../.././ConNF/FOA/Behaviour/NearLitterBehaviour.html#ConNF.NearLitterBehaviour.extraLitterMap🔗  ξ hξ N hN 🗟=🗟🔗../../.././Init/Prelude.html#Eq🔗  { fst := ((ξ.nearLitterMap N).get hN).fst,\n snd := { val := 🗟ConNF.NearLitterBehaviour.extraLitterMap'🗟🔗../../.././ConNF/FOA/Behaviour/NearLitterBehaviour.html#ConNF.NearLitterBehaviour.extraLitterMap'🔗  ξ hξ N hN, property := ⋯ } }\n\n", "used_premises": [1, 823], "def_path": "ConNF/FOA/Behaviour/NearLitterBehaviour.lean", "pos": [666, 669], "informalization": "Function `ConNF.NearLitterBehaviour.extraLitterMap` takes a lawful near-litter-behaviour `ξ`, a near-litter `N`, and a proof that `N` is in the domain of the near-litter map of `ξ`. It returns a new near-litter, where the first component is the same as the first component of the image of `N` under the near-litter map of `ξ`, and the second component is obtained by applying `ConNF.NearLitterBehaviour.extraLitterMap'`."}
{"full_name": "ConNF.NearLitterBehaviour.extraLitterMap_eq", "url": "ConNF/FOA/Behaviour/NearLitterBehaviour.html#ConNF.NearLitterBehaviour.extraLitterMap_eq", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterBehaviour.extraLitterMap_eq [ConNF.Params🔗<|PREMISE|>🔗 ] {ξ : ConNF.NearLitterBehaviour} {hξ : ConNF.NearLitterBehaviour.Lawful🔗<|PREMISE|>🔗 ξ} {N₁ : ConNF.NearLitter} {N₂ : ConNF.NearLitter} (h : N₁.fst = N₂.fst) (hN₁ : (ξ.nearLitterMap N₁).Dom) (hN₂ : (ξ.nearLitterMap N₂).Dom) :ConNF.NearLitterBehaviour.extraLitterMap🔗<|PREMISE|>🔗 ξ hξ N₁ hN₁ = ConNF.NearLitterBehaviour.extraLitterMap🔗<|PREMISE|>🔗 ξ hξ N₂ hN₂", "code": "theorem extraLitterMap_eq {ξ : NearLitterBehaviour} {hξ : ξ.Lawful}\n    {N₁ N₂ : NearLitter} (h : N₁.1 = N₂.1)\n    (hN₁ : (ξ.nearLitterMap N₁).Dom) (hN₂ : (ξ.nearLitterMap N₂).Dom) :\n    ξ.extraLitterMap hξ N₁ hN₁ = ξ.extraLitterMap hξ N₂ hN₂ :=\n  NearLitter.ext (extraLitterMap'_eq h hN₁ hN₂)\n", "additional_info": "", "used_premises": [1, 823, 1298, 1298], "def_path": "ConNF/FOA/Behaviour/NearLitterBehaviour.lean", "pos": [675, 680], "informalization": "Given a lawful near-litter-behaviour `ξ`, two near-litters `N₁` and `N₂` with the same first component, and proofs that both `N₁` and `N₂` are in the domain of the near-litter map of `ξ`, the function `ConNF.NearLitterBehaviour.extraLitterMap` returns the same near-litter for both `N₁` and `N₂`."}
{"full_name": "ConNF.NearLitterBehaviour.extraAtomMap_mem_iff'", "url": "ConNF/FOA/Behaviour/NearLitterBehaviour.html#ConNF.NearLitterBehaviour.extraAtomMap_mem_iff'", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterBehaviour.extraAtomMap_mem_iff' [ConNF.Params🔗<|PREMISE|>🔗 ] {ξ : ConNF.NearLitterBehaviour} {hξ : ConNF.NearLitterBehaviour.Lawful🔗<|PREMISE|>🔗 ξ} {a : ConNF.Atom} (ha : (ConNF.NearLitterBehaviour.extraAtomMap🔗<|PREMISE|>🔗 ξ hξ a).Dom) {N : ConNF.NearLitter} (hN : (ξ.nearLitterMap N).Dom) :(ConNF.NearLitterBehaviour.extraAtomMap🔗<|PREMISE|>🔗 ξ hξ a).get ha ∈ ConNF.NearLitterBehaviour.extraLitterMap🔗<|PREMISE|>🔗 ξ hξ N hN ↔ a.1 = N.fst", "code": "theorem extraAtomMap_mem_iff' {ξ : NearLitterBehaviour} {hξ : Lawful ξ}\n    {a : Atom} (ha : (ξ.extraAtomMap hξ a).Dom)\n    {N : NearLitter} (hN : (ξ.nearLitterMap N).Dom) :\n    (ξ.extraAtomMap hξ a).get ha ∈ ξ.extraLitterMap hξ N hN ↔ a.1 = N.1 := by\n  rw [mem_extraLitterMap_iff, extraLitterMap']\n  constructor\n  · rintro (⟨ha₁, ha₂⟩ | ⟨ha₁, ha₂⟩)\n    · rw [SetLike.mem_coe, extraAtomMap_mem_iff] at ha₁\n      contrapose! ha₂\n      simp only [mem_iUnion, mem_singleton_iff]\n      exact ⟨a, Or.inr ⟨ha₁, ha₂⟩, rfl⟩\n    · rw [SetLike.mem_coe, extraAtomMap_mem_iff] at ha₂\n      simp only [mem_iUnion, mem_singleton_iff] at ha₁\n      obtain ⟨b, hb, hab⟩ := ha₁\n      cases extraAtomMap_injective _ _ hab\n      obtain (hb | hb) := hb\n      · exact hb.1\n      · cases ha₂ hb.1\n  · intro ha₁\n    by_cases ha₂ : a ∈ N\n    · refine Or.inl ⟨?_, ?_⟩\n      · rw [SetLike.mem_coe, extraAtomMap_mem_iff]\n        exact ha₂\n      · simp only [mem_iUnion, mem_singleton_iff, not_exists]\n        intro b hb hab\n        cases extraAtomMap_injective _ _ hab\n        obtain (hb | hb) := hb\n        · cases hb.2 ha₂\n        · cases hb.2 ha₁\n    · refine Or.inr ⟨?_, ?_⟩\n      · simp only [mem_iUnion, mem_singleton_iff]\n        exact ⟨a, Or.inl ⟨ha₁, ha₂⟩, rfl⟩\n      · rw [SetLike.mem_coe, extraAtomMap_mem_iff]\n        exact ha₂\n", "additional_info": "", "used_premises": [1, 823, 1282, 1282, 1298], "def_path": "ConNF/FOA/Behaviour/NearLitterBehaviour.lean", "pos": [713, 747], "informalization": "Given a lawful near-litter-behaviour `ξ`, `ConNF.NearLitterBehaviour.extraAtomMap_mem_iff'` states that for any atom `a` in the domain of the extended atom map, and any near-litter `N` in the domain of the near-litter map, `a` is a member of the extended near-litter map of `N` if and only if the first component of `a` is equal to the first component of the near-litter `N`."}
{"full_name": "ConNF.NearLitterBehaviour.extraAtomMap_ran_of_mem_symmDiff", "url": "ConNF/FOA/Behaviour/NearLitterBehaviour.html#ConNF.NearLitterBehaviour.extraAtomMap_ran_of_mem_symmDiff", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterBehaviour.extraAtomMap_ran_of_mem_symmDiff [ConNF.Params🔗<|PREMISE|>🔗 ] {ξ : ConNF.NearLitterBehaviour} (hξ : ConNF.NearLitterBehaviour.Lawful🔗<|PREMISE|>🔗 ξ) {N₁ : ConNF.NearLitter} {N₂ : ConNF.NearLitter} (hN₁ : (ξ.nearLitterMap N₁).Dom) (hN₂ : (ξ.nearLitterMap N₂).Dom) (hN : N₁.fst = (ConNF.Litter.toNearLitter🔗<|PREMISE|>🔗 N₂.fst).fst) {a : ConNF.Atom} (ha : a ∈ symmDiff🔗<|PREMISE|>🔗 (↑((ξ.nearLitterMap N₁).get hN₁)) (ConNF.NearLitterBehaviour.extraLitterMap'🔗<|PREMISE|>🔗 ξ hξ N₂ hN₂)) :a ∈ PFun.ran🔗<|PREMISE|>🔗 (ConNF.NearLitterBehaviour.extraAtomMap🔗<|PREMISE|>🔗 ξ hξ)", "code": "theorem extraAtomMap_ran_of_mem_symmDiff {ξ : NearLitterBehaviour} (hξ : ξ.Lawful)\n    {N₁ N₂ : NearLitter} (hN₁ : (ξ.nearLitterMap N₁).Dom) (hN₂ : (ξ.nearLitterMap N₂).Dom)\n    (hN : N₁.fst = (Litter.toNearLitter N₂.1).fst)\n    {a : Atom} (ha : a ∈ ((ξ.nearLitterMap N₁).get hN₁ : Set Atom) ∆ ξ.extraLitterMap' hξ N₂ hN₂) :\n    a ∈ (ξ.extraAtomMap hξ).ran := by\n  obtain (⟨ha₁, ha₂⟩ | ⟨ha₁, ha₂⟩) := ha\n  · contrapose! ha₂\n    have ha' : a ∈ (ξ.nearLitterMap N₂).get hN₂\n    · by_contra ha'\n      obtain ⟨b, hb, rfl⟩ := hξ.ran_of_mem_symmDiff a (by exact hN) hN₁ hN₂ (Or.inl ⟨ha₁, ha'⟩)\n      refine ha₂ ⟨b, Or.inl hb, ?_⟩\n      rw [extraAtomMap_eq_of_dom]\n    refine Or.inl ⟨ha', ?_⟩\n    simp only [mem_iUnion, mem_singleton_iff, not_exists]\n    rintro b hb rfl\n    exact ha₂ ⟨b, _, rfl⟩\n  · obtain (⟨ha₁, ha₃⟩ | ⟨ha₁, ha₃⟩) := ha₁\n    · simp only [mem_iUnion, mem_singleton_iff, not_exists] at ha₃\n      obtain ⟨b, hb, rfl⟩ := hξ.ran_of_mem_symmDiff a (by exact hN) hN₁ hN₂ (Or.inr ⟨ha₁, ha₂⟩)\n      refine ⟨b, Or.inl hb, ?_⟩\n      rw [extraAtomMap_eq_of_dom]\n    · simp only [mem_iUnion, mem_singleton_iff] at ha₁\n      obtain ⟨b, hb, rfl⟩ := ha₁\n      exact ⟨_, _, rfl⟩\n", "additional_info": "", "used_premises": [1, 823, 483, 62, 1293, 824, 1282], "def_path": "ConNF/FOA/Behaviour/NearLitterBehaviour.lean", "pos": [748, 772], "informalization": "The Lean 4 object `ConNF.NearLitterBehaviour.extraAtomMap_ran_of_mem_symmDiff` is a theorem in the context of Constructive Ordinal Notation (ConNF) in Lean 4. It states that if `ξ` is a lawful near-litter-behaviour, `N₁` and `N₂` are near-litters, `a` is an atom, and `a` is in the symmetric difference of the image of `N₁` under the near-litter map of `ξ` and the union of the images of the atoms in the symmetric difference of the litter set of `N₂` and `N₂` itself, under the extra-atom map of `ξ`, then `a` is in the range of the extra-atom map of `ξ`."}
{"full_name": "ConNF.NearLitterBehaviour.extraAtomMap_ran_of_mem_inter", "url": "ConNF/FOA/Behaviour/NearLitterBehaviour.html#ConNF.NearLitterBehaviour.extraAtomMap_ran_of_mem_inter", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterBehaviour.extraAtomMap_ran_of_mem_inter [ConNF.Params🔗<|PREMISE|>🔗 ] {ξ : ConNF.NearLitterBehaviour} (hξ : ConNF.NearLitterBehaviour.Lawful🔗<|PREMISE|>🔗 ξ) {N₁ : ConNF.NearLitter} {N₂ : ConNF.NearLitter} (hN₁ : (ξ.nearLitterMap N₁).Dom) (hN₂ : (ξ.nearLitterMap N₂).Dom) (hN : N₁.fst ≠ (ConNF.Litter.toNearLitter🔗<|PREMISE|>🔗 N₂.fst).fst) {a : ConNF.Atom} (ha : a ∈ ↑((ξ.nearLitterMap N₁).get hN₁) ∩ ConNF.NearLitterBehaviour.extraLitterMap'🔗<|PREMISE|>🔗 ξ hξ N₂ hN₂) :a ∈ PFun.ran🔗<|PREMISE|>🔗 (ConNF.NearLitterBehaviour.extraAtomMap🔗<|PREMISE|>🔗 ξ hξ)", "code": "theorem extraAtomMap_ran_of_mem_inter {ξ : NearLitterBehaviour} (hξ : ξ.Lawful)\n    {N₁ N₂ : NearLitter} (hN₁ : (ξ.nearLitterMap N₁).Dom) (hN₂ : (ξ.nearLitterMap N₂).Dom)\n    (hN : N₁.fst ≠ (Litter.toNearLitter N₂.1).fst)\n    {a : Atom} (ha : a ∈ ((ξ.nearLitterMap N₁).get hN₁ : Set Atom) ∩ ξ.extraLitterMap' hξ N₂ hN₂) :\n    a ∈ (ξ.extraAtomMap hξ).ran := by\n  obtain ⟨ha₁, ⟨ha₂, ha₃⟩ | ⟨ha₂, ha₃⟩⟩ := ha\n  · simp only [mem_iUnion, mem_singleton_iff, not_exists] at ha₃\n    obtain ⟨b, hb, rfl⟩ := hξ.ran_of_mem_inter a (by exact hN) hN₁ hN₂ ⟨ha₁, ha₂⟩\n    refine ⟨b, Or.inl hb, ?_⟩\n    rw [extraAtomMap_eq_of_dom]\n  · simp only [mem_iUnion, mem_singleton_iff] at ha₂\n    obtain ⟨b, hb, rfl⟩ := ha₂\n    rw [SetLike.mem_coe, extraAtomMap_mem_iff] at ha₁ ha₃\n    exact ⟨b, _, rfl⟩\n", "additional_info": "", "used_premises": [1, 823, 483, 1293, 824, 1282], "def_path": "ConNF/FOA/Behaviour/NearLitterBehaviour.lean", "pos": [773, 787], "informalization": "Given a lawful near-litter-behaviour $\\xi$, two near-litters $N_1$ and $N_2$, with $N_1$ not equal to $N_2$ as litters, and an atom $a$ that is in the intersection of the image of $N_1$ under the near-litter map of $\\xi$ and the extra-litter map of $\\xi$ applied to $N_2$, then $a$ is in the range of the extra-atom map of $\\xi$."}
{"full_name": "ConNF.NearLitterBehaviour.withLitters_lawful", "url": "ConNF/FOA/Behaviour/NearLitterBehaviour.html#ConNF.NearLitterBehaviour.withLitters_lawful", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterBehaviour.withLitters_lawful [ConNF.Params🔗<|PREMISE|>🔗 ] (ξ : ConNF.NearLitterBehaviour) (hξ : ConNF.NearLitterBehaviour.Lawful🔗<|PREMISE|>🔗 ξ) :ConNF.NearLitterBehaviour.Lawful🔗<|PREMISE|>🔗 (ConNF.NearLitterBehaviour.withLitters🔗<|PREMISE|>🔗 ξ hξ)", "code": "theorem withLitters_lawful (ξ : NearLitterBehaviour) (hξ : ξ.Lawful) :\n    (ξ.withLitters hξ).Lawful := by\n  constructor\n  case atomMap_injective => exact extraAtomMap_injective\n  case atom_mem_iff =>\n    rintro a ha N (hN | ⟨⟨_⟩, ⟨N, hN, hN'⟩⟩)\n    · rw [withLitters_nearLitterMap_of_dom hξ hN]\n      exact extraAtomMap_mem_iff ha hN\n    · cases hN'\n      rw [withLitters_nearLitterMap_fst hξ hN]\n      exact extraAtomMap_mem_iff' ha hN\n  case dom_of_mem_symmDiff =>\n    rintro a N₁ N₂ h (hN₁ | ⟨⟨_⟩, ⟨N₁, -, hN₁'⟩⟩) (hN₂ | ⟨⟨_⟩, ⟨N₂, -, hN₂'⟩⟩) ha\n    · exact Or.inl (hξ.dom_of_mem_symmDiff a h hN₁ hN₂ ha)\n    · cases hN₂'\n      refine extraAtomMap_dom_of_mem_symmDiff hξ hN₁ ?_\n      rw [h]\n      rw [symmDiff_comm] at ha\n      exact ha\n    · cases hN₁'\n      refine extraAtomMap_dom_of_mem_symmDiff hξ hN₂ ?_\n      rw [← h]\n      exact ha\n    · cases hN₁'\n      cases hN₂'\n      rw [Litter.toNearLitter_fst] at h\n      obtain (ha | ha) := ha\n      · rw [h] at ha\n        cases ha.2 ha.1\n      · rw [h] at ha\n        cases ha.2 ha.1\n  case dom_of_mem_inter =>\n    rintro a N₁ N₂ h (hN₁ | ⟨⟨_⟩, ⟨N₁, -, hN₁'⟩⟩) (hN₂ | ⟨⟨_⟩, ⟨N₂, -, hN₂'⟩⟩) ha\n    · exact Or.inl (hξ.dom_of_mem_inter a h hN₁ hN₂ ha)\n    · cases hN₂'\n      exact extraAtomMap_dom_of_mem_inter hξ hN₁ h ha.1 ha.2\n    · cases hN₁'\n      exact extraAtomMap_dom_of_mem_inter hξ hN₂ h.symm ha.2 ha.1\n    · cases hN₁'\n      cases hN₂'\n      simp only [Litter.toNearLitter_fst, ne_eq] at h\n      cases h (ha.1.symm.trans ha.2)\n  case ran_of_mem_symmDiff =>\n    rintro a N₁ N₂ h (hN₁ | ⟨⟨_⟩, ⟨N₁, hN₁, hN₁'⟩⟩) (hN₂ | ⟨⟨_⟩, ⟨N₂, hN₂, hN₂'⟩⟩) ha\n    · rw [withLitters_nearLitterMap_of_dom hξ hN₁, withLitters_nearLitterMap_of_dom hξ hN₂] at ha\n      obtain ⟨b, hb, rfl⟩ := hξ.ran_of_mem_symmDiff a h hN₁ hN₂ ha\n      refine ⟨b, Or.inl hb, ?_⟩\n      simp only [withLitters, extraAtomMap_eq_of_dom _ hb]\n    · cases hN₂'\n      refine extraAtomMap_ran_of_mem_symmDiff hξ hN₁ hN₂ h ?_\n      rw [withLitters_nearLitterMap_of_dom hξ hN₁,\n        withLitters_nearLitterMap_fst hξ hN₂] at ha\n      exact ha\n    · cases hN₁'\n      refine extraAtomMap_ran_of_mem_symmDiff hξ hN₂ hN₁ h.symm ?_\n      rw [withLitters_nearLitterMap_of_dom hξ hN₂,\n        withLitters_nearLitterMap_fst hξ hN₁, symmDiff_comm] at ha\n      exact ha\n    · cases hN₁'\n      cases hN₂'\n      rw [Litter.toNearLitter_fst] at h\n      simp only [h, Litter.toNearLitter_fst, symmDiff_self, bot_eq_empty, mem_empty_iff_false] at ha\n  case ran_of_mem_inter =>\n    rintro a N₁ N₂ h (hN₁ | ⟨⟨_⟩, ⟨N₁, hN₁, hN₁'⟩⟩) (hN₂ | ⟨⟨_⟩, ⟨N₂, hN₂, hN₂'⟩⟩) ha\n    · rw [withLitters_nearLitterMap_of_dom hξ hN₁, withLitters_nearLitterMap_of_dom hξ hN₂] at ha\n      obtain ⟨b, hb, rfl⟩ := hξ.ran_of_mem_inter a h hN₁ hN₂ ha\n      refine ⟨b, Or.inl hb, ?_⟩\n      simp only [withLitters, extraAtomMap_eq_of_dom _ hb]\n    · cases hN₂'\n      refine extraAtomMap_ran_of_mem_inter hξ hN₁ hN₂ h ?_\n      rw [withLitters_nearLitterMap_of_dom hξ hN₁,\n        withLitters_nearLitterMap_fst hξ hN₂] at ha\n      exact ha\n    · cases hN₁'\n      refine extraAtomMap_ran_of_mem_inter hξ hN₂ hN₁ h.symm ?_\n      rw [withLitters_nearLitterMap_of_dom hξ hN₂,\n        withLitters_nearLitterMap_fst hξ hN₁, inter_comm] at ha\n      exact ha\n    · cases hN₁'\n      cases hN₂'\n      simp only [mem_inter_iff, SetLike.mem_coe,\n        withLitters_nearLitterMap_fst hξ hN₁, withLitters_nearLitterMap_fst hξ hN₂,\n        mem_extraLitterMap_iff] at ha\n      cases extraLitterMap'_disjoint (by exact h) hN₁ hN₂ a ha\n", "additional_info": "", "used_premises": [1, 823, 823, 832], "def_path": "ConNF/FOA/Behaviour/NearLitterBehaviour.lean", "pos": [788, 872], "informalization": "The theorem `ConNF.NearLitterBehaviour.withLitters_lawful` states that given a lawful near-litter-behaviour `ξ`, the modified near-litter-behaviour `ConNF.NearLitterBehaviour.withLitters ξ hξ` is also lawful."}
{"full_name": "ConNF.StructApprox.ihAction_atomMap", "url": "ConNF/FOA/Complete/LitterCompletion.html#ConNF.StructApprox.ihAction_atomMap", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.StructApprox.ihAction_atomMap [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.FOAAssumptions] {β : ConNF.Λ} {c : ConNF.Address🔗<|PREMISE|>🔗 ↑β} {H : ConNF.HypAction🔗<|PREMISE|>🔗 c} {B : ConNF.ExtendedIndex🔗<|PREMISE|>🔗 ↑β} {a : ConNF.Atom} :(ConNF.StructApprox.ihAction🔗<|PREMISE|>🔗 H B).atomMap a = { Dom := { path := B, value := Sum.inl🔗<|PREMISE|>🔗 a } < c, get := fun (h : { path := B, value := Sum.inl🔗<|PREMISE|>🔗 a } < c) => H.atomImage B a h }", "code": "theorem ihAction_atomMap {β : Λ} {c : Address β} {H : HypAction c}\n    {B : ExtendedIndex β} {a : Atom} : (ihAction H B).atomMap a = ⟨_, fun h => H.atomImage B a h⟩ :=\n  rfl\n", "additional_info": "", "used_premises": [1, 60, 1305, 61, 1306, 67, 67], "def_path": "ConNF/FOA/Complete/LitterCompletion.lean", "pos": [53, 56], "informalization": "In the context of Constructive Ordinal Notation (ConNF), the function `ConNF.StructApprox.ihAction_atomMap` defines the atom map of a `β`-structural action as a product that assigns a near-litter action to each `β`-extended index, given an inductive hypothesis. It injects an element of type `α` into the left side of the sum type `α ⊕ β`."}
{"full_name": "ConNF.HypAction", "url": "ConNF/FOA/Complete/HypAction.html#ConNF.HypAction", "code_src": "con-nf", "ptype": "structure", "header": "structure ConNF.HypAction [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.FOAAssumptions] {β : ConNF.Λ} (c : ConNF.Address🔗<|PREMISE|>🔗 ↑β) :Type u\n | atomImage : (A : ConNF.ExtendedIndex🔗<|PREMISE|>🔗  ↑β) → (a : ConNF.Atom) → { path := A, value := Sum.inl🔗<|PREMISE|>🔗  a } <  c → ConNF.Atom\n | nearLitterImage : (A : ConNF.ExtendedIndex🔗<|PREMISE|>🔗  ↑β) → (N : ConNF.NearLitter) → { path := A, value := Sum.inr🔗<|PREMISE|>🔗  N } <  c → ConNF.NearLitter", "code": "structure HypAction {β : Λ} (c : Address β) where\n  atomImage : ∀ A a, ⟨A, inl a⟩ < c → Atom\n  nearLitterImage : ∀ A N, ⟨A, inr N⟩ < c → NearLitter\n", "additional_info": "The inductive hypothesis used to construct the induced action of an approximation in the\nfreedom of action theorem.\n", "used_premises": [1, 60, 61, 67, 61, 65], "def_path": "ConNF/FOA/Complete/HypAction.lean", "pos": [18, 21], "informalization": "The inductive hypothesis used to construct the induced action of an approximation in the freedom of action theorem."}
{"full_name": "ConNF.StructApprox.ihAction", "url": "ConNF/FOA/Complete/LitterCompletion.html#ConNF.StructApprox.ihAction", "code_src": "con-nf", "ptype": "def", "header": "def ConNF.StructApprox.ihAction [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.FOAAssumptions] {β : ConNF.Λ} {c : ConNF.Address🔗<|PREMISE|>🔗 ↑β} (H : ConNF.HypAction🔗<|PREMISE|>🔗 c) :ConNF.StructAction🔗<|PREMISE|>🔗 ↑β", "code": "def ihAction {β : Λ} {c : Address β} (H : HypAction c) : StructAction β := fun B =>\n  { atomMap := fun a => ⟨_, fun h => H.atomImage B a h⟩\n    litterMap := fun L => ⟨_, fun h => H.nearLitterImage B L.toNearLitter h⟩\n    atomMap_dom_small := by\n      simp only [PFun.dom_mk]\n      have := transClosure_small (small_singleton c)\n      simp only [transClosure, mem_singleton_iff, exists_prop, exists_eq_left] at this\n      refine' Small.image_subset (fun a => ⟨B, inl a⟩) _ this _\n      · intro a b h\n        simpa [Address.mk.injEq, inl.injEq, true_and] using h\n      · rintro _ ⟨a, h, rfl⟩\n        exact h\n    litterMap_dom_small := by\n      simp only [PFun.dom_mk]\n      have := transClosure_small (small_singleton c)\n      simp only [transClosure, mem_singleton_iff, exists_prop, exists_eq_left] at this\n      refine' Small.image_subset (fun L => ⟨B, inr L.toNearLitter⟩) _ this _\n      · intro L₁ L₂ h\n        simpa only [Address.mk.injEq, inr.injEq, Litter.toNearLitter_injective.eq_iff,\n          true_and] using h\n      · rintro _ ⟨a, h, rfl⟩\n        exact h }\n", "additional_info": "The structural action associated to a given inductive hypothesis.\nEquations\n* One or more equations did not get rendered due to their size.\n\n", "used_premises": [1, 60, 1305, 808], "def_path": "ConNF/FOA/Complete/LitterCompletion.lean", "pos": [29, 51], "informalization": "Function `ConNF.StructApprox.ihAction` defines a `β`-structural action as a product that assigns a near-litter action to each `β`-extended index, given an inductive hypothesis in the context of Constructive Ordinal Notation (ConNF)."}
{"full_name": "ConNF.StructApprox.ihAction_litterMap", "url": "ConNF/FOA/Complete/LitterCompletion.html#ConNF.StructApprox.ihAction_litterMap", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.StructApprox.ihAction_litterMap [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.FOAAssumptions] {β : ConNF.Λ} {c : ConNF.Address🔗<|PREMISE|>🔗 ↑β} {H : ConNF.HypAction🔗<|PREMISE|>🔗 c} {B : ConNF.ExtendedIndex🔗<|PREMISE|>🔗 ↑β} {L : ConNF.Litter} :(ConNF.StructApprox.ihAction🔗<|PREMISE|>🔗 H B).litterMap L = { Dom := { path := B, value := Sum.inr🔗<|PREMISE|>🔗 (ConNF.Litter.toNearLitter🔗<|PREMISE|>🔗 L) } < c, get := fun (h : { path := B, value := Sum.inr🔗<|PREMISE|>🔗 (ConNF.Litter.toNearLitter🔗<|PREMISE|>🔗 L) } < c) => H.nearLitterImage B (ConNF.Litter.toNearLitter🔗<|PREMISE|>🔗 L) h }", "code": "theorem ihAction_litterMap {β : Λ} {c : Address β} {H : HypAction c}\n    {B : ExtendedIndex β} {L : Litter} :\n    (ihAction H B).litterMap L = ⟨_, fun h => H.nearLitterImage B L.toNearLitter h⟩ :=\n  rfl\n", "additional_info": "", "used_premises": [1, 60, 1305, 61, 1306, 65, 483, 65, 483, 483], "def_path": "ConNF/FOA/Complete/LitterCompletion.lean", "pos": [58, 62], "informalization": "The theorem `ConNF.StructApprox.ihAction_litterMap` is a part of the Constructive Ordinal Notation (ConNF) project in Lean 4. It defines the litter map of a `β`-structural action as a product that assigns a near-litter action to each `β`-extended index, given an inductive hypothesis in the context of ConNF."}
{"full_name": "ConNF.StructAction.allowable_exactlyApproximates", "url": "ConNF/FOA/Complete/LitterCompletion.html#ConNF.StructAction.allowable_exactlyApproximates", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.StructAction.allowable_exactlyApproximates [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.FOAAssumptions] {β : ConNF.Λ} [ConNF.LeLevel🔗<|PREMISE|>🔗 ↑β] [ConNF.StructApprox.FreedomOfActionHypothesis🔗<|PREMISE|>🔗 β] {γ : ConNF.Λ} [ConNF.LtLevel🔗<|PREMISE|>🔗 ↑γ] (φ : ConNF.StructAction🔗<|PREMISE|>🔗 ↑γ) (h : γ < β) (h₁ : ConNF.StructAction.Lawful🔗<|PREMISE|>🔗 φ) (h₂ : ConNF.StructAction.MapFlexible🔗<|PREMISE|>🔗 φ) :ConNF.StructApprox.ExactlyApproximates🔗<|PREMISE|>🔗 (ConNF.StructAction.rc🔗<|PREMISE|>🔗 φ h₁) (ConNF.Allowable.toStructPerm (ConNF.StructAction.allowable🔗<|PREMISE|>🔗 φ h h₁ h₂))", "code": "theorem ConNF.StructAction.allowable_exactlyApproximates {γ : Λ} [LtLevel γ]\n    (φ : StructAction γ) (h : γ < β) (h₁ : φ.Lawful) (h₂ : φ.MapFlexible) :\n    (φ.rc h₁).ExactlyApproximates (Allowable.toStructPerm (φ.allowable h h₁ h₂)) :=\n  (freedomOfAction_of_lt _ h _ (StructAction.rc_free _ h₁ h₂)).choose_spec\n", "additional_info": "", "used_premises": [1, 402, 779, 98, 808, 809, 814, 803, 810, 1309], "def_path": "ConNF/FOA/Complete/LitterCompletion.lean", "pos": [69, 73], "informalization": "In the context of Constructive Ordinal Notation (ConNF), the theorem `ConNF.StructAction.allowable_exactlyApproximates` states that given a `γ`-structural action `φ`, a proof `h` that `γ < β`, a proof `h₁` that `φ` is lawful, and a proof `h₂` that `φ` maps flexible litters to flexible litters, the refined and completed `γ`-structural approximation `ConNF.StructAction.rc φ h₁` exactly approximates the `γ`-allowable permutation `ConNF.Allowable.toStructPerm (ConNF.StructAction.allowable φ h h₁ h₂)`."}
{"full_name": "ConNF.StructAction.allowable", "url": "ConNF/FOA/Complete/LitterCompletion.html#ConNF.StructAction.allowable", "code_src": "con-nf", "ptype": "noncomputable def", "header": "noncomputable def ConNF.StructAction.allowable [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.FOAAssumptions] {β : ConNF.Λ} [ConNF.LeLevel🔗<|PREMISE|>🔗 ↑β] [ConNF.StructApprox.FreedomOfActionHypothesis🔗<|PREMISE|>🔗 β] {γ : ConNF.Λ} [ConNF.LtLevel🔗<|PREMISE|>🔗 ↑γ] (φ : ConNF.StructAction🔗<|PREMISE|>🔗 ↑γ) (h : γ < β) (h₁ : ConNF.StructAction.Lawful🔗<|PREMISE|>🔗 φ) (h₂ : ConNF.StructAction.MapFlexible🔗<|PREMISE|>🔗 φ) :ConNF.Allowable ↑γ", "code": "noncomputable def ConNF.StructAction.allowable {γ : Λ} [LtLevel γ]\n    (φ : StructAction γ) (h : γ < β) (h₁ : φ.Lawful) (h₂ : φ.MapFlexible) : Allowable γ :=\n  (freedomOfAction_of_lt _ h _ (StructAction.rc_free _ h₁ h₂)).choose\n", "additional_info": "Equations\n* 🗟ConNF.StructAction.allowable🗟🔗../../.././ConNF/FOA/Complete/LitterCompletion.html#ConNF.StructAction.allowable🔗  φ h h₁ h₂ 🗟=🗟🔗../../.././Init/Prelude.html#Eq🔗  🗟Exists.choose🗟🔗../../.././Init/Classical.html#Exists.choose🔗  ⋯\n\n", "used_premises": [1, 402, 779, 98, 808, 809, 814], "def_path": "ConNF/FOA/Complete/LitterCompletion.lean", "pos": [65, 68], "informalization": "Function `ConNF.StructAction.allowable` is a noncomputable function in the context of Constructive Ordinal Notation (ConNF) that, given a `γ`-structural action `φ`, a proof `h` that `γ < β`, a proof `h₁` that `φ` is lawful, and a proof `h₂` that `φ` maps flexible litters to flexible litters, returns a `γ`-allowable permutation."}
{"full_name": "ConNF.StructAction.hypothesisedAllowable_exactlyApproximates", "url": "ConNF/FOA/Complete/LitterCompletion.html#ConNF.StructAction.hypothesisedAllowable_exactlyApproximates", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.StructAction.hypothesisedAllowable_exactlyApproximates [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.FOAAssumptions] {β : ConNF.Λ} [ConNF.LeLevel🔗<|PREMISE|>🔗 ↑β] [ConNF.StructApprox.FreedomOfActionHypothesis🔗<|PREMISE|>🔗 β] (φ : ConNF.StructAction🔗<|PREMISE|>🔗 ↑β) {A : ConNF.ExtendedIndex🔗<|PREMISE|>🔗 ↑β} (h : ConNF.InflexibleCoePath🔗<|PREMISE|>🔗 A) (h₁ : ConNF.StructAction.Lawful🔗<|PREMISE|>🔗 (ConNF.Tree.comp🔗<|PREMISE|>🔗 (Quiver.Path.cons🔗<|PREMISE|>🔗 h.B ⋯) φ)) (h₂ : ConNF.StructAction.MapFlexible🔗<|PREMISE|>🔗 (ConNF.Tree.comp🔗<|PREMISE|>🔗 (Quiver.Path.cons🔗<|PREMISE|>🔗 h.B ⋯) φ)) :ConNF.StructApprox.ExactlyApproximates🔗<|PREMISE|>🔗 (ConNF.StructAction.rc🔗<|PREMISE|>🔗 (ConNF.Tree.comp🔗<|PREMISE|>🔗 (Quiver.Path.cons🔗<|PREMISE|>🔗 h.B ⋯) φ) h₁) (ConNF.Allowable.toStructPerm (ConNF.StructAction.hypothesisedAllowable🔗<|PREMISE|>🔗 φ h h₁ h₂))", "code": "theorem ConNF.StructAction.hypothesisedAllowable_exactlyApproximates (φ : StructAction β)\n    {A : ExtendedIndex β} (h : InflexibleCoePath A)\n    (h₁ : StructAction.Lawful (φ.comp (h.B.cons h.hδ)))\n    (h₂ : StructAction.MapFlexible (φ.comp (h.B.cons h.hδ))) :\n    StructApprox.ExactlyApproximates\n      (StructAction.rc (φ.comp (h.B.cons h.hδ)) h₁)\n      (Allowable.toStructPerm (φ.hypothesisedAllowable h h₁ h₂)) :=\n  StructAction.allowable_exactlyApproximates (φ.comp (h.B.cons h.hδ)) _ _ _\n", "additional_info": "", "used_premises": [1, 402, 779, 808, 61, 890, 809, 304, 301, 814, 304, 301, 803, 810, 304, 301, 1311], "def_path": "ConNF/FOA/Complete/LitterCompletion.lean", "pos": [84, 92], "informalization": "The theorem `ConNF.StructAction.hypothesisedAllowable_exactlyApproximates` states that given a `β`-structural action `φ`, an inflexible coe path `A`, and two hypotheses (lawfulness and map flexibility), the refined and completed `β`-structural approximation `ConNF.StructAction.rc (ConNF.Tree.comp (Quiver.Path.cons h.B ⋯) φ) h₁` exactly approximates the allowable permutation `ConNF.Allowable.toStructPerm (ConNF.StructAction.hypothesisedAllowable φ h h₁ h₂)`."}
{"full_name": "ConNF.StructAction.hypothesisedAllowable", "url": "ConNF/FOA/Complete/LitterCompletion.html#ConNF.StructAction.hypothesisedAllowable", "code_src": "con-nf", "ptype": "noncomputable def", "header": "noncomputable def ConNF.StructAction.hypothesisedAllowable [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.FOAAssumptions] {β : ConNF.Λ} [ConNF.LeLevel🔗<|PREMISE|>🔗 ↑β] [ConNF.StructApprox.FreedomOfActionHypothesis🔗<|PREMISE|>🔗 β] (φ : ConNF.StructAction🔗<|PREMISE|>🔗 ↑β) {A : ConNF.ExtendedIndex🔗<|PREMISE|>🔗 ↑β} (h : ConNF.InflexibleCoePath🔗<|PREMISE|>🔗 A) (h₁ : ConNF.StructAction.Lawful🔗<|PREMISE|>🔗 (ConNF.Tree.comp🔗<|PREMISE|>🔗 (Quiver.Path.cons🔗<|PREMISE|>🔗 h.B ⋯) φ)) (h₂ : ConNF.StructAction.MapFlexible🔗<|PREMISE|>🔗 (ConNF.Tree.comp🔗<|PREMISE|>🔗 (Quiver.Path.cons🔗<|PREMISE|>🔗 h.B ⋯) φ)) :ConNF.Allowable ↑h.δ", "code": "noncomputable def ConNF.StructAction.hypothesisedAllowable (φ : StructAction β)\n    {A : ExtendedIndex β} (h : InflexibleCoePath A)\n    (h₁ : StructAction.Lawful (φ.comp (h.B.cons h.hδ)))\n    (h₂ : StructAction.MapFlexible (φ.comp (h.B.cons h.hδ))) :\n    Allowable h.δ :=\n  StructAction.allowable\n    (φ.comp (h.B.cons h.hδ))\n    (coe_lt_coe.mp (h.hδ.trans_le (le_of_path h.B)))\n    h₁ h₂\n", "additional_info": "Equations\n* 🗟ConNF.StructAction.hypothesisedAllowable🗟🔗../../.././ConNF/FOA/Complete/LitterCompletion.html#ConNF.StructAction.hypothesisedAllowable🔗  φ h h₁ h₂ 🗟=🗟🔗../../.././Init/Prelude.html#Eq🔗  🗟ConNF.StructAction.allowable🗟🔗../../.././ConNF/FOA/Complete/LitterCompletion.html#ConNF.StructAction.allowable🔗  (🗟ConNF.Tree.comp🗟🔗../../.././ConNF/Structural/Tree.html#ConNF.Tree.comp🔗  (🗟Quiver.Path.cons🗟🔗../../.././Mathlib/Combinatorics/Quiver/Path.html#Quiver.Path.cons🔗  h.B ⋯) φ) ⋯ h₁ h₂\n\n", "used_premises": [1, 402, 779, 808, 61, 890, 809, 304, 301, 814, 304, 301], "def_path": "ConNF/FOA/Complete/LitterCompletion.lean", "pos": [74, 83], "informalization": "`ConNF.StructAction.hypothesisedAllowable` is a noncomputable definition in Lean 4 that constructs an allowable permutation from a β-structural action, an inflexible coe path, and two hypotheses (lawfulness and map flexibility). It uses the `ConNF.StructAction.allowable` function to construct an allowable permutation by composing the given β-structural action with the inflexible coe path and providing the necessary hypotheses. This allows for the construction of allowable permutations in the context of Constructive Ordinal Notation (ConNF)."}
{"full_name": "ConNF.StructApprox.litterCompletion_of_flexible", "url": "ConNF/FOA/Complete/LitterCompletion.html#ConNF.StructApprox.litterCompletion_of_flexible", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.StructApprox.litterCompletion_of_flexible [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.FOAAssumptions] {β : ConNF.Λ} [ConNF.LeLevel🔗<|PREMISE|>🔗 ↑β] [ConNF.StructApprox.FreedomOfActionHypothesis🔗<|PREMISE|>🔗 β] (π : ConNF.StructApprox🔗<|PREMISE|>🔗 ↑β) (A : ConNF.ExtendedIndex🔗<|PREMISE|>🔗 ↑β) (L : ConNF.Litter) (H : ConNF.HypAction🔗<|PREMISE|>🔗 { path := A, value := Sum.inr🔗<|PREMISE|>🔗 (ConNF.Litter.toNearLitter🔗<|PREMISE|>🔗 L) }) (hflex : ConNF.Flexible🔗<|PREMISE|>🔗 A L) :ConNF.StructApprox.litterCompletion🔗<|PREMISE|>🔗 π A L H = ConNF.NearLitterApprox.flexibleCompletion🔗<|PREMISE|>🔗 (π A) A • L", "code": "theorem litterCompletion_of_flexible (π : StructApprox β) (A : ExtendedIndex β) (L : Litter)\n    (H : HypAction ⟨A, inr L.toNearLitter⟩) (hflex : Flexible A L) :\n    litterCompletion π A L H = NearLitterApprox.flexibleCompletion (π A) A • L := by\n  rw [litterCompletion, dif_neg, dif_neg]\n  · rintro ⟨⟨⟨γ, ε, hε, C, rfl⟩, a, rfl⟩⟩\n    exact hflex (Inflexible.mk_bot hε _ _)\n  · rintro ⟨⟨⟨γ, δ, ε, hδ, hε, hδε, C, rfl⟩, t, rfl⟩⟩\n    exact hflex (Inflexible.mk_coe hδ hε hδε _ _)\n", "additional_info": "", "used_premises": [1, 402, 779, 781, 61, 1305, 65, 483, 842, 1313, 1314], "def_path": "ConNF/FOA/Complete/LitterCompletion.lean", "pos": [104, 112], "informalization": "The theorem `ConNF.StructApprox.litterCompletion_of_flexible` is a part of the proof of freedom of action in Constructive Ordinal Notation (ConNF). It states that, given a `β`-structural approximation `π`, an extended index `A`, a litter `L`, and a hypothesis `H` about the action of `π` on `A` and `L`, the litter completion `ConNF.StructApprox.litterCompletion π A L H` is equal to the flexible completion `ConNF.NearLitterApprox.flexibleCompletion (π A) A • L`."}
{"full_name": "ConNF.StructApprox.litterCompletion", "url": "ConNF/FOA/Complete/LitterCompletion.html#ConNF.StructApprox.litterCompletion", "code_src": "con-nf", "ptype": "noncomputable def", "header": "noncomputable def ConNF.StructApprox.litterCompletion [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.FOAAssumptions] {β : ConNF.Λ} [ConNF.LeLevel🔗<|PREMISE|>🔗 ↑β] [ConNF.StructApprox.FreedomOfActionHypothesis🔗<|PREMISE|>🔗 β] (π : ConNF.StructApprox🔗<|PREMISE|>🔗 ↑β) (A : ConNF.ExtendedIndex🔗<|PREMISE|>🔗 ↑β) (L : ConNF.Litter) (H : ConNF.HypAction🔗<|PREMISE|>🔗 { path := A, value := Sum.inr🔗<|PREMISE|>🔗 (ConNF.Litter.toNearLitter🔗<|PREMISE|>🔗 L) }) :ConNF.Litter", "code": "noncomputable def litterCompletion (π : StructApprox β) (A : ExtendedIndex β) (L : Litter)\n    (H : HypAction ⟨A, inr L.toNearLitter⟩) : Litter :=\n  if h : Nonempty (InflexibleCoe A L) then\n    if hs : _ ∧ _ then\n      fuzz h.some.path.hδε ((ihAction H).hypothesisedAllowable h.some.path hs.1 hs.2 • h.some.t)\n    else L\n  else if h : Nonempty (InflexibleBot A L) then\n    fuzz (show (⊥ : TypeIndex) ≠ (h.some.path.ε : Λ) from bot_ne_coe)\n      (H.atomImage (h.some.path.B.cons (bot_lt_coe _)) h.some.a h.some.constrains)\n  else NearLitterApprox.flexibleCompletion (π A) A • L\n", "additional_info": "Equations\n* One or more equations did not get rendered due to their size.\n\n", "used_premises": [1, 402, 779, 781, 61, 1305, 65, 483], "def_path": "ConNF/FOA/Complete/LitterCompletion.lean", "pos": [93, 103], "informalization": "The Lean 4 object `ConNF.StructApprox.litterCompletion` is a function that, given a `β`-structural approximation `π`, an extended index `A`, a litter `L`, and a hypothesis `H` about the action of `π` on `A` and `L`, returns a litter. This function is part of the proof of freedom of action in Constructive Ordinal Notation (ConNF)."}
{"full_name": "ConNF.NearLitterApprox.flexibleCompletion", "url": "ConNF/FOA/Complete/FlexibleCompletion.html#ConNF.NearLitterApprox.flexibleCompletion", "code_src": "con-nf", "ptype": "noncomputable def", "header": "noncomputable def ConNF.NearLitterApprox.flexibleCompletion [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.FOAAssumptions] {β : ConNF.TypeIndex} (π : ConNF.NearLitterApprox) (A : ConNF.ExtendedIndex🔗<|PREMISE|>🔗 β) :ConNF.NearLitterApprox", "code": "noncomputable def flexibleCompletion : NearLitterApprox\n    where\n  atomPerm := π.atomPerm\n  litterPerm := flexibleCompletionLitterPerm π A\n  domain_small := π.domain_small\n", "additional_info": "Equations\n* 🗟ConNF.NearLitterApprox.flexibleCompletion🗟🔗../../.././ConNF/FOA/Complete/FlexibleCompletion.html#ConNF.NearLitterApprox.flexibleCompletion🔗  π A 🗟=🗟🔗../../.././Init/Prelude.html#Eq🔗  { atomPerm := π.atomPerm, litterPerm := 🗟ConNF.NearLitterApprox.flexibleCompletionLitterPerm🗟🔗../../.././ConNF/FOA/Complete/FlexibleCompletion.html#ConNF.NearLitterApprox.flexibleCompletionLitterPerm🔗  π A, domain_small := ⋯ }\n\n", "used_premises": [1, 61], "def_path": "ConNF/FOA/Complete/FlexibleCompletion.lean", "pos": [39, 44], "informalization": "Function `ConNF.NearLitterApprox.flexibleCompletion` takes a `ConNF.NearLitterApprox` object `π` and an `ConNF.ExtendedIndex` object `A`, and returns a new `ConNF.NearLitterApprox` object. The new object has the same `atomPerm` and `domain_small` as `π`, but its `litterPerm` is determined by `ConNF.NearLitterApprox.flexibleCompletionLitterPerm`."}
{"full_name": "ConNF.StructApprox.completeAtomMap_eq", "url": "ConNF/FOA/Complete/CompleteAction.html#ConNF.StructApprox.completeAtomMap_eq", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.StructApprox.completeAtomMap_eq [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.FOAAssumptions] {β : ConNF.Λ} [ConNF.LeLevel🔗<|PREMISE|>🔗 ↑β] [ConNF.StructApprox.FreedomOfActionHypothesis🔗<|PREMISE|>🔗 β] {π : ConNF.StructApprox🔗<|PREMISE|>🔗 ↑β} {A : ConNF.ExtendedIndex🔗<|PREMISE|>🔗 ↑β} {a : ConNF.Atom} :ConNF.StructApprox.completeAtomMap🔗<|PREMISE|>🔗 π A a = ConNF.StructApprox.atomCompletion🔗<|PREMISE|>🔗 π A a (ConNF.StructApprox.foaHypothesis🔗<|PREMISE|>🔗 π)", "code": "theorem completeAtomMap_eq : π.completeAtomMap A a = π.atomCompletion A a π.foaHypothesis :=\n  HypAction.fixAtom_eq _ _ _ _\n", "additional_info": "", "used_premises": [1, 402, 779, 781, 61, 784, 1316, 1317], "def_path": "ConNF/FOA/Complete/CompleteAction.lean", "pos": [43, 45], "informalization": "The theorem `ConNF.StructApprox.completeAtomMap_eq` states that the function `ConNF.StructApprox.completeAtomMap`, which maps each `β`-extended index to an atom, is equal to the function `ConNF.StructApprox.atomCompletion`, which defines the action of a `β`-structural approximation `π` on an atom `a`."}
{"full_name": "ConNF.StructApprox.atomCompletion", "url": "ConNF/FOA/Complete/AtomCompletion.html#ConNF.StructApprox.atomCompletion", "code_src": "con-nf", "ptype": "noncomputable def", "header": "noncomputable def ConNF.StructApprox.atomCompletion [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.FOAAssumptions] {β : ConNF.Λ} (π : ConNF.StructApprox🔗<|PREMISE|>🔗 ↑β) (A : ConNF.ExtendedIndex🔗<|PREMISE|>🔗 ↑β) (a : ConNF.Atom) (H : ConNF.HypAction🔗<|PREMISE|>🔗 { path := A, value := Sum.inl🔗<|PREMISE|>🔗 a }) :ConNF.Atom", "code": "noncomputable def atomCompletion (A : ExtendedIndex β) (a : Atom) (H : HypAction ⟨A, inl a⟩) :\n    Atom :=\n  if h : a ∈ (π A).atomPerm.domain then π A • a\n  else\n    ((π A).largestSublitter a.1).equiv\n      ((π A).largestSublitter\n        (H.nearLitterImage A a.1.toNearLitter (Relation.TransGen.single <| Constrains.atom A a)).1)\n      ⟨a, (π A).mem_largestSublitter_of_not_mem_domain a h⟩\n", "additional_info": "Computes the action of a structural approximation `π` on an atom `a`.\nEquations\n* One or more equations did not get rendered due to their size.\n\n", "used_premises": [1, 781, 61, 1305, 67], "def_path": "ConNF/FOA/Complete/AtomCompletion.lean", "pos": [28, 36], "informalization": "Function `ConNF.StructApprox.atomCompletion` defines the action of a `β`-structural approximation `π` on an atom `a` in the context of Constructive Ordinal Notation (ConNF). It checks if `a` is within the domain of the permutation defined by `π`, and if so, applies the permutation to `a`. If `a` is not in the domain, it uses the equivalence between the largest sublitter of `a` and the largest sublitter of the near-litter image of `a` to map `a` to an element within the domain of the permutation."}
{"full_name": "ConNF.StructApprox.foaHypothesis", "url": "ConNF/FOA/Complete/CompleteAction.html#ConNF.StructApprox.foaHypothesis", "code_src": "con-nf", "ptype": "noncomputable def", "header": "noncomputable def ConNF.StructApprox.foaHypothesis [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.FOAAssumptions] {β : ConNF.Λ} [ConNF.LeLevel🔗<|PREMISE|>🔗 ↑β] [ConNF.StructApprox.FreedomOfActionHypothesis🔗<|PREMISE|>🔗 β] (π : ConNF.StructApprox🔗<|PREMISE|>🔗 ↑β) {c : ConNF.Address🔗<|PREMISE|>🔗 ↑β} :ConNF.HypAction🔗<|PREMISE|>🔗 c", "code": "noncomputable def foaHypothesis (π : StructApprox β) {c : Address β} : HypAction c :=\n  ⟨fun B b _ => π.completeAtomMap B b, fun B N _ => π.completeNearLitterMap B N⟩\n", "additional_info": "Equations\n* One or more equations did not get rendered due to their size.\n\n", "used_premises": [1, 402, 779, 781, 60, 1305], "def_path": "ConNF/FOA/Complete/CompleteAction.lean", "pos": [34, 36], "informalization": "Function `ConNF.StructApprox.foaHypothesis` is an inductive hypothesis used in the proof of freedom of action in Constructive Ordinal Notation (ConNF). It states that every free approximation exactly approximates some allowable permutation."}
{"full_name": "ConNF.StructApprox.completeNearLitterMap_eq", "url": "ConNF/FOA/Complete/CompleteAction.html#ConNF.StructApprox.completeNearLitterMap_eq", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.StructApprox.completeNearLitterMap_eq [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.FOAAssumptions] {β : ConNF.Λ} [ConNF.LeLevel🔗<|PREMISE|>🔗 ↑β] [ConNF.StructApprox.FreedomOfActionHypothesis🔗<|PREMISE|>🔗 β] {π : ConNF.StructApprox🔗<|PREMISE|>🔗 ↑β} {A : ConNF.ExtendedIndex🔗<|PREMISE|>🔗 ↑β} {N : ConNF.NearLitter} :ConNF.StructApprox.completeNearLitterMap🔗<|PREMISE|>🔗 π A N = ConNF.StructApprox.nearLitterCompletion🔗<|PREMISE|>🔗 π A N (ConNF.StructApprox.foaHypothesis🔗<|PREMISE|>🔗 π)", "code": "theorem completeNearLitterMap_eq :\n    π.completeNearLitterMap A N = π.nearLitterCompletion A N π.foaHypothesis :=\n  HypAction.fixNearLitter_eq _ _ _ _\n", "additional_info": "", "used_premises": [1, 402, 779, 781, 61, 792, 1319, 1317], "def_path": "ConNF/FOA/Complete/CompleteAction.lean", "pos": [46, 49], "informalization": "The theorem `ConNF.StructApprox.completeNearLitterMap_eq` is a part of the proof of freedom of action (FOA) in the context of Constructive Ordinal Notation (ConNF). It states that the function `ConNF.StructApprox.completeNearLitterMap` is equivalent to the function `ConNF.StructApprox.nearLitterCompletion` applied to the inductive hypothesis `ConNF.StructApprox.foaHypothesis`, which is a crucial part of the proof to establish that every free approximation exactly approximates some allowable permutation. This theorem is a key step in demonstrating that the FOA is consistent with the ConNF system, ensuring that the natural numbers can be constructed constructively with the desired properties."}
{"full_name": "ConNF.StructApprox.nearLitterCompletion", "url": "ConNF/FOA/Complete/NearLitterCompletion.html#ConNF.StructApprox.nearLitterCompletion", "code_src": "con-nf", "ptype": "noncomputable def", "header": "noncomputable def ConNF.StructApprox.nearLitterCompletion [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.FOAAssumptions] {β : ConNF.Λ} [ConNF.LeLevel🔗<|PREMISE|>🔗 ↑β] [ConNF.StructApprox.FreedomOfActionHypothesis🔗<|PREMISE|>🔗 β] (π : ConNF.StructApprox🔗<|PREMISE|>🔗 ↑β) (A : ConNF.ExtendedIndex🔗<|PREMISE|>🔗 ↑β) (N : ConNF.NearLitter) (H : ConNF.HypAction🔗<|PREMISE|>🔗 { path := A, value := Sum.inr🔗<|PREMISE|>🔗 N }) :ConNF.NearLitter", "code": "noncomputable def nearLitterCompletion (π : StructApprox β) (A : ExtendedIndex β) (N : NearLitter)\n    (H : HypAction ⟨A, inr N⟩) : NearLitter :=\n  ⟨litterCompletion π A N.1 (nearLitterHypothesis A N H), nearLitterCompletionMap π A N H,\n    nearLitterCompletionMap_isNearLitter π A N H⟩\n", "additional_info": "Equations\n* One or more equations did not get rendered due to their size.\n\n", "used_premises": [1, 402, 779, 781, 61, 1305, 65], "def_path": "ConNF/FOA/Complete/NearLitterCompletion.lean", "pos": [52, 56], "informalization": "Function `ConNF.StructApprox.nearLitterCompletion` defines a `β`-structural approximation in the context of Constructive Ordinal Notation (ConNF), which is a product that assigns a near-litter approximation to each `β`-extended index. Given a `β`-structural approximation `π`, a `β`-extended index `A`, a near-litter `N`, and a hypothesis `H` about the action of `π` on `A` and `N`, the function `nearLitterCompletion` returns a near-litter that is the completion of `N` with respect to `π`, `A`, and `H`."}
{"full_name": "ConNF.StructApprox.completeLitterMap_eq", "url": "ConNF/FOA/Complete/CompleteAction.html#ConNF.StructApprox.completeLitterMap_eq", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.StructApprox.completeLitterMap_eq [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.FOAAssumptions] {β : ConNF.Λ} [ConNF.LeLevel🔗<|PREMISE|>🔗 ↑β] [ConNF.StructApprox.FreedomOfActionHypothesis🔗<|PREMISE|>🔗 β] {π : ConNF.StructApprox🔗<|PREMISE|>🔗 ↑β} {A : ConNF.ExtendedIndex🔗<|PREMISE|>🔗 ↑β} {L : ConNF.Litter} :ConNF.StructApprox.completeLitterMap🔗<|PREMISE|>🔗 π A L = ConNF.StructApprox.litterCompletion🔗<|PREMISE|>🔗 π A L (ConNF.StructApprox.foaHypothesis🔗<|PREMISE|>🔗 π)", "code": "theorem completeLitterMap_eq :\n    π.completeLitterMap A L = π.litterCompletion A L π.foaHypothesis := by\n  rw [completeLitterMap, completeNearLitterMap_eq]\n  rfl\n", "additional_info": "", "used_premises": [1, 402, 779, 781, 61, 787, 1313, 1317], "def_path": "ConNF/FOA/Complete/CompleteAction.lean", "pos": [50, 54], "informalization": "The theorem `ConNF.StructApprox.completeLitterMap_eq` states that the function `ConNF.StructApprox.completeLitterMap` is equal to the function `ConNF.StructApprox.litterCompletion` applied to a `β`-structural approximation `π`, a `β`-extended index `A`, a litter `L`, and a hypothesis `ConNF.StructApprox.foaHypothesis π` about the action of `π` on `A` and `L`."}
{"full_name": "ConNF.StructApprox.completeNearLitterMap_fst_eq", "url": "ConNF/FOA/Complete/CompleteAction.html#ConNF.StructApprox.completeNearLitterMap_fst_eq", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.StructApprox.completeNearLitterMap_fst_eq [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.FOAAssumptions] {β : ConNF.Λ} [ConNF.LeLevel🔗<|PREMISE|>🔗 ↑β] [ConNF.StructApprox.FreedomOfActionHypothesis🔗<|PREMISE|>🔗 β] {π : ConNF.StructApprox🔗<|PREMISE|>🔗 ↑β} {A : ConNF.ExtendedIndex🔗<|PREMISE|>🔗 ↑β} {L : ConNF.Litter} :(ConNF.StructApprox.completeNearLitterMap🔗<|PREMISE|>🔗 π A (ConNF.Litter.toNearLitter🔗<|PREMISE|>🔗 L)).fst = ConNF.StructApprox.completeLitterMap🔗<|PREMISE|>🔗 π A L", "code": "theorem completeNearLitterMap_fst_eq :\n    (π.completeNearLitterMap A L.toNearLitter).1 = π.completeLitterMap A L :=\n  rfl\n", "additional_info": "", "used_premises": [1, 402, 779, 781, 61, 792, 483, 787], "def_path": "ConNF/FOA/Complete/CompleteAction.lean", "pos": [55, 58], "informalization": "The theorem `ConNF.StructApprox.completeNearLitterMap_fst_eq` states that for a `β`-structural approximation `π`, a `β`-extended index `A`, and a litter `L`, the first component of the near-litter returned by `ConNF.StructApprox.completeNearLitterMap π A (ConNF.Litter.toNearLitter L)` is equal to the litter returned by `ConNF.StructApprox.completeLitterMap π A L`."}
{"full_name": "ConNF.StructApprox.completeNearLitterMap_fst_eq'", "url": "ConNF/FOA/Complete/CompleteAction.html#ConNF.StructApprox.completeNearLitterMap_fst_eq'", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.StructApprox.completeNearLitterMap_fst_eq' [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.FOAAssumptions] {β : ConNF.Λ} [ConNF.LeLevel🔗<|PREMISE|>🔗 ↑β] [ConNF.StructApprox.FreedomOfActionHypothesis🔗<|PREMISE|>🔗 β] {π : ConNF.StructApprox🔗<|PREMISE|>🔗 ↑β} {A : ConNF.ExtendedIndex🔗<|PREMISE|>🔗 ↑β} {N : ConNF.NearLitter} :(ConNF.StructApprox.completeNearLitterMap🔗<|PREMISE|>🔗 π A N).fst = ConNF.StructApprox.completeLitterMap🔗<|PREMISE|>🔗 π A N.fst", "code": "theorem completeNearLitterMap_fst_eq' :\n    (π.completeNearLitterMap A N).1 = π.completeLitterMap A N.1 := by\n  rw [completeNearLitterMap_eq, nearLitterCompletion, completeLitterMap_eq]\n  rfl\n", "additional_info": "", "used_premises": [1, 402, 779, 781, 61, 792, 787], "def_path": "ConNF/FOA/Complete/CompleteAction.lean", "pos": [60, 64], "informalization": "The theorem `ConNF.StructApprox.completeNearLitterMap_fst_eq'` is a part of the proof of freedom of action in Constructive Ordinal Notation (ConNF). It states that the first component of the result of the function `ConNF.StructApprox.completeNearLitterMap` applied to a `β`-structural approximation `π`, a `β`-extended index `A`, and a near-litter `N`, is equal to the result of the function `ConNF.StructApprox.completeLitterMap` applied to `π`, `A`, and the first component of `N`."}
{"full_name": "ConNF.StructApprox.foaHypothesis_atomImage", "url": "ConNF/FOA/Complete/CompleteAction.html#ConNF.StructApprox.foaHypothesis_atomImage", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.StructApprox.foaHypothesis_atomImage [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.FOAAssumptions] {β : ConNF.Λ} [ConNF.LeLevel🔗<|PREMISE|>🔗 ↑β] [ConNF.StructApprox.FreedomOfActionHypothesis🔗<|PREMISE|>🔗 β] {π : ConNF.StructApprox🔗<|PREMISE|>🔗 ↑β} {A : ConNF.ExtendedIndex🔗<|PREMISE|>🔗 ↑β} {a : ConNF.Atom} {c : ConNF.Address🔗<|PREMISE|>🔗 ↑β} (h : { path := A, value := Sum.inl🔗<|PREMISE|>🔗 a } < c) :(ConNF.StructApprox.foaHypothesis🔗<|PREMISE|>🔗 π).atomImage A a h = ConNF.StructApprox.completeAtomMap🔗<|PREMISE|>🔗 π A a", "code": "theorem foaHypothesis_atomImage {c : Address β} (h : ⟨A, inl a⟩ < c) :\n    (π.foaHypothesis : HypAction c).atomImage A a h = π.completeAtomMap A a :=\n  rfl\n", "additional_info": "", "used_premises": [1, 402, 779, 781, 61, 60, 67, 1317, 784], "def_path": "ConNF/FOA/Complete/CompleteAction.lean", "pos": [66, 69], "informalization": "The theorem `ConNF.StructApprox.foaHypothesis_atomImage` is a part of the proof of Freedom of Action in Constructive Ordinal Notation (ConNF). It states that for a `β`-structural approximation `π` and a `β`-extended index `A`, the image of an atom `a` under the function `ConNF.StructApprox.foaHypothesis` is equal to the complete atom map of `π` applied to `A` and `a`."}
{"full_name": "ConNF.StructApprox.foaHypothesis_nearLitterImage", "url": "ConNF/FOA/Complete/CompleteAction.html#ConNF.StructApprox.foaHypothesis_nearLitterImage", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.StructApprox.foaHypothesis_nearLitterImage [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.FOAAssumptions] {β : ConNF.Λ} [ConNF.LeLevel🔗<|PREMISE|>🔗 ↑β] [ConNF.StructApprox.FreedomOfActionHypothesis🔗<|PREMISE|>🔗 β] {π : ConNF.StructApprox🔗<|PREMISE|>🔗 ↑β} {A : ConNF.ExtendedIndex🔗<|PREMISE|>🔗 ↑β} {N : ConNF.NearLitter} {c : ConNF.Address🔗<|PREMISE|>🔗 ↑β} (h : { path := A, value := Sum.inr🔗<|PREMISE|>🔗 N } < c) :(ConNF.StructApprox.foaHypothesis🔗<|PREMISE|>🔗 π).nearLitterImage A N h = ConNF.StructApprox.completeNearLitterMap🔗<|PREMISE|>🔗 π A N", "code": "theorem foaHypothesis_nearLitterImage {c : Address β} (h : ⟨A, inr N⟩ < c) :\n    (π.foaHypothesis : HypAction c).nearLitterImage A N h = π.completeNearLitterMap A N :=\n  rfl\n", "additional_info": "", "used_premises": [1, 402, 779, 781, 61, 60, 65, 1317, 792], "def_path": "ConNF/FOA/Complete/CompleteAction.lean", "pos": [71, 74], "informalization": "The theorem `ConNF.StructApprox.foaHypothesis_nearLitterImage` is a part of the proof of Freedom of Action in Constructive Ordinal Notation (ConNF). It states that for any `β`-structural approximation `π`, any `β`-extended index `A`, and any near-litter `N`, the near-litter image of `A` and `N` under the Freedom of Action hypothesis is equal to the complete near-litter map of `π` applied to `A` and `N`."}
{"full_name": "ConNF.StructApprox.completeAtomMap_eq_of_mem_domain", "url": "ConNF/FOA/Complete/CompleteAction.html#ConNF.StructApprox.completeAtomMap_eq_of_mem_domain", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.StructApprox.completeAtomMap_eq_of_mem_domain [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.FOAAssumptions] {β : ConNF.Λ} [ConNF.LeLevel🔗<|PREMISE|>🔗 ↑β] [ConNF.StructApprox.FreedomOfActionHypothesis🔗<|PREMISE|>🔗 β] {π : ConNF.StructApprox🔗<|PREMISE|>🔗 ↑β} {A : ConNF.ExtendedIndex🔗<|PREMISE|>🔗 ↑β} {a : ConNF.Atom} (h : a ∈ (π A).atomPerm.domain) :ConNF.StructApprox.completeAtomMap🔗<|PREMISE|>🔗 π A a = π A • a", "code": "theorem completeAtomMap_eq_of_mem_domain {A} {a} (h : a ∈ (π A).atomPerm.domain) :\n    π.completeAtomMap A a = π A • a := by rw [completeAtomMap_eq, atomCompletion, dif_pos h]\n", "additional_info": "", "used_premises": [1, 402, 779, 781, 61, 784], "def_path": "ConNF/FOA/Complete/CompleteAction.lean", "pos": [77, 79], "informalization": "The theorem `ConNF.StructApprox.completeAtomMap_eq_of_mem_domain` states that for a `β`-structural approximation `π` and a `β`-extended index `A`, if an atom `a` is in the domain of the atom permutation of `π A`, then the complete atom map of `π` at `A` applied to `a` is equal to the action of `π A` on `a`."}
{"full_name": "ConNF.StructApprox.completeLitterMap_eq_of_flexible", "url": "ConNF/FOA/Complete/CompleteAction.html#ConNF.StructApprox.completeLitterMap_eq_of_flexible", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.StructApprox.completeLitterMap_eq_of_flexible [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.FOAAssumptions] {β : ConNF.Λ} [ConNF.LeLevel🔗<|PREMISE|>🔗 ↑β] [ConNF.StructApprox.FreedomOfActionHypothesis🔗<|PREMISE|>🔗 β] {π : ConNF.StructApprox🔗<|PREMISE|>🔗 ↑β} {A : ConNF.ExtendedIndex🔗<|PREMISE|>🔗 ↑β} {L : ConNF.Litter} (h : ConNF.Flexible🔗<|PREMISE|>🔗 A L) :ConNF.StructApprox.completeLitterMap🔗<|PREMISE|>🔗 π A L = ConNF.NearLitterApprox.flexibleCompletion🔗<|PREMISE|>🔗 (π A) A • L", "code": "theorem completeLitterMap_eq_of_flexible {A : ExtendedIndex β} {L : Litter} (h : Flexible A L) :\n    π.completeLitterMap A L = NearLitterApprox.flexibleCompletion (π A) A • L := by\n  rw [completeLitterMap_eq, litterCompletion_of_flexible _ _ _ _ h]\n", "additional_info": "A basic definition unfold.", "used_premises": [1, 402, 779, 781, 61, 842, 787, 1314], "def_path": "ConNF/FOA/Complete/CompleteAction.lean", "pos": [122, 125], "informalization": "In the context of Constructive Ordinal Notation (ConNF), the theorem `ConNF.StructApprox.completeLitterMap_eq_of_flexible` states that for a `β`-structural approximation `π`, a `β`-extended index `A`, and a litter `L` that is `A`-flexible, the litter `ConNF.StructApprox.completeLitterMap π A L` is equal to `ConNF.NearLitterApprox.flexibleCompletion (π A) A • L`. This theorem serves as a basic definition unfold in the proof of Freedom of Action in Constructive Ordinal Notation (ConNF). The `ConNF.NearLitterApprox.flexibleCompletion` function is crucial in ensuring that the construction of the natural numbers in ConNF is well-defined and consistent."}
{"full_name": "ConNF.StructApprox.toStructPerm_bot", "url": "ConNF/FOA/Complete/CompleteAction.html#ConNF.StructApprox.toStructPerm_bot", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.StructApprox.toStructPerm_bot [ConNF.Params🔗<|PREMISE|>🔗 ] :⇑ConNF.Allowable.toStructPerm = ⇑(MulEquiv.toMonoidHom🔗<|PREMISE|>🔗 ConNF.Tree.toBotIso)", "code": "theorem toStructPerm_bot :\n    (Allowable.toStructPerm : Allowable ⊥ → StructPerm ⊥) = Tree.toBotIso.toMonoidHom :=\n  rfl\n", "additional_info": "", "used_premises": [1, 1328], "def_path": "ConNF/FOA/Complete/CompleteAction.lean", "pos": [126, 129], "informalization": "The theorem `ConNF.StructApprox.toStructPerm_bot` states that the function `ConNF.Allowable.toStructPerm` is equal to the monoid homomorphism obtained from the multiplicative equivalence `ConNF.Tree.toBotIso`."}
{"full_name": "MulEquiv.toMonoidHom", "url": "Mathlib/Algebra/Group/Equiv/Basic.html#MulEquiv.toMonoidHom", "code_src": "mathlib4", "ptype": "def", "header": "def MulEquiv.toMonoidHom {M : Type u_6} {N : Type u_7} [MulOneClass🔗<|PREMISE|>🔗 M] [MulOneClass🔗<|PREMISE|>🔗 N] (h : M ≃* N) :M →* N", "code": "def toMonoidHom (h : M ≃* N) : M →* N :=\n  { h with map_one' := h.map_one }\n", "additional_info": "Extract the forward direction of a multiplicative equivalence\nas a multiplication-preserving function.\nEquations\n* 🗟MulEquiv.toMonoidHom🗟🔗../../../.././Mathlib/Algebra/Group/Equiv/Basic.html#MulEquiv.toMonoidHom🔗  h 🗟=🗟🔗../../../.././Init/Prelude.html#Eq🔗  { toOneHom := { toFun := h.toFun, map_one' := ⋯ }, map_mul' := ⋯ }\n\n", "used_premises": [847, 847], "def_path": "Mathlib/Algebra/Group/Equiv/Basic.lean", "pos": [638, 640], "informalization": "Function `MulEquiv.toMonoidHom` converts a multiplicative equivalence `h` between two `MulOneClass` types into a monoid homomorphism that preserves the multiplicative structure."}
{"full_name": "ConNF.StructApprox.completeNearLitterMap_eq'", "url": "ConNF/FOA/Complete/CompleteAction.html#ConNF.StructApprox.completeNearLitterMap_eq'", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.StructApprox.completeNearLitterMap_eq' [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.FOAAssumptions] {β : ConNF.Λ} [ConNF.LeLevel🔗<|PREMISE|>🔗 ↑β] [ConNF.StructApprox.FreedomOfActionHypothesis🔗<|PREMISE|>🔗 β] {π : ConNF.StructApprox🔗<|PREMISE|>🔗 ↑β} (A : ConNF.ExtendedIndex🔗<|PREMISE|>🔗 ↑β) (N : ConNF.NearLitter) :↑(ConNF.StructApprox.completeNearLitterMap🔗<|PREMISE|>🔗 π A N) = symmDiff🔗<|PREMISE|>🔗 (↑(ConNF.StructApprox.completeNearLitterMap🔗<|PREMISE|>🔗 π A (ConNF.Litter.toNearLitter🔗<|PREMISE|>🔗 N.fst))) (ConNF.StructApprox.completeAtomMap🔗<|PREMISE|>🔗 π A '' symmDiff🔗<|PREMISE|>🔗 (ConNF.litterSet🔗<|PREMISE|>🔗 N.fst) ↑N)", "code": "theorem completeNearLitterMap_eq' (A : ExtendedIndex β) (N : NearLitter) :\n    (π.completeNearLitterMap A N : Set Atom) =\n      (π.completeNearLitterMap A N.fst.toNearLitter : Set Atom) ∆\n        (π.completeAtomMap A '' litterSet N.fst ∆ ↑N) := by\n  simp only [completeNearLitterMap_eq, nearLitterCompletion, nearLitterCompletionMap,\n    nearLitterHypothesis_eq, NearLitterApprox.coe_largestSublitter, mem_diff,\n    foaHypothesis_atomImage, NearLitter.coe_mk, Subtype.coe_mk, Litter.coe_toNearLitter,\n    Litter.toNearLitter_fst, symmDiff_self, bot_eq_empty, mem_empty_iff_false, false_and_iff,\n    iUnion_neg', not_false_iff, iUnion_empty, symmDiff_empty]\n  ext a : 1\n  constructor\n  · rintro (⟨ha₁ | ⟨a, ha₁, rfl⟩, ha₂⟩ | ⟨⟨_, ⟨b, rfl⟩, _, ⟨⟨hb₁, hb₂⟩, rfl⟩, ha⟩, ha₂⟩)\n    · refine' Or.inl ⟨Or.inl ha₁, _⟩\n      simp only [mem_image, not_exists, not_and]\n      intro b hb\n      by_cases h : b ∈ (π A).atomPerm.domain\n      · rw [completeAtomMap_eq_of_mem_domain h]\n        rintro rfl\n        exact ha₁.2 ((π A).atomPerm.map_domain h)\n      · simp only [mem_iUnion, mem_singleton_iff, not_exists, and_imp] at ha₂\n        exact Ne.symm (ha₂ b hb h)\n    · by_cases h : a ∈ litterSet N.fst\n      · refine' Or.inl ⟨Or.inr ⟨a, ⟨h, ha₁.2⟩, rfl⟩, _⟩\n        simp only [mem_image, not_exists, not_and]\n        intro b hb\n        by_cases hb' : b ∈ (π A).atomPerm.domain\n        · rw [completeAtomMap_eq_of_mem_domain hb']\n          intro hab\n          cases (π A).atomPerm.injOn hb' ha₁.2 hab\n          obtain hb | hb := hb\n          exact hb.2 ha₁.1\n          exact hb.2 h\n        · simp only [mem_iUnion, mem_singleton_iff, not_exists, and_imp] at ha₂\n          exact Ne.symm (ha₂ b hb hb')\n      · refine' Or.inr ⟨⟨a, Or.inr ⟨ha₁.1, h⟩, _⟩, _⟩\n        · simp only [completeAtomMap_eq_of_mem_domain ha₁.2]\n        rintro (ha | ⟨b, hb₁, hb₂⟩)\n        · exact ha.2 ((π A).atomPerm.map_domain ha₁.2)\n        · cases (π A).atomPerm.injOn hb₁.2 ha₁.2 hb₂\n          exact h hb₁.1\n    · simp only [mem_singleton_iff] at ha\n      subst ha\n      refine' Or.inr ⟨⟨b, hb₁, rfl⟩, _⟩\n      contrapose! ha₂\n      obtain ha₂ | ha₂ := ha₂\n      · exact Or.inl ha₂\n      obtain ⟨a, ha₁, ha₂⟩ := ha₂\n      by_cases h : a ∈ N\n      · rw [← ha₂]\n        exact Or.inr ⟨a, ⟨h, ha₁.2⟩, rfl⟩\n      rw [completeAtomMap_eq_of_not_mem_domain hb₂]\n      simp only [mem_union, mem_diff, mem_litterSet, Sublitter.equiv_apply_fst_eq,\n        NearLitterApprox.largestSublitter_litter]\n      refine' Or.inl ⟨_, _⟩\n      · suffices b ∈ litterSet N.fst by\n          rw [mem_litterSet] at this\n          rw [this, completeLitterMap_eq]\n        obtain hb₁ | hb₁ := hb₁\n        · exact hb₁.1\n        · exfalso\n          rw [completeAtomMap_eq_of_not_mem_domain hb₂] at ha₂\n          have : π A • a ∈ _ := (π A).atomPerm.map_domain ha₁.2\n          dsimp only at ha₂\n          rw [ha₂] at this\n          exact NearLitterApprox.not_mem_domain_of_mem_largestSublitter _\n            (Sublitter.equiv_apply_mem _) this\n      · exact NearLitterApprox.not_mem_domain_of_mem_largestSublitter _\n          (Sublitter.equiv_apply_mem _)\n  · rintro (⟨ha₁ | ⟨a, ha₁, rfl⟩, ha₂⟩ | ⟨⟨a, ha₁, rfl⟩, ha₂⟩)\n    · refine' Or.inl ⟨Or.inl ha₁, _⟩\n      simp only [mem_iUnion, mem_singleton_iff, not_exists, and_imp]\n      rintro b hb _ rfl\n      exact ha₂ ⟨b, hb, rfl⟩\n    · refine' Or.inl ⟨_, _⟩\n      · by_cases h : a ∈ N\n        · exact Or.inr ⟨a, ⟨h, ha₁.2⟩, rfl⟩\n        · simp only [mem_image, not_exists, not_and] at ha₂\n          have := ha₂ a (Or.inl ⟨ha₁.1, h⟩)\n          rw [completeAtomMap_eq_of_mem_domain ha₁.2] at this\n          cases this rfl\n      · contrapose! ha₂\n        obtain ⟨_, ⟨b, rfl⟩, _, ⟨hb, rfl⟩, ha₂⟩ := ha₂\n        simp only [mem_singleton_iff] at ha₂\n        rw [ha₂]\n        exact ⟨b, hb.1, rfl⟩\n    · rw [mem_union, not_or] at ha₂\n      by_cases ha : a ∈ litterSet N.fst\n      · have : a ∉ (π A).atomPerm.domain := by\n          intro h\n          refine' ha₂.2 ⟨a, ⟨ha, h⟩, _⟩\n          simp only [completeAtomMap_eq_of_mem_domain h]\n        refine' Or.inr ⟨_, _⟩\n        · exact ⟨_, ⟨a, rfl⟩, _, ⟨⟨ha₁, this⟩, rfl⟩, rfl⟩\n        · rintro (h | ⟨b, hb₁, hb₂⟩)\n          · exact ha₂.1 h\n          simp only [completeAtomMap_eq_of_not_mem_domain this] at hb₂\n          have : π A • b ∈ _ := (π A).atomPerm.map_domain hb₁.2\n          rw [hb₂] at this\n          exact\n            NearLitterApprox.not_mem_domain_of_mem_largestSublitter _\n              (Sublitter.equiv_apply_mem _) this\n      · by_cases h : a ∈ (π A).atomPerm.domain\n        · refine' Or.inl ⟨_, _⟩\n          · simp only [completeAtomMap_eq_of_mem_domain h]\n            refine' Or.inr ⟨a, ⟨_, h⟩, rfl⟩\n            obtain ha₁ | ha₁ := ha₁\n            · cases ha ha₁.1\n            · exact ha₁.1\n          · simp only [mem_iUnion, mem_singleton_iff, not_exists, and_imp]\n            intro b _ hb hab\n            rw [completeAtomMap_eq_of_mem_domain h, completeAtomMap_eq_of_not_mem_domain hb] at hab\n            have : π A • a ∈ _ := (π A).atomPerm.map_domain h\n            rw [hab] at this\n            exact\n              NearLitterApprox.not_mem_domain_of_mem_largestSublitter _\n                (Sublitter.equiv_apply_mem _) this\n        · refine' Or.inr ⟨_, _⟩\n          · exact ⟨_, ⟨a, rfl⟩, _, ⟨⟨ha₁, h⟩, rfl⟩, rfl⟩\n          rintro (h' | ⟨b, hb₁, hb₂⟩)\n          · exact ha₂.1 h'\n          simp only [completeAtomMap_eq_of_not_mem_domain h] at hb₂\n          have : π A • b ∈ _ := (π A).atomPerm.map_domain hb₁.2\n          rw [hb₂] at this\n          exact NearLitterApprox.not_mem_domain_of_mem_largestSublitter _\n            (Sublitter.equiv_apply_mem _) this\n", "additional_info": "", "used_premises": [1, 402, 779, 781, 61, 792, 62, 792, 483, 784, 62, 467], "def_path": "ConNF/FOA/Complete/CompleteAction.lean", "pos": [131, 256], "informalization": "In the context of Constructive Ordinal Notation (ConNF), the theorem `ConNF.StructApprox.completeNearLitterMap_eq'` states that for a `β`-structural approximation `π`, a `β`-extended index `A`, and a near-litter `N`, the near-litter `ConNF.StructApprox.completeNearLitterMap π A N` is equal to the symmetric difference of the near-litter `ConNF.StructApprox.completeNearLitterMap π A (ConNF.Litter.toNearLitter N.fst)` and the set of atoms `ConNF.StructApprox.completeAtomMap π A '' symmDiff (ConNF.litterSet N.fst) ↑N`."}
{"full_name": "ConNF.StructApprox.eq_of_mem_completeNearLitterMap", "url": "ConNF/FOA/Complete/CompleteAction.html#ConNF.StructApprox.eq_of_mem_completeNearLitterMap", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.StructApprox.eq_of_mem_completeNearLitterMap [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.FOAAssumptions] {β : ConNF.Λ} [ConNF.LeLevel🔗<|PREMISE|>🔗 ↑β] [ConNF.StructApprox.FreedomOfActionHypothesis🔗<|PREMISE|>🔗 β] {π : ConNF.StructApprox🔗<|PREMISE|>🔗 ↑β} {L₁ : ConNF.Litter} {L₂ : ConNF.Litter} {A : ConNF.ExtendedIndex🔗<|PREMISE|>🔗 ↑β} (a : ConNF.Atom) (ha₁ : a ∈ ConNF.StructApprox.completeNearLitterMap🔗<|PREMISE|>🔗 π A (ConNF.Litter.toNearLitter🔗<|PREMISE|>🔗 L₁)) (ha₂ : a ∈ ConNF.StructApprox.completeNearLitterMap🔗<|PREMISE|>🔗 π A (ConNF.Litter.toNearLitter🔗<|PREMISE|>🔗 L₂)) :ConNF.StructApprox.completeLitterMap🔗<|PREMISE|>🔗 π A L₁ = ConNF.StructApprox.completeLitterMap🔗<|PREMISE|>🔗 π A L₂", "code": "theorem eq_of_mem_completeNearLitterMap {L₁ L₂ : Litter} {A : ExtendedIndex β} (a : Atom)\n    (ha₁ : a ∈ π.completeNearLitterMap A L₁.toNearLitter)\n    (ha₂ : a ∈ π.completeNearLitterMap A L₂.toNearLitter) :\n    π.completeLitterMap A L₁ = π.completeLitterMap A L₂ := by\n  rw [← SetLike.mem_coe, completeNearLitterMap_toNearLitter_eq] at ha₁ ha₂\n  obtain ⟨ha₁, ha₁'⟩ | ha₁ := ha₁ <;> obtain ⟨ha₂, ha₂'⟩ | ha₂ := ha₂\n  · exact eq_of_mem_litterSet_of_mem_litterSet ha₁ ha₂\n  · obtain ⟨b, hb, rfl⟩ := ha₂\n    cases ha₁' ((π A).atomPerm.map_domain hb.2)\n  · obtain ⟨b, hb, rfl⟩ := ha₁\n    cases ha₂' ((π A).atomPerm.map_domain hb.2)\n  · obtain ⟨b, hb, rfl⟩ := ha₁\n    obtain ⟨c, hc, hc'⟩ := ha₂\n    cases (π A).atomPerm.injOn hc.2 hb.2 hc'\n    rw [eq_of_mem_litterSet_of_mem_litterSet hb.1 hc.1]\n", "additional_info": "", "used_premises": [1, 402, 779, 781, 61, 792, 483, 792, 483, 787, 787], "def_path": "ConNF/FOA/Complete/CompleteAction.lean", "pos": [269, 284], "informalization": "The theorem `eq_of_mem_completeNearLitterMap` states that, under certain conditions, if two litters both contain an atom `a` that is also contained in the near-litter approximation of a `β`-extended index `A` for a `β`-structural approximation `π`, then the litter maps of `L₁` and `L₂` will be equal. This theorem is a key step in the proof of freedom of action in Constructive Ordinal Notation (ConNF)."}
{"full_name": "ConNF.NearLitterApprox.idOnFlexible_domain", "url": "ConNF/FOA/Complete/FlexibleCompletion.html#ConNF.NearLitterApprox.idOnFlexible_domain", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterApprox.idOnFlexible_domain [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.FOAAssumptions] {β : ConNF.TypeIndex} (π : ConNF.NearLitterApprox) (A : ConNF.ExtendedIndex🔗<|PREMISE|>🔗 β) :(ConNF.NearLitterApprox.idOnFlexible🔗<|PREMISE|>🔗 π A).domain = {L : ConNF.Litter | ConNF.Flexible🔗<|PREMISE|>🔗 A L} \\ π.litterPerm.domain", "code": "theorem idOnFlexible_domain :\n    (idOnFlexible π A).domain = {L | Flexible A L} \\ π.litterPerm.domain :=\n  rfl\n", "additional_info": "", "used_premises": [1, 61, 1332, 842], "def_path": "ConNF/FOA/Complete/FlexibleCompletion.lean", "pos": [24, 27], "informalization": "The theorem `ConNF.NearLitterApprox.idOnFlexible_domain` states that the domain of the partial permutation `ConNF.NearLitterApprox.idOnFlexible` is the set of litters that are `Flexible` with respect to a given `ConNF.ExtendedIndex` `A`, excluding those litters that are already in the domain of the `ConNF.NearLitterApprox` `π.litterPerm`."}
{"full_name": "ConNF.NearLitterApprox.idOnFlexible", "url": "ConNF/FOA/Complete/FlexibleCompletion.html#ConNF.NearLitterApprox.idOnFlexible", "code_src": "con-nf", "ptype": "def", "header": "def ConNF.NearLitterApprox.idOnFlexible [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.FOAAssumptions] {β : ConNF.TypeIndex} (π : ConNF.NearLitterApprox) (A : ConNF.ExtendedIndex🔗<|PREMISE|>🔗 β) :PartialPerm🔗<|PREMISE|>🔗 ConNF.Litter", "code": "def idOnFlexible : PartialPerm Litter where\n  toFun := id\n  invFun := id\n  domain := {L | Flexible A L} \\ π.litterPerm.domain\n  toFun_domain' _ h := h\n  invFun_domain' _ h := h\n  left_inv' _ _ := rfl\n  right_inv' _ _ := rfl\n", "additional_info": "Equations\n* One or more equations did not get rendered due to their size.\n\n", "used_premises": [1, 61, 645], "def_path": "ConNF/FOA/Complete/FlexibleCompletion.lean", "pos": [15, 23], "informalization": "Function `ConNF.NearLitterApprox.idOnFlexible` defines a partial permutation on the set of litters, where the domain of the permutation is the set of litters that are `Flexible` with respect to a given `ConNF.ExtendedIndex` `A`, excluding those litters that are already in the domain of the `ConNF.NearLitterApprox` `π.litterPerm`."}
{"full_name": "ConNF.NearLitterApprox.idOnFlexible_domain_disjoint", "url": "ConNF/FOA/Complete/FlexibleCompletion.html#ConNF.NearLitterApprox.idOnFlexible_domain_disjoint", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterApprox.idOnFlexible_domain_disjoint [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.FOAAssumptions] {β : ConNF.TypeIndex} (π : ConNF.NearLitterApprox) (A : ConNF.ExtendedIndex🔗<|PREMISE|>🔗 β) :Disjoint🔗<|PREMISE|>🔗 π.litterPerm.domain (ConNF.NearLitterApprox.idOnFlexible🔗<|PREMISE|>🔗 π A).domain", "code": "theorem idOnFlexible_domain_disjoint : Disjoint π.litterPerm.domain (idOnFlexible π A).domain :=\n  by rw [disjoint_iff_inter_eq_empty, idOnFlexible_domain, inter_diff_self]\n", "additional_info": "", "used_premises": [1, 61, 757, 1332], "def_path": "ConNF/FOA/Complete/FlexibleCompletion.lean", "pos": [28, 30], "informalization": "The theorem `ConNF.NearLitterApprox.idOnFlexible_domain_disjoint` asserts that two sets, the domain of the permutation `π.litterPerm` and the domain of the partial permutation `ConNF.NearLitterApprox.idOnFlexible π A`, are disjoint. The domain of `π.litterPerm` represents the set of litters that are permuted by the `ConNF.NearLitterApprox`, while `ConNF.NearLitterApprox.idOnFlexible π A` is a partial permutation that operates only on the set of `Flexible` litters with respect to the `ConNF.ExtendedIndex` `A`, excluding those litters that are already in the domain of `π.litterPerm`. The theorem states that there is no overlap between these two sets, i.e., no litter is both in the domain of `π.litterPerm` and in the domain of `ConNF.NearLitterApprox.idOnFlexible π A`."}
{"full_name": "ConNF.NearLitterApprox.flexibleCompletionLitterPerm_domain", "url": "ConNF/FOA/Complete/FlexibleCompletion.html#ConNF.NearLitterApprox.flexibleCompletionLitterPerm_domain", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterApprox.flexibleCompletionLitterPerm_domain [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.FOAAssumptions] {β : ConNF.TypeIndex} (π : ConNF.NearLitterApprox) (A : ConNF.ExtendedIndex🔗<|PREMISE|>🔗 β) :(ConNF.NearLitterApprox.flexibleCompletionLitterPerm🔗<|PREMISE|>🔗 π A).domain = π.litterPerm.domain ∪ {L : ConNF.Litter | ConNF.Flexible🔗<|PREMISE|>🔗 A L}", "code": "theorem flexibleCompletionLitterPerm_domain :\n    (flexibleCompletionLitterPerm π A).domain = π.litterPerm.domain ∪ {L | Flexible A L} := by\n  rw [flexibleCompletionLitterPerm, PartialPerm.piecewise_domain, idOnFlexible_domain,\n    union_diff_self]\n", "additional_info": "", "used_premises": [1, 61, 1335, 842], "def_path": "ConNF/FOA/Complete/FlexibleCompletion.lean", "pos": [34, 38], "informalization": "The theorem `ConNF.NearLitterApprox.flexibleCompletionLitterPerm_domain` states that the domain of the partial permutation `ConNF.NearLitterApprox.flexibleCompletionLitterPerm π A` is equal to the union of the domain of the partial permutation `π.litterPerm` and the set of all *flexible* litters with respect to the extended index `A`."}
{"full_name": "ConNF.NearLitterApprox.flexibleCompletionLitterPerm", "url": "ConNF/FOA/Complete/FlexibleCompletion.html#ConNF.NearLitterApprox.flexibleCompletionLitterPerm", "code_src": "con-nf", "ptype": "noncomputable def", "header": "noncomputable def ConNF.NearLitterApprox.flexibleCompletionLitterPerm [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.FOAAssumptions] {β : ConNF.TypeIndex} (π : ConNF.NearLitterApprox) (A : ConNF.ExtendedIndex🔗<|PREMISE|>🔗 β) :PartialPerm🔗<|PREMISE|>🔗 ConNF.Litter", "code": "noncomputable def flexibleCompletionLitterPerm : PartialPerm Litter :=\n  PartialPerm.piecewise π.litterPerm (idOnFlexible π A) (idOnFlexible_domain_disjoint π A)\n", "additional_info": "Equations\n* 🗟ConNF.NearLitterApprox.flexibleCompletionLitterPerm🗟🔗../../.././ConNF/FOA/Complete/FlexibleCompletion.html#ConNF.NearLitterApprox.flexibleCompletionLitterPerm🔗  π A 🗟=🗟🔗../../.././Init/Prelude.html#Eq🔗  🗟PartialPerm.piecewise🗟🔗../../.././ConNF/Mathlib/Logic/Equiv/PartialPerm.html#PartialPerm.piecewise🔗  π.litterPerm (🗟ConNF.NearLitterApprox.idOnFlexible🗟🔗../../.././ConNF/FOA/Complete/FlexibleCompletion.html#ConNF.NearLitterApprox.idOnFlexible🔗  π A) ⋯\n\n", "used_premises": [1, 61, 645], "def_path": "ConNF/FOA/Complete/FlexibleCompletion.lean", "pos": [31, 33], "informalization": "Function `ConNF.NearLitterApprox.flexibleCompletionLitterPerm` takes a `ConNF.NearLitterApprox` object `π` and an `ConNF.ExtendedIndex` object `A`, and returns a `PartialPerm ConNF.Litter`, which is a partial permutation of the `ConNF.Litter` type. This function is used in the context of Constructive Ordinal Notation (ConNF) to construct a permutation of the litter type based on the given near litter approximation and extended index."}
{"full_name": "ConNF.NearLitterApprox.flexibleCompletion_litterPerm_domain", "url": "ConNF/FOA/Complete/FlexibleCompletion.html#ConNF.NearLitterApprox.flexibleCompletion_litterPerm_domain", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterApprox.flexibleCompletion_litterPerm_domain [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.FOAAssumptions] {β : ConNF.TypeIndex} (π : ConNF.NearLitterApprox) (A : ConNF.ExtendedIndex🔗<|PREMISE|>🔗 β) :(ConNF.NearLitterApprox.flexibleCompletion🔗<|PREMISE|>🔗 π A).litterPerm.domain = π.litterPerm.domain ∪ {L : ConNF.Litter | ConNF.Flexible🔗<|PREMISE|>🔗 A L}", "code": "theorem flexibleCompletion_litterPerm_domain :\n    (flexibleCompletion π A).litterPerm.domain = π.litterPerm.domain ∪ {L | Flexible A L} := by\n  rw [flexibleCompletion, flexibleCompletionLitterPerm_domain]\n", "additional_info": "", "used_premises": [1, 61, 1314, 842], "def_path": "ConNF/FOA/Complete/FlexibleCompletion.lean", "pos": [45, 48], "informalization": "The theorem `ConNF.NearLitterApprox.flexibleCompletion_litterPerm_domain` states that the domain of the `litterPerm` of the `ConNF.NearLitterApprox` object obtained by applying the `ConNF.NearLitterApprox.flexibleCompletion` function to a `ConNF.NearLitterApprox` object `π` and an `ConNF.ExtendedIndex` object `A` is equal to the union of the domain of `π.litterPerm` and the set of all `ConNF.Litter`s that are `ConNF.Flexible` with respect to `A`."}
{"full_name": "ConNF.NearLitterApprox.flexibleCompletion_litterPerm_domain_free", "url": "ConNF/FOA/Complete/FlexibleCompletion.html#ConNF.NearLitterApprox.flexibleCompletion_litterPerm_domain_free", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterApprox.flexibleCompletion_litterPerm_domain_free [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.FOAAssumptions] {β : ConNF.TypeIndex} (π : ConNF.NearLitterApprox) (A : ConNF.ExtendedIndex🔗<|PREMISE|>🔗 β) (hπ : ConNF.NearLitterApprox.Free🔗<|PREMISE|>🔗 π A) :(ConNF.NearLitterApprox.flexibleCompletion🔗<|PREMISE|>🔗 π A).litterPerm.domain = {L : ConNF.Litter | ConNF.Flexible🔗<|PREMISE|>🔗 A L}", "code": "theorem flexibleCompletion_litterPerm_domain_free (hπ : π.Free A) :\n    (flexibleCompletion π A).litterPerm.domain = {L | Flexible A L} := by\n  rw [flexibleCompletion_litterPerm_domain, union_eq_right]\n  exact fun L hL => hπ L hL\n", "additional_info": "", "used_premises": [1, 61, 1338, 1314, 842], "def_path": "ConNF/FOA/Complete/FlexibleCompletion.lean", "pos": [49, 53], "informalization": "The theorem `ConNF.NearLitterApprox.flexibleCompletion_litterPerm_domain_free` states that the domain of the `litterPerm` of the `ConNF.NearLitterApprox` object obtained by applying the `ConNF.NearLitterApprox.flexibleCompletion` function to a `ConNF.NearLitterApprox` object `π` and an `ConNF.ExtendedIndex` object `A` is exactly the set of all `ConNF.Litter`s that are `ConNF.Flexible` with respect to `A`."}
{"full_name": "ConNF.NearLitterApprox.Free", "url": "ConNF/FOA/Approximation/NearLitterApprox.html#ConNF.NearLitterApprox.Free", "code_src": "con-nf", "ptype": "def", "header": "def ConNF.NearLitterApprox.Free [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.FOAAssumptions] {β : ConNF.TypeIndex} (π : ConNF.NearLitterApprox) (A : ConNF.ExtendedIndex🔗<|PREMISE|>🔗 β) :Prop", "code": "def Free [Level] [FOAAssumptions] {β : TypeIndex} (π : NearLitterApprox)\n    (A : ExtendedIndex β) : Prop :=\n  ∀ L ∈ π.litterPerm.domain, Flexible A L\n", "additional_info": "Equations\n* 🗟ConNF.NearLitterApprox.Free🗟🔗../../.././ConNF/FOA/Approximation/NearLitterApprox.html#ConNF.NearLitterApprox.Free🔗  π A 🗟=🗟🔗../../.././Init/Prelude.html#Eq🔗  ∀ L ∈ π.litterPerm.domain, 🗟ConNF.Flexible🗟🔗../../.././ConNF/FOA/Basic/Flexible.html#ConNF.Flexible🔗  A L\n\n", "used_premises": [1, 61], "def_path": "ConNF/FOA/Approximation/NearLitterApprox.lean", "pos": [198, 201], "informalization": "Function `ConNF.NearLitterApprox.Free` defines a property of a `ConNF.NearLitterApprox` object `π` and an `ConNF.ExtendedIndex` object `A`. It asserts that for every `L` in the domain of `π.litterPerm`, the `ConNF.Flexible` property holds between `A` and `L`. This property is crucial in the context of Constructive Ordinal Notation (ConNF), where it ensures that the `ConNF.NearLitterApprox` object `π` is compatible with the `ConNF.ExtendedIndex` object `A` in terms of extensionality."}
{"full_name": "ConNF.NearLitterApprox.flexibleCompletion_smul_eq", "url": "ConNF/FOA/Complete/FlexibleCompletion.html#ConNF.NearLitterApprox.flexibleCompletion_smul_eq", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterApprox.flexibleCompletion_smul_eq [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.FOAAssumptions] {β : ConNF.TypeIndex} (π : ConNF.NearLitterApprox) (A : ConNF.ExtendedIndex🔗<|PREMISE|>🔗 β) (L : ConNF.Litter) :ConNF.NearLitterApprox.flexibleCompletion🔗<|PREMISE|>🔗 π A • L = (ConNF.NearLitterApprox.flexibleCompletionLitterPerm🔗<|PREMISE|>🔗 π A).toFun L", "code": "theorem flexibleCompletion_smul_eq (L : Litter) :\n    flexibleCompletion π A • L = flexibleCompletionLitterPerm π A L :=\n  rfl\n", "additional_info": "", "used_premises": [1, 61, 1314, 1335], "def_path": "ConNF/FOA/Complete/FlexibleCompletion.lean", "pos": [54, 57], "informalization": "The theorem `ConNF.NearLitterApprox.flexibleCompletion_smul_eq` states that for a `ConNF.NearLitterApprox` object `π` and an `ConNF.ExtendedIndex` object `A`, the action of `ConNF.NearLitterApprox.flexibleCompletion π A` on a `ConNF.Litter` object `L` is equal to the application of the partial permutation `ConNF.NearLitterApprox.flexibleCompletionLitterPerm π A` to `L`."}
{"full_name": "ConNF.NearLitterApprox.flexibleCompletion_smul_of_mem_domain", "url": "ConNF/FOA/Complete/FlexibleCompletion.html#ConNF.NearLitterApprox.flexibleCompletion_smul_of_mem_domain", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterApprox.flexibleCompletion_smul_of_mem_domain [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.FOAAssumptions] {β : ConNF.TypeIndex} (π : ConNF.NearLitterApprox) (A : ConNF.ExtendedIndex🔗<|PREMISE|>🔗 β) (L : ConNF.Litter) (hL : L ∈ π.litterPerm.domain) :ConNF.NearLitterApprox.flexibleCompletion🔗<|PREMISE|>🔗 π A • L = π.litterPerm.toFun L", "code": "theorem flexibleCompletion_smul_of_mem_domain (L : Litter) (hL : L ∈ π.litterPerm.domain) :\n    flexibleCompletion π A • L = π.litterPerm L := by\n  rw [flexibleCompletion_smul_eq, flexibleCompletionLitterPerm,\n    PartialPerm.piecewise_apply_eq_left hL]\n", "additional_info": "", "used_premises": [1, 61, 1314], "def_path": "ConNF/FOA/Complete/FlexibleCompletion.lean", "pos": [58, 62], "informalization": "The theorem `ConNF.NearLitterApprox.flexibleCompletion_smul_of_mem_domain` states that for any `ConNF.NearLitterApprox` object `π`, any `ConNF.ExtendedIndex` object `A`, and any `ConNF.Litter` object `L` that is in the domain of `π.litterPerm`, the action of `ConNF.NearLitterApprox.flexibleCompletion π A` on `L` is equal to the action of `π.litterPerm` on `L`."}
{"full_name": "ConNF.NearLitterApprox.flexibleCompletion_smul_flexible", "url": "ConNF/FOA/Complete/FlexibleCompletion.html#ConNF.NearLitterApprox.flexibleCompletion_smul_flexible", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterApprox.flexibleCompletion_smul_flexible [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.FOAAssumptions] {β : ConNF.TypeIndex} (π : ConNF.NearLitterApprox) (A : ConNF.ExtendedIndex🔗<|PREMISE|>🔗 β) (hπ : ConNF.NearLitterApprox.Free🔗<|PREMISE|>🔗 π A) (L : ConNF.Litter) (hL : ConNF.Flexible🔗<|PREMISE|>🔗 A L) :ConNF.Flexible🔗<|PREMISE|>🔗 A (ConNF.NearLitterApprox.flexibleCompletion🔗<|PREMISE|>🔗 π A • L)", "code": "theorem flexibleCompletion_smul_flexible (hπ : π.Free A) (L : Litter) (hL : Flexible A L) :\n    Flexible A (flexibleCompletion π A • L) := by\n  have := PartialPerm.map_domain (flexibleCompletion π A).litterPerm (x := ?_) ?_\n  · rw [flexibleCompletion_litterPerm_domain_free π A hπ] at this\n    exact this\n  · rw [flexibleCompletion_litterPerm_domain_free π A hπ]\n    exact hL\n", "additional_info": "", "used_premises": [1, 61, 1338, 842, 842, 1314], "def_path": "ConNF/FOA/Complete/FlexibleCompletion.lean", "pos": [63, 70], "informalization": "The theorem `ConNF.NearLitterApprox.flexibleCompletion_smul_flexible` states that if `π` is a `ConNF.NearLitterApprox` object that is `ConNF.NearLitterApprox.Free` with respect to an `ConNF.ExtendedIndex` object `A`, and `L` is a `ConNF.Litter` object that is `ConNF.Flexible` with respect to `A`, then the `ConNF.NearLitterApprox.flexibleCompletion` of `π` with respect to `A` applied to `L` is also `ConNF.Flexible` with respect to `A`."}
{"full_name": "ConNF.NearLitterApprox.flexibleCompletion_symm_smul_flexible", "url": "ConNF/FOA/Complete/FlexibleCompletion.html#ConNF.NearLitterApprox.flexibleCompletion_symm_smul_flexible", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.NearLitterApprox.flexibleCompletion_symm_smul_flexible [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.FOAAssumptions] {β : ConNF.TypeIndex} (π : ConNF.NearLitterApprox) (A : ConNF.ExtendedIndex🔗<|PREMISE|>🔗 β) (hπ : ConNF.NearLitterApprox.Free🔗<|PREMISE|>🔗 π A) (L : ConNF.Litter) (hL : ConNF.Flexible🔗<|PREMISE|>🔗 A L) :ConNF.Flexible🔗<|PREMISE|>🔗 A (ConNF.NearLitterApprox.symm🔗<|PREMISE|>🔗 (ConNF.NearLitterApprox.flexibleCompletion🔗<|PREMISE|>🔗 π A) • L)", "code": "theorem flexibleCompletion_symm_smul_flexible (hπ : π.Free A) (L : Litter) (hL : Flexible A L) :\n    Flexible A ((flexibleCompletion π A).symm • L) := by\n  have := PartialPerm.map_domain (flexibleCompletion π A).symm.litterPerm (x := ?_) ?_\n  · rw [symm_litterPerm, PartialPerm.symm_domain,\n      flexibleCompletion_litterPerm_domain_free π A hπ] at this\n    exact this\n  · rw [symm_litterPerm, PartialPerm.symm_domain,\n      flexibleCompletion_litterPerm_domain_free π A hπ]\n    exact hL\n", "additional_info": "", "used_premises": [1, 61, 1338, 842, 842, 1223, 1314], "def_path": "ConNF/FOA/Complete/FlexibleCompletion.lean", "pos": [71, 80], "informalization": "In the context of Constructive Ordinal Notation (ConNF), the theorem `ConNF.NearLitterApprox.flexibleCompletion_symm_smul_flexible` asserts that given a `ConNF.NearLitterApprox` object `π`, an `ConNF.ExtendedIndex` object `A`, and a `ConNF.Litter` object `L`, if `π` is `ConNF.NearLitterApprox.Free` with respect to `A` and `L` is `ConNF.Flexible` with respect to `A`, then `ConNF.NearLitterApprox.symm (ConNF.NearLitterApprox.flexibleCompletion π A) • L` is also `ConNF.Flexible` with respect to `A`. This property is crucial in ensuring that the construction of the natural numbers in ConNF is well-defined and consistent."}
{"full_name": "ConNF.StructApprox.nearLitterCompletionMap_isNearLitter", "url": "ConNF/FOA/Complete/NearLitterCompletion.html#ConNF.StructApprox.nearLitterCompletionMap_isNearLitter", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.StructApprox.nearLitterCompletionMap_isNearLitter [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.FOAAssumptions] {β : ConNF.Λ} [ConNF.LeLevel🔗<|PREMISE|>🔗 ↑β] [ConNF.StructApprox.FreedomOfActionHypothesis🔗<|PREMISE|>🔗 β] (π : ConNF.StructApprox🔗<|PREMISE|>🔗 ↑β) (A : ConNF.ExtendedIndex🔗<|PREMISE|>🔗 ↑β) (N : ConNF.NearLitter) (H : ConNF.HypAction🔗<|PREMISE|>🔗 { path := A, value := Sum.inr🔗<|PREMISE|>🔗 N }) :ConNF.IsNearLitter🔗<|PREMISE|>🔗 (ConNF.StructApprox.litterCompletion🔗<|PREMISE|>🔗 π A N.fst (ConNF.StructApprox.nearLitterHypothesis🔗<|PREMISE|>🔗 A N H)) (ConNF.StructApprox.nearLitterCompletionMap🔗<|PREMISE|>🔗 π A N H)", "code": "theorem nearLitterCompletionMap_isNearLitter (π : StructApprox β) (A : ExtendedIndex β)\n    (N : NearLitter) (H : HypAction ⟨A, inr N⟩) :\n    IsNearLitter (π.litterCompletion A N.fst (nearLitterHypothesis A N H))\n      (π.nearLitterCompletionMap A N H) := by\n  rw [nearLitterCompletionMap, IsNearLitter, IsNear, NearLitterApprox.coe_largestSublitter,\n    ← symmDiff_assoc, symmDiff_comm, ← Small.symmDiff_iff _]\n  · rw [Set.symmDiff_def, ← diff_diff, sdiff_sdiff_right_self, union_diff_distrib,\n      sdiff_sdiff_self, bot_eq_empty, empty_union]\n    exact Small.union (Small.mono (diff_subset _ _) ((π A).domain_small _))\n      (Small.mono (diff_subset _ _) (NearLitterApprox.nearLitter_domain_small _ _).image)\n  · exact Small.bUnion (Small.mono (diff_subset _ _) N.2.prop) fun _ _ => small_singleton _\n", "additional_info": "", "used_premises": [1, 402, 779, 781, 61, 1305, 65, 466, 1313, 1344, 1345], "def_path": "ConNF/FOA/Complete/NearLitterCompletion.lean", "pos": [40, 51], "informalization": "In the context of Constructive Ordinal Notation (ConNF), the theorem `ConNF.StructApprox.nearLitterCompletionMap_isNearLitter` states that given a `β`-structural approximation `π`, an extended index `A`, a near-litter `N`, and a hypothesis `H` about the action of `π` on `A` and `N`, the litter returned by the function `ConNF.StructApprox.litterCompletion` is near the near-litter returned by the function `ConNF.StructApprox.nearLitterCompletionMap`."}
{"full_name": "ConNF.StructApprox.nearLitterHypothesis", "url": "ConNF/FOA/Complete/NearLitterCompletion.html#ConNF.StructApprox.nearLitterHypothesis", "code_src": "con-nf", "ptype": "def", "header": "def ConNF.StructApprox.nearLitterHypothesis [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.FOAAssumptions] {β : ConNF.Λ} (A : ConNF.ExtendedIndex🔗<|PREMISE|>🔗 ↑β) (N : ConNF.NearLitter) (H : ConNF.HypAction🔗<|PREMISE|>🔗 { path := A, value := Sum.inr🔗<|PREMISE|>🔗 N }) :ConNF.HypAction🔗<|PREMISE|>🔗 { path := A, value := Sum.inr🔗<|PREMISE|>🔗 (ConNF.Litter.toNearLitter🔗<|PREMISE|>🔗 N.fst) }", "code": "def nearLitterHypothesis (A : ExtendedIndex β) (N : NearLitter) (H : HypAction ⟨A, inr N⟩) :\n    HypAction ⟨A, inr N.1.toNearLitter⟩\n    where\n  atomImage B a h :=\n    H.atomImage B a\n      (by\n        by_cases h' : N.IsLitter\n        · rw [h'.eq_fst_toNearLitter]\n          exact h\n        · exact Relation.TransGen.tail h (Constrains.nearLitter A N h'))\n  nearLitterImage B N' h :=\n    H.nearLitterImage B N'\n      (by\n        by_cases h' : N.IsLitter\n        · rw [h'.eq_fst_toNearLitter]\n          exact h\n        exact Relation.TransGen.tail h (Constrains.nearLitter A N h'))\n", "additional_info": "Equations\n* One or more equations did not get rendered due to their size.\n\n", "used_premises": [1, 61, 1305, 65, 1305, 65, 483], "def_path": "ConNF/FOA/Complete/NearLitterCompletion.lean", "pos": [15, 32], "informalization": "Function `ConNF.StructApprox.nearLitterHypothesis` is a method within the context of Constructive Ordinal Notation (ConNF) that is used to construct the induced action of an approximation in the freedom of action theorem. It takes as input an extended index `A`, a near-litter `N`, and a hypothesis `H` of type `ConNF.HypAction`, which represents the inductive hypothesis used to construct the induced action. The output is a new hypothesis of type `ConNF.HypAction` for the near-litter `N.1.toNearLitter`."}
{"full_name": "ConNF.StructApprox.nearLitterCompletionMap", "url": "ConNF/FOA/Complete/NearLitterCompletion.html#ConNF.StructApprox.nearLitterCompletionMap", "code_src": "con-nf", "ptype": "def", "header": "def ConNF.StructApprox.nearLitterCompletionMap [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.FOAAssumptions] {β : ConNF.Λ} [ConNF.LeLevel🔗<|PREMISE|>🔗 ↑β] [ConNF.StructApprox.FreedomOfActionHypothesis🔗<|PREMISE|>🔗 β] (π : ConNF.StructApprox🔗<|PREMISE|>🔗 ↑β) (A : ConNF.ExtendedIndex🔗<|PREMISE|>🔗 ↑β) (N : ConNF.NearLitter) (H : ConNF.HypAction🔗<|PREMISE|>🔗 { path := A, value := Sum.inr🔗<|PREMISE|>🔗 N }) :Set🔗<|PREMISE|>🔗 ConNF.Atom", "code": "def nearLitterCompletionMap (π : StructApprox β) (A : ExtendedIndex β) (N : NearLitter)\n    (H : HypAction ⟨A, inr N⟩) : Set Atom :=\n  (NearLitterApprox.largestSublitter (π A) (π.litterCompletion A N.1 (nearLitterHypothesis A N H)) ∪\n      π A • ((N : Set Atom) ∩ (π A).atomPerm.domain)) ∆\n    ⋃ (a : Atom) (ha : a ∈ litterSet N.1 ∆ N \\ (π A).atomPerm.domain),\n      {H.atomImage A a (Relation.TransGen.single (Constrains.symmDiff A N a ha.1))}\n", "additional_info": "Equations\n* One or more equations did not get rendered due to their size.\n\n", "used_premises": [1, 402, 779, 781, 61, 1305, 65, 69], "def_path": "ConNF/FOA/Complete/NearLitterCompletion.lean", "pos": [33, 39], "informalization": "Function `ConNF.StructApprox.nearLitterCompletionMap` defines a `β`-structural approximation in the context of Constructive Ordinal Notation (ConNF), which is a product that assigns a near-litter approximation to each `β`-extended index."}
{"full_name": "ConNF.StructApprox.nearLitterCompletion_fst_eq", "url": "ConNF/FOA/Complete/NearLitterCompletion.html#ConNF.StructApprox.nearLitterCompletion_fst_eq", "code_src": "con-nf", "ptype": "theorem", "header": "@[simp]theorem ConNF.StructApprox.nearLitterCompletion_fst_eq [ConNF.Params🔗<|PREMISE|>🔗 ] [ConNF.Level] [ConNF.FOAAssumptions] {β : ConNF.Λ} [ConNF.LeLevel🔗<|PREMISE|>🔗 ↑β] [ConNF.StructApprox.FreedomOfActionHypothesis🔗<|PREMISE|>🔗 β] (π : ConNF.StructApprox🔗<|PREMISE|>🔗 ↑β) (A : ConNF.ExtendedIndex🔗<|PREMISE|>🔗 ↑β) (N : ConNF.NearLitter) (H : ConNF.HypAction🔗<|PREMISE|>🔗 { path := A, value := Sum.inr🔗<|PREMISE|>🔗 N }) :(ConNF.StructApprox.nearLitterCompletion🔗<|PREMISE|>🔗 π A N H).fst = ConNF.StructApprox.litterCompletion🔗<|PREMISE|>🔗 π A N.fst (ConNF.StructApprox.nearLitterHypothesis🔗<|PREMISE|>🔗 A N H)", "code": "theorem nearLitterCompletion_fst_eq (π : StructApprox β) (A : ExtendedIndex β) (N : NearLitter)\n    (H : HypAction ⟨A, inr N⟩) :\n    (π.nearLitterCompletion A N H).1 = litterCompletion π A N.1 (nearLitterHypothesis A N H) :=\n  rfl\n", "additional_info": "", "used_premises": [1, 402, 779, 781, 61, 1305, 65, 1319, 1313, 1344], "def_path": "ConNF/FOA/Complete/NearLitterCompletion.lean", "pos": [58, 62], "informalization": "The theorem `ConNF.StructApprox.nearLitterCompletion_fst_eq` is a part of the proof of freedom of action in Constructive Ordinal Notation (ConNF). It states that for a `β`-structural approximation `π`, a `β`-extended index `A`, a near-litter `N`, and a hypothesis `H` about the action of `π` on `A` and `N`, the first component of the near-litter completion `ConNF.StructApprox.nearLitterCompletion π A N H` is equal to the litter completion `ConNF.StructApprox.litterCompletion π A N.fst (ConNF.StructApprox.nearLitterHypothesis A N H)`."}
{"full_name": "ConNF.StructApprox.equiv_apply_mem", "url": "ConNF/FOA/Complete/AtomCompletion.html#ConNF.StructApprox.equiv_apply_mem", "code_src": "con-nf", "ptype": "theorem", "header": "theorem ConNF.StructApprox.equiv_apply_mem [ConNF.Params🔗<|PREMISE|>🔗 ] {S : ConNF.Sublitter} {T : ConNF.Sublitter} {a : ↥S} {L : ConNF.Litter} (h : ↑((ConNF.Sublitter.equiv🔗<|PREMISE|>🔗 S T) a) ∈ ConNF.litterSet🔗<|PREMISE|>🔗 L) :T.litter = L", "code": "theorem equiv_apply_mem {S T : Sublitter} {a} {L : Litter}\n    (h : (S.equiv T a : Atom) ∈ litterSet L) : T.litter = L := by\n  rw [← Litter.litter_toSublitter L, ← Sublitter.inter_nonempty_iff]\n  exact ⟨_, (S.equiv T a).prop, h⟩\n", "additional_info": "", "used_premises": [1, 876, 467], "def_path": "ConNF/FOA/Complete/AtomCompletion.lean", "pos": [17, 21], "informalization": "The theorem `ConNF.StructApprox.equiv_apply_mem` states that for any two sublitters `S` and `T` in the context of Constructive Ordinal Notation (ConNF), and any atom `a` in `S`, if the image of `a` under the equivalence `ConNF.Sublitter.equiv S T` belongs to the set `ConNF.litterSet L` for some litter `L`, then the litter corresponding to `T` is equal to `L`."}
